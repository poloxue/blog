[{"id":0,"href":"/gofyne/docs/02-explore/01-canvas/","title":"01. Canvas 和 CanvasObject","section":"探索 Fyne","content":" Canvas 和 CanvasObject # 在Fyne中，画布（Canvas）是应用程序绘制的区域。每个窗口都有一个画布，你可以通过Window.Canvas()访问它，但通常你会发现Window上的函数可以避免直接访问画布。\nFyne中可以绘制的所有内容都是CanvasObject类型。这个示例打开了一个新窗口，然后通过设置窗口画布的内容来展示不同类型的基本图形元素。如文本和圆形示例所示，每种类型的对象都有许多定制方式。\n除了使用Canvas.SetContent()更改显示的内容外，还可以更改当前可见的内容。例如，如果你更改了矩形的FillColour，可以使用rect.Refresh()请求刷新这个已存在的组件。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Canvas\u0026#34;) myCanvas := myWindow.Canvas() blue := color.NRGBA{R: 0, G: 0, B: 180, A: 255} rect := canvas.NewRectangle(blue) myCanvas.SetContent(rect) go func() { time.Sleep(time.Second) green := color.NRGBA{R: 0, G: 180, B: 0, A: 255} rect.FillColor = green rect.Refresh() }() myWindow.Resize(fyne.NewSize(100, 100)) myWindow.ShowAndRun() } 我们可以用相同的方式绘制许多不同的绘图元素，如圆形和文本。\nfunc setContentToText(c fyne.Canvas) { green := color.NRGBA{R: 0, G: 180, B: 0, A: 255} text := canvas.NewText(\u0026#34;Text\u0026#34;, green) text.TextStyle.Bold = true c.SetContent(text) } func setContentToCircle(c fyne.Canvas) { red := color.NRGBA{R: 0xff, G: 0x33, B: 0x33, A: 0xff} circle := canvas.NewCircle(color.White) circle.StrokeWidth = 4 circle.StrokeColor = red c.SetContent(circle) } 控件 Widget # fyne.Widget是一种特殊类型的画布对象，它与交互元素关联。在控件中，逻辑与其外观（也称为WidgetRenderer）是分开的。\n控件也是CanvasObject类型，因此我们可以将窗口的内容设置为单个控件。看看我们如何创建一个新的widget.Entry并将其设置为窗口的内容。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Widget\u0026#34;) myWindow.SetContent(widget.NewEntry()) myWindow.ShowAndRun() } 这段描述说明了如何在Fyne应用程序中处理和更新画布内容，以及如何使用控件来创建交互式用户界面元素。\n"},{"id":1,"href":"/gofyne/docs/09-architecture/01-geometry/","title":"01. 几何 Geometry","section":"架构","content":" 几何 Geometry # Fyne 应用基于每个窗口有一个画布。每个画布有一个根 CanvasObject，它可以是一个单独的控件或一个容器，用于控制多个子对象的大小和位置，这些子对象由布局控制。\n位置 # 每个画布的原点位于左上角（0, 0），UI 的每个元素都可能根据输出设备进行缩放，因此 API 不描述像素或精确的尺寸。 例如，在120DPI的显示器上，位置（10, 10）可能从原点向右和向下各10像素，但在HiDPI（或“Retina”）显示器上，这可能更接近20像素。\n每个 CanvasObject 引用的位置都是相对于它的父级的。这对于布局算法很重要，但对于开发者在例如 Tappable.Tapped(PointEvent) 处理程序这样的情况下也很重要。这里的 X/Y 坐标将从按钮的左上角而不是整个画布计算。这样设计是为了让代码尽可能自包含。\n像素大小 # 像其他基于矢量的 GUI 库一样，Fyne 坐标需要基于某种基线显示器分辨率。所有 缩放都是相对于这个值的。对于 Fyne 来说，该分辨率是120DPI。这意味着当你的显示器是120DPI且所有缩放值都设置为1时，fyne.Size中引用的尺寸将是1=1px。对于 HiDPI 屏幕，如上所述，实际 DPI 可能更接近240，在移动设备上甚至可能是360或更高。为了管理这种复杂性，工具包在内部管理缩放，因此你的应用总是看起来大小合适。如果用户设置的缩放比例较小，那么他们的应用将始终具有小于正常的字体、按钮等，当他们指定较大时，你的应用将适当放大。\n与 Material Design 相比，我们可以看到他们的基线 DPI 是 160，尽管数学上相似，但实际数字会有所不同。这意味着 Fyne 中的设备独立尺寸使用较小的数字来代表相同的物理尺寸。例如，Fyne 中高度为 18 的图标在标准的 Material Design（例如 Android）应用中的尺寸为 24。构建应用程序时，这并不重要，但在与设计师或熟悉 Material Design 的专家合作时可能很重要。\n如果你开始加载位图图像，像素尺寸将变得重要。通常这些图像会适当缩放，但如果你指定 FillMode=fyne.FillOriginal，则由于像素密度的不同，实际图像大小在不同设备上会有所不同。通常这个功能会在 Scroll 容器内使用。Fyne 还定义了一个 canvas.Raster 原始类型，它将在输出设备的像素密度下精确绘制像素。这使你的代码能够在不了解运行设备的详细信息的情况下，以最高可能的输出分辨率进行绘制。如果由于某种原因你需要“像素完美”定位，你需要将 CanvasObject.Size() 乘以 Canvas.Scale()。\n"},{"id":2,"href":"/gofyne/docs/06-collection/01-list/","title":"01. 列表 List","section":"集合","content":" 列表 List # List 集合控件是工具包中的集合控件之一。这些控件旨在帮助构建在呈现大量数据时性能非常高的界面。你还可以看到具有类似 API 的 Table 和 Tree 控件。由于这种设计，它们使用起来稍微复杂一些。\nList 使用回调函数来在需要数据时请求数据。有三个主要的回调函数：Length、CreateItem 和 UpdateItem。Length 回调（首先传递）是最简单的，它返回要展示的数据中有多少项。其他回调与模板相关 - 如何创建、缓存和重用图形元素。\nCreateItem 回调返回一个新的模板对象。当控件呈现时，这将使用真实数据重新使用。此对象的 MinSize 将影响 List 的最小尺寸。最后，UpdateItem 被调用来将一个数据项应用于缓存的模板。使用这个来设置准备显示的内容。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) var data = []string{\u0026#34;a\u0026#34;, \u0026#34;string\u0026#34;, \u0026#34;list\u0026#34;} func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;列表控件\u0026#34;) list := widget.NewList( func() int { return len(data) }, func() fyne.CanvasObject { return widget.NewLabel(\u0026#34;template\u0026#34;) }, func(i widget.ListItemID, o fyne.CanvasObject) { o.(*widget.Label).SetText(data[i]) }) myWindow.SetContent(list) myWindow.ShowAndRun() } "},{"id":3,"href":"/gofyne/docs/01-started/01-index/","title":"01. 安装指南","section":"快速开始","content":" 安装指南 # 使用 Fyne 工具包构建跨平台应用程序非常简单，但在开始之前需要安装一些工具。如果您的计算机已经为Go开发设置好了，以下步骤可能不是必需的，但我们建议您阅读一下您操作系统的提示，以防万一。如果本教程后面的步骤出现问题，那么您应该重新检查以下的先决条件。\n先决条件 # Fyne需要3个基本元素：Go工具（至少版本1.12）、一个C编译器（用于与系统图形驱动连接）和一个系统图形驱动。根据您的操作系统，安装指令会有所不同，请选择下面适合您的选项卡查看安装指令。\n请注意，这些步骤仅用于开发 - 您的Fyne应用不需要为最终用户安装任何设置或依赖！\n如下的 termux 是用于在 Android 设备上构建 Fyne 应用，无 PC 依赖。 Windows 从 下载页面下载Go并按照说明安装 为Windows安装以下测试过的C编译器之一： MSYS2配合MingW-w64 - msys2.org TDM-GCC - tdm-gcc.tdragon.net Cygwin - cygwin.com 在Windows上，您的图形驱动程序已经安装好了，但建议确保它们是最新的。 使用MSYS2（推荐）的安装步骤如下：\n从 msys2.org安装MSYS2 安装完成后不要使用打开的MSYS终端 从开始菜单打开“MSYS2 MinGW 64位” 执行以下命令（如果询问安装选项，请确保选择“全部”）： $ pacman -Syu $ pacman -S git mingw-w64-x86_64-toolchain 您需要将 /c/Program\\ Files/Go/bin和 ~/Go/bin 添加到您的 $PATH 中，对于MSYS2，您可以将以下命令粘贴到终端中： $ echo \u0026#34;export PATH=\\$PATH:/c/Program\\ Files/Go/bin:~/Go/bin\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 为了让编译器在其他终端上工作，您需要设置Windows的%PATH%变量，以便找到这些工具。进入“编辑系统环境变量”控制面板，点击“高级”，并将“C:\\msys64\\mingw64\\bin”添加到路径列表中。 MacOS 从 下载页面下载Go并按照说明进行安装。 从 Mac App Store安装Xcode。 通过打开终端窗口并输入以下命令来设置Xcode命令行工具：xcode-select --install。 在macOS上，图形驱动程序将已经安装。 Linux 您需要使用包管理器安装Go、gcc和图形库头文件，以下命令之一可能会起作用。\nDebian / Ubuntu: sudo apt-get install golang gcc libgl1-mesa-dev xorg-dev\nFedora: sudo dnf install golang gcc libXcursor-devel libXrandr-devel mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel\nArch Linux: sudo pacman -S go xorg-server-devel libxcursor libxrandr libxinerama libxi\nSolus: sudo eopkg it -c system.devel golang mesalib-devel libxrandr-devel libxcursor-devel libxi-devel libxinerama-devel\nopenSUSE: sudo zypper install go gcc libXcursor-devel libXrandr-devel Mesa-libGL-devel libXi-devel libXinerama-devel libXxf86vm-devel\nVoid Linux: sudo xbps-install -S go base-devel xorg-server-devel libXrandr-devel libXcursor-devel libXinerama-devel\nAlpine Linux: sudo apk add go gcc libxcursor-dev libxrandr-dev libxinerama-dev libxi-dev linux-headers mesa-dev\nNixOS: nix-shell -p libGL pkg-config xorg.libX11.dev xorg.libXcursor xorg.libXi xorg.libXinerama xorg.libXrandr xorg.libXxf86vm\nRaspberry Pi 您需要使用包管理器安装Go、gcc和图形库头文件。\nsudo apt-get install golang gcc libegl1-mesa-dev xorg-dev BSD 您需要使用包管理器安装Go、gcc和图形库头文件。\nFreeBSD: sudo pkg install go gcc xorg pkgconf OpenBSD: sudo pkg_add go NetBSD: sudo pkgin install go pkgconf Android 要为Android开发应用，您首先需要为您当前的电脑（Windows、macOS或Linux）安装工具。 完成后，您需要安装Android SDK和Android NDK——推荐的方法是安装 Android Studio，然后转到Tools \u0026gt; SDK Manager，并从SDK Tools安装NDK（并行）包。 或者，您可以下载 Standalone Android NDK，这是一种更精简的方法。解压缩文件夹，并将ANDROID_NDK_HOME环境变量指向它。 IOS 要为iOS开发应用，您将需要访问一台按照上面macOS标签配置的苹果Mac电脑。 您还需要创建一个苹果开发者账户并注册开发者计划（需要支付费用）以获取在任何设备上运行应用所需的证书。 Termux 在Android上编译Fyne应用，您将需要Android 9或以上版本。\n安装fdroid，然后从那里安装termux。 打开Termux并安装Go和Git：pkg install golang git。 从 https://github.com/Lzhiyong/termux-ndk安装NDK和SDK到termux，并设置环境变量ANDROID_HOME和ANDROID_NDK_HOME。 下载 # 使用Go模块（Go 1.16及更高版本要求），在使用包之前需要设置模块。\nGo模块（适用于Go 1.16或更新版本） # 如果您不使用模块或您的模块已经初始化，可以跳过此步骤到下一个步骤。运行以下命令并将MODULE_NAME替换为您偏好的模块名（应在为您的应用程序专门创建的新文件夹中调用）。\n$ cd myapp $ go mod init MODULE_NAME 现在您需要下载Fyne模块和辅助工具。使用以下命令完成：\n$ go get fyne.io/fyne/v2@latest $ go install fyne.io/fyne/v2/cmd/fyne@latest 如果您不确定Go模块如何工作，考虑阅读[教程：创建一个Go模块]。\n旧版Go安装 # 使用旧版Go发布安装Fyne工具包和辅助工具，只需执行go get命令：\n$ go get fyne.io/fyne/v2 $ go get fyne.io/fyne/v2/cmd/fyne 检查您的安装 # 在编写应用或运行示例之前，您可以使用Fyne安装工具检查您的安装。只需从链接下载适合您计算机的应用并运行它，您应该看到类似以下屏幕的内容：\n如果您的安装有任何问题，请查看 故障排除 部分以获取提示。\n运行演示 # 如果您在开始编写自己的应用程序之前想看看Fyne工具包的实际运行情况，您可以通过执行以下命令在您的计算机上运行我们的演示应用：\n$ go run fyne.io/fyne/v2/cmd/fyne_demo@latest 请注意，首次运行需要编译一些C代码，因此可能比平时需要更长的时间。后续构建会重用缓存，将会快得多。\n旧版 Go 版本 # 要在旧版Go上运行演示，只需执行以下命令：\n$ go run fyne.io/fyne/v2/cmd/fyne_demo 安装 # 如果您愿意，您也可以使用以下命令安装演示（需要Go 1.16或更高版本）：\n$ go install fyne.io/fyne/v2/cmd/fyne_demo@latest 对于早期版本的Go，您需要使用以下命令：\n$ go get fyne.io/fyne/v2/cmd/fyne_demo 如果您的GOBIN环境变量已添加到路径中（在macOS和Windows上默认应该如此），那么您就可以运行演示了：\n$ fyne_demo 就是这样！现在您可以用您选择的IDE编写自己的Fyne应用程序了。就这些了！现在你可以在你选择的IDE中编写自己的Fyne应用程序了。如果你想看到一些Fyne代码的实际运用，那么你可以阅读你的第一个应用程序。\n"},{"id":4,"href":"/gofyne/docs/10-faq/01-layout/","title":"01. 布局与控件大小","section":"常见问题","content":" 布局与控件大小 # 移动和调整大小 # 问：我如何将我的控件移动到不同的位置或调整其大小？\n答： Fyne 应用中元素的位置和大小由它们所在的容器的布局控制。如果你的 UI 元素太小，请考虑使用不同的 布局或容器。\n一个新的Window会扩展传递给SetContent()的任何元素以填满它的大小。每次你向此添加一个容器时，它都会根据布局划分可用空间。像HBox和VBox这样的布局会将内容缩小到其MinSize()以在一个或另一个维度上打包内容。像Max或Border这样的布局会扩展内容以填充空间。通过编写 自定义布局，你可以完全控制容器中的项目。\n问：我的图像为什么这么小？\n答： 使用像 Fyne 这样的完全可缩放的用户界面工具包的一个困难是，坐标系统是与设备无关的。这允许应用根据连接的硬件以正确的分辨率或像素密度绘制，以获得最佳结果。这对于基于像素的图像意味着它们的大小可能会根据编译时未知的细节而变化。\n由于这种复杂性，使用canvas.NewImageFromFile()或类似调用加载的图像将不会设置大小，导致它非常小或默认情况下看起来被隐藏。当放置在适当的布局中时，图像将根据其FillMode属性进行拉伸。如果你希望图像始终设置为特定大小（或更大），你可以调用Image.SetMinSize()并为图像指定一个与设备无关的大小。\n容器和布局 # 问：我如何手动控制元素的位置\n答： 在某些情况下，你可能希望完全控制容器中元素的位置和大小。为此，你创建一个没有布局的容器。container.NewWithoutLayout()函数将创建一个用于手动定位的容器——你应该将你想要在这个容器中管理的图形元素列表传递给该构造函数。\n设置好后，你可以使用Move()和Resize()在每个元素上进行定位。在执行此操作时，请注意，它不会随着可用空间的变化而调整——它也没有明确的最小尺寸。要添加这些功能中的任何一个，你应该用 自定义布局替换你的手动定位。\n"},{"id":5,"href":"/gofyne/docs/05-widget/01-label/","title":"01. 标签 Label ","section":"控件","content":" 标签 Label # Widgets 是 Fyne 应用程序 GUI 的主要组件，它们可以被用在任何一个基本的 fyne.CanvasObject 可以使用的地方。它们管理用户交互，并且总是与当前主题相匹配。\nLabel widget 是最简单的一个 - 它向用户展示文本。与 canvas.Text 不同，它可以处理一些简单的格式化（如 \\n）和换行（通过设置 Wrapping 字段）。 你可以通过调用 widget.NewLabel(\u0026quot;some text\u0026quot;) 来创建一个标签，结果可以被赋值给一个变量或直接传递给一个容器。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Label Widget\u0026#34;) content := widget.NewLabel(\u0026#34;text\u0026#34;) myWindow.SetContent(content) myWindow.ShowAndRun() } "},{"id":6,"href":"/gofyne/docs/04-container/01-box/","title":"01. 盒子 Box","section":"容器与布局","content":" 盒子 Box # 如在 容器和布局中讨论的，容器中的元素可以使用布局来排列。本节探讨内置布局及其使用方法。\n最常用的布局是 layout.BoxLayout，它有两个变体，水平和垂直。盒子布局将所有元素排列在单个行或列中，并可选择间隔以协助对齐。\n水平盒子布局，通过 layout.NewHBoxLayout() 创建，将项目排列在单行中。盒子中的每个项目的宽度将设置为其 MinSize().Width，高度对所有项目而言都是相等的，值为所有 MinSize().Height 值中的最大值。该布局可用于容器中，或者你可以使用盒子控件 widget.NewHBox()。\n垂直盒子布局与之相似，但它将项目排列在一列中。每个项目的高度将设置为最小值，所有宽度将相等，设置为最小宽度中的最大值。\n为了在元素之间创建扩展空间（例如，使某些元素左对齐，其他元素右对齐），在项目中添加一个 layout.NewSpacer()。间隔符将扩展以填充所有可用空间。在垂直盒子布局开始处添加一个间隔符将导致所有项目底部对齐。你可以在水平排列的开始和结束处各添加一个间隔符，以创建居中对齐。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;盒子布局\u0026#34;) text1 := canvas.NewText(\u0026#34;你好\u0026#34;, color.White) text2 := canvas.NewText(\u0026#34;在那里\u0026#34;, color.White) text3 := canvas.NewText(\u0026#34;(右侧)\u0026#34;, color.White) content := container.New(layout.NewHBoxLayout(), text1, text2, layout.NewSpacer(), text3) text4 := canvas.NewText(\u0026#34;居中\u0026#34;, color.White) centered := container.New(layout.NewHBoxLayout(), layout.NewSpacer(), text4, layout.NewSpacer()) myWindow.SetContent(container.New(layout.NewVBoxLayout(), content, centered)) myWindow.ShowAndRun() } "},{"id":7,"href":"/gofyne/docs/03-canvas/01-rectangle/","title":"01. 矩形 Rectangle","section":"画图和动画","content":" 矩形 Rectangle # canvas.Rectangle 是 Fyne 中最简单的画布对象。它显示指定颜色的区块。您也可以使用 FillColor 字段设置颜色。\n在这个示例中，矩形填充了窗口，因为它是唯一的内容元素。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;矩形\u0026#34;) rect := canvas.NewRectangle(color.White) w.SetContent(rect) w.Resize(fyne.NewSize(150, 100)) w.ShowAndRun() } 其他的 fyne.CanvasObject 类型有更多的配置，让我们 接下来看看 canvas.Text。\n"},{"id":8,"href":"/gofyne/docs/07-binding/01-simple/","title":"01. 简单绑定","section":"数据绑定","content":" 简单绑定 # 绑定控件的最简单形式是将绑定项作为值传递给它，而不是静态值。许多控件提供了一个WithData构造函数，它将接受一个类型化的数据绑定项。要设置绑定，你需要做的就是传递正确的类型。\n尽管在初始代码中这看起来可能没有多大好处，但你可以看到它如何确保显示的内容始终与数据源保持最新。你会注意到，我们不需要在Label控件上调用Refresh()，甚至不需要保留它的引用，但它仍然会适当更新。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;Simple\u0026#34;) str := binding.NewString() str.Set(\u0026#34;Initial value\u0026#34;) text := widget.NewLabelWithData(str) w.SetContent(text) go func() { time.Sleep(time.Second * 2) str.Set(\u0026#34;A new string\u0026#34;) }() w.ShowAndRun() } 在下一步中，我们将看看如何通过 双向绑定设置编辑值的控件。\n"},{"id":9,"href":"/gofyne/docs/08-extend/01-custom-layout/","title":"01. 自定义布局 Layout","section":"扩展新类型","content":" 自定义布局 Layout # 在Fyne应用程序中，每个Container都使用一个简单的布局算法来排列其子元素。Fyne在fyne.io/fyne/v2/layout包中定义了许多可用的布局。如果你查看代码，你会看到它们都实现了Layout接口。\ntype Layout interface { Layout([]CanvasObject, Size) MinSize(objects []CanvasObject) Size } 任何应用程序都可以提供一个自定义布局来以非标准的方式排列控件。为此，你需要在自己的代码中实现上述接口。为了说明这一点，我们将创建一个新的布局，该布局将元素排列在对角线上，并排列到其容器的左下角。\n首先，我们将定义一个新类型diagonal，并定义其最小大小将是多少。为了计算这个，我们只需添加所有子元素（指定为MinSize的[]fyne.CanvasObject参数）的宽度和高度。\nimport \u0026#34;fyne.io/fyne/v2\u0026#34; type diagonal struct { } func (d *diagonal) MinSize(objects []fyne.CanvasObject) fyne.Size { w, h := float32(0), float32(0) for _, o := range objects { childSize := o.MinSize() w += childSize.Width h += childSize.Height } return fyne.NewSize(w, h) } 对这个类型，我们添加一个Layout()函数，该函数应该将所有指定的对象移动到第二个参数中指定的fyne.Size中。\n在我们的实现中，我们计算控件的左上角位置（这是0 x参数，并且有一个y位置，即容器的高度减去所有子项高度的总和）。从顶部位置开始，我们简单地将每个项目位置按前一个子项目的大小向前移动。\nfunc (d *diagonal) Layout(objects []fyne.CanvasObject, containerSize fyne.Size) { pos := fyne.NewPos(0, containerSize.Height - d.MinSize(objects).Height) for _, o := range objects { size := o.MinSize() o.Resize(size) o.Move(pos) pos = pos.Add(fyne.NewPos(size.Width, size.Height)) } } 创建自定义布局就是这么简单。现在代码都写好了，我们可以将其作为container.New的layout参数使用。下面的代码设置了3个Label控件，并将它们与我们新的布局放在一个容器中。如果你运行这个应用程序，你将看到对角线控件的排列，并且在调整窗口大小时，它们将对齐到可用空间的左下角。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Diagonal\u0026#34;) text1 := widget.NewLabel(\u0026#34;topleft\u0026#34;) text2 := widget.NewLabel(\u0026#34;Middle Label\u0026#34;) text3 := widget.NewLabel(\u0026#34;bottomright\u0026#34;) w.SetContent(container.New(\u0026amp;diagonal{}, text1, text2, text3)) w.ShowAndRun() } "},{"id":10,"href":"/gofyne/docs/10-faq/02-theme/","title":"02. 主题与自定义","section":"常见问题","content":" 主题与自定义 # 在这个页面上，我们回答了一些关于Fyne主题和控件设计的常见问题。\n自定义 # 问：如何更改Label控件文本的颜色？\n答： 所有标准控件都使用当前的Theme定义来设置颜色、字体和大小。要对你的应用程序进行更改，请考虑使用 自定义主题。\n如果你的应用程序需要不同颜色的文本，可以使用canvas.Text类型代替。这允许直接设置文本的颜色和大小。在执行此操作时要小心，因为用户可以在浅色或深色主题变体之间选择，所以你应该在两种情况下都进行测试。\n问：如何从我的Entry控件中移除背景颜色？\n答： 输入背景是由主题的InputBackground颜色设置的。你可以将其更改为color.Transparent以移除所有输入背景框。不可能编辑单个输入元素的样式——主题API旨在提供可自定义的，但一致的设计。\n主题API # 问：如何使用我在v2.0.0之前编写的自定义主题？\n答： 随着时间的推移，你应该考虑更新使用新的主题API。然而，它是可能的在过渡时期使用一个简单的适配器来允许旧主题的使用。你会发现theme.FromLegacy函数，可以将旧的主题实例适配到新的API。\nmyTheme := \u0026amp;myOldThemeType{} updated := theme.FromLegacy(myTheme) app.Settings().SetTheme(updated) 使用这种模式下的主题时，没有性能损失，但在未来的版本中这个API将被移除。\n"},{"id":11,"href":"/gofyne/docs/01-started/02-hello/","title":"02. 创建第一个应用","section":"快速开始","content":" 第一个应用 # 在完成了入门安装文档中的步骤后，你现在已经准备好构建你的第一个应用程序了。为了说明这个过程，我们将构建一个简单的“Hello World”应用程序。\n一个简单的应用程序从使用app.New()创建一个应用实例开始，然后使用app.NewWindow()打开一个窗口。接着定义一个控件树，并使用窗口上的SetContent()将其设置为主内容。然后通过在窗口上调用ShowAndRun()来显示应用UI。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Hello World\u0026#34;) w.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) w.ShowAndRun() } 上面的代码可以使用命令go build .进行构建，然后通过运行hello命令或双击图标来执行。你也可以跳过编译步骤，直接使用go run ..来运行代码。\n无论采取哪种方法，都会显示一个窗口，看起来像这样：\n如果你更喜欢浅色主题，只需设置环境变量FYNE_THEME=light，你就会得到：\n这就是入门的全部内容了。要了解更多，你可以阅读完整的 API文档。\n"},{"id":12,"href":"/gofyne/docs/07-binding/02-twoway/","title":"02. 双向绑定","section":"数据绑定","content":" 双向绑定 # 到目前为止，我们已经看到了数据绑定作为一种方式来保持用户界面元素更新。然而，更常见的需求是从UI控件更新值并保持数据在各处都是最新的。值得庆幸的是，Fyne提供的绑定是“双向”的，这意味着值既可以被推入其中也可以被读出。数据的更改将被通知到所有连接的代码，无需任何额外的代码。\n为了看到这个功能的实际操作，我们可以更新最后的测试应用，以显示一个Label和一个Entry，它们绑定到同一个值。通过这样设置，你可以看到通过entry编辑值也会更新label中的文本。这一切都可以在不调用refresh或在代码中引用控件的情况下实现。\n通过将你的应用移动到使用数据绑定，你可以停止保存指向所有控件的指针。相反，通过捕获数据作为一组绑定的值，你的用户界面可以是完全独立的代码。更清晰易读，更易于管理。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;Two Way\u0026#34;) str := binding.NewString() str.Set(\u0026#34;Hi!\u0026#34;) w.SetContent(container.NewVBox( widget.NewLabelWithData(str), widget.NewEntryWithData(str), )) w.ShowAndRun() } 接下来，我们将看看如何在我们的数据中添加 转换。\n"},{"id":13,"href":"/gofyne/docs/02-explore/02-container/","title":"02. 容器与布局","section":"探索 Fyne","content":" 容器与布局 # 在前一个示例中，我们看到了如何将CanvasObject设置为Canvas的内容，但只显示一个视觉元素并不是很有用。要显示多个项，我们使用Container类型。\n由于fyne.Container也是一个fyne.CanvasObject，我们可以将它设置为fyne.Canvas的内容。在这个示例中，我们创建了3个文本对象，然后使用container.NewWithoutLayout()函数将它们放入一个容器中。由于没有设置布局，我们可以像你看到的那样用text2.Move()移动元素。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; //\u0026#34;fyne.io/fyne/v2/layout\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Container\u0026#34;) green := color.NRGBA{R: 0, G: 180, B: 0, A: 255} text1 := canvas.NewText(\u0026#34;Hello\u0026#34;, green) text2 := canvas.NewText(\u0026#34;There\u0026#34;, green) text2.Move(fyne.NewPos(20, 20)) content := container.NewWithoutLayout(text1, text2) // content := container.New(layout.NewGridLayout(2), text1, text2) myWindow.SetContent(content) myWindow.ShowAndRun() } fyne.Layout实现了一种在容器内组织项目的方法。通过在这个示例中取消注释container.New()行，你改变了容器以使用2列的网格布局。运行此代码并尝试调整窗口大小，看看布局如何自动配置窗口的内容。还要注意，text2的手动位置被布局代码忽略了。\n要了解更多，你可以查看 布局组件。\n"},{"id":14,"href":"/gofyne/docs/05-widget/02-button/","title":"02. 按钮 Button","section":"控件","content":" 按钮 Button # 按钮控件可以包含文本、图标或两者，构造函数是 widget.NewButton() 和 widget.NewButtonWithIcon()。要创建一个文本按钮，只有两个参数，string 内容和一个没有参数的 func()，当按钮被点击时将调用此函数。参见示例以了解如何创建它。\n带有图标的按钮构造函数包含一个额外的参数，即包含图标数据的 fyne.Resource。theme 包中的内置图标都适当地适应主题更改。如果将自己的图像加载为资源，你可以传入自己的图像 - 诸如 fyne.LoadResourceFromPath() 的助手可能会有所帮助，尽可能推荐捆绑资源。\n要创建仅带图标的按钮，你应该将 \u0026quot;\u0026quot; 作为标签参数传递给 widget.NewButtonWithIcon()。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; //\u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;按钮控件\u0026#34;) content := widget.NewButton(\u0026#34;点击我\u0026#34;, func() { log.Println(\u0026#34;点击\u0026#34;) }) //content := widget.NewButtonWithIcon(\u0026#34;首页\u0026#34;, theme.HomeIcon(), func() { //\tlog.Println(\u0026#34;点击首页\u0026#34;) //}) myWindow.SetContent(content) myWindow.ShowAndRun() } "},{"id":15,"href":"/gofyne/docs/03-canvas/02-text/","title":"02. 文本 Text","section":"画图和动画","content":" 文本 Text # canvas.Text 用于 Fyne 内的所有文本渲染。它通过指定文本和文本颜色来创建。文本使用当前主题指定的默认字体渲染。\n文本对象允许某些配置，如 Alignment 和 TextStyle 字段，如此示例中所示。如果你想使用等宽字体，可以指定 fyne.TextStyle{Monospace: true}。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;文本\u0026#34;) text := canvas.NewText(\u0026#34;文本对象\u0026#34;, color.White) text.Alignment = fyne.TextAlignTrailing text.TextStyle = fyne.TextStyle{Italic: true} w.SetContent(text) w.ShowAndRun() } 通过指定 FYNE_FONT 环境变量，可以使用另一种字体。使用这个来设置一个 .ttf 文件，代替 Fyne 工具包或当前主题提供的字体。\n"},{"id":16,"href":"/gofyne/docs/09-architecture/02-scaling/","title":"02. 缩放 Scaling","section":"架构","content":" 缩放 Scaling # Fyne 完全使用矢量图形构建，这意味着用 Fyne 编写的应用程序可以美观地缩放到任何大小（不仅仅是整数增量）。这对于移动设备和高端计算机上越来越受欢迎的高密度显示屏是一个巨大的好处。默认的缩放值是根据你的操作系统计算出来的 - 在一些系统上，这是用户配置，在其他系统上则来自于你的屏幕像素密度（DPI - 每英寸点数）。如果一个 Fyne 窗口被移动到另一个屏幕上，它将重新缩放并相应地调整窗口大小！我们称之为“自动缩放”，旨在在更换显示器时保持应用程序用户界面的相同大小。\n你可以使用 fyne_settings 应用程序调整应用程序的大小，或者通过设置 FYNE_SCALE 环境变量来设置特定的缩放比例。这些值可以使内容比系统设置大或小，使用 \u0026ldquo;1.5\u0026rdquo; 会使事物变大 50%，设置 0.8 会使其缩小 20%。\nStandard size FYNE_SCALE=0.5 FYNE_SCALE=2.5 "},{"id":17,"href":"/gofyne/docs/04-container/02-grid/","title":"02. 网格 Grid","section":"容器与布局","content":" 网格 Grid # 网格布局将容器的元素以网格模式布置，具有固定数量的列。项目将填充单个行，直到达到列数，之后将创建新行。垂直空间将在对象的每一行之间平均分配。\n使用 layout.NewGridLayout(cols) 创建网格布局，其中 cols 是您希望每行中有的项目（列）数量。然后将此布局作为第一个参数传递给 container.New(...)。\n如果您调整容器的大小，则每个单元格将平等地调整大小，以分享可用空间。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;网格布局\u0026#34;) text1 := canvas.NewText(\u0026#34;1\u0026#34;, color.White) text2 := canvas.NewText(\u0026#34;2\u0026#34;, color.White) text3 := canvas.NewText(\u0026#34;3\u0026#34;, color.White) grid := container.New(layout.NewGridLayout(2), text1, text2, text3) myWindow.SetContent(grid) myWindow.ShowAndRun() } "},{"id":18,"href":"/gofyne/docs/08-extend/02-custom-widget/","title":"02. 自定义控件 Widget","section":"扩展新类型","content":" 自定义控件 Widget\u0026quot; # 标准控件与 Fyne 一起提供，旨在支持标准用户交互和需求。由于 GUI 经常需要提供自定义功能，因此可能需要编写自定义控件。本文概述了如何进行。\n一个控件被分为两个区域 - 每个都实现一个标准接口 - fyne.Widget 和 fyne.WidgetRenderer。控件定义行为和状态，而渲染器用于定义它应如何绘制到屏幕上。\nfyne.Widget # Fyne 中的控件简单来说是一个有状态的画布对象，其渲染定义与主逻辑分离。从 fyne.Widget 接口可以看出，必须实现的内容并不多。\ntype Widget interface { CanvasObject CreateRenderer() WidgetRenderer } 由于控件需要像任何其他画布项目一样被使用，我们从相同的接口继承。为了省去编写所有必需的函数，我们可以使用 widget.BaseWidget 类型，它处理了基础内容。\n每个控件定义将包含比接口要求更多的内容。在 Fyne 控件中导出定义行为的字段是标准做法（就像 canvas 包中定义的原语一样）。\n例如，看看 widget.Button 类型：\ntype Button struct { BaseWidget Text string Style ButtonStyle Icon fyne.Resource OnTapped func() } 你可以看到这些项目如何存储有关控件行为的状态，但没有关于它如何呈现的信息。\nfyne.WidgetRenderer # 控件渲染器负责管理一组 fyne.CanvasObject 原语，这些原语组合在一起创建了我们控件的设计。它很像 fyne.Container，但有自定义布局和一些额外的主题处理。\n每个控件都必须提供一个渲染器，但完全可以重用另一个控件的渲染器 - 特别是如果你的控件是另一个标准控件的轻量级包装。\ntype WidgetRenderer interface { Layout(Size) MinSize() Size Refresh() Objects() []CanvasObject Destroy() } 可以看到 Layout(Size) 和 MinSize() 函数类似于 fyne.Layout 接口，但没有 []fyne.CanvasObject 参数 - 这是因为控件确实需要布局，但它控制哪些对象将被包含。\nRefresh() 方法在绘制的控件发生变化或主题被更改时触发。在任一情况下，我们可能需要调整它的外观。最后，当这个渲染器不再需要时，会调用 Destroy() 方法，因此它应该清除任何可能泄漏的资源。\n再次与按钮控件比较 - 它的 fyne.WidgetRenderer 实现基于以下类型：\ntype buttonRenderer struct { icon *canvas.Image label *canvas.Text shadow *fyne.CanvasObject objects []fyne.CanvasObject button *Button } 可以看到它有字段来缓存实际图像、文本和阴影画布对象用于绘制。它跟踪 fyne.WidgetRenderer 所需的对象切片以方便使用。\n最后它保留对 widget.Button 的引用以获取所有状态信息。在 Refresh() 方法中，它将根据 widget.Button 类型中的任何更改更新图形状态。\n整合 # 基本的控件将扩展 widget.BaseWidget 类型并声明控件持有的任何状态。CreateRenderer() 函数必须存在并返回一个新的 fyne.WidgetRenderer 实例。Fyne 中的控件和驱动代码将确保这被相应地缓存 - 如果\n"},{"id":19,"href":"/gofyne/docs/06-collection/02-table/","title":"02. 表格 Table","section":"集合","content":" 表格 Table # Table集合控件类似于 List控件（工具包的另一个集合控件），它具有二维索引。像List一样，这旨在帮助构建性能非常高的接口，当展示大量数据时。因此，控件不是用所有数据创建的，而是在需要时调用数据源。\nTable使用回调函数在需要数据时请求数据。有3个主要的回调，Length、CreateCell和UpdateCell。Length回调（首先传递）是最简单的，它返回要展示的数据中有多少项，它返回的两个int分别代表行数和列数。其他两个与内容模板相关。\nCreateCell回调返回一个新的模板对象，就像列表一样。不同之处在于MinSize将定义每个单元格的标准大小，以及表格的最小大小（它至少显示一个单元格）。如前所述，UpdateCell被调用来将数据应用于单元格模板。传入的索引是相同的(row, col)int对。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) var data = [][]string{[]string{\u0026#34;左上角\u0026#34;, \u0026#34;右上角\u0026#34;}, []string{\u0026#34;左下角\u0026#34;, \u0026#34;右下角\u0026#34;}} func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;表格控件\u0026#34;) list := widget.NewTable( func() (int, int) { return len(data), len(data[0]) }, func() fyne.CanvasObject { return widget.NewLabel(\u0026#34;宽内容\u0026#34;) }, func(i widget.TableCellID, o fyne.CanvasObject) { o.(*widget.Label).SetText(data[i.Row][i.Col]) }) myWindow.SetContent(list) myWindow.ShowAndRun() } "},{"id":20,"href":"/gofyne/docs/02-explore/03-widgets/","title":"03. 内置控件 Widget","section":"探索 Fyne","content":" 标准 Widget (在 widget 包中） # 手风琴（Accordion） # 手风琴显示一个手风琴项目列表。每个项目由一个按钮表示，当点击时会展示一个详细视图。\n按钮（Button） # 按钮控件有一个文本标签和图标，两者都是可选的。\n卡片（Card） # 卡片控件以头部和副标题将元素分组，所有这些都是可选的。\n复选框（Check） # 复选框控件有一个文本标签和一个选中（或未选中）的图标。\n输入框（Entry） # 输入框控件允许在聚焦时输入简单文本。\n密码输入框控件隐藏文本输入，并添加一个按钮以显示文本。\n文件图标（FileIcon） # 文件图标为各种类型的文件提供有用的标准图标。它显示文件类型的指示图标并显示文件类型的扩展名。\n表单（Form） # 表单控件是一个两列网格，每行有一个标签和一个控件（通常是输入）。如果应该显示任何表单控制按钮，则网格的最后一行将包含它们。\n超链接（Hyperlink） # 超链接控件是一个具有适当填充和布局的文本组件。点击时，URL会在默认网络浏览器中打开。\n图标（Icon） # 图标控件是一个基本的图像组件，加载资源以匹配主题。\n标签（Label） # 标签控件是一个具有适当填充和布局的标签组件。\n进度条（Progress bar） # 进度条控件创建一个表示进度的水平面板。\n无限进度条控件创建一个表示无限等待的水平面板。一个无限进度条会重复从0%循环到100%，直到调用Stop()。\n单选组（RadioGroup） # 单选组控件有一个文本标签列表和每个旁边的单选检查图标。\n选择（Select） # 选择控件有一个选项列表，显示当前选项，并在点击时触发一个事件函数。\n选择输入（SelectEntry） # 选择输入控件在选择控件中添加了一个可编辑组件。用户可以选择一个选项或输入自己的值。\n分隔符（Separator） # 分隔符控件在其他元素之间显示一条分隔线。\n滑块（Slider） # 滑块是一个可以在两个固定值之间滑动的控件。\n文本网格（TextGrid） # 文本网格是一个等宽的字符网格。这是设计用来被文本编辑器、代码预览或终端仿真器使用的。\n工具栏（Toolbar） # 工具栏控件创建一个水平的工具按钮列表。\n集合控件（在widget包中） # 集合控件提供高级缓存功能，以提供大量数据的高性能渲染。这确实导致了更复杂的构造器，但对于它启用的结果来说是一个好平衡。这些控件中的每一个都使用了一系列回调，最小集由它们的构造函数定义，其中包括数据大小，可以重用的模板项目的创建，以及将数据应用到即将添加到显示中的控件的函数。\n列表（List） # 列表提供了许多子项的高性能垂直滚动。\n表格（Table） # 表格提供了许多子项的高性能滚动二维显示。\n树形（Tree） # 树形 控件提供了一个高性能的垂直滚动列表，可以展开以显示子元素。\n容器控件（在container包中） # 容器控件类似于常规容器，但它们提供了一些额外的功能。\n应用标签页 # 应用标签页控件允许从一系列标签项中切换可见内容。每个项都由顶部的一个按钮代表。\n滚动 # 滚动容器定义了一个比内容小的容器。\n分割 # 分割容器定义了一个容器，其大小在两个子项之间分割。\n"},{"id":21,"href":"/gofyne/docs/09-architecture/03-widgets/","title":"03. 控件 Widget","section":"架构","content":" 控件 Widget # Fyne 工具包中的控件旨在提供干净愉快的用户交互体验，遵循标准主题，并支持快速应用开发、稳定测试和易于维护。这里有一些促进这一目标的设计考虑，我们将在本页探讨它们。\n行为 API # 你会注意到标准控件的 API 全部关于行为和状态——但实际上很少控制元素的外观。这是有意为之的。它使我们的代码，以及应用开发者的代码，能够专注于控件的行为，以便将其渲染过程留给其他代码处理。这使得测试变得更加容易，实际上完整的应用可以在内存中通过单元测试运行，而无需渲染应用。\n你可以 扩展现有控件来添加新的行为，而无需担心其渲染方式。也可以 编写自己的组件，应用不限于使用提供的控件集。构建自己的控件时，你会注意到渲染细节与状态完全分离——这是上述设计的一部分。WidgetRenderer（渲染Widget的代码）通常持有对它将要渲染的控件的引用，以访问状态或其他信息。当控件状态改变时，将调用 Refresh()——然后会要求渲染器刷新，并且它应该更新显示以反映新状态。建议自定义控件使用当前的Theme，但在看似合适的情况下可以选择指定自己的尺寸、颜色和图标。\n内容填充 # 标准控件使用主题指定的填充来在其图形组件周围创建适当的空间。widget 包使用标准高度和基线来确保提供的布局默认情况下能够很好地对齐。如果你正在构建自定义控件，建议遵循这些指南。\ntheme.Padding() 的值用于布局中以分隔容器的元素，它在应用的各个部分周围创建一致的空间。然而，有些控件的内容应该从范围的边缘内缩。考虑Entry，它有一个背景和边框延伸到边缘，但其内容应该内缩。因此，我们标准化了用于内缩的空间量，以便对齐匹配。\n控件的标准内缩或内容填充被定义为theme.InnerPadding()。标准的填充值是4，内部填充是8。你可以在Label和Entry中看到（文本）内容被这么多内缩，以便它们在并排放置时能够水平和垂直对齐。\n建议自定义控件包含类似的尺寸，以便它们能够与标准控件很好地配合。\n"},{"id":22,"href":"/gofyne/docs/10-faq/03-troubleshoot/","title":"03. 故障排查","section":"常见问题","content":" 故障排查 # 在设置过程中或编译第一个应用程序时，可能会遇到一些意外情况。我们在这里尝试解决这些问题。记住，你也可以使用 Fyne Setup 工具检查你的配置。\n编译器问题 # 问：命令未找到：fyne\n答： 如果你已经使用 go install fyne.io/fyne/v2/cmd/fyne@latest 安装了 Fyne 命令，但尝试运行时看到错误，则最可能的问题是你的 Go 安装没有正确设置你的 PATH 环境变量。\nGo 会将工具安装到用户的 GOPATH 位置的 bin 目录中（通常是 ~/go）- 你可以通过检查你的 PATH 变量是否包含此位置来验证这一点。如果似乎缺少这个位置，那么你应该更新你的 PATH 环境变量以包含 ~/go/bin，或者如果你更改了安装位置，则可以使用 $(go env GOPATH)/bin 代替。\n问：构建约束排除了\u0026hellip;中的所有 Go 文件\n答： 如果你正在交叉编译，你可能会看到关于 go 文件被排除的错误，随后是构建失败。当进行标准的 Go 交叉编译时，它会自动关闭 CGo。为了解决这个问题，请确保在你的编译命令中设置 CGO_ENABLED=1。\n问：cc1.exe: 抱歉，未实现：未在 64 位模式中编译\n答： Windows 编译有时会抱怨没有可用的 64 位模式。这通常是因为安装了错误的编译器，或者配置不正确。如果你已经按照我们的 MSYS2 和 MingW64 的 安装说明，那么请确保你使用的是开始菜单中标题为“MSYS2 MinGW 64-bit”的启动器。\n分发 # 问：Apple macOS 说我的应用在下载时已损坏\n答： 当文件在 macOS 计算机上下载时，它们会被标记有“隔离”标志，以便由操作系统检查是否有问题。如果你的应用程序使用从 Apple 购买的证书签名，这不是问题。然而，如果你想在没有那个成本的情况下分享你的软件，这个错误可能会出现 - 并且在 M1/2 计算机上，不可能使用系统设置来允许应用运行。\n修复的方法是删除隔离标志，你可以通过打开终端并执行以下命令来做到这一点：\nsudo xattr -r -d com.apple.quarantine MyApp.app "},{"id":23,"href":"/gofyne/docs/07-binding/03-conversion/","title":"03. 数据转换","section":"数据绑定","content":" 数据转换 # 到目前为止，我们使用的数据绑定是数据类型与输出类型匹配的情况（例如String与Label或Entry）。通常，将需要以不同于原始格式的方式展示数据。为此，binding包提供了许多有用的转换函数。\n最常见的用途是将不同类型的数据转换为字符串，以便在Label或Entry控件中显示。看看我们如何使用binding.FloatToString将Float转换为String。原始值可以通过移动滑块来编辑。每次数据变化时，它都会运行转换代码并更新任何连接的控件。\n也可以使用格式字符串为用户界面添加更自然的输出。你可以看到我们的short绑定也是将Float转换为String，但通过使用WithFormat助手，我们可以传递一个格式字符串（类似于fmt包）来提供自定义输出。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;转换\u0026#34;) f := binding.NewFloat() str := binding.FloatToString(f) short := binding.FloatToStringWithFormat(f, \u0026#34;%0.0f%%\u0026#34;) f.Set(25.0) w.SetContent(container.NewVBox( widget.NewSliderWithData(0, 100.0, f), widget.NewLabelWithData(str), widget.NewLabelWithData(short), )) w.ShowAndRun() } 最后，在本节中，我们将查看 list数据。\n"},{"id":24,"href":"/gofyne/docs/06-collection/03-tree/","title":"03. 树 Tree","section":"集合","content":" 树 Tree # Tree 集合控件类似于 List 控件（工具包的另一个集合控件），具有多级数据结构。像 List 一样，它旨在帮助构建性能良好的接口，以便在展示大量数据时使用。因此，控件不是用所有数据创建的，而是在需要时调用数据源。\nTree 使用回调函数在需要时请求数据。有四个主要的回调，ChildUIDs、IsBranch、CreateNode 和 UpdateNode。ChildUIDs 回调在这里传递每个子节点的唯一 ID 到请求的节点。这将以 TreeNodeID 为 \u0026quot;\u0026quot; 被调用，首先获取所有显示在树根中的 ID 列表。IsBranch 回调应当在节点是分支时返回 true。如果节点 ID 有子节点，通常返回 true - 但你可以有一个空的分支。\n确保树中每个树节点的 id 是唯一的，这一点至关重要。 例如，如果你正在构建一个文件管理器，ID 应该是文件路径而不是其名称。\n其他两个回调与内容模板相关。\nCreateNode 回调返回一个新的模板对象，就像列表一样，尽管有一个额外的 bool 参数，如果节点可以有子元素（是一个分支），则为 true。如前所述，UpdateNode 被调用以将数据应用于单元格模板。你应该根据 TreeNodeID 和 isBranch 参数更新内容。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;树形控件\u0026#34;) tree := widget.NewTree( func(id widget.TreeNodeID) []widget.TreeNodeID { switch id { case \u0026#34;\u0026#34;: return []widget.TreeNodeID{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} case \u0026#34;a\u0026#34;: return []widget.TreeNodeID{\u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;} } return []string{} }, func(id widget.TreeNodeID) bool { return id == \u0026#34;\u0026#34; || id == \u0026#34;a\u0026#34; }, func(branch bool) fyne.CanvasObject { if branch { return widget.NewLabel(\u0026#34;分支模板\u0026#34;) } return widget.NewLabel(\u0026#34;叶子模板\u0026#34;) }, func(id widget.TreeNodeID, branch bool, o fyne.CanvasObject) { text := id if branch { text += \u0026#34; (分支)\u0026#34; } o.(*widget.Label).SetText(text) }) myWindow.SetContent(tree) myWindow.ShowAndRun() } "},{"id":25,"href":"/gofyne/docs/03-canvas/03-line/","title":"03. 线条 Line","section":"画图和动画","content":" 线条 Line # canvas.Line 对象从 Position1（默认是左上角）画到 Position2（默认是右下角）。你可以指定它的颜色，并且可以改变笔触宽度，否则默认为 1。\n线的位置可以使用 Position1 或 Position2 字段，或者使用 Move() 和 Resize() 函数来操作。例如，宽度为 0 的区域会显示为垂直线，而高度为 0 则会是水平线。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;线条\u0026#34;) line := canvas.NewLine(color.White) line.StrokeWidth = 5 w.SetContent(line) w.Resize(fyne.NewSize(100, 100)) w.ShowAndRun() } 线条通常用于自定义布局或手动控制。与文本不同，它们没有自然（最小）大小，但可以在复杂布局中产生出色的效果。\n"},{"id":26,"href":"/gofyne/docs/04-container/03-gridwrap/","title":"03. 网格包装 Grid Wrap","section":"容器与布局","content":" 网格包装 Grid Wrap # 与之前的网格布局一样，网格包装布局在网格模式中创建元素的排列。然而，这种网格没有固定数量的列，而是为每个单元格使用固定大小，然后将内容流动到需要显示项目的尽可能多的行中。\n使用 layout.NewGridWrapLayout(size) 创建网格包装布局，其中 size 指定要应用于所有子元素的大小。然后将此布局作为第一个参数传递给 container.New(...)。根据容器的当前大小计算列数和行数。\n最初，网格包装布局将有一个单列，如果您调整它的大小（如代码注释中所示），它将重新排列子元素以填充空间。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;网格包装布局\u0026#34;) text1 := canvas.NewText(\u0026#34;1\u0026#34;, color.White) text2 := canvas.NewText(\u0026#34;2\u0026#34;, color.White) text3 := canvas.NewText(\u0026#34;3\u0026#34;, color.White) grid := container.New(layout.NewGridWrapLayout(fyne.NewSize(50, 50)), text1, text2, text3) myWindow.SetContent(grid) // myWindow.Resize(fyne.NewSize(180, 75)) myWindow.ShowAndRun() } "},{"id":27,"href":"/gofyne/docs/08-extend/03-bundle/","title":"03. 资源包 Bundle","section":"扩展新类型","content":" 资源包 # 基于 Go 的应用程序通常构建为单个二进制可执行文件，Fyne应用程序也是如此。单个文件使我们更容易分发和安装软件。不幸的是，GUI应用程序通常需要额外的资源来渲染用户界面。为了管理这个挑战，Go应用程序可以将资产捆绑到二进制文件本身中。Fyne工具包更喜欢使用\u0026quot;fyne bundle\u0026quot;，因为它有我们将在下面探索的各种好处。\n捆绑资产的基本方法是执行\u0026quot;fyne bundle\u0026quot;命令。这个工具有各种参数来自定义输出，但在其最基本的形式中，要捆绑的文件将被转换为可以构建到您的应用程序中的Go源代码。\n$ ls image.png\tmain.go $ fyne bundle -o bundled.go image.png $ ls bundled.go\timage.png\tmain.go $ bundled.go的内容将是我们然后可以在代码中访问的资源变量列表。例如，上面的代码将导致包含以下内容的文件：\nvar resourceImagePng = \u0026amp;fyne.StaticResource{ StaticName: \u0026#34;image.png\u0026#34;, StaticContent: []byte{ ... }} 如你所见，默认命名为\u0026quot;resource\u0026lt;Name\u0026gt;.\u0026lt;Ext\u0026gt;\u0026quot;。这个文件中使用的名称和包可以在命令参数中自定义。然后我们可以使用这个名称来，例如，在我们的画布上加载一张图片：\nimg := canvas.NewImageFromResource(resourceImagePng) Fyne资源只是一个带有唯一名称的字节集合，所以这可以是一个字体、一个声音\n"},{"id":28,"href":"/gofyne/docs/05-widget/03-entry/","title":"03. 输入框 Entry","section":"控件","content":" 输入框 Entry # 输入控件（Entry widget）用于用户输入简单文本内容。可以通过widget.NewEntry()构造函数简单地创建一个输入控件。创建控件时，保留一个引用，以便以后可以访问其Text字段。还可以使用OnChanged回调函数，每当内容变化时都会收到通知。\n输入控件还可以有验证功能，用于验证输入的文本。这可以通过设置Validator字段为fyne.StringValidator来完成。你还可以设置PlaceHolder文本，并且设置输入控件为MultiLine以接受多行文本。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Entry Widget\u0026#34;) input := widget.NewEntry() input.SetPlaceHolder(\u0026#34;Enter text...\u0026#34;) content := container.NewVBox(input, widget.NewButton(\u0026#34;Save\u0026#34;, func() { log.Println(\u0026#34;Content was:\u0026#34;, input.Text) })) myWindow.SetContent(content) myWindow.ShowAndRun() } 你还可以使用NewPasswordEntry()函数创建一个密码输入控件（内容被隐藏）。\n"},{"id":29,"href":"/gofyne/docs/01-started/03-demo/","title":"03. 运行 Fyne Demo","section":"快速开始","content":" 运行 Fyne Demo # 如果你想在开始编写自己的应用程序之前看到Fyne工具包的实际效果，你可以查看我们的演示应用程序。\n运行 # 如果愿意，你可以使用以下命令直接运行演示（需要Go 1.16或更高版本）：\ngo run fyne.io/fyne/v2/cmd/fyne_demo@latest 效果图：\n对于早期版本的Go，你需要使用以下命令：\ngo run fyne.io/fyne/v2/cmd/fyne_demo 通过浏览应用的不同标签，你可以看到Fyne工具包的所有功能。\n安装 # 你可以将该应用安装为计算机上的图形应用程序，就像所有其他应用程序一样。我们有一个有用的fyne工具可以为你完成这项工作。首先，你需要安装该工具：\ngo install fyne.io/fyne/v2/cmd/fyne@latest 之后，你可以简单地打包并安装演示应用程序：\nfyne get fyne.io/fyne/v2/cmd/fyne_demo 完成这一步骤后，你可以在应用启动器中找到“Fyne Demo”。\n探索代码 # 如果你对任何功能感兴趣，你应该查看源代码或加入社区频道之一。\n"},{"id":30,"href":"/gofyne/docs/01-started/04-apprun/","title":"04. App 和 RunLoop","section":"快速开始","content":" App 和 RunLoop # 对于一个图形用户界面（GUI）应用程序来说，它需要运行一个事件循环（有时被称为运行循环），来处理用户交互和绘图事件。在Fyne中，这是通过使用App.Run()或Window.ShowAndRun()函数启动的。这些函数中的一个必须在你的main()函数的设置代码末尾被调用。\n一个应用程序应该只有一个运行循环，因此你应该在代码中只调用Run()一次。第二次调用它将会导致错误。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Hello\u0026#34;) myWindow.SetContent(widget.NewLabel(\u0026#34;Hello\u0026#34;)) myWindow.Show() myApp.Run() tidyUp() } func tidyUp() { fmt.Println(\u0026#34;Exited\u0026#34;) } 对于桌面运行时，一个应用程序可以通过调用App.Quit()直接退出（移动应用不支持此功能）- 通常在开发者代码中不需要。一旦所有窗口都被关闭，应用程序也将退出。另外，请注意，在应用程序退出之前，执行Run()之后的函数将不会被调用。\n"},{"id":31,"href":"/gofyne/docs/07-binding/04-list/","title":"04. 列表类型","section":"数据绑定","content":" 列表类型 # 为了展示如何连接更复杂的类型，我们将看看List控件以及数据绑定如何使其更易用。首先，我们创建一个StringList数据绑定，这是一个String数据类型的列表。一旦我们有了列表类型的数据，我们就可以将这个数据连接到标准的List控件。为此，我们使用widget.NewListWithData构造函数，这和其他控件类似。\n将这段代码与 列表教程进行比较，你会看到两个主要变化，第一个是我们将数据类型作为第一个参数传递，而不是长度回调函数。第二个变化是最后一个参数，我们的UpdateItem回调。修订版采用binding.DataItem值而不是widget.ListIndexID。使用这种回调结构时，我们应该Bind到模板标签控件而不是调用SetText。这意味着如果数据源中的任何字符串发生变化，表格的每个受影响行都将刷新。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;List Data\u0026#34;) data := binding.BindStringList( \u0026amp;[]string{\u0026#34;Item 1\u0026#34;, \u0026#34;Item 2\u0026#34;, \u0026#34;Item 3\u0026#34;}, ) list := widget.NewListWithData(data, func() fyne.CanvasObject { return widget.NewLabel(\u0026#34;template\u0026#34;) }, func(i binding.DataItem, o fyne.CanvasObject) { o.(*widget.Label).Bind(i.(binding.String)) }) add := widget.NewButton(\u0026#34;Append\u0026#34;, func() { val := fmt.Sprintf(\u0026#34;Item %d\u0026#34;, data.Length()+1) data.Append(val) }) myWindow.SetContent(container.NewBorder(nil, add, nil, nil, list)) myWindow.ShowAndRun() } 在我们的演示代码中，有一个“Append”按钮，当点击时，它会向数据源追加一个新值。这样做将自动触发数据变化处理程序并扩展List控件以显示新数据。\n"},{"id":32,"href":"/gofyne/docs/09-architecture/04-organisation/","title":"04. 包组织 Package","section":"架构","content":" 包的组织 # Fyne 项目分为许多包，每个包提供不同类型的功能，如下所示：\nfyne.io/fyne/v2 这个导入提供了所有 Fyne 代码共有的基本定义，包括数据类型和接口。 fyne.io/fyne/v2/app app 包提供启动新应用的 API。 通常你只需要 app.New() 或 app.NewWithID()。 fyne.io/fyne/v2/canvas canvas 包提供 Fyne 中所有的绘图 API。 完整的 Fyne 工具包由这些原始图形类型组成。 fyne.io/fyne/v2/container container 包提供用于布局和组织应用的容器。 fyne.io/fyne/v2/data/binding binding 包包含将数据源绑定到控件的方法。 fyne.io/fyne/v2/data/validation validation 包提供工具用于验证控件内的数据。 fyne.io/fyne/v2/dialog dialog 包包含确认、错误和文件保存/打开等对话框。 fyne.io/fyne/v2/layout layout 包提供用于容器的各种布局实现（在后续教程中讨论）。 fyne.io/fyne/v2/storage storage 包提供存储访问和管理功能。 fyne.io/fyne/v2/test 使用 test 包内的工具可以更容易地测试应用。 fyne.io/fyne/v2/widget 大多数图形应用是使用一系列控件创建的。 Fyne 中的所有控件和交互元素都在这个包中。 "},{"id":33,"href":"/gofyne/docs/03-canvas/04-circle/","title":"04. 圆 Circle","section":"画图和动画","content":" 圆 Circle # canvas.Circle 定义了一个由指定颜色填充的圆形。您还可以设置 StrokeWidth，因此显示不同的 StrokeColor，如此示例中所示。\n圆形将填充通过调用 Resize() 或由其控制的布局指定的空间。由于示例将圆形设置为窗口内容，它将调整大小以填充窗口，存在基本的内边距（由主题控制）。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;圆形\u0026#34;) circle := canvas.NewCircle(color.White) circle.StrokeColor = color.Gray{Y: 0x99} circle.StrokeWidth = 5 w.SetContent(circle) w.Resize(fyne.NewSize(100, 100)) w.ShowAndRun() } 所有这些都是基本类型，可以由我们的驱动程序渲染，无需额外信息。接下来，我们将看看更复杂的类型，从 Image 开始。\n"},{"id":34,"href":"/gofyne/docs/05-widget/04-choices/","title":"04. 复选框 Choices","section":"控件","content":" 复选框 Choices # 有各种控件可用于向用户展示选择，包括复选框、单选按钮组和下拉选择框。\nwidget.Check 提供一个简单的是/否选择，使用字符串标签创建。这些控件每一个都接受一个 \u0026ldquo;changed\u0026rdquo; func(...)，其中参数类型适用于它们。因此，widget.NewCheck(..) 接受一个 string 参数作为标签和一个 func(bool) 参数作为更改处理器。你也可以使用 Checked 字段来获取布尔值。\n单选按钮控件类似，但第一个参数是表示每个选项的 string 切片。这次更改函数期望一个 string 参数，以返回当前选定的值。调用 widget.NewRadioGroup(...) 来构造单选按钮组控件，你可以稍后使用这个引用来读取 Selected 字段，而不是使用更改回调。\n下拉选择控件在构造函数签名上与单选按钮控件相同。调用 widget.NewSelect(...) 将显示一个按钮，当点击时会显示一个弹出窗口，用户可以从中进行选择。对于长列表的选项，这更加合适。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;选择控件\u0026#34;) check := widget.NewCheck(\u0026#34;可选\u0026#34;, func(value bool) { log.Println(\u0026#34;复选框设置为\u0026#34;, value) }) radio := widget.NewRadioGroup([]string{\u0026#34;选项 1\u0026#34;, \u0026#34;选项 2\u0026#34;}, func(value string) { log.Println(\u0026#34;单选按钮设置为\u0026#34;, value) }) combo := widget.NewSelect([]string{\u0026#34;选项 1\u0026#34;, \u0026#34;选项 2\u0026#34;}, func(value string) { log.Println(\u0026#34;选择设置为\u0026#34;, value) }) myWindow.SetContent(container.NewVBox(check, radio, combo)) myWindow.ShowAndRun() } "},{"id":35,"href":"/gofyne/docs/02-explore/04-layouts/","title":"04. 布局组件","section":"探索 Fyne","content":" 布局组件 # 水平盒（HBox） # 水平盒将项目以水平行的方式排列。容器中的每个元素将具有相同的高度（容器中最高项目的高度），并且对象将按其最小宽度左对齐。\n垂直盒（VBox） # 垂直盒将项目以垂直列的方式排列。容器中的每个元素将具有相同的宽度（容器中最宽项目的宽度），并且对象将按其最小高度顶部对齐。\n居中（Center） # 居中布局将所有容器元素定位在容器的中心。每个对象都将设置为其最小尺寸。\n表单（Form） # 表单布局将项目成对排列，其中第一列为最小宽度。这通常用于表单中的标签元素，其中标签位于第一列，其描述的项目位于第二列。你应该总是向表单布局添加偶数个元素。\n网格（Grid） # 网格布局在可用空间中均匀排列项目。指定列数，对象水平定位，直到达到列数，此时开始新的行。所有对象具有相同的大小，即宽度除以列总数，高度将是总高度除以所需行数减去填充。\n网格包裹（GridWrap） # 网格包裹布局将所有项目沿一行流动排列，如果空间不足，则换到新行。所有对象将设置为相同的大小，即传递给布局的大小。这种布局可能不会尊重项目的MinSize以管理这种统一布局。通常用于文件管理器或图像缩略图列表。\n边框（Border） # 边框布局支持在可用空间外围定位项目。边框传递指向对象的指针（顶部、左侧、底部、右侧）。容器中未定位在边框上的所有项目将填充剩余空间。\n最大（Max） # 最大布局将所有容器元素定位以填充可用空间。对象都将是全尺寸的，并按照它们被添加到容器中的顺序绘制（最后添加的在最上面）。\n填充（Padded） # 填充布局将所有容器元素定位以填充可用空间，但在外围有一小块填充。填充的大小是主题特定的。对象都将按照它们被添加到容器中的顺序绘制（最后添加的在最上面）。\n组合布局 # 通过使用多个布局，可以构建更复杂的应用程序结构。每个具有自己布局的多个容器可以嵌套，仅使用上面列出的标准布局创建完整的用户界面布局。例如，一个用于页眉的水平盒，一个用于左侧文件面板的垂直盒，以及内容区域中的网格包装布局 - 所有这些都放在使用边框布局的容器内，可以构建下面所示的结果。\n"},{"id":36,"href":"/gofyne/docs/08-extend/04-custom-theme/","title":"04. 自定义主题 Theme","section":"扩展新类型","content":" 自定义主题 Theme # 应用程序能够加载自定义主题，这些主题可以对标准主题进行小的更改，或提供完全独特的外观。一个主题需要实现fyne.Theme接口的函数，该接口定义如下：\ntype Theme interface { Color(ThemeColorName, ThemeVariant) color.Color Font(TextStyle) Resource Icon(ThemeIconName) Resource Size(ThemeSizeName) float32 } 要应用我们的主题更改，我们首先定义一个实现了这个接口的新类型。\n定义你的主题 # 我们从定义一个将成为我们主题的新类型开始，一个简单的空结构体就可以了：\ntype myTheme struct {} 断言我们实现了一个接口是个好主意，这样编译错误会更接近于定义类型。\nvar _ fyne.Theme = (*myTheme)(nil) 此时你可能会看到编译错误，因为我们还需要实现方法，我们从颜色开始。\n自定义颜色 # Theme接口中定义的Color函数要求我们定义一个命名颜色，并且还为用户期望的变体提供了提示（例如theme.VariantLight或theme.VariantDark）。在我们的主题中，我们将返回一个自定义的背景颜色 - 对于明亮和暗黑主题使用不同的值。\n// 需要从\u0026#34;image/color\u0026#34;导入color包。 func (m myTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color { if name == theme.ColorNameBackground { if variant == theme.VariantLight { return color.White } return color.Black } return theme.DefaultTheme().Color(name, variant) } 你会看到这里的最后一行引用了theme.DefaultTheme()来查找标准值。这允许我们提供自定义值，但在我们不想提供自己的值时回退到标准主题。\n当然，颜色比资源更简单，我们来看看如何自定义图标。\n覆盖默认图标 # 图标（和字体）使用fyne.Resource作为值，而不是像int（用于大小）或color.Color（用于颜色）这样的简单类型。我们可以使用fyne.NewStaticResource构建自己的资源，或者你可以传入使用 资源嵌入创建的值。\nfunc (m myTheme) Icon(name fyne.ThemeIconName) fyne.Resource { if name == theme.IconNameHome { return fyne.NewStaticResource(\u0026#34;myHome\u0026#34;, homeBytes) } return theme.DefaultTheme().Icon(name) } 如上所述，如果我们不想提供特定的覆盖，我们返回默认主题图标。\n加载主题 # 在你可以加载主题之前，你还需要实现Size和Font方法。如果你满意使用默认值，你可以使用这些空实现。\nfunc (m myTheme) Font(style fyne.TextStyle) fyne.Resource { return theme.DefaultTheme().Font(style) } func (m myTheme) Size(name fyne.ThemeSizeName) float32 { return theme.DefaultTheme().Size(name) } 要为你的应用设置主题，你需要添加以下代码行：\napp.Settings().SetTheme(\u0026amp;myTheme{}) 通过这些更改，你可以应用自己的风格，进行小的调整或提供完全自定义的应用程序外观！\n"},{"id":37,"href":"/gofyne/docs/04-container/04-border/","title":"04. 边框布局 Border","section":"容器与布局","content":" 边框布局 Border # 边框布局可能是构建用户界面时使用最广泛的布局之一，因为它允许围绕一个将扩展以填充空间的中心元素定位项目。要创建一个边框容器，你需要将应该在边框位置定位的 fyne.CanvasObject 作为构造函数的前四个参数传递。这个语法基本上就是 container.NewBorder(top, bottom, left, right, center)，如示例所示。\n传递给容器的前四个项目之后的任何项目都将被定位到中心区域，并将扩展以填充可用空间。你也可以将 nil 传递给你希望留空的边框参数。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;边框布局\u0026#34;) top := canvas.NewText(\u0026#34;顶部栏\u0026#34;, color.White) left := canvas.NewText(\u0026#34;左侧\u0026#34;, color.White) middle := canvas.NewText(\u0026#34;内容\u0026#34;, color.White) content := container.NewBorder(top, nil, left, nil, middle) myWindow.SetContent(content) myWindow.ShowAndRun() } 请注意，中心的所有项目都将扩展以填充空间（就像它们在 layout.MaxLayout 容器中一样）。要自己管理该区域，你可以使用任何 fyne.Container 作为内容。\n"},{"id":38,"href":"/gofyne/docs/02-explore/05-dialogs/","title":"05. Dialog 对话框","section":"探索 Fyne","content":" 对话框列表 # 颜色 # 允许用户从标准集合中选择一个颜色（或在高级模式中选择任何颜色）。\n确认 # 请求确认一个操作。\n文件打开 # 提示用户选择一个文件以在应用内使用。实际显示的对话框将取决于当前操作系统。\n表单 # 在一个对话框中获取各种输入元素，并进行验证。\n信息 # 一种向应用用户展示一些信息的简单方法。\n自定义 # 在对话框容器内展示任何内容。\n"},{"id":39,"href":"/gofyne/docs/03-canvas/05-image/","title":"05. 图片 Image","section":"画图和动画","content":" 图片 Image # canvas.Image 在 Fyne 中代表一个可缩放的图像资源。它可以从资源（如示例所示）、图像文件、包含图像的 URI 位置、io.Reader 或内存中的 Go image.Image 加载。\n默认的图像填充模式是 canvas.ImageFillStretch，它会导致图像填充指定的空间（通过 Resize() 或布局）。或者，你可以使用 canvas.ImageFillContain 以确保保持纵横比并且图像在边界内。此外，你可以使用 canvas.ImageFillOriginal（如此示例中所用），以确保它也具有等于原始图像大小的最小尺寸。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;图像\u0026#34;) image := canvas.NewImageFromResource(theme.FyneLogo()) // image := canvas.NewImageFromURI(uri) // image := canvas.NewImageFromImage(src) // image := canvas.NewImageFromReader(reader, name) // image := canvas.NewImageFromFile(fileName) image.FillMode = canvas.ImageFillOriginal w.SetContent(image) w.ShowAndRun() } 图像可以是基于位图的（如 PNG 和 JPEG）或基于矢量的（如 SVG）。我们建议尽可能使用可缩放图像，因为它们在大小变化时继续渲染良好。在使用原始图像大小时要小心，因为它们可能不会完全按预期与不同的用户界面比例一致。由于 Fyne 允许整个用户界面缩放，一个 25px 的图像文件可能与一个 25 高度的 fyne 对象不同。\n"},{"id":40,"href":"/gofyne/docs/08-extend/05-extending-widgets/","title":"05. 扩展控件 Widget","section":"扩展新类型","content":" 扩展控件 Widget # Fyne标准控件提供最小的功能和自定义选项以支持大多数用例。在某些时候可能需要更高级的功能。与其让开发者构建自己的控件，不如扩展现有的控件。\n例如，我们将扩展图标控件以支持被点击。为此，我们声明一个新的结构体，嵌入了widget.Icon类型。我们创建一个构造函数，调用重要的ExtendBaseWidget函数。\nimport ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) type tappableIcon struct { widget.Icon } func newTappableIcon(res fyne.Resource) *tappableIcon { icon := \u0026amp;tappableIcon{} icon.ExtendBaseWidget(icon) icon.SetResource(res) return icon } 注意： 像widget.NewIcon这样的控件构造函数可能不适用于扩展，因为它已经调用了ExtendBaseWidget。\n然后，我们添加新函数以实现fyne.Tappable接口，有了这些函数，每次用户点击我们的新图标时都会调用新的Tapped函数。接口需要有两个函数，Tapped(*PointEvent)和TappedSecondary(*PointEvent)，所以我们将添加这两个。\nimport \u0026#34;log\u0026#34; func (t *tappableIcon) Tapped(_ *fyne.PointEvent) { log.Println(\u0026#34;I have been tapped\u0026#34;) } func (t *tappableIcon) TappedSecondary(_ *fyne.PointEvent) { } 我们可以使用如下简单的应用程序测试这个新控件。\nimport ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Tappable\u0026#34;) w.SetContent(newTappableIcon(theme.FyneLogo())) w.ShowAndRun() } "},{"id":41,"href":"/gofyne/docs/01-started/05-updating/","title":"05. 更新 GUI 内容","section":"快速开始","content":" 更新 GUI 内容 # 在完成了Hello World教程或其他示例之后，你将创建一个基本的用户界面。在这个页面中，我们将看到如何从代码中更新GUI的内容。\n第一步是将你想要更新的控件赋值给一个变量。在Hello World教程中，我们直接将widget.NewLabel传递给SetContent()，为了更新它，我们将其更改为两行不同的代码，例如：\nclock := widget.NewLabel(\u0026#34;\u0026#34;) w.SetContent(clock) 一旦内容被赋值给一个变量，我们就可以调用像SetText(\u0026quot;new text\u0026quot;)这样的函数。在我们的示例中，我们将使用Time.Format的帮助，将标签的内容设置为当前时间。\nformatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) clock.SetText(formatted) 这就是我们需要做的，以改变一个可见项的内容（见下面的完整代码）。然而，我们可以进一步定期更新内容。\n在后台运行 # 大多数应用程序都需要在后台运行进程，例如下载数据或响应事件。为了模拟这一点，我们将扩展上述代码，使其每秒运行一次。\n像大多数Go代码一样，我们可以创建一个goroutine（使用go关键字）并在那里运行我们的代码。如果我们将文本更新代码移动到一个新函数中，它可以在初始显示以及定期更新时被调用。通过组合goroutine和time.Tick在一个for循环中，我们可以每秒更新标签。\ngo func() { for range time.Tick(time.Second) { updateTime(clock) } }() 将这段代码放在ShowAndRun或Run调用之前是很重要的，因为它们在应用程序关闭之前不会返回。将所有这些结合在一起，代码将运行并每秒更新用户界面，创建一个基本的时钟控件。完整的代码如下：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func updateTime(clock *widget.Label) { formatted := time.Now().Format(\u0026#34;Time: 03:04:05\u0026#34;) clock.SetText(formatted) } func main() { a := app.New() w := a.NewWindow(\u0026#34;Clock\u0026#34;) clock := widget.NewLabel(\u0026#34;\u0026#34;) updateTime(clock) w.SetContent(clock) go func() { for range time.Tick(time.Second) { updateTime(clock) } }() w.ShowAndRun() } 这段代码演示了如何在Fyne应用程序中创建动态更新的内容，这是构建交云动用户界面的基础。\n"},{"id":42,"href":"/gofyne/docs/05-widget/05-form/","title":"05. 表单 Form","section":"控件","content":" 表单 Form # 表单控件用于排列许多输入字段、标签以及可选的取消和提交按钮。在其最简单的形式中，它将标签对齐到每个输入控件的左侧。通过设置OnCancel或OnSubmit，表单将添加一个按钮栏，当适当时调用指定的处理程序。\n可以通过传递widget.FormItem列表使用widget.NewForm(...)创建控件，或者使用示例中所示的\u0026amp;widget.Form{}语法。还有一个有用的Form.Append(label, widget)，可用于另一种语法。\n在这个例子中，我们创建了两个输入框，其中一个是“多行”的（类似HTML TextArea）来保存值。有一个OnSubmit处理程序，在关闭窗口（因此是应用程序）之前打印信息。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;表单控件\u0026#34;) entry := widget.NewEntry() textArea := widget.NewMultiLineEntry() form := \u0026amp;widget.Form{ Items: []*widget.FormItem{ // 我们可以在构造函数中指定项 {Text: \u0026#34;输入框\u0026#34;, Widget: entry}}, OnSubmit: func() { // 可选，处理表单提交 log.Println(\u0026#34;表单提交：\u0026#34;, entry.Text) log.Println(\u0026#34;多行：\u0026#34;, textArea.Text) myWindow.Close() }, } // 我们也可以追加项目 form.Append(\u0026#34;文本\u0026#34;, textArea) myWindow.SetContent(form) myWindow.ShowAndRun() } "},{"id":43,"href":"/gofyne/docs/04-container/05-form/","title":"05. 表单布局 Form","section":"容器与布局","content":" 表单布局 Form # layout.FormLayout 类似于两列的 网格布局，但针对应用中的表单布局进行了调整。每个项目的高度将是每行中两个最小高度中的较大者。第一列中所有项目的最大最小宽度将是左侧项目的宽度，而每行中的第二个项目将扩展以填满空间。\n这种布局更典型地用于 widget.Form（用于验证、提交和取消按钮等），但也可以直接使用 layout.NewFormLayout() 作为 container.New(...) 的第一个参数。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;表单布局\u0026#34;) label1 := widget.NewLabel(\u0026#34;标签 1\u0026#34;) value1 := widget.NewLabel(\u0026#34;值\u0026#34;) label2 := widget.NewLabel(\u0026#34;标签 2\u0026#34;) value2 := widget.NewLabel(\u0026#34;某些内容\u0026#34;) grid := container.New(layout.NewFormLayout(), label1, value1, label2, value2) myWindow.SetContent(grid) myWindow.ShowAndRun() } "},{"id":44,"href":"/gofyne/docs/02-explore/06-icons/","title":"06. 主题 Icon 小图标","section":"探索 Fyne","content":" 主题 Icon 小图标 # 以下每个图标都可以通过theme包作为一个函数获得。例如theme.InfoIcon()。\n这些图标也可以通过使用ThemeIconName以及在实现了fyne.Theme的结构体上的Icon方法，通过它们的源图标名称获得。例如theme.Icon(theme.IconNameInfo)。\n列表 # AccountIcon ArrowDropDownIcon ArrowDropUpIcon BrokenImageIcon CancelIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e CheckButtonIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e CheckButtonCheckedIcon ColorAchromaticIcon ColorChromaticIcon ColorPaletteIcon ComputerIcon ConfirmIcon ContentAddIcon ContentClearIcon ContentCopyIcon ContentCutIcon ContentPasteIcon ContentRedoIcon ContentRemoveIcon ContentUndoIcon DeleteIcon DocumentCreateIcon DocumentIcon DocumentPrintIcon DocumentSaveIcon DownloadIcon ErrorIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e FileApplicationIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e FileAudioIcon FileIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e FileImageIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e FileTextIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e FileVideoIcon FolderIcon FolderNewIcon FolderOpenIcon GridIcon HelpIcon HistoryIcon HomeIcon InfoIcon ListIcon LoginIcon LogoutIcon MailAttachmentIcon MailComposeIcon MailForwardIcon MailReplyAllIcon MailReplyIcon MailSendIcon MediaFastForwardIcon MediaFastRewindIcon MediaMusicIcon MediaPauseIcon MediaPhotoIcon MediaPlayIcon MediaRecordIcon MediaReplayIcon MediaSkipNextIcon MediaSkipPreviousIcon MediaStopIcon MediaVideoIcon MenuExpandIcon MenuIcon MoreHorizontalIcon MoreVerticalIcon MoveDownIcon MoveUpIcon NavigateBackIcon NavigateNextIcon QuestionIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e RadioButtonCheckedIcon \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e RadioButtonIcon SearchReplaceIcon SearchIcon SettingsIcon StorageIcon UploadIcon ViewFullScreenIcon ViewRefreshIcon ViewRestoreIcon ViewZoomFitIcon ViewZoomInIcon ViewZoomOutIcon VisibilityOffIcon VisibilityIcon VolumeDownIcon VolumeMuteIcon VolumeUpIcon WarningIcon 使用其他颜色集 # 每个图标都可以作为特定主题颜色的源使用各种公共帮助方法：\nNewDisabledThemedResource NewErrorThemedResource NewInvertedThemedResource NewPrimaryThemedResource 默认情况下，所有图标都适应当前主题前景色，使用NewThemedResource，它使用主题前景色。所有图标都是SVG width=\u0026quot;24\u0026quot;, height=\u0026quot;24\u0026quot;。\n"},{"id":45,"href":"/gofyne/docs/04-container/06-center/","title":"06. 居中布局 Center","section":"容器与布局","content":" 居中布局 # layout.CenterLayout 将其容器中的所有项目都组织在可用空间的中心。这些对象将按照它们被传递到容器的顺序绘制，最后传递的对象将被绘制在最顶部。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Center Layout\u0026#34;) img := canvas.NewImageFromResource(theme.FyneLogo()) img.FillMode = canvas.ImageFillOriginal text := canvas.NewText(\u0026#34;Overlay\u0026#34;, color.Black) content := container.New(layout.NewCenterLayout(), img, text) myWindow.SetContent(content) myWindow.ShowAndRun() } 中心布局使所有项目保持其最小大小，如果你希望扩展项目以填充空间，那么请参见 layout.MaxLayout。\n"},{"id":46,"href":"/gofyne/docs/08-extend/06-numerical-entry/","title":"06. 数字输入框 Entry","section":"扩展新类型","content":" 数字输入框 Entry # 在传统意义上，GUI程序使用回调来自定义控件的操作。Fyne不暴露插入自定义回调来捕获控件上的事件，但这并不是必需的。Go语言完全有足够的扩展性来实现这一点。\n我们可以简单地使用类型嵌入来扩展控件，使其只能输入数值。\n首先创建一个新的类型结构体，我们将其称为numericalEntry。\ntype numericalEntry struct { widget.Entry } 如 扩展现有控件中所提到的，我们遵循良好实践并创建一个构造函数，该函数扩展了BaseWidget。\nfunc newNumericalEntry() *numericalEntry { entry := \u0026amp;numericalEntry{} entry.ExtendBaseWidget(entry) return entry } 现在我们需要让条目只接受数字。这可以通过重写TypedRune(rune)方法来完成，这是fyne.Focusable接口的一部分。这将允许我们拦截按键输入的标准处理，并只通过我们想要的输入。在此方法中，我们将使用条件检查rune是否匹配0到9之间的任何数字。如果是，我们将其委托给嵌入式条目的标准TypedRune(rune)方法。如果不是，我们就忽略输入。此实现只允许输入整数，但如果需要，可以轻松扩展以检查将来的其他键。\nfunc (e *numericalEntry) TypedRune(r rune) { if r \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;9\u0026#39; { e.Entry.TypedRune(r) } } 如果我们想要更新实现以允许输入小数，我们可以简单地将.和,添加到允许的rune列表中（一些语言对于小数记数使用逗号而不是点）。\nfunc (e *numericalEntry) TypedRune(r rune) { if (r \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;9\u0026#39;) || r == \u0026#39;.\u0026#39; || r == \u0026#39;,\u0026#39; { e.Entry.TypedRune(r) } } 通过这种方式，现在条目只允许用户在按键时输入数值。然而，粘贴快捷键仍然允许输入文本。为了解决这个问题，我们可以重写TypedShortcut(fyne.Shortcut)方法，这是fyne.Shortcutable接口的一部分。首先我们需要进行类型断言，检查给定的快捷键是否为*fyne.ShortcutPaste类型。如果不是，我们可以将快捷键委托回嵌入式条目。如果是，我们检查剪贴板内容是否为数值，通过使用strconv.ParseFloat()（如果你只想允许整数，strconv.Atoi()就足够了），然后如果剪贴板内容可以无误地解析，再将快捷键委托回嵌入式条目。\nfunc (e *numericalEntry) TypedShortcut(shortcut fyne.Shortcut) { paste, ok := shortcut.(*fyne.ShortcutPaste) if !ok { e.Entry.TypedShortcut(shortcut) return } content := paste.Clipboard.Content() if _, err := strconv.ParseFloat(content, 64); err == nil { e.Entry.TypedShortcut(shortcut) } } 作为额外福利，我们还可以确保移动操作系统打开数值键盘而不是默认键盘。这可以通过首先导入fyne.io/fyne/v2/driver/mobile包并重写mobile.Keyboardable接口的Keyboard() mobile.KeyboardType方法来完成。在函数中，我们简单地返回mobile.NumberKeyboard类型。\nfunc (e *numericalEntry) Keyboard() mobile.KeyboardType { return mobile.NumberKeyboard } 最后，结果代码可能如下所示：\npackage main import ( \u0026#34;strconv\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/driver/mobile\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) type numericalEntry struct { widget.Entry } func newNumericalEntry() *numericalEntry { entry := \u0026amp;numericalEntry{} entry.ExtendBaseWidget(entry) return entry } func (e *numericalEntry) TypedRune(r rune) { if (r \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; r \u0026lt;= \u0026#39;9\u0026#39;) || r == \u0026#39;.\u0026#39; || r == \u0026#39;,\u0026#39; { e.Entry.TypedRune(r) } } func (e *numericalEntry) TypedShortcut(shortcut fyne.Shortcut) { paste, ok := shortcut.(*fyne.ShortcutPaste) if !ok { e.Entry.TypedShortcut(shortcut) return } content := paste.Clipboard.Content() if _, err := strconv.ParseFloat(content, 64); err == nil { e.Entry.TypedShortcut(shortcut) } } func (e *numericalEntry) Keyboard() mobile.KeyboardType { return mobile.NumberKeyboard } func main() { a := app.New() w := a.NewWindow(\u0026#34;Numerical\u0026#34;) entry := newNumericalEntry() w.SetContent(entry) w.ShowAndRun() } 这个示例展示了如何扩展Fyne的Entry控件来创建一个只接受数值输入的Entry控件，通过重写TypedRune和TypedShortcut方法，并通过重写Keyboard方法为移动设备提供了数值键盘。\n"},{"id":47,"href":"/gofyne/docs/03-canvas/06-raster/","title":"06. 矢量 Raster","section":"画图和动画","content":" 矢量 Raster # canvas.Raster 类似于图像，但在屏幕上为每个像素精确绘制一个点。这意味着，随着用户界面缩放或图像调整大小，将请求更多像素来填充空间。为此，我们使用一个 Generator 函数，如此示例所示——它将用于返回每个像素的颜色。\n生成器函数可以基于像素（如此示例中我们为每个像素生成一个新的随机颜色）或基于完整图像。生成完整图像（使用 canvas.NewRaster()）更高效，但有时直接控制像素更方便。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;Raster\u0026#34;) raster := canvas.NewRasterWithPixels( func(_, _, w, h int) color.Color { return color.RGBA{R: uint8(rand.Intn(255)), G: uint8(rand.Intn(255)), B: uint8(rand.Intn(255)), A: 0xff} }) // raster := canvas.NewRasterFromImage() w.SetContent(raster) w.Resize(fyne.NewSize(120, 100)) w.ShowAndRun() } 如果您的像素数据存储在图像中，您可以通过 NewRasterFromImage() 函数加载它，该函数将加载图像以在屏幕上精确显示像素。\n"},{"id":48,"href":"/gofyne/docs/01-started/06-windows/","title":"06. 窗口 Window 处理","section":"快速开始","content":" 窗口 Window 处理 # 窗口是使用App.NewWindow()创建的，并需要使用Show()函数来显示。fyne.Window上的辅助方法ShowAndRun()允许你同时显示窗口并运行应用程序。\n默认情况下，窗口将通过检查MinSize()函数（在后面的示例中会有更多介绍）来显示其内容的正确大小。你可以通过调用Window.Resize()方法来设置更大的尺寸。这个方法接受一个fyne.Size，其中包含使用设备独立像素（这意味着在不同设备上将是相同的）的宽度和高度，例如，要默认使窗口正方形，我们可以这样做：\nw.Resize(fyne.NewSize(100, 100)) 请注意，桌面环境可能有限制，导致窗口小于请求的尺寸。移动设备通常会忽略这一点，因为它们只以全屏显示。\n如果你希望显示第二个窗口，你只需调用Show()函数。如果你想在应用程序启动时打开多个窗口，将Window.Show()与App.Run()分开也可能是有帮助的。下面的示例展示了如何在启动时加载两个窗口。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Hello World\u0026#34;) w.SetContent(widget.NewLabel(\u0026#34;Hello World!\u0026#34;)) w.Show() w2 := a.NewWindow(\u0026#34;Larger\u0026#34;) w2.SetContent(widget.NewLabel(\u0026#34;More content\u0026#34;)) w2.Resize(fyne.NewSize(100, 100)) w2.Show() a.Run() } 上述应用程序将在两个窗口都关闭时退出。如果你的应用程序安排得当，一个窗口是主窗口，其他窗口是辅助视图，你可以设置一个窗口为“主窗口”，这样如果该窗口关闭，应用程序就会退出。要做到这一点，使用Window上的SetMaster()函数。\n窗口可以在任何时候被创建，我们可以改变上面的代码，使得第二个窗口（w2）的内容是一个打开新窗口的按钮。你也可以从更复杂的工作流中加载窗口，但要小心，因为新窗口通常会出现在当前活动内容之上。\nw2.SetContent(widget.NewButton(\u0026#34;Open new\u0026#34;, func() { w3 := a.NewWindow(\u0026#34;Third\u0026#34;) w3.SetContent(widget.NewLabel(\u0026#34;Third\u0026#34;)) w3.Show() })) 这段描述说明了如何在Fyne应用程序中处理窗口，包括创建、显示、调整大小以及如何从代码中动态添加新窗口。\n"},{"id":49,"href":"/gofyne/docs/05-widget/06-progressbar/","title":"06. 进度条 ProgressBar","section":"控件","content":" 进度条 ProgressBar # 进度条控件有两种形式，标准进度条向用户显示已达到的 Value，从 Min 到 Max。默认最小值是 0.0，最大值默认为 1.0。要使用默认值，只需调用 widget.NewProgressBar()。创建后，你可以设置 Value 字段。\n要设置自定义范围，你可以手动设置 Min 和 Max 字段。标签将始终显示完成百分比。\n进度控件的另一种形式是无限进度条。此版本仅通过将条的一部分从左向右移动然后再移动回来，简单地显示一些活动正在进行中。使用 widget.NewProgressBarInfinite() 创建此版本，并且一旦显示就会开始动画。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;进度条控件\u0026#34;) progress := widget.NewProgressBar() infinite := widget.NewProgressBarInfinite() go func() { for i := 0.0; i \u0026lt;= 1.0; i += 0.1 { time.Sleep(time.Millisecond * 250) progress.SetValue(i) } }() myWindow.SetContent(container.NewVBox(progress, infinite)) myWindow.ShowAndRun() } "},{"id":50,"href":"/gofyne/docs/05-widget/07-toolbar/","title":"07. 工具栏 Toolbar","section":"控件","content":" 工具栏 Toolbar # 工具栏控件使用图标创建一行动作按钮来表示每个操作。widget.NewToolbar(...) 构造函数接受一系列 widget.ToolbarItem 参数。内置的工具栏项目类型有动作，分隔符和空格器。\n最常用的项目是动作，使用 widget.NewToolbarAction(..) 函数创建。动作有两个参数，第一个是要绘制的图标资源，后一个是点击时调用的 func()。这样创建了一个标准的工具栏按钮。\n你可以使用 widget.NewToolbarSeparator() 在工具栏中的项目之间创建一个小分隔符（通常是一个细的垂直线）。最后，你可以使用 widget.NewToolbarSpacer() 在元素之间创建一个灵活的空间。这最适合用于右对齐列表中的工具栏项目。\n工具栏应始终位于内容区域的顶部，所以通常使用 layout.BorderLayout 将其添加到 fyne.Container 中，以便将其与其他内容对齐。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;工具栏控件\u0026#34;) toolbar := widget.NewToolbar( widget.NewToolbarAction(theme.DocumentCreateIcon(), func() { log.Println(\u0026#34;新建文档\u0026#34;) }), widget.NewToolbarSeparator(), widget.NewToolbarAction(theme.ContentCutIcon(), func() {}), widget.NewToolbarAction(theme.ContentCopyIcon(), func() {}), widget.NewToolbarAction(theme.ContentPasteIcon(), func() {}), widget.NewToolbarSpacer(), widget.NewToolbarAction(theme.HelpIcon(), func() { log.Println(\u0026#34;显示帮助\u0026#34;) }), ) content := container.NewBorder(toolbar, nil, nil, nil, widget.NewLabel(\u0026#34;内容\u0026#34;)) myWindow.SetContent(content) myWindow.ShowAndRun() } "},{"id":51,"href":"/gofyne/docs/02-explore/07-shortcuts/","title":"07. 快捷键","section":"探索 Fyne","content":" 快捷键 # 快捷键是可以通过键盘组合键或上下文菜单触发的常见任务。快捷键，很像键盘事件，可以附加到一个聚焦的元素上，或者在Canvas上注册，以便在Window中始终可用。\n在Canvas中注册 # 有许多标准的快捷键定义（如fyne.ShortcutCopy），它们连接到标准键盘快捷键和右键菜单。添加新Shortcut的第一步是定义快捷键。对于大多数用途，这将是一个键盘触发的快捷键，这是一个桌面扩展。为此，我们使用desktop.CustomShortcut，例如，要使用Tab键和Control修饰符，你可能会做如下操作：\nctrlTab := \u0026amp;desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: fyne.KeyModifierControl} ctrlAltTab := \u0026amp;desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: fyne.KeyModifierControl | fyne.KeyModifierAlt} 注意，这个快捷键可以重复使用，所以你可以将它附加到菜单或其他项上。在这个示例中，我们希望它始终可用，所以我们将其注册到我们窗口的Canvas上，如下所示：\nctrlTab := \u0026amp;desktop.CustomShortcut{KeyName: fyne.KeyTab, Modifier: fyne.KeyModifierControl} w.Canvas().AddShortcut(ctrlTab, func(shortcut fyne.Shortcut) { log.Println(\u0026#34;我们按下了Ctrl+Tab\u0026#34;) }) w.Canvas().AddShortcut(ctrlAltTab, func(shortcut fyne.Shortcut) { log.Println(\u0026#34;我们按下了Ctrl+Alt+Tab\u0026#34;) }) 如你所见，在这种方式注册快捷键有两个部分 - 传递快捷键定义以及回调函数。如果用户输入键盘快捷键，那么函数将被调用并打印输出。\n快捷键只能与修饰键结合使用。为了响应没有修饰键的键盘输入，请使用canvas.OnTypedRune或canvas.OnTypedKey。\n在输入框中添加快捷键 # 当当前项目聚焦时，让快捷键仅适用也是有帮助的。这种方法可以用于任何可聚焦的控件，并通过扩展该控件并添加TypedShortcut处理器来管理。这和添加键处理器很像，不同之处在于传入的值将是一个fyne.Shortcut。\ntype myEntry struct { widget.Entry } func (m *myEntry) TypedShortcut(s fyne.Shortcut) { if _, ok := s.(*desktop.CustomShortcut); !ok { m.Entry.TypedShortcut(s) return } log.Println(\u0026#34;输入了快捷键:\u0026#34;, s) } 从上面的摘录中你可以看到如何实现一个TypedShortcut处理器。在这个函数内部，你应该检查快捷键是否为之前使用的自定义类型。如果快捷键是标准的，调用原始快捷键处理器（如果控件有一个）是个好主意。 完成这些检查后，你可以将快捷键与你正在处理的各种类型进行比较（如果有多个）。\n"},{"id":52,"href":"/gofyne/docs/04-container/07-max/","title":"07. 最大布局 Max","section":"容器与布局","content":" 最大布局 Max # layout.MaxLayout是最简单的布局，它将容器中的所有项目设置为与容器相同的大小。这通常在一般的容器中不太有用，但在组合控件时可能适用。\n最大布局会扩展容器，使其至少与最大项目的最小大小相同。对象将按照它们传递给容器的顺序被绘制，最后传递的对象将被绘制在最上面。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; \u0026#34;fyne.io/fyne/v2/layout\u0026#34; \u0026#34;fyne.io/fyne/v2/theme\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;Max Layout\u0026#34;) img := canvas.NewImageFromResource(theme.FyneLogo()) text := canvas.NewText(\u0026#34;Overlay\u0026#34;, color.Black) content := container.New(layout.NewMaxLayout(), img, text) myWindow.SetContent(content) myWindow.ShowAndRun() } "},{"id":53,"href":"/gofyne/docs/01-started/07-testing/","title":"07. 测试 GUI 应用程序","section":"快速开始","content":" 测试 GUI 应用程序 # 一个好的测试套件的一部分是能够快速编写测试并定期运行它们。Fyne的API旨在使应用程序测试变得简单。通过将组件逻辑与其渲染定义分离，我们可以在不实际显示它们的情况下加载应用程序，并完全测试其功能。\n示例 # 我们可以通过扩展我们的 Hello World应用程序来演示单元测试，包括为用户输入他们的名字以便问候的空间。我们首先更新用户界面，使其包含两个元素：一个用于问候的Label和一个用于输入名字的Entry。我们使用container.NewVBox（一个垂直盒子容器）将它们一个接一个地显示。更新后的用户界面代码如下所示：\nfunc makeUI() (*widget.Label, *widget.Entry) { return widget.NewLabel(\u0026#34;Hello world!\u0026#34;), widget.NewEntry() } func main() { a := app.New() w := a.NewWindow(\u0026#34;Hello Person\u0026#34;) w.SetContent(container.NewVBox(makeUI())) w.ShowAndRun() } 为了测试这个输入行为，我们创建了一个新文件（以 _test.go 结尾，将其标记为测试），定义了一个TestGreeter函数。\npackage main import ( \u0026#34;testing\u0026#34; ) func TestGreeting(t *testing.T) { } 我们可以添加一个验证初始状态的初始测试，为此我们测试从makeUI返回的Label的Text字段，如果它不正确，则错误测试。将以下代码添加到测试方法中：\nout, in := makeUI() if out.Text != \u0026#34;Hello world!\u0026#34; { t.Error(\u0026#34;Incorrect initial greeting\u0026#34;) } 这个测试将通过 - 接下来我们添加到测试中以验证问候者。我们使用Fyne的fyne.io/fyne/v2/test包来帮助测试场景，调用test.Type来模拟用户输入。以下测试代码将检查当输入用户姓名时输出是否更新（也确保添加了导入）：\ntest.Type(in, \u0026#34;Andy\u0026#34;) if out.Text != \u0026#34;Hello Andy!\u0026#34; { t.Error(\u0026#34;Incorrect user greeting\u0026#34;) } 你可以使用go test .运行所有这些测试 - 就像任何其他测试一样。这样做，你现在会看到一个失败 - 因为我们没有添加问候逻辑。将makeUI函数更新为以下代码：\nfunc makeUI() (*widget.Label, *widget.Entry) { out := widget.NewLabel(\u0026#34;Hello world!\u0026#34;) in := widget.NewEntry() in.OnChanged = func(content string) { out.SetText(\u0026#34;Hello \u0026#34; + content + \u0026#34;!\u0026#34;) } return out, in } 这样做，你会看到测试现在通过了。你也可以运行完整的应用程序（使用go run .），并且当你在Entry字段中输入名字时，看到问候更新。还要注意，所有这些测试都是在不显示窗口或窃取你的鼠标的情况下运行的 - 这是Fyne单元测试设置的另一个好处。\n"},{"id":54,"href":"/gofyne/docs/03-canvas/07-gradient/","title":"07. 渐变 Gradient","section":"画图和动画","content":" 渐变 Gradient # 最后一个画布原始类型是 Gradient，可用作 canvas.LinearGradient 和 canvas.RadialGradient，用于绘制从一种颜色到另一种颜色的渐变，有多种模式。你可以使用 NewHorizontalGradient()、NewVerticalGradient() 或 NewRadialGradient() 创建渐变。\n要创建一个渐变，你需要一个起始颜色和结束颜色——画布会计算其中的每一个颜色。在这个示例中，我们使用 color.Transparent 来展示如何使用渐变（或任何其他类型）通过透明度值在背后的内容上实现半透明效果。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; ) func main() { myApp := app.New() w := myApp.NewWindow(\u0026#34;渐变\u0026#34;) gradient := canvas.NewHorizontalGradient(color.White, color.Transparent) //gradient := canvas.NewRadialGradient(color.White, color.Transparent) w.SetContent(gradient) w.Resize(fyne.NewSize(100, 100)) w.ShowAndRun() } "},{"id":55,"href":"/gofyne/docs/07-binding/","title":"数据绑定","section":"介绍","content":" 数据绑定 # 数据绑定是 Fyne 工具包的一个强大新功能，它在版本 v2.0.0 中引入。通过使用数据绑定，我们可以避免手动管理许多标准对象，如 Label、Button 和 List。\n内置绑定支持许多原始类型（如 Int、String、Float 等）、列表（例如 StringList、BoolList）以及 Map 和 Struct 绑定。每种类型都可以使用简单的构造函数创建。例如，要使用零值创建一个新的字符串绑定，可以使用 binding.NewString()。你可以使用 Get 和 Set 方法获取或设置大多数数据绑定的值。\n也可以使用以 Bind 开头的类似函数绑定到现有值，它们都接受指向绑定类型的指针。要绑定到现有的 int，我们可以使用 binding.BindInt(\u0026amp;myInt)。通过保留对绑定值的引用而不是原始变量，我们可以配置控件和函数以自动响应任何更改。如果你直接更改外部数据，请确保调用 Reload() 以确保绑定系统读取新值。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; ) func main() { boundString := binding.NewString() s, _ := boundString.Get() log.Printf(\u0026#34;Bound = \u0026#39;%s\u0026#39;\u0026#34;, s) myInt := 5 boundInt := binding.BindInt(\u0026amp;myInt) i, _ := boundInt.Get() log.Printf(\u0026#34;Source = %d, bound = %d\u0026#34;, myInt, i) } 接下来我们开始学习关于 简单绑定控件绑定。\n"},{"id":56,"href":"/gofyne/docs/04-container/08-apptabs/","title":"08. Tab 布局 AppTabs","section":"容器与布局","content":" Tab 布局 AppTabs # AppTabs 容器用于允许用户在不同的内容面板之间切换。标签页要么只有文本，要么是文本和图标。建议不要混合使用一些标签页有图标而另一些没有图标的情况。使用 container.NewAppTabs(...) 创建标签容器，并传递 container.TabItem 项（可以使用 container.NewTabItem(...) 创建）。\n可以通过设置标签的位置来配置标签容器，位置选项包括 container.TabLocationTop、container.TabLocationBottom、container.TabLocationLeading 和 container.TabLocationTrailing。默认位置是顶部。\npackage main import ( \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; //\u0026#34;fyne.io/fyne/v2/theme\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { myApp := app.New() myWindow := myApp.NewWindow(\u0026#34;TabContainer 控件\u0026#34;) tabs := container.NewAppTabs( container.NewTabItem(\u0026#34;标签 1\u0026#34;, widget.NewLabel(\u0026#34;你好\u0026#34;)), container.NewTabItem(\u0026#34;标签 2\u0026#34;, widget.NewLabel(\u0026#34;世界！\u0026#34;)), ) //tabs.Append(container.NewTabItemWithIcon(\u0026#34;首页\u0026#34;, theme.HomeIcon(), widget.NewLabel(\u0026#34;首页标签\u0026#34;))) tabs.SetTabLocation(container.TabLocationLeading) myWindow.SetContent(tabs) myWindow.ShowAndRun() } 在移动设备上加载时，可能会忽略标签位置。在纵向方向，前导或尾随位置将被更改为底部。在横向方向，顶部或底部位置将移至前导。\n"},{"id":57,"href":"/gofyne/docs/02-explore/08-preferences/","title":"08. 偏好设置","section":"探索 Fyne","content":" 偏好设置 # 为应用程序存储用户配置和值是应用开发者的常见任务，但在多个平台上实现它可能既乏味又耗时。为了简化这个过程，Fyne 提供了一个 API，用于以清晰且易于理解的方式在文件系统上存储值，同时为您处理复杂的部分。\n让我们从 API 的设置开始。它是 Preferences 接口的一部分，其中存在用于 Bool、Float、Int 和 String 值的存储和加载功能。它们每个都包含三个不同的函数，一个用于加载，一个带有回退值的加载，最后一个用于存储值。下面为 String 类型展示了这三个函数及其行为：\n// String 查找键的字符串值 String(key string) string // StringWithFallback 查找字符串值，并在未找到时返回给定的回退值 StringWithFallback(key, fallback string) string // SetString 为给定键保存一个字符串值 SetString(key string, value string) 这些函数可以通过创建的应用变量并调用其 Preferences() 方法来访问。请注意，创建带有唯一 ID 的应用是必要的（通常像反转的 url 那样）。这意味着应用程序需要使用 app.NewWithID() 来创建，以拥有自己存储值的位置。它大致可以像下面的示例那样使用：\na := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;) [...] a.Preferences().SetBool(\u0026#34;Boolean\u0026#34;, true) number := a.Preferences().IntWithFallback(\u0026#34;ApplicationLuckyNumber\u0026#34;, 21) expression := a.Preferences().String(\u0026#34;RegularExpression\u0026#34;) [...] 为了展示这一点，我们将构建一个简单的小应用，它总是在设定的时间后关闭。这个超时应该是用户可更改的，并在应用程序的下一次启动时应用。\n让我们首先创建一个名为 timeout 的变量，用于以 time.Duration 的形式存储时间。\nvar timeout time.Duration 然后，我们可以创建一个选择控件，让用户从几个预定义的字符串中选择超时，然后将超时乘以字符串所对应的秒数。最后，使用 \u0026quot;AppTimeout\u0026quot; 键将字符串值设置为选定的值。\ntimeoutSelector := widget.NewSelect([]string{\u0026#34;10秒\u0026#34;, \u0026#34;30秒\u0026#34;, \u0026#34;1分钟\u0026#34;}, func(selected string) { switch selected { case \u0026#34;10秒\u0026#34;: timeout = 10 * time.Second case \u0026#34;30秒\u0026#34;: timeout = 30 * time.Second case \u0026#34;1分钟\u0026#34;: timeout = time.Minute } a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected) }) 现在，我们想要获取设置的值，如果不存在，我们想要有一个回退，将超时设置为最短的一个，以节省用户等待时的时间。这可以通过将 timeoutSelector 的选定值设置为加载的值或回退值（如果是这种情况）来完成。通过这种方式，选择控件中的代码将针对该特定值运行。\ntimeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10秒\u0026#34;)) 最后一部分将只是有一个函数，在一个单独的 goroutine 中启动，并在选定的超时后告诉应用退出。\ngo func() { time.Sleep(timeout) a.Quit() }() 最终，结果代码应该看起来像这样：\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.NewWithID(\u0026#34;com.example.tutorial.preferences\u0026#34;) w := a.NewWindow(\u0026#34;超时\u0026#34;) var timeout time.Duration timeoutSelector := widget.NewSelect([]string{\u0026#34;10秒\u0026#34;, \u0026#34;30秒\u0026#34;, \u0026#34;1分钟\u0026#34;}, func(selected string) { switch selected { case \u0026#34;10秒\u0026#34;: timeout = 10 * time.Second case \u0026#34;30秒\u0026#34;: timeout = 30 * time.Second case \u0026#34;1分钟\u0026#34;: timeout = time.Minute } a.Preferences().SetString(\u0026#34;AppTimeout\u0026#34;, selected) }) timeoutSelector.SetSelected(a.Preferences().StringWithFallback(\u0026#34;AppTimeout\u0026#34;, \u0026#34;10秒\u0026#34;)) go func() { time.Sleep(timeout) a.Quit() }() w.SetContent(timeoutSelector) w.ShowAndRun() } 这段代码演示了如何利用 Fyne 的 Preferences API 来存储和读取用户的偏好设置，例如应用的超时设置。通过这种方式，开发者可以在多个平台上轻松地实现配置的存储和加载，而不需要处理底层的文件系统操作。Fyne 为处理复杂的部分提供了一个简单的界面，使得开发跨平台应用程序变得更加容易和直接。\n"},{"id":58,"href":"/gofyne/docs/03-canvas/08-animation/","title":"08. 动画 Animation","section":"画图和动画","content":" 动画 Animation # Fyne 包含一个动画框架，允许您在一段时间内平滑地过渡画布属性从一个值到另一个值。动画可以包含任何代码，这意味着可以管理任何类型的对象属性，但是内置了尺寸、位置和颜色的动画。\n动画通常使用画布包的内置助手创建，例如 NewSizeAnimation，并在创建的动画上调用 Start()。您可以设置动画以重复或自动反转，如下所示。\n首先让我们看看逐渐改变 Rectangle 填充颜色的颜色动画。在以下代码示例中，我们将矩形设置为窗口的内容，如之前的代码示例所做的那样。最大的不同是我们在显示窗口之前启动的动画。使用 NewColorRGBAAnimation 创建动画，它将在指定的 red 状态到 blue 状态之间过渡颜色通道，并将在指定的持续时间（2秒）内完成。\npackage main import ( \u0026#34;image/color\u0026#34; \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/canvas\u0026#34; \u0026#34;fyne.io/fyne/v2/container\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Hello\u0026#34;) obj := canvas.NewRectangle(color.Black) obj.Resize(fyne.NewSize(50, 50)) w.SetContent(container.NewWithoutLayout(obj)) red := color.NRGBA{R:0xff, A:0xff} blue := color.NRGBA{B:0xff, A:0xff} canvas.NewColorRGBAAnimation(red, blue, time.Second*2, func(c color.Color) { obj.FillColor = c canvas.Refresh(obj) }).Start() w.Resize(fyne.NewSize(250, 50)) w.SetPadded(false) w.ShowAndRun() } 也可以同时对多个属性进行动画处理。如果您仔细观察，您会看到我们将矩形添加到了没有布局的容器中——这意味着我们可以手动移动或调整对象的大小。让我们添加一个新的位置动画，它将在窗口中移动 Rectangle，并自动反转。\nmove := canvas.NewPositionAnimation(fyne.NewPos(0, 0), fyne.NewPos(200, 0), time.Second, obj.Move) move.AutoReverse = true move.Start() 因为 CanvasObject 的 Move() 函数期望一个 fyne.Position 参数，位置动画回调也是如此，我们可以简单地传递方法名称而不是创建一个新函数。如果您在第一个动画下面添加上面的代码，您会看到对象在改变颜色的同时跨越窗口移动！\n"},{"id":59,"href":"/gofyne/docs/01-started/08-packaging/","title":"08. 打包桌面应用","section":"快速开始","content":" 打包桌面应用 # 将图形应用程序打包以供分发可能会很复杂。图形应用程序通常有与它们关联的图标和元数据，以及集成到每个环境所需的特定格式。Windows可执行文件需要嵌入图标，macOS应用是捆绑包，在Linux中有各种应该安装的元数据文件。多麻烦啊！\n幸运的是，“fyne”应用有一个“package”命令可以自动处理这一切。只需指定目标操作系统和任何所需的元数据（如图标），就会生成适当的包。对于.icns或.ico图标转换将自动完成，所以只需提供.png文件 :)。你需要做的就是已经为目标平台构建了应用程序\u0026hellip;\ngo install fyne.io/fyne/v2/cmd/fyne@latest fyne package -os darwin -icon myapp.png 如果你使用的是Go的旧版本（\u0026lt;1.16），你应该使用go get安装fyne\ngo get fyne.io/fyne/v2/cmd/fyne fyne package -os darwin -icon myapp.png 将创建myapp.app，一个完整的捆绑结构，用于分发给macOS用户。然后你也可以为Linux和Windows版本构建\u0026hellip;\nfyne package -os linux -icon myapp.png fyne package -os windows -icon myapp.png 这些命令将创建：\nmyapp.tar.gz，包含从usr/local/开始的文件夹结构，Linux用户可以将其展开到他们的系统根目录。 myapp.exe（在第二次构建后，这是Windows包所需的）将嵌入图标和应用元数据。 如果你只想在你的电脑上安装桌面应用程序，那么你可以使用有用的install子命令。例如，要将你当前的应用程序系统范围内安装，你可以简单地执行以下操作：\nfyne install -icon myapp.png 所有这些命令也支持默认图标文件Icon.png，这样你就可以避免每次执行时键入参数。从Fyne 2.1开始，还有一个 元数据文件，你可以为你的项目设置默认选项。\n当然，如果你愿意，你仍然可以使用标准的Go工具运行你的应用程序。\n"},{"id":60,"href":"/gofyne/docs/01-started/09-mobile/","title":"09. 打包移动应用","section":"快速开始","content":" 打包移动应用 # 你的Fyne应用代码可以直接作为移动应用运行，就像它在桌面上做的那样。然而，将代码打包用于分发就复杂一些。这个页面将探索正是为了做到这一点而将你的应用带到iOS和Android上的过程。\n首先，你需要为移动打包安装更多的开发工具。对于Android构建，你必须安装Android SDK和NDK，并设置适当的环境，以便工具（如adb）可以在命令行中找到。要构建iOS应用，你需要在你的macOS电脑上安装Xcode以及命令行工具可选包。\n一旦你有了一个工作的开发环境，打包就很简单了。要为Android和iOS构建应用程序，以下命令将为你完成所有操作。确保有一个唯一的应用程序标识符，因为在你首次发布后更改这些是不明智的。\nfyne package -os android -appID com.example.myapp -icon mobileIcon.png fyne package -os ios -appID com.example.myapp -icon mobileIcon.png 在这些命令完成后（首次编译可能需要一些时间），你将在你的目录中看到两个新文件，myapp.apk和myapp.app。你会看到后者与darwin应用程序捆绑包同名 - 不要将它们混淆，因为它们在另一个平台上不会工作。\n要在你的手机或模拟器上安装Android应用，只需调用：\nadb install myapp.apk 对于iOS，要在设备上安装，打开Xcode并在“Window”菜单中选择“Devices and Simulators”菜单项。然后找到你的手机并将myapp.app图标拖到你的应用列表上。\n如果你想在模拟器上安装，请确保使用iossimulator而不是ios打包你的应用程序\nfyne package -os iossimulator -appID com.example.myapp -icon mobileIcon.png 之后，你可以如下使用命令行工具：\nxcrun simctl install booted myapp.app 这些步骤介绍了如何为iOS和Android设备打包和安装Fyne应用程序，从而使Fyne成为开发跨平台移动应用的强大工具。\n"},{"id":61,"href":"/gofyne/docs/02-explore/09-systray/","title":"09. 系统托盘菜单","section":"探索 Fyne","content":" 添加系统托盘菜单 # 自 v2.2.0 版本以来，Fyne 内置了对系统托盘菜单的支持。此功能在 macOS、Windows 和 Linux 计算机上显示一个图标，当点击时，会弹出由应用程序指定的菜单。\n由于这是一个特定于桌面的功能，我们首先必须进行运行时检查，以确认应用程序正在桌面模式下运行。为此，我们进行 Go 类型断言以获取对桌面功能的引用：\nif desk, ok := a.(desktop.App); ok { ... } 如果 ok 变量为真，则我们可以使用标准 Fyne 菜单 API 设置菜单，你可能之前在 Window.SetMainMenu 中使用过这个 API。\nm := fyne.NewMenu(\u0026#34;MyApp\u0026#34;, fyne.NewMenuItem(\u0026#34;Show\u0026#34;, func() { log.Println(\u0026#34;点击了显示\u0026#34;) })) desk.SetSystemTrayMenu(m) 将此代码添加到应用程序的设置中，运行应用程序，你会看到系统托盘中显示了一个 Fyne 图标。当你点击它时，会出现一个包含“显示”和“退出”的菜单。\n默认图标是 Fyne 标志，你可以通过 应用元数据更改这个设置，或者通过 App.SetIcon 或直接使用 desk.SetSystemTrayIcon 为系统托盘设置应用图标。\n管理窗口生命周期 # 默认情况下，当你关闭所有窗口时 Fyne 应用将会退出，这可能不是你希望的系统托盘应用的行为。要覆盖此行为，你可以使用 Window.SetCloseIntercept 功能来覆盖窗口关闭时的操作。在下面的示例中，我们通过调用 Window.Hide() 来隐藏窗口而不是关闭它。在第一次显示窗口之前添加这个。\nw.SetCloseIntercept(func() { w.Hide() }) 隐藏窗口的好处是你可以简单地再次使用 Window.Show() 显示它，如果需要第二次使用相同的内容，这比创建一个新窗口更高效。我们更新之前创建的菜单以显示上面隐藏的窗口。\nfyne.NewMenuItem(\u0026#34;Show\u0026#34;, func() { w.Show() })) 完整的应用程序 # 这就是使用 Fyne 设置系统托盘菜单的全部内容！本教程的完整代码如下所示。\npackage main import ( \u0026#34;fyne.io/fyne/v2\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/driver/desktop\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;SysTray\u0026#34;) if desk, ok := a.(desktop.App); ok { m := fyne.NewMenu(\u0026#34;MyApp\u0026#34;, fyne.NewMenuItem(\u0026#34;Show\u0026#34;, func() { w.Show() })) desk.SetSystemTrayMenu(m) } w.SetContent(widget.NewLabel(\u0026#34;Fyne 系统托盘\u0026#34;)) w.SetCloseIntercept(func() { w.Hide() }) w.ShowAndRun() } "},{"id":62,"href":"/gofyne/docs/01-started/10-webapp/","title":"10. 在浏览器中运行","section":"快速开始","content":" 在浏览器中运行 # Fyne应用程序也可以通过标准的网络浏览器在网络上运行！由于不同引擎的标准和优势各异，这稍微复杂一些。\n使用Fyne创建的网络应用将提供一个WASM运行时以及一个JavaScript代码包，这使得生成的网页可以查看当前浏览器并选择适合其优势的实现方式。这在大多数系统上提供了极好的用户体验。\n为了准备你的应用通过网络使用，我们再次使用“fyne”命令行应用，它有一个用于快速测试的“serve”命令\ngo install fyne.io/fyne/v2/cmd/fyne@latest fyne serve 你会看到，过了一会儿，一个网页服务器已经在8080端口启动。只需在你的网络浏览器中打开https://localhost:8080，你就可以使用你的应用了！\n这个过程中使用的工具对Go版本非常敏感，因此可能会出现与版本不匹配相关的错误。如果你使用的是1.18版之后的Go，你应该确保你有1.18版的副本，并在你的环境中引用它，比如（对于一个基于 homebrew的安装）：\nexport GOPHERJS_GOROOT=/opt/homebrew/Cellar/go@1.18/1.18.10/libexec 你可以在 GopherJS文档上了解更多相关信息。\n打包用于网络分发 # fyne serve命令非常适合本地测试，但就像其他平台一样，你也会想要能够分发你的应用。为了准备上传的文件，就像常规的 打包一样，使用fyne package命令。\nfyne package -os web 你也可以选择只为WASM或JavaScript打包，而不是自动检测设置：\nfyne package -os wasm fyne package -os js 演示 # 你可以访问 demo.fyne.io，在任何设备上测试Fyne应用的实际运行情况。\n限制 # 截至v2.4.0版本发布，网络驱动程序还没有完全完成，所以你的应用可能无法使用以下功能：\n多窗口（但对话框都可以在当前窗口内部工作） 文档和偏好设置的存储 这些问题正在被解决，并将在未来的版本中得到解决。\n"},{"id":63,"href":"/gofyne/docs/02-explore/10-binding/","title":"10. 数据绑定","section":"探索 Fyne","content":" 数据绑定 # 数据绑定在 Fyne v2.0.0 中引入，使得将许多控件连接到随时间更新的数据源变得更加容易。data/binding 包提供了许多有用的绑定，可以管理应用中使用的大多数标准类型。数据绑定可以使用绑定 API 管理（例如 NewString），也可以连接到外部数据项（如 BindInt(*int)）。\n支持绑定的控件通常有一个 ...WithData 构造器，在创建控件时设置绑定。你也可以调用 Bind() 和 Unbind() 来管理现有控件的数据。以下示例展示了如何管理一个与简单的 Label 控件绑定的 String 数据项。\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fyne.io/fyne/v2/app\u0026#34; \u0026#34;fyne.io/fyne/v2/data/binding\u0026#34; \u0026#34;fyne.io/fyne/v2/widget\u0026#34; ) func main() { a := app.New() w := a.NewWindow(\u0026#34;Hello\u0026#34;) str := binding.NewString() go func() { dots := \u0026#34;.....\u0026#34; for i := 5; i \u0026gt;= 0; i-- { str.Set(\u0026#34;倒计时\u0026#34; + dots[:i]) time.Sleep(time.Second) } str.Set(\u0026#34;发射！\u0026#34;) }() w.SetContent(widget.NewLabelWithData(str)) w.ShowAndRun() } 你可以在本站的 数据绑定部分了解更多信息。\n"},{"id":64,"href":"/gofyne/docs/10-faq/","title":"常见问题","section":"介绍","content":" 常见问题 # 由于 Fyne 工具包在某些方面提出了与传统 GUI 工具包设计不同的方法，我们编纂了这些常见问题解答。内容分为以下几个领域：\n布局和控件大小 主题和定制 如果您有更多问题，请 联系我们。\n"},{"id":65,"href":"/gofyne/docs/01-started/11-metadata/","title":"11. 应用元数据 Metadata","section":"快速开始","content":" 应用元数据 Metadata # 自fyne命令v2.1.0版本发布以来，我们支持一个元数据文件，允许你在仓库中存储有关你的应用的信息。这个文件是可选的，但可以帮助避免在每个包和发布命令中记住特定的构建参数。\n文件应该命名为FyneApp.toml，位于你运行fyne命令的目录中（通常是main包）。文件的内容如下：\nWebsite = \u0026#34;https://example.com\u0026#34; [Details] Icon = \u0026#34;Icon.png\u0026#34; Name = \u0026#34;My App\u0026#34; ID = \u0026#34;com.example.app\u0026#34; Version = \u0026#34;1.0.0\u0026#34; Build = 1 文件的顶部部分是元数据，如果你将你的应用上传到https://apps.fyne.io列表页面时会使用，因此它是可选的。[Details]部分包含了其他应用商店和操作系统在发布过程中使用的有关你的应用的数据。如果找到了这个文件，fyne工具将会使用它，很多强制性的命令参数如果元数据存在则不是必需的。你仍然可以使用命令行参数覆盖这些值。\n"},{"id":66,"href":"/gofyne/docs/02-explore/11-compiling/","title":"11. 编译选项","section":"探索 Fyne","content":" 编译选项 # Fyne 通常会通过选择驱动程序和配置来适当地为目标平台配置您的应用程序。以下构建标签得到支持，可帮助您的开发。例如，如果您希望在桌面计算机上模拟移动应用程序，您可以使用以下命令：\ngo run -tags mobile main.go 标签 描述 debug 显示调试信息，包括视觉布局，以帮助理解您的应用。 gles 强制使用嵌入式 OpenGL (GLES) 而不是完整的 OpenGL。这通常由目标设备控制，通常不需要。 hints 显示开发者提示以进行改进或优化。使用 hints 运行时，当您的应用程序不遵循材料设计或其他建议时，将记录下来。 mobile 此标签在模拟的移动窗口中运行应用程序。当您想要在不编译和安装到设备的情况下预览您的应用在移动平台上的外观时非常有用。 no_animations 禁用标准控件和容器中的非必要动画。 no_emoji 不包含嵌入的 emoji 字体。这将在您的应用中禁用 emoji，但会使二进制文件更小。 no_native_menus 此标志专门用于 macOS，表示应用程序不应使用 macOS 原生菜单。相反，菜单将在应用程序窗口内显示。在 macOS 上测试应用程序以模拟 Windows 或 Linux 上的行为时最有用。 "},{"id":67,"href":"/gofyne/docs/11-api/","title":"接口 API 定义","section":"介绍","content":" API 定义 # Fyne 的 API 定义部分建议直接查看 官方文档。\n"},{"id":68,"href":"/gofyne/docs/01-started/12-distribution/","title":"12. 发布到应用商店","section":"快速开始","content":" 分发到应用商店 # 按照 打包页面所述打包图形应用程序会提供一个可以直接分享或分发的文件或捆绑包。然而，签名并上传到应用商店和市场是一个需要特定平台配置的额外步骤，我们将在这个页面中介绍。\n在这些步骤中，我们将使用fyne命令行工具的一部分新工具。fyne release步骤处理为每个商店的签名和准备，但参数因平台而异，我们将在下面看到。\nmacOS AppStore（自fyne 1.4.2起） # 先决条件：\n运行macOS和Xcode的Apple mac Apple开发者账户 Mac AppStore 应用证书 Mac AppStore 安装程序证书 从 AppStore 下载的 Apple Transporter 应用 在 AppStore Connect上为要上传的构建准备好你的应用/版本。\n为发布捆绑完成的应用：\n$ fyne release -appID com.example.myapp -appVersion 1.0 -appBuild 1 -category games 将.pkg拖到Transporter上并点击“交付”。\n返回到AppStore Connect网站，选择你的构建版本进行发布，并提交审核。\n谷歌Play商店（Android） # 先决条件：\nGoogle Play控制台账户 分发密钥库（创建指南在 android文档） 在 Google Play控制台上为要上传的构建准备好你的应用/版本。关闭“Play应用签名”选项，因为我们自己管理它。\n为发布捆绑完成的应用：\n$ fyne release -os android -appID com.example.myapp -appVersion 1.0 -appBuild 1 将.apk文件拖到Play控制台中应用版本页面的构建投放区。\n开始新版本的推出。\niOS AppStore（自fyne 1.4.1起） # 先决条件：\n运行macOS和Xcode的Apple mac Apple开发者账户 iOS AppStore 分发证书 从 AppStore 下载的Apple Transporter应用 在 AppStore Connect上为要上传的构建准备好你的应用/版本。\n为发布捆绑完成的应用：\n$ fyne release -os ios -appID com.example.myapp -appVersion 1.0 -appBuild 1 将.ipa拖到Transporter上并点击“交付”。\n返回到AppStore Connect网站，选择你的构建版本进行发布，并提交审核。\n"},{"id":69,"href":"/gofyne/docs/01-started/13-cross-compile/","title":"13. 跨平台编译","section":"快速开始","content":" 跨平台编译 # 使用Go进行跨平台编译被设计得非常简单 - 我们只需设置目标操作系统的环境变量GOOS（如果目标是不同的架构，还需要设置GOARCH）。不幸的是，当使用原生图形调用时，Fyne中的CGo使用使这变得有些复杂。\n从开发计算机编译 # 要跨编译Fyne应用程序，你还必须设置CGO_ENABLED=1，这告诉go启用C编译器（当目标平台与当前系统不同时，这通常是关闭的）。不幸的是，这意味着你必须为你将要编译的目标平台安装一个C编译器。安装适当的编译器后，你还需要设置CC环境变量来告诉Go使用哪个编译器。\n安装所需工具有许多方法 - 并且可以使用不同的工具。Fyne开发者推荐的配置是：\nGOOS（目标） CC 提供者 下载 备注 darwin o32-clang osxcross 来自github.com 你还需要安装macOS SDK（下载链接处有指引） windows x86_64-w64-mingw64-gcc mingw64 包管理器 对于macOS使用 homebrew linux gcc 或 x86_64-linux-musl-gcc gcc 或 musl-cross cygwin 或 包管理器 musl-cross可从 homebrew获取，提供linux gcc。你还需要为编译安装X11和mesa头文件。 设置上述环境变量后，你应该能够以通常的方式进行编译。如果进一步出现错误，很可能是由于缺少包。一些目标平台需要安装额外的库或头文件才能成功编译。\n使用虚拟环境 # 由于Linux系统能够轻松地交叉编译到macOS和Windows，因此当你不是从Linux开发时，使用虚拟化环境可能更简单。Docker镜像是复杂构建配置的有用工具，这也适用于Fyne。可以使用不同的工具。Fyne开发者推荐的工具是 fyne-cross。它受到 xgo的启发，并使用基于 golang-cross镜像构建的 docker镜像，该镜像包括了Windows的MinGW编译器和macOS SDK，以及Fyne的需求。\nfyne-cross允许为以下目标构建二进制文件并创建分发包：\nGOOS GOARCH darwin amd64 darwin 386 linux amd64 linux 386 linux arm64 linux arm windows amd64 windows 386 android amd64 android 386 android arm64 android arm ios freebsd amd64 freebsd arm64 注意：iOS编译仅支持在darwin主机上。\n要求 # go \u0026gt;= 1.13 docker 安装 # 你可以使用以下命令安装fyne-cross（需要Go 1.16或更高版本）：\ngo install github.com/fyne-io/fyne-cross@latest 对于Go的早期版本，你需要使用以下命令代替：\ngo get github.com/fyne-io/fyne-cross 使用方法 # fyne-cross \u0026lt;command\u0026gt; [options] 命令包括： darwin 为darwin OS构建和打包fyne应用程序 linux 为linux OS构建和打包fyne应用程序 windows 为windows OS构建和打包fyne应用程序 android 为android OS构建和打包fyne应用程序 ios 为iOS OS构建和打包fyne应用程序 freebsd 为freebsd OS构建和打包fyne应用程序 version 打印fyne-cross版本信息 使用 \u0026#34;fyne-cross \u0026lt;command\u0026gt; -help\u0026#34; 获取有关命令的更多信息。 通配符 # arch标志支持通配符，以防你想要针对指定GOOS的所有支持GOARCH进行编译\n示例：\nfyne-cross windows -arch=* 等同于\nfyne-cross windows -arch=amd64,386 示例 # 以下示例交叉编译并打包 fyne示例应用程序\ngit clone https://github.com/fyne-io/examples.git cd examples 编译并打包主示例应用 # fyne-cross linux 注意：默认情况下，fyne-cross将在当前目录下编译包。\n上面的命令等同于：fyne-cross linux .\n编译并打包特定示例应用 # fyne-cross linux -output bugs ./cmd/bugs 通过上述方法，使用fyne-cross可以轻松地为多个平台交叉编译和打包Fyne应用程序，而无需手动配置每个平台的复杂环境，从而简化了跨平台开发和分发过程。\n"},{"id":70,"href":"/gofyne/docs/","title":"介绍","section":"首页","content":"本文档是 Go GUI 框架 Fyne 的中文翻译，英文原版请查看： docs.fyne.io/doc\n"}]