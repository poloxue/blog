[{"id":0,"href":"/backtrader/docs/12-analyzers/01-analyzers/","title":"Analyzers","section":"Analyzer","content":"分析器# 无论是回测还是交易，能够分析交易系统的表现对于理解是否不仅仅获得了利润，而且是否在实现利润的过程中承担了过多的风险，或者与参考资产（或无风险资产）相比是否真的值得付出努力，都是关键。\n这就是分析器对象的作用：提供对已发生情况或当前情况的分析。\n分析器的性质 接口的设计参照了线条对象，例如具有 next 方法，但有一个主要的区别：分析器不包含线条。\n这意味着它们在内存方面不是很消耗资源，因为即使在分析了成千上万个价格条之后，它们可能仍然只在内存中保存单个结果。\n在生态系统中的位置# 分析器对象（如同策略、观察者和数据）通过 cerebro 实例添加到系统中：\naddanalyzer(ancls, *args, **kwargs)但在 cerebro.run 操作期间，对于系统中存在的每个策略，将会发生以下情况：\nancls 在 cerebro.run 期间会用 *args 和 **kwargs 实例化 ancls 实例将会附加到策略上 这意味着：\n如果回测运行包含例如 3 个策略，那么将创建 3 个 ancls 实例，并且每个实例将附加到不同的策略上。\n结论：分析器分析单个策略的表现，而不是整个系统的表现。\n附加位置# 某些分析器对象可能实际上使用其他分析器来完成其工作。例如：SharpeRatio 使用 TimeReturn 的输出进行计算。\n这些子分析器或从属分析器也将插入到创建它们的同一策略中。但它们对用户是完全不可见的。\n属性# 为了完成预期的工作，分析器对象提供了一些默认属性，这些属性会自动传递并在实例中设置，以便于使用：\nself.strategy：对分析器对象正在运行的策略子类的引用。策略可以访问的任何内容，分析器也可以访问。 self.datas[x]：策略中存在的数据源数组。虽然可以通过策略引用访问，但快捷方式使工作更舒适。 self.data：对 self.datas[0] 的快捷方式，以增加舒适度。 self.dataX：对不同的 self.datas[x] 的快捷方式。 还有一些其他别名可用，尽管它们可能有些多余：\nself.dataX_Y，其中 X 是对 self.datas[X] 的引用，Y 指的是线条，最终指向 self.datas[X].lines[Y]。 如果线条有名称，还可以使用以下命名：\nself.dataX_Name，解析为 self.datas[X].Name，按名称而不是按索引返回线条。 对于第一个数据，最后两个快捷方式在没有初始 X 数字引用的情况下可用。例如：\nself.data_2 指 self.datas[0].lines[2]。\nself.data_close 指 self.datas[0].close。\n返回分析结果# Analyzer 基类创建了一个 self.rets（类型为 collections.OrderedDict）成员属性来返回分析结果。这是在 create_analysis 方法中完成的，子类可以覆盖该方法以创建自定义分析器。\n操作模式# 虽然分析器对象不是线条对象，因此不迭代线条，但它们被设计为遵循相同的操作模式。\n在系统启动之前实例化（因此调用 __init__）。 使用 start 信号表示操作开始。 prenext / nextstart / next 方法将根据策略的计算最小周期被调用。 prenext 和 nextstart 的默认行为是调用 next，因为分析器可能会从系统开始运行的第一刻起进行分析。 在线条对象中通常调用 len(self) 以检查实际条数。这在分析器中也适用，通过返回 self.strategy 的值。 订单和交易将像通知策略一样通过 notify_order 和 notify_trade 进行通知。 现金和价值也将通过 notify_cashvalue 方法像对策略那样进行通知。 现金、价值、基金价值和基金份额也将通过 notify_fund 方法像对策略那样进行通知。 使用 stop 信号表示操作结束。 一旦常规操作周期完成，分析器将提供用于提取/输出信息的附加方法： get_analysis：理想情况下（不是强制的）返回一个包含分析结果的字典样对象。 print 使用标准的 backtrader.WriterFile（除非被覆盖）写出 get_analysis 的分析结果。 pprint（漂亮打印）使用 Python 的 pprint 模块打印 get_analysis 结果。 最后：\nget_analysis 创建一个类型为 collections.OrderedDict 的成员属性 self.ret，分析器将分析结果写入其中。\n分析器的子类可以覆盖此方法以改变此行为。\n分析器模式# 在 backtrader 平台中开发分析器对象揭示了生成分析的两种不同使用模式：\n在执行过程中通过 notify_xxx 和 next 方法收集信息，并在 next 中生成当前的分析信息。 例如，TradeAnalyzer 仅使用 notify_trade 方法生成统计数据。 如上所述收集信息（或不收集），但在 stop 方法期间进行单次生成分析。 SQN（系统质量编号）在 notify_trade 期间收集交易信息，但在 stop 方法期间生成统计数据。 快速示例# 尽可能简单：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import datetime import backtrader as bt import backtrader.analyzers as btanalyzers import backtrader.feeds as btfeeds import backtrader.strategies as btstrats cerebro = bt.Cerebro() # 数据 dataname = \u0026#39;../datas/sample/2005-2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=dataname) cerebro.adddata(data) # 策略 cerebro.addstrategy(btstrats.SMA_CrossOver) # 分析器 cerebro.addanalyzer(btanalyzers.SharpeRatio, _name=\u0026#39;mysharpe\u0026#39;) thestrats = cerebro.run() thestrat = thestrats[0] print(\u0026#39;Sharpe Ratio:\u0026#39;, thestrat.analyzers.mysharpe.get_analysis())执行它（已将其存储在 analyzer-test.py 中）：\n$ ./analyzer-test.py Sharpe Ratio: {\u0026#39;sharperatio\u0026#39;: 11.647332609673256}没有绘图，因为 SharpeRatio 是在计算结束时的单一值。\n分析器的取证分析 让我们重复一下，分析器不是线条对象，但为了无缝集成到 backtrader 生态系统中，遵循了几个线条对象的内部 API 约定（实际上是它们的混合）。\n注意\nSharpeRatio 的代码已经演变，例如考虑了年化，此版本仅应作为参考。\n请查看分析器参考。\n此外还有一个 SharpeRatio_A 提供了直接以年化形式给出的值，而不管所需的时间范围。\nSharpeRatio 的代码作为基础（简化版本）：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import operator from backtrader.utils.py3 import map from backtrader import Analyzer, TimeFrame from backtrader.mathsupport import average, standarddev from backtrader.analyzers import AnnualReturn class SharpeRatio(Analyzer): params = ((\u0026#39;timeframe\u0026#39;, TimeFrame.Years), (\u0026#39;riskfreerate\u0026#39;, 0.01),) def __init__(self): super(SharpeRatio, self).__init__() self.anret = AnnualReturn() def start(self): # Not needed ... but could be used pass def next(self): # Not needed ... but could be used pass def stop(self): retfree = [self.p.riskfreerate] * len(self.anret.rets) retavg = average(list(map(operator.sub, self.anret.rets, retfree))) retdev = standarddev(self.anret.rets) self.ratio = retavg / retdev def get_analysis(self): return dict(sharperatio=self.ratio)代码可以分解为：\nparams 声明 尽管声明的参数没有使用（作为示例），分析器像大多数其他对象一样支持参数。 __init__ 方法 就像策略在 __init__ 中声明指标一样，分析器也声明支持对象。 在这种情况下：SharpeRatio 使用年度回报计算。计算将是自动的，并且将可用于 SharpeRatio 进行自己的计算。 next 方法 SharpeRatio 不需要它，但此方法将在父策略 next 的每次调用后被调用。 start 方法 在回测开始前调用。可以用于额外的初始化任务。 SharpeRatio 不需要它。\nstop 方法 在回测结束后调用。就像 SharpeRatio 所做的那样，它可以用于完成/进行计算。 get_analysis 方法（返回字典） 为外部调用者提供生成的分析。 返回：包含分析结果的字典。\n参考# class backtrader.Analyzer()Analyzer 基类。所有分析器都是此类的子类。\n分析器实例在策略的框架内运行，并为该策略提供分析。\n自动设置的成员属性：\nself.strategy（提供对策略及其可访问内容的访问） self.datas[x] 提供对系统中存在的数据源数组的访问，这些数据源也可以通过策略引用访问 self.data 提供对 self.datas[0] 的访问 self.dataX -\u0026gt; self.datas[X] self.dataX_Y -\u0026gt; self.datas[X].lines[Y] self.dataX_name -\u0026gt; self.datas[X].name self.data_name -\u0026gt; self.datas[0].name self.data_Y -\u0026gt; self.datas[0].lines[Y] 这不是线条对象，但方法和操作遵循相同的设计：\n在实例化和初始设置期间 __init__ 使用 start / stop 表示操作的开始和结束 prenext / nextstart / next 方法家族，遵循策略中相同方法的调用 notify_trade / notify_order / notify_cashvalue / notify_fund 接收与策略等效方法相同的通知 操作模式是开放的，没有首选模式。因此，分析可以通过 next 调用生成，在 stop 期间生成，也可以通过单个方法如 notify_trade 生成。\n重要的是覆盖 get_analysis 以返回包含分析结果的字典样对象（实际格式取决于实现）。\nstart() 调用以指示操作开始，给分析器时间设置所需内容。 stop() 调用以指示操作结束，给分析器时间关闭所需内容。 prenext() 在策略的每次 prenext 调用期间调用，直到达到策略的最小周期。 分析器的默认行为是调用 next。 nextstart() 在策略的 nextstart 调用时调用一次，当首次达到最小周期时。 next() 在策略的每次 next 调用期间调用，一旦达到策略的最小周期。 notify_cashvalue(cash, value) 在每个 next 周期之前接收现金/价值通知。 notify_fund(cash, value, fundvalue, shares) 接收当前现金、价值、基金价值和基金份额。 notify_order(order) 在每个 next 周期之前接收订单通知。 notify_trade(trade) 在每个 next 周期之前接收交易通知。 get_analysis() 返回包含分析结果的字典样对象。 字典中分析结果的键和值的格式取决于实现。 甚至不强制结果是字典样对象，只是一种约定。 默认实现返回由默认 create_analysis 方法创建的默认 OrderedDict rets。 create_analysis() 供子类覆盖。提供创建保存分析结果的结构的机会。 默认行为是创建名为 rets 的 OrderedDict。 print(*args, **kwargs) 使用标准 Writerfile 对象打印 get_analysis 返回的结果，默认写入标准输出。 pprint(*args, **kwargs) 使用 Python 的 pprint 模块打印 get_analysis 返回的结果。 len() 支持在分析器上调用 len，实际上返回分析器运行的策略的当前长度。 "},{"id":1,"href":"/backtrader/docs/10-broker/01-broker/","title":"Broker","section":"Broker","content":"Broker# 类 backtrader.brokers.BackBroker()# Broker 经纪商模拟器，该模拟支持不同的订单类型，检查提交订单的现金需求与当前现金的对比，跟踪每次 Cerebro 迭代的现金和价值，并保持不同数据的当前头寸。\n现金在每次迭代中调整，对于期货等工具来说，当价格变化时，会在实际经纪商中增加或减少现金。 支持的订单类型：\nMarket：将在下一个柱的第一个tick（即开盘价）执行 Close：用于日内交易，订单以会话最后一个柱的收盘价执行 Limit：如果在会话期间看到给定的限价则执行 Stop：如果看到给定的止损价，则执行市场订单 StopLimit：如果看到给定的止损价，则启动限价订单 因为经纪商由 Cerebro 实例化，用户通常不需要替换经纪商实例，因此参数不受用户控制。\n要更改参数，有两种选择：\n手动创建带所需参数的 Broker，用 cerebro.broker = instance 将该实例设置为这个经纪商； 使用 set_xxx 方法通过 cerebro.broker.set_xxx 设置参数，其中 xxx 代表设置参数名称； 注意，cerebro.broker 是一个由 Cerebro 的 getbroker 和 setbroker 方法支持的属性。\n参数# 参数名 默认值 描述 cash 10000 起始现金 commission CommInfoBase(percabs=True) 适用于所有资产的基础佣金方案 checksubmit True 在将订单接受到系统之前检查保证金/现金 eosbar False 对于日内 Bar，考虑与会话结束时间相同的柱为会话结束。通常不会这样，因为许多交易所会在会话结束后几分钟内为许多产品生成一些柱（最终拍卖） filler None 一个可调用对象，签名为 callable(order, price, ago)。参数说明：- order：显然是执行中的订单。这提供了对数据的访问（包括 ohlc 和成交量值）、执行类型、剩余大小（order.executed.remsize）等。- price：订单将在 ago 柱中执行的价格- ago：用于从 order.data 提取 ohlc 和成交量价格的索引。在大多数情况下，这将是 0，但在某些角落情况下，对于 Close 订单，这将是 -1。- 可调用对象必须返回执行的大小（值 \u0026gt;= 0）可调用对象当然可以是一个 __call__ 符合上述签名的对象。默认情况下，订单将一次性完全执行。 slip_perc 0.0 用于买卖订单上下滑动价格的绝对百分比（且为正值）。注意：0.01 是 1%，0.001 是 0.1% slip_fixed 0.0 用于买卖订单上下滑动价格的单位百分比（且为正值）。注意：如果 slip_perc 非零，则优先于此。 slip_open False 是否滑动专门使用下一个柱的开盘价执行的订单价格。例如，市场订单将在下一个可用tick执行，即柱的开盘价。这也适用于其他一些执行，因为逻辑尝试检测开盘价是否会匹配请求的价格/执行类型在移动到新柱时。 slip_match True - 如果为 True，经纪商将通过在高/低价位封顶滑点来提供匹配，以防它们超出。- 如果为 False，经纪商将不会使用当前价格匹配订单，并将在下一次迭代中尝试执行 slip_limit True - 限价订单，给定确切的匹配价格请求，即使 slip_match 为 False，也会被匹配。- 此选项控制该行为。- 如果为 True，那么限价订单将通过在限价/高低价位封顶价格进行匹配- 如果为 False 且滑点超出上限，则不会有匹配 slip_out False 即使价格超出高-低范围，也提供滑点。 coc False Cheat-On-Close 将其设置为 True 与 set_coc 启用，将“市场”订单与订单条的收盘价匹配。这实际上是作弊，因为柱已关闭，任何订单都应首先与下一个柱的价格匹配 coo False Cheat-On-Open 将其设置为 True 与 set_coo 启用，将“市场”订单与开盘价匹配，例如使用设置为 True 的计时器，因为这种计时器在经纪商评估之前执行 int2pnl True 将生成的利息（如果有）分配给减少头寸的操作的利润和亏损（无论是多头还是空头）。在某些情况下，这可能是不希望的，因为不同的策略在竞争，利息将以不确定的方式分配给其中任何一个。 shortcash True 如果为 True，则在卖空类似股票的资产时将增加现金，并且该资产的计算价值将为负值。- 如果为 False，则现金将作为操作成本扣除，计算的价值将为正值，以最终得到相同的金额 fundstartval 100.0 此参数控制基金式绩效测量的起始值，即：现金可以增加和扣除，增加股票数量。绩效不是使用投资组合的净资产价值来衡量，而是使用基金的价值 fundmode False 如果设置为 True，诸如 TimeReturn 的分析器可以基于基金价值而不是总净资产价值自动计算回报 方法# 签名 描述 set_cash(cash) 设置现金参数（别名：setcash） get_cash() 返回当前现金（别名：getcash） get_value( datas=None, mkt=False, lever=False) 返回给定数据的投资组合价值（如果数据为 None，则返回总投资组合价值）（别名：getvalue） set_eosbar(eosbar) 设置 eosbar 参数（别名：seteosbar） set_checksubmit(checksubmit) 设置 checksubmit 参数 set_filler(filler) 设置用于成交量填充执行的填充器 set_coc(coc) 配置 Cheat-On-Close 方法以在订单柱上买入收盘价 set_coo(coo) 配置 Cheat-On-Open 方法以在订单柱上买入收盘价 set_int2pnl(int2pnl) 配置将利息分配给利润和亏损 set_fundstartval(fundstartval) 设置基金式绩效跟踪器的起始值 set_slippage_perc( perc, slip_open=True, slip_limit=True, slip_match=True, \u0026amp;emspslip_out=False) 配置滑点为基于百分比 set_slippage_fixed( fixed, slip_open=True, slip_limit=True, slip_match=True, slip_out=False) 配置滑点为固定点数 get_orders_open(safe=False) 返回仍然打开的订单（未执行或部分执行）的可迭代对象。返回的订单不得被触摸。如果需要订单操作，请将参数 safe 设置为 True getcommissioninfo(data) 检索与给定数据相关的 CommissionInfo 方案 setcommission( commission=0.0, margin=None, mult=1.0, commtype=None, percabs=True, stocklike=False, interest=0.0, interest_long=False, leverage=1.0, automargin=False, name=None) 为 Broker 设置 CommissionInfo 对象，参考 CommInfoBase 文档介绍。如果 name 为 None，这将是没有找到其他 CommissionInfo 方案的资产的默认设置 addcommissioninfo( comminfo, name=None) 添加 CommissionInfo 对象，如果 name 为 None，将成为所有资产的默认设置 getposition(data) 返回给定数据的当前头寸状态（一个 Position 实例） get_fundshares() 返回基金模式中的当前股票数量 get_fundvalue() 返回基金式的股票价值 add_cash(cash) 添加/移除系统现金（使用负值移除） "},{"id":2,"href":"/backtrader/docs/05-cerebro/01-cerebro/","title":"Cerebro","section":"Cerebro","content":"Cerebro# Cerebro 是 Backtrader 的核心类，负责整个系统的运行。\n它的功能包括：\n收集输入（数据源）、执行者（策略）、观察者、评论者（分析器）和记录者（编写器），确保系统的正常运行。 执行回测或实时数据供给和交易。 返回回测结果。 提供策略绘图功能。 创建 Cerebro 实例# 创建 Cerebro 实例时，可以通过传递一些控制参数：\ncerebro = bt.Cerebro(**kwargs)这些参数会影响系统的执行，具体的参数说明可以参考文档（也可以应用于后续的 run 方法）。\n添加数据源# 最常见的方式是使用 cerebro.adddata(data) 添加数据源，data 是已实例化的数据源。例如：\ndata = bt.BacktraderCSVData(dataname=\u0026#39;mypath.days\u0026#39;, timeframe=bt.TimeFrame.Days) cerebro.adddata(data)数据的重采样与重放# Cerebro 也支持对数据进行重采样或重放：\n重采样：\ndata = bt.BacktraderCSVData(dataname=\u0026#39;mypath.min\u0026#39;, timeframe=bt.TimeFrame.Minutes) cerebro.resampledata(data, timeframe=bt.TimeFrame.Days)重放数据：\ndata = bt.BacktraderCSVData(dataname=\u0026#39;mypath.min\u0026#39;, timeframe=bt.TimeFrame.Minutes) cerebro.replaydata(data, timeframe=bt.TimeFrame.Days)你可以同时使用多种类型的数据源，包括常规数据、重采样数据和重放数据。但需要确保它们的时间对齐。详见文档中的 多时间框架 和 数据重采样 部分。\n添加策略# Cerebro 接受策略类并传递相关参数，即使没有优化，也可以使用以下方式添加策略：\ncerebro.addstrategy(MyStrategy, myparam1=value1, myparam2=value2)策略优化# 在优化时，参数需要作为可迭代对象传递。例如：\ncerebro.optstrategy(MyStrategy, myparam1=range(10, 20))这会运行 MyStrategy 10次，myparam1 的值从 10 到 19。\n添加其他组件# 你可以通过以下方法为回测添加额外的功能：\naddwriter：记录回测数据。 addanalyzer：分析回测结果。 addobserver 或 addobservermulti：添加观察者，实时跟踪策略执行。 自定义经纪人# Cerebro 默认使用 Backtrader 内建的经纪人，但你也可以自定义经纪人：\nbroker = MyBroker() cerebro.broker = broker # 通过 getbroker/setbroker 方法设置接收通知# 数据源或经纪人可能会发出通知。Cerebro 通过 notify_store 方法接收这些通知。处理通知有三种方式：\n使用回调函数# 你可以通过 addnotifycallback(callback) 向 Cerebro 添加回调函数，函数签名如下：\ncallback(msg, *args, **kwargs)在策略中覆盖 notify_store 方法# 你也可以在策略类中直接覆盖 notify_store 方法来处理通知，签名如下：\ndef notify_store(self, msg, *args, **kwargs): # 处理通知子类化 Cerebro# 通过子类化 Cerebro 并覆盖 notify_store，这是最不推荐的方法。\n执行回测# 回测执行通过以下方法进行：\nresult = cerebro.run(**kwargs)run 方法支持多种参数，可以在实例化时指定，详细说明可以参考文档。\n标准观察者# Cerebro 默认会实例化三个标准观察者：\n经纪人观察者：追踪现金和投资组合的价值。 交易观察者：记录每笔交易的效果。 买卖观察者：记录操作的执行时间。 如果不需要这些标准观察者，可以通过 stdstats=False 禁用它们。\n返回回测结果# 回测执行后，Cerebro 会返回策略实例，供你分析回测结果。你可以访问策略中的所有元素进行详细检查：\nresult = cerebro.run(**kwargs)优化时的返回结果# 如果没有使用优化，result 将是一个策略实例列表。 如果进行了优化，result 将是一个列表的列表，每个内部列表对应一次优化运行后的策略实例。 注意：优化的默认行为已经更改，优化时只会返回分析器结果，优化的策略结果需要通过设置 optreturn=False 来获取。\n提供绘图功能# 如果你安装了 matplotlib，可以通过以下方式绘制回测图形：\ncerebro.plot()回测流程概述# 回测的执行逻辑大致如下：\n传递任何存储的通知。 数据源提供下一组 tick/条。 数据同步：多个数据源的数据会按时间对齐，确保不同时间框架的数据能够同时进行计算。 版本更新：1.9.0.99 版本引入了新的同步行为。 通知策略有关订单、交易和现金的更新。 经纪人接受排队订单，并根据新数据执行订单。 调用策略的 next 方法，评估新数据并执行策略逻辑。 更新观察者、指标、分析器等，触发其他活动。 将数据写入目标（通过编写器）。 重要注意事项# 在数据源传递新的一组数据时，这些数据是“已关闭”的。这意味着策略发出的订单将基于 下一条数据 执行，而不是当前数据。\n"},{"id":3,"href":"/backtrader/docs/06-datafeed/01-datafeeds/","title":"Data Feeds","section":"DataFeed","content":"数据源# Backtrader 提供了一组数据源解析器（在撰写本文时都是基于 CSV 的）以便从不同来源加载数据。\nYahoo（在线或已保存到文件） VisualChart（参见 www.visualchart.com） Backtrader CSV（自定义格式用于测试） 通用 CSV 支持 从快速入门指南中可以清楚地看到，您可以将数据源添加到 Cerebro 实例中。这些数据源稍后将在策略中可用：\nself.datas 数组（按插入顺序） 数组对象的别名： self.data 和 self.data0 指向第一个元素 self.dataX 指向数组中索引为 X 的元素 以下是插入方式的快速提醒：\nimport backtrader as bt import backtrader.feeds as btfeeds data = btfeeds.YahooFinanceCSVData(dataname=\u0026#39;wheremydatacsvis.csv\u0026#39;) cerebro = bt.Cerebro() cerebro.adddata(data) # 可以传递一个 \u0026#39;name\u0026#39; 参数用于绘图数据源通用参数# 这个数据源可以直接从 Yahoo 下载数据并将其输入系统。\nBacktrader 数据源常用参数：\n参数名 默认值 描述 dataname None 必须提供。其含义因数据源类型而异，例如文件路径、股票代码等。 name '' 用于绘图时的装饰性名称。如果未指定，可能会从 dataname 派生（例如：文件路径的最后一部分）。 fromdate mindate Python datetime 对象，表示应忽略此日期之前的任何数据。 todate maxdate Python datetime 对象，表示应忽略此日期之后的任何数据。 timeframe TimeFrame.Days 时间框架。可能的值包括：Ticks、Seconds、Minutes、Days、Weeks、Months 和 Years。 compression 1 每个实际条形图的条形数。仅在数据重采样/重放中有效。 sessionstart None 数据会话的开始时间。可用于重采样等目的。 sessionend None 数据会话的结束时间。可用于重采样等目的。 CSV 数据源通用参数# 参数（除了通用参数外）：\n参数名 默认值 描述 headers True 指示传递的数据是否具有初始标题行。 separator ',' 分隔符，用于标记 CSV 每行中的各个字段。 GenericCSVData# 此类公开了一个通用接口，允许解析几乎所有的 CSV 文件格式。\n根据参数定义的顺序和字段存在情况解析 CSV 文件。\n特定参数（或特定含义）：\n参数名 默认值 描述 dataname 必须提供 要解析的文件名或类似文件的对象。 datetime 0 包含日期（或日期时间）字段的列索引。 time -1 如果与日期时间字段分开，则包含时间字段的列索引（-1 表示不存在）。 open 1 包含开盘价字段的列索引。 high 2 包含最高价字段的列索引。 low 3 包含最低价字段的列索引。 close 4 包含收盘价字段的列索引。 volume 5 包含成交量字段的列索引。 openinterest 6 包含未平仓合约数字段的列索引。 nullvalue float('NaN') 如果缺少应有的值（CSV 字段为空），将使用的值。 dtformat '%Y-%m-%d %H:%M:%S' 用于解析日期时间 CSV 字段的格式。 tmformat '%H:%M:%S' 如果存在，用于解析时间 CSV 字段的格式（默认情况下时间 CSV 字段不存在）。 这些参数允许用户根据其 CSV 文件的结构自定义数据解析方式，以便正确加载数据进行回测。\n示例使用# 满足以下要求的示例用法：\n限制输入年份为 2000 HLOC 顺序而不是 OHLC 将缺失值替换为零（0.0） 提供日线数据，日期时间只是格式为 YYYY-MM-DD 的日期 没有 openinterest 列 代码如下：\nimport datetime import backtrader as bt import backtrader.feeds as btfeeds ... ... data = btfeeds.GenericCSVData( dataname=\u0026#39;mydata.csv\u0026#39;, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), nullvalue=0.0, dtformat=(\u0026#39;%Y-%m-%d\u0026#39;), datetime=0, high=1, low=2, open=3, close=4, volume=5, openinterest=-1 ) ...略微修改后的要求：\n限制输入年份为 2000 HLOC 顺序而不是 OHLC 将缺失值替换为零（0.0） 提供日内数据，带有单独的日期和时间列 日期格式为 YYYY-MM-DD 时间格式为 HH.MM.SS（而不是通常的 HH:MM:SS） 没有 openinterest 列 代码如下：\nimport datetime import backtrader as bt import backtrader.feeds as btfeeds ... ... data = btfeeds.GenericCSVData( dataname=\u0026#39;mydata.csv\u0026#39;, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), nullvalue=0.0, dtformat=(\u0026#39;%Y-%m-%d\u0026#39;), tmformat=(\u0026#39;%H.%M.%S\u0026#39;), datetime=0, time=1, high=2, low=3, open=4, close=5, volume=6, openinterest=-1 )这也可以通过子类化永久保存：\nimport datetime import backtrader.feeds as btfeeds class MyHLOC(btfeeds.GenericCSVData): params = ( (\u0026#39;fromdate\u0026#39;, datetime.datetime(2000, 1, 1)), (\u0026#39;todate\u0026#39;, datetime.datetime(2000, 12, 31)), (\u0026#39;nullvalue\u0026#39;, 0.0), (\u0026#39;dtformat\u0026#39;, (\u0026#39;%Y-%m-%d\u0026#39;)), (\u0026#39;tmformat\u0026#39;, (\u0026#39;%H.%M.%S\u0026#39;)), (\u0026#39;datetime\u0026#39;, 0), (\u0026#39;time\u0026#39;, 1), (\u0026#39;high\u0026#39;, 2), (\u0026#39;low\u0026#39;, 3), (\u0026#39;open\u0026#39;, 4), (\u0026#39;close\u0026#39;, 5), (\u0026#39;volume\u0026#39;, 6), (\u0026#39;openinterest\u0026#39;, -1) )现在可以通过提供 dataname 重用此新类：\ndata = btfeeds.MyHLOC(dataname=\u0026#39;mydata.csv\u0026#39;)"},{"id":4,"href":"/backtrader/docs/15-livetrading/01-interactive-brokers/","title":"Interactive Brokers","section":"实盘","content":"盈透（Interactive Brokers）# 与盈透（Interactive Brokers）的集成支持以下功能：\n实时数据馈送 实时交易 注意：尽管已经尽力测试了尽可能多的错误条件和情况，但代码（像任何其他软件一样）可能包含错误。在进入生产环境之前，请使用纸面交易账户或 TWS 演示帐户彻底测试任何策略。\n注意：与互动经纪商的交互是通过使用 IbPy 模块进行的，该模块在使用前必须安装。目前在 Pypi 中没有该模块的包（撰写本文时），但可以使用以下命令通过 pip 安装：\npip install git+https://github.com/blampe/IbPy.git如果您的系统中没有 git（例如在 Windows 上安装），以下命令也可以正常工作：\npip install https://github.com/blampe/IbPy/archive/master.zip示例代码# 源码包含一个完整的示例，位于：\nsamples/ibtest/ibtest.py\n该示例无法涵盖所有可能的用例，但它试图提供广泛的见解，并应强调在使用回测模块或实时数据模块时没有实际差异。\n需要注意的一点是：\n示例在任何交易活动开始之前，都会等待 data.LIVE 数据状态通知。这可能是任何实时策略中都需要考虑的事项。\n存储模型与直接模型# 与互动经纪商的交互支持两种模型：\n存储模型（推荐） 直接与数据馈送类和经纪商类交互 存储模型提供了一种明确的分离模式，用于创建经纪商和数据。以下两个代码片段应更好地作为示例。\n首先是存储模型：\nimport backtrader as bt ibstore = bt.stores.IBStore(host=\u0026#39;127.0.0.1\u0026#39;, port=7496, clientId=35) data = ibstore.getdata(dataname=\u0026#39;EUR.USD-CASH-IDEALPRO\u0026#39;)这里的参数：\nhost，port 和 clientId 传递到 IBStore 中，用于打开连接。 然后使用 getdata 创建数据馈送，并使用 backtrader 中所有数据馈送中常见的参数 dataname 请求 EUR/USD 外汇对。 直接使用模型：\nimport backtrader as bt data = bt.feeds.IBData(dataname=\u0026#39;EUR.USD-CASH-IDEALPRO\u0026#39;, host=\u0026#39;127.0.0.1\u0026#39;, port=7496, clientId=35)在这里：\n参数直接传递给数据。这些将用于在后台创建 IBStore 实例。 缺点是：\n清晰度较低，因为不清楚哪些属于数据，哪些属于存储。 IBStore - 存储# 存储是实时数据馈送/交易支持的关键，提供了 IbPy 模块和数据馈送及经纪代理需求之间的适配层。\n存储是一个涵盖以下功能的概念：\n作为一个实体的中央商店：在这种情况下，实体是 IB，可以需要或不需要参数。 提供访问获取经纪实例的方法： IBStore.getbroker(*args, **kwargs) 提供访问获取数据馈送实例的方法： IBStore.getdata(*args, **kwargs)在这种情况下，许多 **kwargs 是数据馈送中常见的，如 dataname，fromdate，todate，sessionstart，sessionend，timeframe，compression。\n数据可能会提供其他参数。请检查下面的参考。\nIBStore 提供：\n连接目标（host 和 port 参数） 身份识别（clientId 参数） 重新连接控制（reconnect 和 timeout 参数） 时间偏移检查（timeoffset 参数，见下文） 通知和调试 notifyall (default: False): 在这种情况下，IB 发送的任何错误信息（许多只是信息性）将被转发到 Cerebro/Strategy。 _debug (default: False): 在这种情况下，TWS 接收到的每条消息都将打印到标准输出。IBData 数据馈送# 数据选项# 无论是直接还是通过 getdata，IBData 数据馈送都支持以下数据选项：\n历史下载请求\n如果持续时间超过 IB 为给定时间框架/压缩组合设置的限制，这些请求将被拆分为多个请求。\n实时数据有三种口味\ntickPrice 事件（通过 IB reqMktData）\n用于 CASH 产品（根据至少 TWS API 9.70 的实验，其他类型不支持）\n通过查看 BID 价格接收 tick 价格事件，根据非官方互联网文献，这似乎是跟踪 CASH 市场价格的方式。\n时间戳在系统中本地生成。如果最终用户希望，可以使用与 IB 服务器时间的偏移（从 IB reqCurrentTime 计算）。\ntickString 事件（即 RTVolume（通过 IB reqMktData）\n从 IB 大约每 250 毫秒接收一次 OHLC/成交量快照（如果没有交易发生，则更长时间）。\nRealTimeBars 事件（通过 IB reqRealTimeBars）\n每 5 秒接收一次历史 5 秒的条形图（由 IB 固定的持续时间）。\n如果选择的时间框架/组合低于 Seconds/5 级别，此功能将自动禁用。\n注意：RealTimeBars 不适用于 TWS 演示。\n默认行为是在大多数情况下使用：tickString，除非用户特别希望使用 RealTimeBars。\n回填\n除非用户请求只进行历史下载，否则数据馈送将自动回填：\n启动时：最大可能持续时间。例如，对于 Days/1（时间框架/压缩）组合，IB 的默认最大持续时间为 1 年，这是将被回填的时间量。\n数据断开连接后：在这种情况下，通过查看断开连接前接收的最新数据，回填操作下载的数据量将减少到最小。\n注意：请考虑最终时间框架/压缩组合可能不是在创建数据馈送时指定的，而是在系统中插入时指定的。请看以下示例：\ndata = ibstore.getdata(dataname=\u0026#39;EUR.USD-CASH-IDEALPRO\u0026#39;, timeframe=bt.TimeFrame.Seconds, compression=5) cerebro.resampledata(data, timeframe=bt.TimeFrame.Minutes, compression=2)现在应该清楚，最终考虑的时间框架/压缩组合是 Minutes/2。\n数据合约检查# 在启动阶段，数据馈送将尝试下载指定合约的详细信息（请参阅参考，了解如何指定）。如果未找到合约或找到多个匹配项，数据将拒绝继续并将通知系统。一些示例。\n简单但明确的合约规格：\ndata = ibstore.getdata(dataname=\u0026#39;TWTR\u0026#39;) # 推特由于默认类型 STK，交易所 SMART 和货币（默认无），将找到一个在 USD 中交易的单一合约（2016-06）。\n类似的方式对 AAPL 会失败：\ndata = ibstore.getdata(dataname=\u0026#39;AAPL\u0026#39;) # 错误 -\u0026gt; 多个合约因为 SMART 找到在多个实际交易所中的合约，且 AAPL 在其中一些以不同货币交易。以下是可以的：\ndata = ibstore.getdata(dataname=\u0026#39;AAPL-STK-SMART-USD\u0026#39;) # 找到1个合约数据通知# 数据馈送将通过以下一种或多种方式报告当前状态（请检查 Cerebro 和 Strategy 参考）：\nCerebro.notify_data（如果覆盖） 使用 Cerebro.adddatacb 添加的回调 Strategy.notify_data（如果覆盖） 策略中的示例如下：\nclass IBStrategy(bt.Strategy): def notify_data(self, data, status, *args, **kwargs): if status == data.LIVE: # 数据已切换为实时数据 # 执行某些操作 pass在系统中发生变化时，将发送以下通知：\nCONNECTED：在成功初始连接时发送 DISCONNECTED：在这种情况下，无法再检索数据，数据将向系统指示无法执行任何操作。可能的条件包括： 指定的合约错误 历史下载中断 超过与 TWS 的重连次数 CONNBROKEN：与 TWS 或数据农场的连接已丢失。数据馈送将尝试（通过存储）重新连接并在需要时回填，并恢复操作。 NOTSUBSCRIBED：合约和连接正常，但由于缺乏权限无法检索数据。数据将向系统指示无法检索 数据。\nDELAYED：表示历史/回填操作正在进行中，策略处理的数据不是实时数据。 LIVE：表示策略从这一点开始处理的数据是实时数据。 策略开发人员应考虑在发生断开连接或接收到延迟数据时应采取哪些措施。\n数据时间框架和压缩# backtrader 生态系统中的数据馈送在创建期间支持 timeframe 和 compression 参数。这些参数也可以作为属性访问，使用 data._timeframe 和 data._compression。\n时间框架/压缩组合的意义在于将数据传递给 cerebro 实例，通过 resampledata 或 replaydata 让内部重采样器/重放器对象了解目标是什么。 _timeframe 和 _compression 将在重采样/重放期间在数据中被覆盖。\n但在实时数据馈送中，这些信息可能起重要作用。请看以下示例：\ndata = ibstore.getdata(dataname=\u0026#39;EUR.USD-CASH-IDEALPRO\u0026#39;, timeframe=bt.TimeFrame.Ticks, compression=1, # 1 是默认值 rtbar=True, # 使用实时条 ) cerebro.adddata(data)用户请求 tick 数据，这很重要，因为：\n不会进行回填（IB 支持的最小单位是 Seconds/1） 即使请求和支持实时条，如果时间分辨率低于 Seconds/5，也不会使用它们。 除非以 Ticks/1 分辨率工作，否则数据必须重采样/重放。以下是使用实时条的例子：\ndata = ibstore.getdata(dataname=\u0026#39;TWTR-STK-SMART\u0026#39;, rtbar=True) cerebro.resampledata(data, timeframe=bt.TimeFrame.Seconds, compression=20)如上所述，data._timeframe 和 data._compression 属性将在 resampledata 期间被覆盖。以下是将发生的情况：\n回填将请求 Seconds/20 分辨率 实时条将用于实时数据，因为分辨率等于或大于 Seconds/5，数据支持（不是 CASH 产品） 来自 TWS 的事件最多每 5 秒发生一次。这可能并不重要，因为系统每 20 秒只会向策略发送一个条。 没有实时条的情况：\ndata = ibstore.getdata(dataname=\u0026#39;TWTR-STK-SMART\u0026#39;) cerebro.resampledata(data, timeframe=bt.TimeFrame.Seconds, compression=20)在这种情况下：\n回填将请求 Seconds/20 分辨率 tickString 将用于实时数据（不是 CASH 产品） 来自 TWS 的事件最多每 250 毫秒发生一次。这可能并不重要，因为系统每 20 秒只会向策略发送一个条。 最后是 CASH 产品，时间跨度为 20 秒：\ndata = ibstore.getdata(dataname=\u0026#39;EUR.USD-CASH-IDEALPRO\u0026#39;) cerebro.resampledata(data, timeframe=bt.TimeFrame.Seconds, compression=20)在这种情况下：\n回填将请求 Seconds/20 分辨率 tickPrice 将用于实时数据，因为这是一个现金产品 即使添加了 rtbar=True 来自 TWS 的事件最多每 250 毫秒发生一次。这可能并不重要，因为系统每 20 秒只会向策略发送一个条。 时间管理# 数据馈送将自动从 TWS 报告的 ContractDetails 对象中确定时区。\n注意：这需要安装 pytz。如果未安装，用户应提供 tz 参数，一个兼容 tzinfo 的实例，用于所需的输出时区。\n注意：如果安装了 pytz，且用户觉得自动时区确定不起作用，tz 参数可以包含一个时区名称字符串。backtrader 将尝试使用给定名称实例化一个 pytz.timezone。\n报告的日期时间将是与产品相关的时区。例如：\n产品：Eurex 的 EuroStoxxx 50（代码：ESTX50-YYYYMM-DTB） 时区将是 CET（中欧时间），即 Europe/Berlin 产品：ES-Mini（代码：ES-YYYYMM-GLOBEX） 时区将是 EST5EDT，即 EST，即 US/Eastern 产品：EUR.JPY 外汇对（代码：EUR.JPY-CASH-IDEALPRO） 时区将是 EST5EDT，即 EST，即 US/Eastern 实际上，这是一个互动经纪商的设置，因为外汇对几乎 24 小时不间断交易，因此不会有真实的时区。\n这种行为确保无论交易者的实际位置如何，交易都保持一致，因为计算机很可能具有交易地点的实际时区，而不是交易场所的时区。\n请阅读手册中的时间管理部分。\n注意：TWS 演示在报告没有数据下载权限的资产时区方面不准确（EuroStoxx 50 期货是这种情况的一个例子）。\n实时数据馈送和重采样/重放# 设计决策关于何时为实时数据馈送交付条：\n尽可能实时地交付它们。这似乎是显而易见的，对于 Ticks 时间框架来说确实如此，但如果重采样/重放起作用，可能会有延迟。用例：\n重采样配置为 Seconds/5：\ncerebro.resampledata(data, timeframe=bt.TimeFrame.Seconds, compression=5)一个时间戳为 23:05:27.325000 的 tick 被传递。\n市场交易缓慢，下一 tick 在 23:05:59.025000 传递。\n这可能并不显而易见，但 backtrader 不知道交易非常慢，下一 tick 将在大约 32 秒后到来。如果没有任何规定，带时间戳 23:05:30.000000 的重采样条将延迟大约 29 秒。\n这就是为什么实时数据馈送每 x 秒（浮动值）唤醒一次，通知重采样器/重放器没有新数据进来。这是通过在创建实时数据馈送时使用参数 qcheck（默认值：0.5 秒）来控制的。\n这意味着重采样器每 qcheck 秒有一次机会交付条，如果本地时钟说重采样周期结束。这样，前述场景中的重采样条（23:05:30.000000）将最多在报告时间后的 qcheck 秒内交付。\n由于默认值是 0.5 秒，最迟时间将是：23:05:30.500000。这比之前早了将近 29 秒。\n缺点是：\n一些 tick 可能太晚，无法用于已经交付的重采样/重放条。如果在交付之后，TWS 从服务器收到一个时间戳为 23:05:29.995000 的延迟消息，这对于已经报告给系统的时间 23:05.30.000000 来说太晚了。\n这种情况主要发生在：\ntimeoffset 在 IBStore 中被禁用（设置为 False）且 IB 报告的时间和本地时钟之间的时间差显著时。\n避免大多数这些延迟样本的最佳方法：\n增加 qcheck 值，以允许考虑延迟消息：\ndata = ibstore.getdata(\u0026#39;TWTR\u0026#39;, qcheck=2.0, ...)这应该增加额外的空间，即使它会延迟重采样/重放条的交付。\n注意：当然，对于 Seconds/5 重采样来说，2.0 秒的延迟与 Minutes/10 的重采样有不同的意义。\n如果出于某种原因，最终用户希望禁用 timeoffset 并不通过 qcheck 管理，仍然可以获取延迟样本：\n使用 _latethrough 设置为 True 作为 getdata / IBData 的参数：\ndata = ibstore.getdata(\u0026#39;TWTR\u0026#39;, _latethrough=True, ...)在重采样/重放时使用 takelate 设置为 True：\ncerebro.resampledata(data, takelate=True)IBBroker - 实时交易# 注意：应要求，在 backtrader 中提供的模拟经纪商中实现了 tradeid 功能。这允许正确分配不同 tradeid 的佣金。\n由于经纪商在报告佣金时，不支持此实时经纪商，因为佣金是在不可能分离不同 tradeid 值的时间点报告的。\n尽管仍可以指定 tradeid，但它不再有意义。\n使用经纪商# 要使用 IB 经纪商，必须替换 cerebro 创建的标准模拟经纪实例。\n使用存储模型（推荐）：\nimport backtrader as bt cerebro = bt.Cerebro() ibstore = bt.stores.IBStore(host=\u0026#39;127.0.0.1\u0026#39;, port=7496, clientId=35) cerebro.broker = ibstore.getbroker() # 或者 cerebro.setbroker(...)使用直接\n方法：\nimport backtrader as bt cerebro = bt.Cerebro() cerebro.broker = bt.brokers.IBBroker(host=\u0026#39;127.0.0.1\u0026#39;, port=7496, clientId=35)经纪商参数# 无论是直接还是通过 getbroker，IBBroker 都不支持任何参数。这是因为经纪商只是一个代理，真实的经纪商提供的内容不应被删除。\n一些限制# 现金和价值报告# 内部 backtrader 模拟经纪商在调用策略 next 方法之前计算值（净清算价值）和现金，而实时经纪商不能保证这一点。\n如果请求这些值，next 的执行可能会延迟到答案到达。\n经纪商可能尚未计算这些值。\nbacktrader 告诉 TWS 提供更新后的值，但不知道消息何时会到达。\nIBBroker 的 getcash 和 getvalue 方法报告的值始终是从 IB 接收到的最新值。\n注意：进一步的限制是，这些值以账户的基本货币报告，即使可用更多货币的值。这是一个设计选择。\n头寸# backtrader 使用 TWS 报告的资产的头寸（价格和数量）。可以通过订单执行和订单状态消息进行内部计算，但如果丢失了这些消息中的一些，计算将不准确。\n当然，如果在连接到 TWS 时，将进行交易的资产已经有一个未平仓头寸，策略计算的交易将无法像往常一样工作，因为有一个初始偏移。\n交易# 在使用方面没有变化。只需使用策略中提供的方法（请参阅策略参考以获取完整说明）：\nbuy sell close cancel 返回的订单对象# 与 backtrader 订单对象兼容（在相同层次结构中子类化）。\n订单执行类型# IB 支持众多执行类型，其中一些由 IB 模拟，一些由交易所支持。决定最初支持哪些订单执行类型的动机是：\n与 backtrader 中提供的模拟经纪商兼容\n理由是将进行生产的内容已经过回测。\n因此，订单执行类型限于模拟经纪商中可用的类型：\nOrder.Market Order.Close Order.Limit Order.Stop（触发止损后跟随一个市价单） Order.StopLimit（触发止损后跟随一个限价单） 注意：IB 根据不同策略触发止损。backtrader 不会修改默认设置，即 0：\n0 - 默认值。对于 OTC 股票和美国期权，将使用“双重买/卖”方法。所有其他订单将使用“最后”方法。 如果用户希望修改此设置，可以按照 IB 文档提供额外的 **kwargs。 例如，在策略的 next 方法中：\ndef next(self): # 一些逻辑 self.buy(data, m_triggerMethod=2)这将策略改为 2（“最后”方法，其中止损订单基于最后价格触发）。\n请参考 IB API 文档以获取关于止损触发的进一步说明。\n订单有效期# backtrader 在回测期间可用的相同有效期概念（使用 valid 参数买入和卖出）在此也可用，并具有相同含义。因此，有效期参数对于 IB 订单转换如下：\nNone -\u0026gt; GTC（Good Til Cancelled）\n因为未指定有效期，理解为订单必须有效直到取消。\ndatetime/date -\u0026gt; GTD（Good Til Date）\n传递 datetime.datetime 或 datetime.date 实例表示订单必须有效直到某个时间点。\ntimedelta(x) -\u0026gt; GTD（timedelta(x) 不等于 timedelta()）\n解释为订单有效从现在起加上 timedelta(x)。\nfloat -\u0026gt; GTD\n如果值取自 backtrader 使用的原始浮点日期时间存储，则订单必须有效直到由该浮点数指示的日期时间。\ntimedelta() 或 0 -\u0026gt; DAY\n指定了一个值（而不是 None），但为空值，解释为当天（会话）有效的订单。\n通知# 标准订单状态将通过策略的 notify_order 方法通知（如果覆盖）。\nSubmitted - 订单已发送到 TWS\nAccepted - 订单已被放置\nRejected - 订单放置失败或在其生命周期内被系统取消\nPartial - 部分执行已发生\nCompleted - 订单已完全执行\nCanceled（或 Cancelled）\n在 IB 中有多重含义：\n用户手动取消 服务器/交易所取消订单 订单有效期已过 将应用一个启发式方法，如果从 TWS 收到 openOrder 消息，订单状态指示 PendingCancel 或 Canceled，则订单将被标记为已过期。\nExpired - 请参见上文解释。\n参考# IBStore# class backtrader.stores.IBStore()包装一个 ibpy ibConnection 实例的单例类。\n这些参数也可以在使用该存储的类中指定，如 IBData 和 IBBroker。\n参数：\nhost（默认：127.0.0.1）：IB TWS 或 IB Gateway 实际运行的位置。虽然这通常是 localhost，但不一定是。 port（默认：7496）：连接到的端口。演示系统使用 7497。 clientId（默认：无）：用于连接 TWS 的 clientId。 无：生成 1 到 65535 之间的随机 id 整数：将传递为使用的值。 notifyall（默认：False） 如果为 False，则只会将错误消息发送到 Cerebro 和 Strategy 的 notify_store 方法。 如果为 True，将通知收到的每一条来自 TWS 的消息。 _debug（默认：False） 将所有收到的 TWS 消息打印到标准输出。 reconnect（默认：3） 初始连接尝试失败后尝试重新连接的次数。 设置为 -1 值以无限期重新连接。 timeout（默认：3.0） 重新连接尝试之间的时间（秒）。 timeoffset（默认：True） 如果为 True，将使用从 reqCurrentTime（IB 服务器时间）获得的时间计算与本地时间的偏移量，并将该偏移量用于价格通知（例如，CASH 市场的 tickPrice 事件）以修改本地计算的时间戳。 时间偏移将传播到 backtrader 生态系统的其他部分，如重采样以使用计算的偏移量对齐重采样时间戳。 timerefresh（默认：60.0） 时间（秒）：刷新时间偏移的频率。 indcash（默认：True） 将 IND 代码管理为现金以获取价格。 IBBroker# class backtrader.brokers.IBBroker(**kwargs)互动经纪商的经纪商实现。\n该类将互动经纪商的订单/头寸映射到 backtrader 的内部 API。\n注意事项：\ntradeid 实际上不受支持，因为盈亏是直接从互动经纪商获取的。因为（如预期）以 FIFO 方式计算，因此 tradeid 的盈亏不准确。 头寸：如果在操作开始时有资产的未平仓头寸，或者通过其他方式给出的订单改变了头寸，Cerebro 中策略计算的交易将不反映现实。 为避免这种情况，经纪商将不得不进行自己的头寸管理，这也将允许多个 id 的 tradeid（盈亏也将本地计算），但可能被认为违背了与实时经纪商合作的目的。 IBData# class backtrader.feeds.IBData(**kwargs)互动经纪商数据馈送。\n支持以下参数 dataname 中的合约规格：\nTICKER # 股票类型和 SMART 交易所 TICKER-STK # 股票和 SMART 交易所 TICKER-STK-EXCHANGE # 股票 TICKER-STK-EXCHANGE-CURRENCY # 股票 TICKER-CFD # CFD 和 SMART 交易所 TICKER-CFD-EXCHANGE # CFD TICKER-CDF-EXCHANGE-CURRENCY # 股票 TICKER-IND-EXCHANGE # 指数 TICKER-IND-EXCHANGE-CURRENCY # 指数 TICKER-YYYYMM-EXCHANGE # 期货 `TICKER-YYYY MM-EXCHANGE-CURRENCY` # 期货\nTICKER-YYYYMM-EXCHANGE-CURRENCY-MULT # 期货 TICKER-FUT-EXCHANGE-CURRENCY-YYYYMM-MULT # 期货 TICKER-YYYYMM-EXCHANGE-CURRENCY-STRIKE-RIGHT # 期权 TICKER-YYYYMM-EXCHANGE-CURRENCY-STRIKE-RIGHT-MULT # 期权 TICKER-FOP-EXCHANGE-CURRENCY-YYYYMM-STRIKE-RIGHT # 期权 TICKER-FOP-EXCHANGE-CURRENCY-YYYYMM-STRIKE-RIGHT-MULT # 期权 CUR1.CUR2-CASH-IDEALPRO # 外汇 TICKER-YYYYMMDD-EXCHANGE-CURRENCY-STRIKE-RIGHT # 期权 TICKER-YYYYMMDD-EXCHANGE-CURRENCY-STRIKE-RIGHT-MULT # 期权 TICKER-OPT-EXCHANGE-CURRENCY-YYYYMMDD-STRIKE-RIGHT # 期权 TICKER-OPT-EXCHANGE-CURRENCY-YYYYMMDD-STRIKE-RIGHT-MULT # 期权 参数：\nsectype（默认：STK）\n如果在 dataname 规范中未提供，应用的默认值为证券类型。 exchange（默认：SMART）\n如果在 dataname 规范中未提供，应用的默认值为交易所。 currency（默认：\u0026rsquo;\u0026rsquo;）\n如果在 dataname 规范中未提供，应用的默认值为货币。 historical（默认：False）\n如果设置为 True，数据馈送将在首次下载数据后停止。 将使用标准数据馈送参数 fromdate 和 todate 作为参考。 如果请求的持续时间大于 IB 在给定时间框架/压缩组合下允许的持续时间，数据馈送将进行多次请求。 what（默认：None）\n如果为 None，则历史数据请求的默认值将根据资产类型的不同而不同： CASH 资产为 \u0026lsquo;BID\u0026rsquo; 其他为 \u0026lsquo;TRADES\u0026rsquo; 如果希望其他值，请检查 IB API 文档。 rtbar（默认：False）\n如果为 True，将使用互动经纪商提供的 5 秒实时条作为最小刻度。根据文档，这些条形图对应于实时值（经过 IB 整理和处理后）。 如果为 False，则将使用 RTVolume 价格，这些价格基于接收的 tick。在 CASH 资产（如 EUR.JPY）的情况下，始终将使用 RTVolume，并从中提取买入价格（根据互联网上的文献，这已成为与 IB 的行业默认标准）。 即使设置为 True，如果数据重采样/保留到低于 Seconds/5 的时间框架/压缩，也不会使用实时条，因为 IB 不会在该级别以下提供它们。 qcheck（默认：0.5）\n在没有数据接收时唤醒的时间（秒），以便适当地重采样/重放数据包并将通知上传到链中。 backfill_start（默认：True）\n在启动时执行回填。将通过单个请求获取最大可能的历史数据。 backfill（默认：True）\n在断开/重新连接周期后执行回填。将使用间隙持续时间下载最小可能的数据量。 backfill_from（默认：None）\n可以传递另一个数据源以进行初始回填。一旦数据源耗尽，如果需要，将从 IB 回填。理想情况下，这意味着从已存储的来源（如磁盘上的文件）进行回填，但不限于此。 latethrough（默认：False）\n如果数据源被重采样/重放，一些 tick 可能太晚，无法用于已经交付的重采样/重放条。如果为 True，将允许这些 tick 通过。 请检查重采样器文档以了解如何考虑这些 tick。 特别是当 timeoffset 在 IBStore 实例中设置为 False 且 TWS 服务器时间与本地计算机不同步时，可能会发生这种情况。 tradename（默认：None）\n对于某些特定情况（如 CFD），有时价格由一个资产提供，交易在另一个资产中进行。 SPY-STK-SMART-USD -\u0026gt; SP500 ETF（将指定为 `dataname`） SPY-CFD-SMART-USD -\u0026gt; 对应的 CFD，不提供价格跟踪，但在这种情况下将是交易资产（指定为 `tradename`）。 参数中的默认值允许像 TICKER 这样的情况，参数 sectype（默认：STK）和 exchange（默认：SMART）适用。\n一些资产（如 AAPL）需要包括货币在内的完整规格（默认：\u0026rsquo;\u0026rsquo;），而其他资产（如 TWTR）可以直接传递。\nAAPL-STK-SMART-USD 将是 dataname 的完整规格。\n或者：IBData 作为 IBData(dataname='AAPL', currency='USD') 使用默认值（STK 和 SMART）并覆盖货币为 USD。\n"},{"id":5,"href":"/backtrader/docs/04-concepts/02-operate-the-platform/01-iteration/","title":"Line 迭代器","section":"平台操作","content":"Line 迭代器# Backtrader 引入了一个独特的概念，叫做 Line 迭代器（Line Iterator）。它的核心思想是，通过迭代数据来驱动策略和指标的运作。这一点和 Python 的普通迭代器在表面上看有些相似，但实际上它们是为金融数据处理量身定制的。\n在 Backtrader 中，策略 和 指标 都是基于 Line 迭代器构建的。下面，我们会逐步拆解这个概念，让它变得简单易懂。\n什么是 Line 迭代器？# Line 迭代器是一个控制 \u0026ldquo;数据处理节奏\u0026rdquo; 的工具，它的主要职责是：\n驱动数据流动：Line 迭代器像是一个“指挥者”，它会触发从属 Line 迭代器（如指标或策略）依次处理数据。 逐步更新数据：Line 迭代器按照声明的规则迭代数据，并在每一步设置对应的结果。 Line 迭代器如何工作？# 三大关键方法# prenext\n在数据不足以完成计算时被调用。 用于初始化阶段的数据处理，比如累计数据。 nextstart\n当累积到足够多的数据点，达到“最小周期”时被调用，仅触发一次。 默认会调用 next 方法。 next\n在每次迭代时调用，用于正式处理当前索引上的数据。 为什么需要这些方法？# 为了生成有效的计算结果，某些指标需要一个“缓冲期”。如 25 周期的简单移动平均线 (SMA) 需要累积 25 个数据点才能生成第一个值。在这之前，我们需要用 prenext 来处理空白期。\n一旦累积到足够的数据点，进入“正式运行”阶段后，next 方法会被不断调用，每次处理新到达的数据。\n示例：如何实现一个简单的 SMA# 以下是一个 SimpleMovingAverage（简单移动平均线）的实现示例：\nclass SimpleMovingAverage(Indicator): lines = (\u0026#39;sma\u0026#39;,) params = dict(period=25) def prenext(self): print(f\u0026#39;prenext:: 当前周期: {len(self)}\u0026#39;) def nextstart(self): print(f\u0026#39;nextstart:: 当前周期: {len(self)}\u0026#39;) self.next() # 模拟默认行为 def next(self): print(f\u0026#39;next:: 当前周期: {len(self)}\u0026#39;) 实例化 SMA 的过程# 假设我们为一个数据集创建一个 SimpleMovingAverage 指标：\nsma = btind.SimpleMovingAverage(self.data, period=25)SMA 的调用流程# prenext：\n前 24 次调用。 在指标数据不足 25 个点时，每次新数据到达时调用，用于累积数据。 nextstart：\n第 25 次调用。 数据点达到 25 时，开始生成第一个有效的 SMA 值。 next：\n从第 26 次开始，每次新数据到达时调用。 多层指标的交互# 当一个指标的输出作为另一个指标的输入时，会发生什么？比如下面的情况：\nsma1 = btind.SimpleMovingAverage(self.data, period=25) sma2 = btind.SimpleMovingAverage(sma1, period=20)调用流程# sma1 的最小周期是 25：\n需要 25 个数据点后才能生成第一个有效值。 在此之前，sma1 的 prenext 被调用 24 次。 sma2 的最小周期是 sma1 的 25 加上自己的 20：\nsma2 的 prenext 被调用 44 次。 第 45 次调用时，sma2 的 nextstart 被触发，并开始生成第一个有效值。 因此，sma2 的计算需要至少 45 个数据点才能开始正常工作。\n指标的性能优化：runonce 模式# 为了提高性能，Backtrader 提供了一个批量处理模式，叫做 runonce。它可以一次性处理多个数据点，而不是逐步调用 next 方法。\nrunonce 的核心方法# once(self, start, end)\n在最小周期达到时调用，批量处理 start 到 end 索引范围内的数据。 preonce(self, start, end)\n类似于 prenext，但在批量模式下调用。 oncestart(self, start, end)\n类似于 nextstart，但用于批量模式。 批量处理模式的优势是显著的，它可以减少不必要的函数调用，从而显著提高性能。\n最小周期的意义# 最小周期是 Line 迭代器中一个关键的控制点，决定了何时开始生成有意义的输出值。例如：\n对于一个 25 周期的 SMA，最小周期是 25。 当一个指标依赖另一个指标作为输入时，最小周期会累积。 在多层指标中，最小周期的自动调整可以确保所有数据都有意义。\nLine 迭代器的核心价值# 控制节奏：线迭代器通过 prenext、nextstart 和 next 方法灵活控制数据处理的节奏。 支持复杂数据流：它允许多个指标相互依赖，同时自动调整最小周期。 性能优化：通过 runonce 模式，指标的批量处理显著提升了效率。 简单来说，Line 迭代器是 Backtrader 中隐藏的强大工具，它的引入让平台能够高效地处理多层次的指标和策略。\n"},{"id":6,"href":"/backtrader/docs/16-plotting/01-plotting/","title":"Plotting","section":"绘图","content":"绘图# 尽管回测主要是基于数学计算的自动化过程，但人们常常希望能够实际可视化所发生的一切。不论是使用已经经过回测的现有算法，还是查看数据所产生的内置或自定义指标，绘图都能帮助人们更好地理解所发生的事情，剔除、修改或创建新的想法。\n由于所有操作背后都是人类，绘制数据馈送、指标、操作、现金流动和投资组合价值的演变图表有助于人们更好地理解过程，从而做出更明智的决策。因此，backtrader 使用 matplotlib 提供的功能，内置了绘图设施。\n如何绘图# 任何回测运行都可以通过调用一个方法进行绘图：\ncerebro.plot()当然，这通常是最后一个命令。例如，以下简单代码使用了 backtrader 源代码中的一个示例数据：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt class St(bt.Strategy): def __init__(self): self.sma = bt.indicators.SimpleMovingAverage(self.data) data = bt.feeds.BacktraderCSVData(dataname=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;) cerebro = bt.Cerebro() cerebro.adddata(data) cerebro.addstrategy(St) cerebro.run() cerebro.plot()这将生成以下图表：\n图表包含了 3 个观察器，由于缺乏任何交易，它们在这种情况下几乎没有意义：\nCashValue 观察器：跟踪回测运行期间的现金和总投资组合价值（包括现金）。 Trade 观察器：在交易结束时显示实际的利润和亏损。交易定义为开仓并将仓位归零（直接或从多头转为空头或从空头转为多头）。 BuySell 观察器：在价格图上绘制买入和卖出操作的位置。 这 3 个观察器由 cerebro 自动添加，可以通过 stdstats 参数控制（默认：True）。如果希望禁用它们，可以如下操作：\ncerebro = bt.Cerebro(stdstats=False)或在运行时：\ncerebro = bt.Cerebro() ... cerebro.run(stdstats=False)绘图元素# 尽管前面提到了观察器，它们并不是唯一被绘制的元素。以下 3 种元素会被绘制：\n使用 adddata、replaydata 和 resampledata 添加到 Cerebro 的数据馈送。 在策略级别声明的指标（或通过 addindicator 添加到 cerebro 的指标，这纯粹用于实验目的，并将指标添加到一个虚拟策略中）。 使用 addobserver 添加到 cerebro 的观察器。 观察器是与策略同步运行的线性对象，并且可以访问整个生态系统，以便跟踪现金和价值等内容。\n绘图选项# 指标和观察器有几个选项可以控制它们在图表上的绘制方式，分为 3 大类：\n影响整个对象绘图行为的选项。 影响单个线条绘图行为的选项。 影响系统级别绘图选项的选项。 对象级绘图选项# 这些选项由指标和观察器中的 plotinfo 数据集控制：\nplotinfo = dict( plot=True, subplot=True, plotname=\u0026#39;\u0026#39;, plotskip=False, plotabove=False, plotlinelabels=False, plotlinevalues=True, plotvaluetags=True, plotymargin=0.0, plotyhlines=[], plotyticks=[], plothlines=[], plotforce=False, plotmaster=None, plotylimited=True, )尽管 plotinfo 在类定义时显示为字典，但 backtrader 的元类机制将其转变为一个可以继承的对象，并且可以进行多重继承。例如：\n如果子类将 subplot=True 更改为 subplot=False，则层级结构中的进一步子类将具有后者作为 subplot 的默认值。\n有两种方法为这些参数赋值。让我们看一下 SimpleMovingAverage 实例化的第一种方法：\nsma = bt.indicators.SimpleMovingAverage(self.data, period=15, plotname=\u0026#39;mysma\u0026#39;)从示例中可以推断，SimpleMovingAverage 构造函数未消耗的任何 **kwargs 都将被解析（如果可能）为 plotinfo 值。SimpleMovingAverage 只有一个定义的参数，即 period。这意味着 plotname 将匹配 plotinfo 中同名的参数。\n第二种方法：\nsma = bt.indicators.SimpleMovingAverage(self.data, period=15) sma.plotinfo.plotname = \u0026#39;mysma\u0026#39;与 SimpleMovingAverage 一起实例化的 plotinfo 对象可以被访问，并且其中的参数也可以通过标准的 Python 点符号访问。与上面的语法相比，这种方法更容易理解。\n参数含义# plot：是否绘制该对象。 subplot：是否与数据一起绘制或在独立的子图中绘制。例如，移动平均线是绘制在数据上的，而随机指标和 RSI 则是在不同的刻度上绘制的。 plotname：在图表上使用的名称，而不是类名。例如上面的 mysma 而不是 SimpleMovingAverage。 plotskip（已弃用）：plot 的旧别名。 plotabove：是否在数据之上绘制，否则在数据下方绘制。这仅在 subplot=True 时有效。 plotlinelabels：是否在图表的图例中显示单个线条的名称，当 subplot=False 时。 plotlinevalues：控制图例中是否包含指标和观察器线条的最后绘制值。可以通过每条线的 _plotvalue 控制。 plotvaluetags：控制是否在线条的右侧绘制带有最后值的标签。可以通过每条线的 _plotvaluetag 控制。 plotymargin：在图表上单个子图顶部和底部添加的边距。它是一个以 1 为基数的百分比。例如：0.05 表示 5%。 plothlines：一个包含值的可迭代对象（在刻度内），在这些值处绘制水平线。例如，经典指标的超买、超卖区域通常在 70 和 30 处绘制线。 plotyticks：一个包含值的可迭代对象（在刻度内），在这些值处特意放置刻度值。例如，强制刻度有 50 以识别刻度的中点。 plotyhlines：一个包含值的可迭代对象（在刻度内），在这些值处绘制水平线。如果未定义上述任何项，那么水平线和刻度的位置将完全由此值控制。 plotforce：如果所有其他方法都失败，这是一个最后的强制绘图机制。 plotmaster：一个指标/观察器有一个主控，它是工作的数据。在某些情况下，可能希望与不同的主控一起绘图。 plotylimited：目前仅适用于数据馈送。如果为 True（默认），其他线条在数据图上的绘图不会改变刻度。 线条特定绘图选项# 指标/观察器有线条，如何绘制这些线条可以通过 plotlines 对象进行影响。大多数 plotlines 中的选项旨在直接传递给 matplotlib。文档主要通过示例进行说明。\n重要：选项是按每条线条指定的。\n一些选项由 backtrader 直接控制，这些选项都以 _ 开头：\n_plotskip（布尔值）：如果设置为 True，表示跳过绘制特定线条。 _plotvalue（布尔值）：控制此线条的图例是否包含最后绘制的值（默认值为 True）。 _plotvaluetag（布尔值）：控制是否在线条右侧绘制带有最后值的标签（默认值为 True）。 _name（字符串）：更改特定线条的绘图名称。 _skipnan（布尔值，默认：False）：跳过绘制 NaN 值。 _samecolor（布尔值）：强制下一条线条使用与前一条相同的颜色，避免 matplotlib 为每个新绘制的元素循环颜色图。 _method（字符串）：选择 matplotlib 用于绘制元素的方法。 示例：\nMACDHisto 使用 `_ method=\u0026lsquo;bar\u0026rsquo;` 绘制直方图。\nBuySell 观察器： plotlines = dict( buy=dict(marker=\u0026#39;^\u0026#39;, markersize=8.0, color=\u0026#39;lime\u0026#39;, fillstyle=\u0026#39;full\u0026#39;), sell=dict(marker=\u0026#39;v\u0026#39;, markersize=8.0, color=\u0026#39;red\u0026#39;, fillstyle=\u0026#39;full\u0026#39;) ) Trades 观察器： lines = (\u0026#39;pnlplus\u0026#39;, \u0026#39;pnlminus\u0026#39;) plotlines = dict( pnlplus=dict(_name=\u0026#39;Positive\u0026#39;, marker=\u0026#39;o\u0026#39;, color=\u0026#39;blue\u0026#39;, markersize=8.0, fillstyle=\u0026#39;full\u0026#39;), pnlminus=dict(_name=\u0026#39;Negative\u0026#39;, marker=\u0026#39;o\u0026#39;, color=\u0026#39;red\u0026#39;, markersize=8.0, fillstyle=\u0026#39;full\u0026#39;) )系统级绘图选项# cerebro 的 plot 方法签名：\ndef plot(self, plotter=None, numfigs=1, iplot=True, **kwargs): plotter：一个包含控制系统级绘图选项的对象/类。如果为 None，则创建默认 PlotScheme 对象。 numfigs：将图表分解为多少个独立的图表。 iplot：如果在 Jupyter Notebook 中运行，自动内联绘图。 kwargs：将用于更改 plotter 或默认 PlotScheme 对象的属性值。 PlotScheme# 包含控制系统级绘图的所有选项的对象。选项在代码中有文档说明。\n颜色# PlotScheme 类定义了一个方法，可以在子类中重写，该方法返回要使用的下一个颜色：\ndef color(self, idx)其中 idx 是当前线条的索引。默认颜色方案是 Tableau 10 颜色调色板，索引修改为：\ntab10_index = [3, 0, 2, 1, 2, 4, 5, 6, 7, 8, 9]"},{"id":7,"href":"/backtrader/docs/14-sizers/01-sizers/","title":"sizers","section":"Sizer","content":"Sizers# 策略提供交易方法，即：buy、sell 和 close。让我们看看 buy 的签名：\ndef buy(self, data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, **kwargs):注意，如果调用者没有指定 size，则 size 的默认值为 None。这就是 Sizers 发挥重要作用的地方：\nsize=None 请求策略向其 Sizer 询问实际的头寸大小 这显然意味着策略有一个 Sizer：是的，确实如此！如果用户没有添加 Sizer，后台机制会为策略添加一个默认的 Sizer。添加到策略中的默认 Sizer 是 SizerFix。定义的初始行：\nclass SizerFix(SizerBase): params = ((\u0026#39;stake\u0026#39;, 1),)很容易猜到这个 Sizer 只是使用 1 个单位（无论是股票、合约等）买卖。\n使用 Sizers# 从 Cerebro# Sizers 可以通过 Cerebro 以两种不同的方法添加：\naddsizer(sizercls, *args, **kwargs)：添加一个 Sizer，将应用于添加到 cerebro 的任何策略。这就是所谓的默认 Sizer。例如： cerebro = bt.Cerebro() cerebro.addsizer(bt.sizers.SizerFix, stake=20) # 默认策略的 Sizer addsizer_byidx(idx, sizercls, *args, **kwargs)：只将 Sizer 添加到 idx 引用的策略中。 这个 idx 可以作为 addstrategy 的返回值获得。例如：\ncerebro = bt.Cerebro() cerebro.addsizer(bt.sizers.SizerFix, stake=20) # 默认策略的 Sizer idx = cerebro.addstrategy(MyStrategy, myparam=myvalue) cerebro.addsizer_byidx(idx, bt.sizers.SizerFix, stake=5) cerebro.addstrategy(MyOtherStrategy)在这个例子中：\n系统添加了一个默认的 Sizer。这适用于所有没有分配特定 Sizer 的策略。 对于 MyStrategy，在收集其插入 idx 后，添加了一个特定的 Sizer（更改 stake 参数）。 系统添加了第二个策略 MyOtherStrategy。没有为其添加特定的 Sizer。 这意味着：\nMyStrategy 最终会有一个内部特定的 Sizer。 MyOtherStrategy 将获得默认的 Sizer。 注意：默认并不意味着策略共享单个 Sizer 实例。每个策略都接收不同的默认 Sizer 实例。要共享单个实例，共享的 Sizer 应该是一个单例类。如何定义一个超出了 backtrader 的范围。\n从策略# Strategy 类提供了一个 API：setsizer 和 getsizer（以及一个属性 sizer）来管理 Sizer。签名：\ndef setsizer(self, sizer): 它接受一个已经实例化的 Sizer def getsizer(self): 返回当前的 Sizer 实例，sizer 是可以直接获取/设置的属性\n在这种情况下，Sizer 可以例如：\n作为参数传递给策略 在 __init__ 中使用属性 sizer 或 setsizer 设置，例如： class MyStrategy(bt.Strategy): params = ((\u0026#39;sizer\u0026#39;, None),) def __init__(self): if self.p.sizer is not None: self.sizer = self.p.sizer这将允许在与 cerebro 调用相同级别创建一个 Sizer，并将其作为参数传递给系统中的所有策略，从而有效地共享一个 Sizer。\nSizer 开发# 开发一个 Sizer 很容易：\n从 backtrader.Sizer 子类化。 这使您可以访问 self.strategy 和 self.broker，尽管在大多数情况下不需要。可以通过经纪人访问的内容：\n数据的头寸，通过 self.strategy.getposition(data) 完整的投资组合价值，通过 self.broker.getvalue() 注意，这当然也可以通过 self.strategy.broker.getvalue() 来完成。\n重写方法 _getsizing(self, comminfo, cash, data, isbuy)。 参数：\ncomminfo：包含数据佣金信息的 CommissionInfo 实例，并允许计算头寸价值、操作成本和操作佣金。 cash：经纪人的当前可用现金。 data：操作的目标。 isbuy：对于买入操作为 True，对于卖出操作为 False。 此方法返回买入/卖出操作的期望大小。\n返回的符号无关紧要，例如：如果操作是卖出操作（isbuy 为 False），方法可以返回 5 或 -5。卖出操作只会使用绝对值。\nSizer 已经去经纪人那里请求了给定数据的佣金信息、实际现金水平，并提供了操作目标数据的直接引用。\n让我们定义 FixedSize Sizer：\nimport backtrader as bt class FixedSize(bt.Sizer): params = ((\u0026#39;stake\u0026#39;, 1),) def _getsizing(self, comminfo, cash, data, isbuy): return self.params.stake这非常简单，因为 Sizer 不进行计算，参数只是存在。\n但是该机制应该允许构建复杂的头寸系统来管理进入/退出市场时的头寸。\n另一个例子：一个头寸反转器：\nclass FixedReverser(bt.FixedSize): def _getsizing(self, comminfo, cash, data, isbuy): position = self.broker.getposition(data) size = self.p.stake * (1 + (position.size != 0)) return size这个 Sizer 继承了 FixedSize，覆盖了 _getsizing：\n通过 broker 属性获取数据的头寸。 使用 position.size 决定是否加倍固定头寸。 返回计算的值。 这将解除策略决定是否反转头寸或开仓的负担，Sizer 负责控制，可以随时替换而不影响逻辑。\n实用 Sizer 应用# 不考虑复杂的头寸算法，可以使用两种不同的 Sizers 将策略从仅做多转换为多空策略。只需在 cerebro 执行中更改 Sizer，策略的行为将发生变化。一个非常简单的收盘价交叉 SMA 算法：\nclass CloseSMA(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 15),) def __init__(self): sma = bt.indicators.SMA(self.data, period=self.p.period) self.crossover = bt.indicators.CrossOver(self.data, sma) def next(self): if self.crossover \u0026gt; 0: self.buy() elif self.crossover \u0026lt; 0: self.sell()注意策略并没有考虑当前头寸（通过查看 self.position）来决定是否实际执行买入或卖出操作。只有交叉信号被考虑。Sizer 将负责所有事务。\n这个 Sizer 仅在卖出时返回非零头寸大小（如果已有头寸）：\nclass LongOnly(bt.Sizer): params = ((\u0026#39;stake\u0026#39;, 1),) def _getsizing(self, comminfo, cash, data, isbuy): if isbuy: return self.p.stake # 卖出情况 position = self.broker.getposition(data) if not position.size: return 0 # 如果没有持仓则不卖出 return self.p.stake将所有内容放在一起（假设已经导入 backtrader 并向系统添加了数据）：\ncerebro.addstrategy(CloseSMA) cerebro.addsizer(LongOnly) cerebro.run()图表（来自源代码中的示例以测试这一点）。\n多空版本只需将 Sizer 更改为上面显示的 FixedReverser：\ncerebro.addstrategy(CloseSMA) cerebro.addsizer(FixedReverser) cerebro.run()输出图表。\n注意差异：\n交易次数翻倍。 现金水平从未恢复到初始值，因为策略始终在市场中。 两种方法都负面，但这只是一个示例。\nbt.Sizer 参考# class backtrader.Sizer()这是 Sizers 的基类。任何 Sizer 都应继承此类并覆盖 _getsizing 方法。\n成员属性：\nstrategy：由 Sizer 所在的策略设置。可以访问策略的整个 API，例如如果需要获取实际数据头寸： position = self.strategy.getposition(data) broker：由 Sizer 所在的策略设置。可以访问一些 复杂 Sizers 可能需要的信息，例如投资组合价值等。\ndef _getsizing(comminfo, cash, data, isbuy)此方法必须由 Sizer 的子类覆盖以提供大小功能。\n参数：\ncomminfo：包含数据佣金信息的 CommissionInfo 实例，并允许计算头寸价值、操作成本和操作佣金。 cash：经纪人的当前可用现金。 data：操作的目标。 isbuy：对于买入操作为 True，对于卖出操作为 False。 此方法必须返回要执行的实际大小（一个整数）。如果返回 0，则不会执行任何操作。\n返回值的绝对值将被使用。\n"},{"id":8,"href":"/backtrader/docs/07-strategy/01-strategy/","title":"Strategy","section":"Strategy","content":"Strategy# 在 backtrader 中，Cerebro 实例是整个系统的核心，而 Strategy 是用户的核心。\nStrategy 的生命周期方法# 注意, 策略可以在创建时通过抛出 StrategySkipError 异常来中断，该异常来自 backtrader.errors 模块。这将避免在回测期间处理该策略。请参阅“异常”部分。\n构建：__init__# 这是在实例化期间调用的：指标将在此处创建以及其他需要的属性。\n示例代码：\ndef __init__(self): self.sma = btind.SimpleMovingAverage(period=15)启动：start# Cerebro 实例通知策略是时候开始运行了。存在一个默认的空方法。\n初期：prenext# 在创建期间声明的指标将对策略的成熟期施加限制：这称为最小周期。上面的 __init__ 创建了一个周期为 15 的简单移动平均线 (SMA)。\n只要系统看到的 bar 少于 15 个，就会调用 prenext（默认实现为空操作）。\n成熟：next# 一旦系统看到 15 个 bar 并且 SMA 有足够的缓冲区开始生成值，策略就足够成熟可以真正执行。\n存在一个 nextstart 方法，会在从 prenext 切换到 next 时调用一次。nextstart 的默认实现是简单地调用 next。\n繁衍：无# 策略实际上不会繁衍，但从某种意义上来说，它们会，因为系统会在优化时实例化它们多次（使用不同的参数）。\n结束：stop# 系统通知策略是时候重置并整理一切了。存在一个默认的空方法。\n通常情况下和常规使用模式下，这看起来像这样：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma = btind.SimpleMovingAverage(period=15) def next(self): if self.sma \u0026gt; self.data.close: # 执行某些操作 pass elif self.sma \u0026lt; self.data.close: # 执行其他操作 pass在这个代码片段中：\n在 __init__ 中分配一个指标给属性 默认的空 start 方法未被重写 prenext 和 nextstart 未被重写 在 next 中，指标的值与收盘价进行比较，以执行某些操作 默认的空 stop 方法未被重写 策略事件通知# 策略将每个 next 周期收到通知：\nnotify_order# 通过 notify_order(order) 接收任何订单状态的变化通知。\nnotify_trade# 通过 notify_trade(trade) 接收任何交易的开启/更新/关闭通知\nnotify_cashvalue# 通过 notify_cashvalue(cash, value) 接收经纪账户中的当前现金和投资组合\nnotify_fund# 通过 notify_fund(cash, value, fundvalue, shares) 接收经纪账户中的当前现金、投资组合、基金价值和份额\nnotify_store# 通过 notify_store(msg, *args, **kwargs) 接收来自存储提供者的通知\n如何买入/卖出/平仓# buy 和 sell 方法生成订单。调用这些方法时，它们返回一个 Order（或其子类）实例，该实例可用作引用。此订单具有唯一的 ref 标识符，可用于比较。\n注意，特定经纪实现的 Order 子类可能携带经纪提供的其他唯一标识符。\n要创建订单，请使用以下参数：\n参数名 默认值 描述 data None 创建订单的数据。如果为 None，则使用系统中的第一个数据 self.datas[0] 或 self.data0（即 self.data）。 size None 要使用的订单数量（正值）。如果为 None，则使用通过 getsizer 检索到的 sizer 实例来确定大小。 price None） 使用的价格（实时经纪可能对格式有最低价格步长要求）。对于市场和收盘订单（Market 和 Close orders）为 None（市场决定价格）。对于限价、止损和止损限价订单，这个值决定触发点。 plimit None 仅适用于止损限价订单。这是在触发止损后设置隐含限价订单的价格（使用 price）。 exectype None 可能的值：- Order.Market 或 None：市场订单将以下一个可用价格执行。在回测中，将是下一个 bar 的开盘价。- Order.Limit：订单只能以给定价格或更好价格执行。- Order.Stop：订单在 price 触发时被触发，并像 Order.Market 订单一样执行。- Order.StopLimit：订单在 price 触发时被触发，并作为隐含的限价订单执行，限价由 pricelimit 给出。 valid None 可能的值：- None：生成一个不会过期的订单（即 Good til cancel），并保留在市场上直到匹配或取消。实际上，经纪通常会施加一个时间限制，但通常远远在未来，可以认为它不会过期。- datetime.datetime 或 datetime.date 实例：日期将用于生成有效期至给定日期的订单（即 good til date）。- Order.DAY 或 0 或 timedelta()：生成一个有效期至交易日结束的订单（即日订单）。- 数值：假定为 matplotlib 编码的 datetime 值（backtrader 使用的），将用于生成有效期至该时间的订单（即 good til date）。 tradeid 0 backtrader 用于跟踪同一资产上重叠交易的内部值。当通知订单状态变化时，此 tradeid 会发送回策略。 示例：如果 backtrader 直接支持的 4 种订单执行类型不够，可以为 Interactive Brokers 传递以下参数：\norderType=\u0026#39;LIT\u0026#39;, lmtPrice=10.0, auxPrice=9.8这将覆盖 backtrader 创建的设置，并生成一个 LIMIT IF TOUCHED 订单，触及价格为 9.8，限价为 10.0。\n策略信息：# 属性名 描述 env 策略所属的 cerebro 实体 datas 传递给 cerebro 的数据源数组 data/data0 datas[0] 的别名 dataX datas[X] 的别名 dnames 按名称访问数据源的替代方法（通过 [name] 或 .name 语法） broker 与此策略关联的经纪（从 cerebro 接收） stats 包含 cerebro 为此策略创建的观察者的列表/命名元组序列 analyzers 包含 cerebro 为此策略创建的分析器的列表/命名元组序列 position 获取 data0 的当前仓位的属性 成员属性（用于统计/观察者/分析器）：# 属性名 描述 _orderspending 将在调用 next 之前通知策略的订单列表 _tradespending 将在调用 next 之前通知策略的交易列表 _orders 已经通知的订单列表。订单可以在列表中多次出现，具有不同的状态和执行部分。列表旨在保留历史记录。 _trades： 已经通知的交易列表。交易可以像订单一样多次出现在列表中。 注意： prenext、nextstart 和 next 可以针对同一时间点多次调用（例如，当使用每日时间框架时，价格更新每日 bar 的 ticks）。\n策略参考# class backtrader.Strategy(*args, **kwargs)\n基类，用于子类化用户定义的策略。\n方法# 方法名 描述 next() 当所有数据/指标的最小周期满足时，将为所有剩余数据点调用此方法。 nextstart() 当所有数据/指标的最小周期满足时，将调用一次此方法。默认行为是调用 next。 prenext() 在满足所有数据/指标的最小周期之前调用此方法。 start() 在回测即将开始之前调用。 stop() 在回测即将结束之前调用。 notify_order(order) 当订单状态变化时接收通知。 notify_trade(trade) 当交易状态变化时接收通知。 notify_cashvalue(cash, value) 接收策略经纪账户的当前资金和投资组合状态。 notify_fund(cash, value, fundvalue, shares) 接收当前现金、投资组合、基金价值和份额。 notify_store(msg, *args, **kwargs) 接收存储提供者的通知。 订单方法# 方法名 描述 buy(...) 创建买入订单并发送给经纪。 sell(...) 创建卖出（空头）订单并发送给经纪。 close(...)： 关闭现有仓位。 cancel(order) 取消经纪中的订单。 其他方法# 方法名 描述 buy_bracket(...) 创建括号订单组（低侧 - 买入订单 - 高侧）。 sell_bracket(...) 创建括号订单组（低侧 - 卖出订单 - 高侧）。 order_target_size(...) 下订单将仓位重新平衡为目标大小。 order_target_value(...) 下订单将仓位重新平衡为目标价值。 order_target_percent(...) 下订单将仓位重新平衡为当前投资组合价值的目标百分比。 getsizer() 返回用于自动计算头寸的 sizer。 setsizer(sizer) 替换默认的 sizer。 getsizing(data=None, isbuy=True) 返回 sizer 实例为当前情况计算的头寸。 getpositionbyname(name=None, broker=None) 按名称返回给定经纪的当前仓位。 getposition(data=None, broker=None) 返回给定数据和经纪的当前仓位。 getpositionsbyname(broker=None) 直接从经纪获取按名称的所有仓位。 getdatanames() 返回现有数据名称的列表。 getdatabyname(name) 使用环境（cerebro）按名称返回给定数据。 add_timer(...) 计划一个计时器以调用指定的回调或策略的 notify_timer。 notify_timer(timer, when, *args, **kwargs) 接收计时器通知，其中 timer 是由 add_timer 返回的计时器，when 是调用时间。args 和 kwargs 是传递给 add_timer 的额外参数。 "},{"id":9,"href":"/backtrader/docs/01-introduction/","title":"介绍","section":"介绍","content":"什么是 Backtrader？# Backtrader 是一个基于 Python 实现功能强大且开源的量化回测交易框架，相对于其他专门用于策略回测的框架，Backtrader 不仅仅是可以回测交易策略，还可以连接 Broker 实盘交易。\nBacktrader 有着完整的基础设施，支持编写可重用组件，如策略、指标和分析器，支持多品种多周期多策略的回测。\n有哪些特性呢？# 稍微展开说说 Backtrader 的特性吧。\n丰富的技术指标\nBacktrader 提供超过 122 种内置指标，包括多种移动平均线（SMA、EMA 等）和经典指标（MACD、随机指标、RSI 等）。\n如果内置指标不能满足需求，Backtrader 还集成了其他技术指标库，如 ta-lib 库。而且，我们也可以自定义技术指标，Backtrader 也提供了自定义指标的能力。\n支持多种数据源\nBacktrader 支持多种数据源类型，如常见的一些数据源：\nCSV 数据文件； Pandas 数据源，可以借助 Pandas 的强大功能连接各种不同的数据源； YahooFinance，这个好像已经不能用了，不过借助 yfinance 包和 pandas 可轻易集成； 其他的一些公开数据源。 除此以外，Backtrader 支持自定义数据格式，如希望实现股票选择策略，可自定义数据格式，加入财务数据和因子，如 PE、PB、ROI 等指标。\nBacktrader 支持同时添加多个 DataFeed 数据源，如多个时间框架数据源实现多周期策略，多标的数据源实现组合交易策略，或是直接进行数据的重采样和重放功能，实现真实交易环境的模拟。\n灵活的策略实现\nBacktrader 支持灵活的策略开发，如在策略初始化阶段，Backtrader 支持预热计算，预热完成才进入交易逻辑部分。\nBacktrader 支持并行运行多个策略，实现多策略组合。其内置的 Broker 支持多种订单类型，如市价单、限价单、止损单等，支持多空交易，自定义佣金方案和信用利息，提供针对期货类工具的连续现金调整，支持基金模式和自定义滑点策略。\n它还提供多种订单生成方法，并支持事件通知机制，包括新数据、订单、交易和计时器等等。\n性能分析与绘图\nBacktrader 内置多个性能分析器，包括时间收益、交易分析器、夏普比率、VWR 和 SQN 等，帮助用户全面评估策略表现。Backtrader 支持通过一个命令既可绘图（安装 Matplotlib），用户可以自定义图表样式，直观地评估策略表现。\n架构设计# Backtrader 本身是一个模块拆分的非常优秀的框架，解耦复用方面做的非常优秀。\n如下所示的一系列组件：\nDataFeed：负责加载行情数据，包括历史数据和实时数据，是策略运行的基础输入。 Cerebro：Backtrader 的核心引擎，用于统一管理数据、策略、分析器、经纪商等组件，并负责执行回测或实盘。 Indicator：用于计算常见的技术指标（如均线、RSI、布林带等），也可以自定义指标逻辑，为策略提供信号依据。 Strategy：定义具体的交易规则和执行逻辑，包括开仓、平仓、止损止盈等，是系统的决策核心。 Broker：模拟或连接真实交易账户，负责订单撮合、资金管理和手续费处理。 Analyzer：对策略的回测结果进行统计与评估，如收益率、最大回撤、夏普比率等。 Observer：用于跟踪策略运行过程并输出可视化结果，如资金曲线、买卖点、回撤变化等。 如下是各个组件之间的关系架构图：\nBacktrader 的核心 Cerebro 调度整个回测流程。\n首先，由 DataFeed 提供行情数据，Cerebro 将数据传递给 Strategy。策略读取数据并调用 Indicator 计算技术信号，据此生成买卖决策并交由 Broker 执行交易。交易完成后，Broker 更新账户与持仓，并将结果反馈给 Cerebro。\n随后，Analyzer 分析策略绩效（如收益、回撤），Observer 记录并可视化资金曲线与交易点。Cerebro 不断循环此流程，直到数据结束，最终汇总输出策略表现。\n整个系统形成从“数据→决策→执行→反馈→分析”的闭环结构。\n实盘交易# Backtrader 的交易逻辑和经纪商 Broker 的操作是逐事件驱动，这让其可非常容易实现实盘交易。\n我们在回测时，指标计算尽可能通过向量化计算，预加载源数据提升计算速度。而实盘模式下，可在仅事件模式下运行，无需预加载数据。\nBacktrader 支持与多种 Broker 经纪商实时交易，包括 Interactive Brokers、Oanda v1 和 VisualChart。此外，还支持第三方经纪商如 Alpaca、Oanda v2 和 ccxt 的集成。其中，ccxt 是加密货币实盘交易的 Python 库。\n加密货币的程序交易账号相对更加容易获取，后续或许我会用 ccxt 演示 backtrader 的实盘交易加密货币。\n"},{"id":10,"href":"/backtrader/docs/11-commission-schemes/01-commission-schemes/","title":"佣金","section":"Commission","content":"佣金# 中立性# 在开始之前，让我们记住 backtrader 尝试保持数据代表内容的中立性。不同的佣金方案可以应用于相同的数据集。让我们看看如何做到这一点。\n经纪商快捷方式# 这使得最终用户远离 CommissionInfo 对象，因为可以通过一次函数调用创建/设置佣金方案。在常规的 cerebro 创建/设置过程中，只需在经纪商成员属性上添加一个调用 setcommission 的调用即可。\n以下调用设置了使用 Interactive Brokers 操作 Eurostoxx50 期货的常规佣金方案：\ncerebro.broker.setcommission(commission=2.0, margin=2000.0, mult=10.0)由于大多数用户通常只测试单一工具，这已经足够。\n如果你为你的数据馈送命名，因为在图表上同时考虑了多个工具，这个调用可以稍微扩展如下：\ncerebro.broker.setcommission(commission=2.0, margin=2000.0, mult=10.0, name=\u0026#39;Eurostoxxx50\u0026#39;)在这种情况下，此即时佣金方案将仅应用于名称匹配 Eurostoxx50 的工具。\nsetcommission 参数的含义# commission（默认值：0.0）\n每次操作的货币单位，绝对值或百分比。在上述示例中，每份合约的买入和卖出费用分别为 2.0 欧元。 重要的是何时使用绝对值或百分比值。\n如果 margin 为 False（例如，它是 False、0 或 None），则将视为佣金表示为价格乘以操作数量的百分比。\n如果 margin 是其他值，则视为操作发生在类似期货的工具上，佣金是每张合约的固定价格。\nmargin（默认值：None）\n操作期货类工具时需要的保证金。如上所述：\n如果没有设置 margin，则佣金将被视为百分比，并应用于买卖操作的价格 * 数量。\n如果设置了 margin，则佣金将被视为固定值，并乘以买卖操作的数量。\nmult（默认值：1.0）\n对于期货类工具，这决定了应用于损益计算的乘数。这使得期货同时具有吸引力和风险。\nname（默认值：None）\n将佣金方案应用于名称匹配的工具。可以在创建数据馈送时设置此值。如果未设置，则方案将适用于系统中的任何数据。\n两个示例：股票 vs 期货# 期货的示例：\ncerebro.broker.setcommission(commission=2.0, margin=2000.0, mult=10.0)股票的示例：\ncerebro.broker.setcommission(commission=0.005) # 交易金额的 0.5%注意\n第二种语法不设置 margin 和 mult，backtrader 试图通过将佣金视为百分比来进行智能处理。\n要完全指定佣金方案，需要创建 CommissionInfo 的子类。\n创建永久性佣金方案# 可以通过直接使用 CommissionInfo 类创建更永久的佣金方案。用户可以选择在某处定义：\nimport backtrader as bt commEurostoxx50 = bt.CommissionInfo(commission=2.0, margin=2000.0, mult=10.0)然后在另一个 Python 模块中应用：\nfrom mycomm import commEurostoxx50 ... cerebro.broker.addcommissioninfo(commEuroStoxx50, name=\u0026#39;Eurostoxxx50\u0026#39;)CommissionInfo 是一个对象，使用与 backtrader 环境中的其他对象类似的 params 声明。因此上述内容也可以表示为：\nimport backtrader as bt class CommEurostoxx50(bt.CommissionInfo): params = dict(commission=2.0, margin=2000.0, mult=10.0)然后：\nfrom mycomm import CommEurostoxx50 ... cerebro.broker.addcommissioninfo(CommEuroStoxx50(), name=\u0026#39;Eurostoxxx50\u0026#39;)使用 SMA 交叉的实际比较# 使用简单移动平均交叉作为进出信号，使用相同的数据集来测试期货类佣金方案和股票类佣金方案。\n注意\n期货头寸不仅可以给出进出行为，还可以在每次机会时进行反转行为。但这个示例是关于比较佣金方案的。\n代码（见底部完整策略）相同，可以在定义策略之前选择方案。\nfutures_like = True if futures_like: commission, margin, mult = 2.0, 2000.0, 10.0 else: commission, margin, mult = 0.005, None, 1只需将 futures_like 设置为 false 即可使用股票类方案运行。\n一些日志代码已被添加以评估不同佣金方案的影响。让我们集中在前两个操作。\n对于期货：\n2006-03-09, BUY CREATE, 3757.59 2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 2000.00, Comm 2.00 2006-04-11, SELL CREATE, 3788.81 2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 2000.00, Comm 2.00 2006-04-12, OPERATION PROFIT, GROSS 328.00, NET 324.00 2006-04-20, BUY CREATE, 3860.00 2006-04-21, BUY EXECUTED, Price: 3863.57, Cost: 2000.00, Comm 2.00 2006-04-28, SELL CREATE, 3839.90 2006-05-02, SELL EXECUTED, Price: 3839.24, Cost: 2000.00, Comm 2.00 2006-05-02, OPERATION PROFIT, GROSS -243.30, NET -247.30对于股票：\n2006-03-09, BUY CREATE, 3757.59 2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 3754.13, Comm 18.77 2006-04-11, SELL CREATE, 3788.81 2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 3786.93, Comm 18.93 2006-04-12, OPERATION PROFIT, GROSS 32.80, NET -4.91 2006-04-20, BUY CREATE, 3860.00 2006-04-21, BUY EXECUTED, Price: 3863.57, Cost: 3863.57, Comm 19.32 2006-04-28, SELL CREATE, 3839.90 2006-05-02, SELL EXECUTED, Price: 3839.24, Cost: 3839.24, Comm 19.20 2006-05-02, OPERATION PROFIT, GROSS -24.33, NET -62.84第一个操作的价格如下：\n买入（执行）：3754.13 卖出（执行）：3786.93 期货的损益（含佣金）：324.0\n股票的损益（含佣金）：-4.91\n佣金完全吞噬了股票操作的利润，而期货操作的利润只受到轻微影响。\n第二个操作：\n买入（执行）：3863.57 卖出（执行）：3389.24 期货的损益（含佣金）：-247.30\n股票的损益（含佣金）：-62.84\n对于此负操作，期货的影响明显更大。\n但：\n期货累计净利润和损失：324.00 + (-247.30) = 76.70\n股票累计净利润和损失：(-4.91) + (-62.84) = -67.75\n在下图中可以看到累计效果，还可以看到在全年结束时，期货产生了更大的利润，但也遭受了更大的回撤（更深的水下）\n但重要的是：无论是期货还是股票……都可以进行回测。\n代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind futures_like = True if futures_like: commission, margin, mult = 2.0, 2000.0, 10.0 else: commission, margin, mult = 0. 005, None, 1 class SMACrossOver(bt.Strategy): def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39; Logging function for this strategy\u0026#39;\u0026#39;\u0026#39; dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def notify(self, order): if order.status in [order.Submitted, order.Accepted]: # Buy/Sell order submitted/accepted to/by broker - Nothing to do return # Check if an order has been completed # Attention: broker could reject order if not enough cash if order.status in [order.Completed, order.Canceled, order.Margin]: if order.isbuy(): self.log( \u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm self.opsize = order.executed.size else: # Sell self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) gross_pnl = (order.executed.price - self.buyprice) * \\ self.opsize if margin: gross_pnl *= mult net_pnl = gross_pnl - self.buycomm - order.executed.comm self.log(\u0026#39;OPERATION PROFIT, GROSS %.2f, NET %.2f\u0026#39; % (gross_pnl, net_pnl)) def __init__(self): sma = btind.SMA(self.data) # \u0026gt; 0 crossing up / \u0026lt; 0 crossing down self.buysell_sig = btind.CrossOver(self.data, sma) def next(self): if self.buysell_sig \u0026gt; 0: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.data.close[0]) self.buy() # keep order ref to avoid 2nd orders elif self.position and self.buysell_sig \u0026lt; 0: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.data.close[0]) self.sell() if __name__ == \u0026#39;__main__\u0026#39;: # Create a cerebro entity cerebro = bt.Cerebro() # Add a strategy cerebro.addstrategy(SMACrossOver) # Create a Data Feed datapath = (\u0026#39;../../datas/2006-day-001.txt\u0026#39;) data = bt.feeds.BacktraderCSVData(dataname=datapath) # Add the Data Feed to Cerebro cerebro.adddata(data) # set commission scheme -- CHANGE HERE TO PLAY cerebro.broker.setcommission( commission=commission, margin=margin, mult=mult) # Run over everything cerebro.run() # Plot the result cerebro.plot()参考# class backtrader.CommInfoBase()基础类用于佣金方案。\n参数：\ncommission（默认值：0.0）：基础佣金值，百分比或货币单位 mult（默认值：1.0）：应用于资产价值/利润的乘数 margin（默认值：None）：开/持仓所需的货币单位，仅当类中的 _stocklike 属性设置为 False 时适用 automargin（默认值：False）：用于方法 get_margin，自动计算所需的保证金/保证金 commtype（默认值：None）：支持的值为 CommInfoBase.COMM_PERC（佣金理解为 %）和 CommInfoBase.COMM_FIXED（佣金理解为货币单位） 默认值 None 是一个支持的值，用于保留与旧的 CommissionInfo 对象的兼容性。如果 commtype 设置为 None，则以下适用：\nmargin 为 None：内部 _commtype 设置为 COMM_PERC，_stocklike 设置为 True（按百分比操作股票）\nmargin 不是 None：_commtype 设置为 COMM_FIXED，_stocklike 设置为 False（按固定回合佣金操作期货）\n如果此参数设置为其他值，则将传递给内部 _commtype 属性，并且相同将适用于参数 stocklike 和内部属性 _stocklike\nstocklike（默认值：False）： 指示工具是类似股票还是类似期货（请参阅上述 commtype 讨论）\npercabs（默认值：False）： 当 commtype 设置为 COMM_PERC 时，参数 commission 是否理解为 XX% 或 0.XX\n如果此参数为 True：0.XX\n如果此参数为 False：XX%\ninterest（默认值：0.0）：如果这是非零值，则这是持有空头头寸的年利率。这主要是指股票空头卖空\n公式：天数 * 价格 * 绝对值（大小）*（利息 / 365）\n必须以绝对值表示：0.05 -\u0026gt; 5%\n注意，可以通过覆盖方法 _get_credit_interest 更改行为\ninterest_long（默认值：False）：某些产品如 ETF 对空头和多头头寸收取利息。如果为 True 并且 interest 为非零，则对两个方向都收取利息\nleverage（默认值：1.0）：与所需现金相比的杠杆比例\nCommissionInfo 类# 基础类用于实际佣金方案。CommInfoBase 是为了保持对 backtrader 提供的原始不完整支持。新的佣金方案从此类派生。默认的 percabs 值也更改为 True .\n参数：\npercabs（默认值：True）：当 commtype 设置为 COMM_PERC 时，参数 commission 是否理解为 XX% 或 0.XX\n如果此参数为 True：0.XX\n如果此参数为 False：XX%\n返回此佣金方案允许的杠杆水平\nget_leverage()返回在给定价格下满足现金操作所需的大小\ngetsize(price, cash)返回操作所需的现金量\ngetoperationcost(size, price)返回给定价格的大小值。对于类似期货的对象，固定为大小 * 保证金\ngetvaluesize(size, price)返回给定价格的头寸价值。对于类似期货的对象，固定为大小 * 保证金\ngetvalue(position, price)返回在给定价格下单个资产所需的实际保证金/保证金。默认实现有以下策略：\n使用参数 margin 如果参数 automargin 评估为 False\n使用参数 mult，即 mult * price 如果 automargin \u0026lt; 0\n使用参数 automargin，即 automargin * price 如果 automargin \u0026gt; 0\nget_margin(price)计算在给定价格下的操作佣金\ngetcommission(size, price)计算在给定价格下的操作佣金\npseudoexec：如果为 True，则操作尚未执行\n_getcommission(size, price, pseudoexec)返回头寸的实际损益\nprofitandloss(size, price, newprice)计算价格差异的现金调整\ncashadjust(size, price, newprice)计算股票卖空或特定产品的信用费用\nget_credit_interest(data, pos, dt)此方法返回由经纪商收取的信用利息费用。\n在 size \u0026gt; 0 的情况下，仅当类的参数 interest_long 为 True 时才调用此方法\n计算信用利率的公式是：公式：天数 * 价格 * 绝对值（大小）*（利息 / 365）\n_get_credit_interest(data, size, price, days, dt0, dt1)参数：\ndata：收取利息的数据馈送 size：当前头寸大小。\u0026gt; 0 表示多头头寸，\u0026lt; 0 表示空头头寸（此参数不会为 0） price：当前头寸价格 days：自上次信用计算以来经过的天数（这是（dt0 - dt1）.days） dt0：（datetime.datetime）当前日期时间 dt1：（datetime.datetime）上次计算的日期时间 默认实现中不使用 dt0 和 dt1，它们作为覆盖方法的额外输入提供。\n"},{"id":11,"href":"/backtrader/docs/08-indicators/01-using-indicators/","title":"使用指标","section":"Indicator","content":"使用指标# 指标可以在平台中的两个地方使用：\n策略内部 其他指标内部 指标在操作中的使用# 在策略中，指标总是在 __init__ 中实例化。在 next 中使用/检查指标值（或派生值）。有一个重要的公理需要考虑：在 __init__ 中声明的任何指标（或派生值）将在调用 next 之前预先计算。\n让我们了解操作模式的差异。\n__init__ vs next# 在 __init__ 中涉及到线条对象的任何操作都会生成另一个线条对象。在 next 中涉及到线条对象的任何操作都会生成常规的 Python 类型，如浮点数和布尔值。\n如 __init__ 中的一个操作：\nhilo_diff = self.data.high - self.data.low变量 hilo_diff 持有一个线条对象的引用，该对象在调用 next 之前预先计算，可以使用标准数组表示法 [] 访问。\n它显然包含了数据源中每个条的高低差值。\n这在混合简单线条（如 self.data 数据源中的线条）和复杂线条（如指标）时也有效：\nsma = bt.SimpleMovingAverage(self.data.close) close_sma_diff = self.data.close - sma现在 close_sma_diff 再次包含一个线条对象。\n使用逻辑运算符：\nclose_over_sma = self.data.close \u0026gt; sma现在生成的线条对象将包含一个布尔数组。\n在 next 中，一个操作（逻辑运算符）：\nclose_over_sma = self.data.close \u0026gt; self.sma使用等效数组（基于索引 0 的表示法）：\nclose_over_sma = self.data.close[0] \u0026gt; self.sma[0]在这种情况下，close_over_sma 生成一个布尔值，这是比较两个浮点值的结果，这些值由应用于 self.data.close 和 self.sma 的 [0] 运算符返回。\n为什么选择 __init__ vs next# 逻辑简化（以及易用性）是关键。可以在 __init__ 中声明计算和大部分相关逻辑，将实际操作逻辑保持在 next 中的最小化。\n实际上还有一个附带好处：速度（由于开始时的预计算）。\n一个完整的示例，在 __init__ 中生成一个买入信号：\nclass MyStrategy(bt.Strategy): def __init__(self): sma1 = btind.SimpleMovingAverage(self.data) ema1 = btind.ExponentialMovingAverage() close_over_sma = self.data.close \u0026gt; sma1 close_over_ema = self.data.close \u0026gt; ema1 sma_ema_diff = sma1 - ema1 buy_sig = bt.And(close_over_sma, close_over_ema, sma_ema_diff \u0026gt; 0) def next(self): if buy_sig: self.buy()注意： Python 的 and 运算符无法被重载，迫使平台定义其自己的 And。同样适用于其他构造如 Or 和 If。\n显然，“声明式”方法在 __init__ 期间保持 next（实际策略工作发生的地方）的膨胀最小化。不要忘记，这也有一个加速因素。\n注意： 当逻辑变得非常复杂并涉及多个操作时，通常最好将其封装在一个指标内。\n一些注意事项# 在上述示例中，与其他平台相比，backtrader 已简化了两件事：\n声明的指标既不获取父参数（如它们被创建的策略），也没有调用任何类型的“注册”方法/函数。尽管如此，策略会触发指标和任何因操作生成的线条对象的计算（如 sma - ema）。\nExponentialMovingAverage 实例化时没有传入 self.data。这是故意的。如果没有传入数据，父（在本例中是创建它的策略）的第一个数据将在后台自动传递。\n指标绘图# 首先也是最重要的：声明的指标会自动绘制（如果调用了 cerebro.plot）。操作生成的线条对象不会绘制（如 close_over_sma = self.data.close \u0026gt; self.sma）。\n有一个辅助的 LinePlotterIndicator 可以绘制这些操作，如果需要可以使用以下方法：\nclose_over_sma = self.data.close \u0026gt; self.sma LinePlotterIndicator(close_over_sma, name=\u0026#39;Close_over_SMA\u0026#39;)name 参数为此指标持有的单行命名。\n控制绘图# 在开发指标期间，可以添加一个 plotinfo 声明。它可以是一个包含两元素的元组的元组、一个字典或一个有序字典。看起来像这样：\nclass MyIndicator(bt.Indicator): ... plotinfo = dict(subplot=False) ...稍后可以访问（并设置）该值（如果需要）：\nmyind = MyIndicator(self.data, someparam=value) myind.plotinfo.subplot = True甚至可以在实例化期间设置该值：\nmyind = MyIndicator(self.data, someparams=value, subplot=True)subplot=True 将传递给指标的（在幕后实例化的）成员变量 plotinfo。\nplotinfo 提供以下参数来控制绘图行为：\n参数名 默认值 描述 plot True 是否绘制指标。 subplot True 是否在不同窗口中绘制指标。对于移动平均线等指标，默认值更改为 False。 plotname '' 设置绘图中显示的名称。空值表示将使用指标的规范名称（class.name）。这有一些限制，因为 Python 标识符不能使用算术运算符等。例如，指标 DI+ 将声明如下： plotinfo = dict(plotname='DI+')。 plotabove False 指标通常绘制在其操作的数据下方。将其设置为 True 会使指标绘制在数据上方。 plotlinelabels False 适用于“指标”上的“指标”。如果计算 RSI 的简单移动平均线，绘图通常会显示“SimpleMovingAverage”的名称。这是“指标”的名称，而不是实际绘制的线条的名称。如果将值设置为 True，将使用简单移动平均线内线条的实际名称。 plotymargin 0.0 在指标顶部和底部留出的边距量（0.15 -\u0026gt; 15%）。有时 matplotlib 绘图会超出轴的顶部/底部，可能需要一个边距。 plotyticks [] 用于控制绘制的 y 轴刻度。如果传递一个空列表，将自动计算“y 刻度”。对于像随机指标这样的东西，设置为已知的行业标准可能有意义：[20.0, 50.0, 80.0]。某些指标提供 upperband 和 lowerband 等参数，实际上用于操纵 y 刻度。 plothlines [] 用于控制沿指标轴绘制的水平线。如果传递一个空列表，则不会绘制水平线。对于像随机指标这样的东西，绘制已知的行业标准线可能有意义：[20.0, 80.0]。某些指标提供 upperband 和 lowerband 等参数，实际上用于操纵水平线。 plotyhlines [] 用于同时控制 plotyticks 和 plothlines，使用一个单一参数。 plotforce False 如果由于某种原因您认为某个指标应该绘制但未绘制……请最后设置为 True。 "},{"id":12,"href":"/backtrader/docs/04-concepts/01-platform-concepts/","title":"平台概念","section":"核心概念","content":"平台概念# 先介绍一些 backtrader 这个工具平台上的基础概念，希望能让你更好地了解和使用平台。\n开始之前# 先导入必要的模块：\nimport backtrader as bt import backtrader.indicators as btind import backtrader.feeds as btfeeds如下方法也可以访问子模块（如指标和数据源）：\nimport backtrader as bt thefeed = bt.feeds.OneOfTheFeeds(...) theind = bt.indicators.SimpleMovingAverage(...)运算符，自然构造# 为了实现“易用”目标，平台允许（在 Python 的约束范围内）使用运算符。为了进一步增强此目标，运算符的使用被分为两个阶段。\n阶段 1 - 运算符创建对象# 即使不是明确地为此目的，之前的一个示例已经看到这一点。在像指标和策略这样的对象的初始化阶段（__init__ 方法），运算符创建可以被操作、分配或保留以供策略逻辑的评估阶段稍后使用的对象。\n再次查看 SimpleMovingAverage 的潜在实现，进一步分解为步骤。\n在 SimpleMovingAverage 指标的 __init__ 方法内部的代码可能如下：\ndef __init__(self): # 求和 N 期值 - datasum 现在是一个 *Lines* 对象 # 在使用运算符 [] 和索引 0 查询时 # 返回当前和 datasum = btind.SumN(self.data, period=self.params.period) # datasum（尽管是单行，但作为 *Lines* 对象）可以 # 像在这种情况下那样自然地除以 int/float。 # 实际上它可以被另一个 *Lines* 对象除。 # 操作返回一个对象，分配给 \u0026#34;av\u0026#34;，该对象再次 # 在使用 [0] 查询时返回当前的平均值 av = datasum / self.params.period # av *Lines* 对象可以自然地分配给命名的 # 线该指标交付。使用此 # 指标的其他对象将可以直接访问计算结果 self.line.sma = av在策略的初始化中显示一个更完整的用例：\nclass MyStrategy(bt.Strategy): def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=20) close_over_sma = self.data.close \u0026gt; sma sma_dist_to_high = self.data.high - sma sma_dist_small = sma_dist_to_high \u0026lt; 3.5 # 不幸的是，\u0026#34;and\u0026#34; 不能在 Python 中被覆盖， # 因为它是语言构造而不是运算符，因此平台 # 提供了一个函数来模拟它 sell_sig = bt.And(close_over_sma, sma_dist_small)在上述操作完成后，sell_sig 是一个线对象，可以在策略的逻辑中稍后使用，以指示条件是否满足。\n阶段 2 - 运算符忠于自然# 让我们首先记住，一个策略有一个 next 方法，系统处理每个条时调用该方法。这是运算符实际上处于阶段 2 模式的地方。基于前面的示例：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma = sma = btind.SimpleMovingAverage(self.data, period=20) close_over_sma = self.data.close \u0026gt; sma self.sma_dist_to_high = self.data.high - sma sma_dist_small = sma_dist_to_high \u0026lt; 3.5 # 不幸的是，\u0026#34;and\u0026#34; 不能在 Python 中被覆盖， # 因为它是语言构造而不是运算符，因此平台 # 提供了一个函数来模拟它 self.sell_sig = bt.And(close_over_sma, sma_dist_small) def next(self): # 尽管这看起来不像是一个“运算符”，但实际上是 # 在测试对象是否响应 True/False if self.sma \u0026gt; 30.0: print(\u0026#39;简单移动平均线大于 30.0\u0026#39;) if self.sma \u0026gt; self.data.close: print(\u0026#39;简单移动平均线高于收盘价\u0026#39;) if self.sell_sig: # if sell_sig == True: 也是有效的 print(\u0026#39;卖出信号为真\u0026#39;) else: print(\u0026#39;卖出信号为假\u0026#39;) if self.sma_dist_to_high \u0026gt; 5.0: print(\u0026#39;简单移动平均线与高点的距离大于 5.0\u0026#39;)不是一个非常有用的策略，只是一个示例。在阶段 2 中，运算符返回预期的值（如果测试为真，则为布尔值，如果与浮点数比较，则为浮点数），算术运算也返回预期值。\n注意\n请注意，比较实际上并没有使用 [] 操作符。这是为了进一步简化事情。\nif self.sma \u0026gt; 30.0: 比较 self.sma[0] 和 30.0（第一行和当前值） if self.sma \u0026gt; self.data.close: 比较 self.sma[0] 和 self.data.close[0] 一些未覆盖的运算符/函数# Python 不允许覆盖所有内容，因此提供了一些函数来应对这些情况。\n注意\n仅在阶段 1 中使用，用于创建对象以便稍后提供值。\n运算符：\nand -\u0026gt; And or -\u0026gt; Or 逻辑控制：\nif -\u0026gt; If 函数：\nany -\u0026gt; Any all -\u0026gt; All cmp -\u0026gt; Cmp max -\u0026gt; Max min -\u0026gt; Min sum -\u0026gt; Sum Sum 实际上使用 math.fsum 作为底层操作，因为平台使用浮点数，应用常规求和可能会影响精度。\nreduce -\u0026gt; Reduce 这些实用运算符/函数对可迭代对象操作。可迭代对象中的元素可以是常规的 Python 数值类型（整数、浮点数等），也可以是具有线的对象。\n生成非常愚蠢的买入信号的示例：\nclass MyStrategy(bt.Strategy): def __init__(self): sma1 = btind.SMA(self.data.close, period=15) self.buysig = bt.And(sma1 \u0026gt; self.data.close, sma1 \u0026gt; self.data.high) def next(self): if self.buysig[0]: pass # 在这里做一些事情显然，如果 sma1 高于高点，它必须高于收盘价。但重点是说明 bt.And 的使用。\n使用 bt.If：\nclass MyStrategy(bt.Strategy): def __init__(self): sma1 = btind.SMA(self.data.close, period=15) high_or_low = bt.If(sma1 \u0026gt; self.data.close, self.data.low, self.data.high) sma2 = btind.SMA(high_or_low, period=15)分解：\n在 data.close 上生成一个周期为 15 的 SMA 然后 bt.If 的值大于 close，返回 low，否则返回 high 请记住，在调用 bt.If 时没有实际值返回。它返回一个线对象，就像 SimpleMovingAverage 一样。\n值将在系统运行时计算。\n生成的 bt.If 线对象然后被馈送到第二个 SMA，该 SMA 有时使用低价，有时使用高价进行计算。\n这些函数也接受数值。同样的示例有一个修改：\nclass MyStrategy(bt.Strategy): def __init__(self): sma1 = btind.SMA(self.data.close, period=15) high_or_30 = bt.If(sma1 \u0026gt; self.data.close, 30.0, self.data.high) sma2 = btind.SMA(high_or_30, period=15)现在，第二个移动平均线使用 30.0 或高价进行计算，具体取决于 sma 和 close 的逻辑状态。\n注意\n值 30 内部被转换为一个伪可迭代对象，该对象总是返回 30。\n"},{"id":13,"href":"/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/","title":"数据源 DataFeed","section":"平台概念","content":"数据源 - 配置与使用# 本节介绍 backtrader 中数据源的配置与使用，同时也包含了一些数据访问的技巧。\n数据配置# 在 Backtrader 中，数据源 DataFeed 通过 Celebro 配置。\n配置代码：\ncerebro = bt.Cerebro() data = btfeeds.MyFeed(...) cerebro.adddata(data) cerebro.addstrategy(MyStrategy, period=30)通过 cerebro.adddata 将 DataFeed 添加到系统中。我们无需关心系统是如何接收 DataFeed 的。\n使用方法# 策略中，我们通过 self.datas 数组即可访问数据。我们看一个简单示例，如我们实现策略。\n示例如下：\nclass MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): sma = btind.SimpleMovingAverage(self.datas[0], period=self.params.period)通过 self.datas[0] 即可访问数据。\n示例中有两个注意点：\n策略的 __init__ 方法无需接收 *args 或 **kwargs； self.datas 是一个包含 DataFeed 的数组，至少包含一个数据源，否则会出现异常； 一旦数据源被添加到系统中，我们在策略实现就可以按它们添加的顺序访问到每个数据源。\ncerebro.adddata(data0) cerebro.adddata(data1)在策略类访问：\nself.datas[0] # data0 self.datas[1] # data1快捷访问# 数据源也可通过快捷方式轻松访问，self.datas 数组中的每个元素都可以通过自动生成的成员变量进行访问：\n对应规则：\nself.data 对应的是 self.datas[0] self.dataX 对应的是 self.datas[X] 示例：\nclass MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=self.params.period)示例中的 self.data 是 self.datas[0] 的快捷方式，即访问的就是第一个数据源。如果你添加了多个数据源，就可以通过 self.data1 访问 self.datas[1]，self.data2 访问 self.datas[2]，依次类推。\n省略数据源# 上面的示例还可以进一步简化。\n在调用 SimpleMovingAverage 时，我们可以完全省略 self.data，backtrader 会自动选择数据源：\nclass MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): sma = btind.SimpleMovingAverage(period=self.params.period)在这个简化版本中，SimpleMovingAverage 没有显式传递 self.data。\n如果省略了 self.data，SimpleMovingAverage 会默认选择第一个数据源（即 self.data 或 self.datas[0]）作为输入。\n好的，我将按照步骤来简化表达，这样更清晰易懂：\n数据延伸# 在 Backtrader 中，不仅数据源可以作为输入，指标和计算结果也能作为数据提供给策略。\n通过一个示例说明吧。\n将数据源作为输入计算指标，如：\nsma1 = btind.SimpleMovingAverage(self.datas[0], period=self.p.period1)self.datas[0] 是第一个数据源，它传递给 SimpleMovingAverage 进行计算。\n基于计算出的指标生成新的变量，如：\nsma2 = btind.SimpleMovingAverage(sma1, period=self.p.period2)还可以在指标之间进行运算，将操作结果作为新的变量：\ndiff = sma2 - sma1 + self.data.close操作结果可以像数据源一样传递给下一个指标计算函数：\nsma3 = btind.SimpleMovingAverage(diff, period=self.p.period3) greater = sma3 \u0026gt; sma1 sma4 = btind.SimpleMovingAverage(greater, period=self.p.period4)如上的步骤中，我们不断将计算的中间结果作为新的数据源，传递给后续指标进一步计算。\n"},{"id":14,"href":"/backtrader/docs/03-quickstart/01-setup/","title":"环境设置","section":"快速开始","content":"环境设置# 在开始构建复杂的交易策略前，我们要先配置策略运行环境。Backtrader 的环境离不开一个核心类 Cerebro（大脑），后续会详细介绍它。\n初始化配置# 我们先看完整的环境初始化设置的代码：\nimport backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())在这个示例中，我们首先导入了 backtrader 模块并命名为 bt。\nimport backtrader as bt并基于 bt.Cerebro 实例化了 Cerebro 引擎。\ncerebro = bt.Cerebro()我们通过 cerebro.broker.getvalue() 获取并打印了初始的持仓组合价值，即我们的初始资金。\nprint(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())接着运行 cerebro.run() 以处理数据模拟交易，并再次打印最终的持仓组合价值\ncerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出如下：\nStarting Portfolio Value: 10000.00 Final Portfolio Value: 10000.00配置解析# 这个基础设置是构建复杂交易策略的基础。\n这一简单的示例中，Cerebro 引擎在后台创建了一个 broker 实例，并自动分配了一些初始资金。这种后台 broker 实例化是 backtrader 的常规特性，旨在简化用户操作。如果用户未明确设置 broker，系统会使用默认 broker，默认初始资金通常是 10,000 货币单位。\n接下来，我们将添加数据源（DataFeed）、策略（Strategy）、指标（Indicator）等，逐步完善我们的交易系统。\n"},{"id":15,"href":"/backtrader/docs/17-datetime/01-management/","title":"管理","section":"日期时间","content":"管理# 在发布 1.5.0 版本之前，backtrader 对时间管理采用的是直接方式，即直接使用数据源计算出的任何日期时间。用户输入的参数，如 fromdate（或 sessionstart），也可以传递给任何数据源。\n这种方法在对冻结数据源进行回测时效果很好。可以假设输入的日期时间在进入系统之前已经经过处理。\n但在 1.5.0 版本之后，backtrader 开始支持实时数据源，这就需要考虑日期时间管理。如果以下情况总是成立，那么就不需要进行这种管理：\n纽约的交易者交易 ES-Mini。这两个的时区都是 US/Eastern（或其别名）。 柏林的交易者交易 DAX 期货。在这种情况下，两个的时区都是 CET（或 Europe/Berlin）。 上面的直接输入-输出日期时间方法可以工作，因为柏林的交易者可以始终这样做：\nclass Strategy(bt.Strategy): def next(self): # DAX 期货在 CET 时间早上 08:00 开盘 if self.data.datetime.time() \u0026lt; datetime.time(8, 30): # 市场运行 30 分钟之前不操作 return #当同一个柏林交易者决定交易 ES-Mini 时，直接方法的问题就会显现出来。因为 DST（夏令时）的变化发生在一年中的不同时间，这会导致时间差异在一年中的某些周内不同步。\n以下代码并不总是有效：\nclass Strategy(bt.Strategy): def next(self): # SPX 在 US/Eastern 全年早上 09:30 开盘 # 大部分时间是 15:30 CET # 但有时是 16:30 CET 或 14:30 CET，取决于美国和欧洲的 DST 切换时间 # 因此以下代码是不可靠的 if self.data.datetime.time() \u0026lt; datetime.time(16, 0): # 市场运行 30 分钟之前不操作 return #使用时区操作# 为了解决上述问题并仍然保持与直接输入-输出时间方法的兼容性，backtrader 为终端用户提供了以下选项：\n日期时间输入# 默认情况下，平台不会触及数据源提供的日期时间。\n用户可以通过以下方式覆盖此输入：\n为数据源提供 tzinput 参数。这必须是与 datetime.tzinfo 接口兼容的对象。用户很可能会提供一个 pytz.timezone 实例。 通过这个决定，backtrader 内部使用的时间被认为是 UTC 类格式，即：\n如果数据源已经以 UTC 格式存储它。 通过 tzinput 转换后。 它实际上不是 UTC，但它是用户的参考，因此是 UTC 类的。\n日期时间输出# 如果数据源可以自动确定时区，这将是默认设置。\n这在实时数据源的情况下尤其有意义，例如柏林（CET 时区）的交易者交易 US/Eastern 时区的产品。\n因为交易者总是得到正确的时间，在上面的示例中，开盘时间在 US/Eastern 时区内始终是早上 09:30，而不是一年中大部分时间的 15:30 CET，有时是 16:30 CET，有时是 14:30 CET。\n如果不能确定，那么输出将是输入时确定的时间（UTC 类时间）。\n用户可以覆盖并确定输出的实际时区：\n为数据源提供 tz 参数。这必须是与 datetime.tzinfo 接口兼容的对象。用户很可能会提供一个 pytz.timezone 实例。 注意：\n用户输入的参数（如 fromdate 或 sessionstart）应与实际 tz 同步，无论是由数据源自动计算，用户提供还是默认（None，表示直接输入-输出日期时间）。\n考虑到上述所有内容，让我们回顾一下柏林的交易者，交易 US/Eastern 时区的产品：\nimport pytz import bt data = bt.feeds.MyFeed(\u0026#39;ES-Mini\u0026#39;, tz=pytz.timezone(\u0026#39;US/Eastern\u0026#39;)) class Strategy(bt.Strategy): def next(self): # 这将全年有效。 # 数据源将在 \u0026#39;US/Eastern\u0026#39; 时区的框架内返回数据， # 用户将 \u0026#39;10:00\u0026#39; 作为参考时间 # 因为在 \u0026#39;US/Eastern\u0026#39; 时区，SPX 指数总是 # 在 09:30 开盘，这将始终有效 if self.data.datetime.time() \u0026lt; datetime.time(10, 0): # 市场运行 30 分钟之前不操作 return #对于可以自动确定输出时区的数据源：\nimport bt data = bt.feeds.MyFeedAutoTZ(\u0026#39;ES-Mini\u0026#39;) class Strategy(bt.Strategy): def next(self): # 这将全年有效。 # 数据源将在 \u0026#39;US/Eastern\u0026#39; 时区的框架内返回数据， # 用户将 \u0026#39;10:00\u0026#39; 作为参考时间 # 因为在 \u0026#39;US/Eastern\u0026#39; 时区，SPX 指数总是 # 在 09:30 开盘，这将始终有效 if self.data.datetime.time() \u0026lt; datetime.time(10, 0): # 市场运行 30 分钟之前不操作 return #显然，上面示例中的 MyFeed 和 MyFeedAuto 只是虚拟名称。\n注意：\n在撰写本文时，唯一包含在发行版中的能够自动确定时区的数据源是连接到 Interactive Brokers 的数据源。\n"},{"id":16,"href":"/backtrader/docs/13-observers/01-statistics/","title":"统计","section":"Observer","content":"统计# 在 backtrader 中运行的策略主要处理数据源和指标。数据源添加到 Cerebro 实例中，并最终成为策略的输入（解析并作为实例的属性提供），而指标由策略本身声明和管理。\n到目前为止，所有 backtrader 示例图表都绘制了三件看似理所当然的东西，因为它们在任何地方都没有声明：\n现金和价值（经纪人中的资金情况） 交易（即操作） 买/卖订单 它们是观察器，存在于子模块 backtrader.observers 中。因为 Cerebro 支持一个参数来自动将它们（或不将它们）添加到策略中：stdstats（默认：True）。\n如果遵循默认设置，Cerebro 将执行以下等效用户代码：\nimport backtrader as bt cerebro = bt.Cerebro() # 默认参数：stdstats=True cerebro.addobserver(bt.observers.Broker) cerebro.addobserver(bt.observers.Trades) cerebro.addobserver(bt.observers.BuySell)让我们看看通常带有这三个默认观察器的图表（即使没有发出订单，因此没有交易发生，现金和投资组合价值没有变化）：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt import backtrader.feeds as btfeeds if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro(stdstats=False) cerebro.addstrategy(bt.Strategy) data = bt.feeds.BacktraderCSVData(dataname=\u0026#39;../../datas/2006-day-001.txt\u0026#39;) cerebro.adddata(data) cerebro.run() cerebro.plot()现在让我们在创建 Cerebro 实例时将 stdstats 的值更改为 False（也可以在调用 run 时完成）：\ncerebro = bt.Cerebro(stdstats=False)图表现在有所不同。\n访问观察器# 如上所示，观察器在默认情况下已经存在并收集信息，这些信息可用于统计目的，因此可以通过策略的一个名为 stats 的属性访问观察器。\n这只是一个占位符。如果我们回顾上面列出的添加一个默认观察器的代码：\ncerebro.addobserver(backtrader.observers.Broker)显而易见的问题是如何访问 Broker 观察器。下面是如何在策略的 next 方法中完成的示例：\nclass MyStrategy(bt.Strategy): def next(self): if self.stats.broker.value[0] \u0026lt; 1000.0: print(\u0026#39;WHITE FLAG ... I LOST TOO MUCH\u0026#39;) elif self.stats.broker.value[0] \u0026gt; 10000000.0: print(\u0026#39;TIME FOR THE VIRGIN ISLANDS ....!!!\u0026#39;)Broker 观察器就像数据、指标和策略本身一样也是一个线条对象。在这种情况下，Broker 有两条线：\ncash value 观察器的实现# 实现非常类似于指标：\nclass Broker(Observer): alias = (\u0026#39;CashValue\u0026#39;,) lines = (\u0026#39;cash\u0026#39;, \u0026#39;value\u0026#39;) plotinfo = dict(plot=True, subplot=True) def next(self): self.lines.cash[0] = self._owner.broker.getcash() self.lines.value[0] = value = self._owner.broker.getvalue()步骤：\n从 Observer（而不是 Indicator）派生 根据需要声明线条和参数（Broker 有两条线但没有参数） 将有一个自动属性 _owner，即持有观察器的策略 观察器在以下情况下开始运行：\n所有指标都已计算完毕 策略的 next 方法已执行完毕 这意味着在周期结束时\u0026hellip; 它们观察已发生的情况。在 Broker 的情况下，它只是盲目地记录每个时间点的经纪人现金和投资组合价值。\n将观察器添加到策略# 如上所述，Cerebro 使用 stdstats 参数决定是否添加三个默认观察器，从而减轻最终用户的工作负担。\n可以将其他观察器添加到混合中，无论是与 stdstats 一起使用还是移除它们。\n让我们来看一个通常的策略，当收盘价高于简单移动平均线时买入，相反则卖出。\n有一个“添加”：\nDrawDown，这是 backtrader 生态系统中已经存在的观察器 from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import os.path import time import sys import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind class MyStrategy(bt.Strategy): params = ((\u0026#39;smaperiod\u0026#39;, 15),) def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39; 记录此策略的日志功能 \u0026#39;\u0026#39;\u0026#39; dt = dt or self.data.datetime[0] if isinstance(dt, float): dt = bt.num2date(dt) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): # 主数据上的简单移动平均线 sma = btind.SMA(period=self.p.smaperiod) # 交叉（1：向上，-1：向下）收盘价/移动平均线 self.buysell = btind.CrossOver(self.data.close, sma, plot=True) # 哨兵为 None：允许新订单 self.order = None def next(self): # 访问 -1，因为 drawdown[0] 将在“next”之后计算 self.log(\u0026#39;DrawDown: %.2f\u0026#39; % self.stats.drawdown.drawdown[-1]) self.log(\u0026#39;MaxDrawDown: %.2f\u0026#39; % self.stats.drawdown.maxdrawdown[-1]) # 检查我们是否在市场中 if self.position: if self.buysell \u0026lt; 0: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.data.close[0]) self.sell() elif self.buysell \u0026gt; 0: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.data.close[0]) self.buy() def runstrat(): cerebro = bt.Cerebro() data = bt.feeds.BacktraderCSVData(dataname=\u0026#39;../../datas/2006-day-001.txt\u0026#39;) cerebro.adddata(data) cerebro.addobserver(bt.observers.DrawDown) cerebro.addstrategy(MyStrategy) cerebro.run() cerebro.plot() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()视觉输出显示了回撤的演变：\n部分文本输出：\n... 2006-12-14T23:59:59+00:00, MaxDrawDown: 2.62 2006-12-15T23:59:59+00:00, DrawDown: 0.22 2006-12-15T23:59:59+00:00, MaxDrawDown: 2.62 2006-12-18T23:59:59+00:00, DrawDown: 0.00 2006-12-18T23:59:59+00:00, MaxDrawDown: 2.62 ...注意\n如文本输出和代码所示，DrawDown 观察器实际上有两条线：\ndrawdown maxdrawdown 选择不绘制 maxdrawdown 线，但它仍然可供用户使用。\n实际上，maxdrawdown 的最后一个值也可以通过一个直接属性（不是线条）获取，名称为 maxdd。\n开发观察器# 上面展示了 Broker 观察器的实现。要生成有意义的观察器，实现可以使用以下信息：\nself._owner 是当前正在执行的策略 因此策略中的任何内容对观察器都是可用的。\n策略中可能有用的默认内部内容：\nbroker -\u0026gt; 属性，提供对策略创建订单的经纪人实例的访问。正如在 Broker 中所见，通过调用 getcash 和 getvalue 方法收集现金和投资组合价值。 _orderspending -\u0026gt; 列表，策略创建的订单并且经纪人已通知策略一个事件。BuySell 观察器遍历列表，查找已执行的订单（全部或部分），以便为给定时间点创建一个平均执行价格（索引 0）。 _tradespending -\u0026gt; 交易列表（已完成的买/卖或卖/买对），由买/卖订单编译而成。观察器显然可以通过 self._owner.stats 路径访问其他观察器。 自定义 OrderObserver# 标准的 BuySell 观察器只关心已执行的操作。我们可以创建一个观察器，显示订单何时创建以及它们是否过期。\n为了可见性，显示将不会与价格一起绘制，而是在一个单独的轴上。\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import math import backtrader as bt class OrderObserver(bt.observer.Observer): lines = (\u0026#39;created\u0026#39;, \u0026#39;expired\u0026#39;,) plotinfo = dict(plot=True, subplot=True, plotlinelabels=True) plotlines = dict( created=dict(marker=\u0026#39;*\u0026#39;, markersize=8.0, color=\u0026#39;lime\u0026#39;, fillstyle=\u0026#39;full\u0026#39;), expired=dict(marker=\u0026#39;s\u0026#39;, markersize=8.0, color=\u0026#39;red\u0026#39;, fillstyle=\u0026#39;full\u0026#39;) ) def next(self): for order in self._owner._orderspending: if order.data is not self.data: continue if not order.isbuy(): continue # 只关心“买入”订单，因为策略中的卖出订单是市场订单并会立即执行 if order.status in [bt.Order.Accepted, bt.Order.Submitted]: self.lines.created[0] = order.created.price elif order.status in [bt.Order.Expired]: self.lines.expired[0] = order.created.price自定义观察器只关心买入订单，因为这是一个只买入以尝试获利的策略。卖出订单是市场订单，将立即执行。\n更新后的策略# from __future__ import (absolute_import, division, print_function, unicode_literals) import datetime import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind from orderobserver import OrderObserver class MyStrategy(bt.Strategy): params = ( (\u0026#39;smaperiod\u0026#39;, 15), (\u0026#39;limitperc\u0026#39;, 1.0), (\u0026#39;valid\u0026#39;, 7), ) def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39; 记录此策略的日志功能 \u0026#39;\u0026#39;\u0026#39; dt = dt or self.data.datetime[0] if isinstance(dt, float): dt = bt.num2date(dt) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: # 买入/卖出订单已提交/接受至/由经纪人 - 无需执行任何操作 self.log(\u0026#39;ORDER ACCEPTED/SUBMITTED\u0026#39;, dt=order.created.dt) self.order = order return if order.status in [order.Expired]: self.log(\u0026#39;BUY EXPIRED\u0026#39;) elif order.status in [order.Completed]: if order.isbuy(): self.log( \u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: # 卖出 self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) # 哨兵为 None：允许新订单 self.order = None def __init__(self): # 主数据上的简单移动平均线 sma = btind.SMA(period=self.p.smaperiod) # 交叉（1：向上，-1：向下）收盘价/移动平均线 self.buysell = btind.CrossOver(self.data.close, sma, plot=True) # 哨兵为 None：允许新订单 self.order = None def next(self): if self.order: # 待处理订单...不做任何事 return # 检查我们是否在市场中 if self.position: if self.buysell \u0026lt; 0: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.data.close[0]) self.sell() elif self.buysell \u0026gt; 0: plimit = self.data.close[0] * (1.0 - self.p.limitperc / 100.0) valid = self.data.datetime.date(0) + datetime.timedelta(days=self.p.valid) self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % plimit) self.buy(exectype=bt.Order.Limit, price=plimit, valid=valid) def runstrat(): cerebro = bt.Cerebro() data = bt.feeds.BacktraderCSVData(dataname=\u0026#39;../../datas/2006-day-001.txt\u0026#39;) cerebro.adddata(data) cerebro.addobserver(OrderObserver) cerebro.addstrategy(MyStrategy) cerebro.run() cerebro.plot() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()结果图表显示多个订单已过期，可以在新子图（红色方块）中看到。此外，我们还可以看到“创建”和“执行”之间的几个天数。\n保存/保持统计数据# 截至目前，backtrader 尚未实现任何机制来跟踪观察器的值并将其存储到文件中。最好的方法是：\n在策略的 start 方法中打开一个文件 在策略的 next 方法中写下值 考虑 DrawDown 观察器，可以这样做：\nclass MyStrategy(bt.Strategy): def start(self): self.mystats = open(\u0026#39;mystats.csv\u0026#39;, \u0026#39;wb\u0026#39;) self.mystats.write(\u0026#39;datetime,drawdown, maxdrawdown\\n\u0026#39;) def next(self): self.mystats.write(self.data.datetime.date(0).strftime(\u0026#39;%Y-%m-%d\u0026#39;)) self.mystats.write(\u0026#39;,%.2f\u0026#39; % self.stats.drawdown.drawdown[-1]) self.mystats.write(\u0026#39;,%.2f\u0026#39; % self.stats.drawdown.maxdrawdown[-1]) self.mystats.write(\u0026#39;\\n\u0026#39;)要保存索引 0 的值，一旦所有观察器都被处理完，可以将自定义观察器作为系统的最后一个观察器添加，以将值写入 CSV 文件。\n注意，Writer 功能可以自动执行此任务。\n"},{"id":17,"href":"/backtrader/docs/09-orders/01-general/","title":"订单","section":"Order","content":"订单# Cerebro 是 backtrader 中的关键控制系统，而 Strategy（一个子类）是终端用户的关键控制点。后者需要一个连接系统其他部分的方法，这就是订单发挥关键作用的地方。\n订单将策略中的逻辑决策转化为适合 Broker 执行操作的消息。这是通过以下方式完成的：\n创建# 通过 Strategy 的方法：buy、sell 和 close（Strategy），这些方法返回一个订单实例作为参考。\n取消# 通过 Strategy 的方法：cancel（Strategy），该方法需要一个订单实例来操作。\n订单也作为一种通信方式反馈给用户，通知 Broker 中的执行情况。\n通知# 通过 Strategy 的方法：notify_order（Strategy），该方法报告一个订单实例。\n订单创建# 调用 buy、sell 和 close 时，以下参数适用于创建：\n参数名 默认值 描述 data None 为哪个数据创建订单。如果为 None，则使用系统中的第一个数据，self.datas[0] 或 self.data0（又名 self.data）。 size None 使用的单位数量。如果为 None，则使用通过 getsizer 获取的 sizer 实例来确定大小。 price None 使用的价格（实时 Broker 可能会对格式有实际限制，如果不符合最小刻度要求）。对于 Market 和 Close 订单，None 是有效的（市场决定价格）。对于 Limit、Stop 和 StopLimit 订单，该值决定触发点（在 Limit 的情况下，触发点显然是订单匹配的价格）。 plimit None 仅适用于 StopLimit 订单。这是在 Stop 触发后设置隐含 Limit 订单的价格。 exectype None 可能的值：- Order.Market 或 None：市场订单将以下一个可用价格执行。在回测中，这将是下一根K线的开盘价。- Order.Limit：只能在给定价格或更好的价格执行的订单。- Order.Stop：在价格触发时执行的订单，执行方式如同 Market 订单。- Order.StopLimit：在价格触发时执行的订单，作为隐含 Limit 订单执行，价格由 pricelimit 给定。 valid None 可能的值：- None：生成一个不会过期的订单（即 Good till cancel），并在市场中保留直到匹配或取消。实际上，Broker 往往会强制一个时间限制，但这通常是很长时间，所以认为它不会过期。- datetime.datetime 或 datetime.date 实例：使用给定的日期生成一个有效直到该日期的订单（即 Good till date）。- Order.DAY 或 0 或 timedelta()：生成一个有效期为一天的订单（即日订单），有效期直到会话结束。- 数值：假定为一个对应于 matplotlib 编码的日期时间值（backtrader 使用的），并用于生成一个有效期至该时间的订单（即 Good till date）。 tradeid 0 这是 backtrader 用来跟踪同一资产上重叠交易的内部值。在通知订单状态变化时，该 tradeid 会返回给策略。 **kwargs / 额外的 Broker 实现可能支持额外的参数。backtrader 会将 kwargs 传递给创建的订单对象。 示例# 如果 backtrader 直接支持的 4 种订单执行类型不够，例如对于 Interactive Brokers，可以传递如下参数：\norderType=\u0026#39;LIT\u0026#39;, lmtPrice=10.0, auxPrice=9.8这将覆盖 backtrader 的设置，生成一个触及价格为 9.8 且限价为 10.0 的 LIMIT IF TOUCHED 订单。\n注意：\nclose 方法将检查当前仓位，并相应地使用 buy 或 sell 有效地关闭仓位。除非参数由用户输入，否则大小也将自动计算，在这种情况下可以实现部分关闭或反转。\n订单通知# 要接收通知，必须在用户子类的 Strategy 中重写 notify_order 方法（默认行为是什么都不做）。以下适用于这些通知：\n在策略的 next 方法调用之前发出。 在同一个 next 循环中，可能（并且会）多次发生相同或不同状态的相同订单通知。 订单可能会被提交给 Broker，被接受并在 next 再次调用之前完成执行。 在这种情况下，至少会发生 3 次通知，状态值如下：\nOrder.Submitted 因为订单已发送给 Broker。 Order.Accepted 因为订单已被 Broker 接受并等待执行。 Order.Completed 因为在示例中订单已快速匹配并完全成交（通常适用于 Market 订单）。 对于 Order.Partial 状态，即使在回测 Broker 中（不考虑匹配量）不会看到，但在实际 Broker 中肯定会看到。\n实际 Broker 可能会在更新仓位之前发出一次或多次执行通知，这些执行将构成一个 Order.Partial 通知。\n实际执行数据在属性：order.executed 中，这是一个 OrderData 类型的对象，具有常见的字段如大小和价格。\n创建时的值存储在 order.created 中，在订单生命周期中保持不变。\n订单状态值# 以下定义：\nOrder.Created：在创建订单实例时设置。除非手动创建订单实例，否则终端用户不会看到该状态。 Order.Submitted：在订单实例已传输给 Broker 时设置。这只是意味着已发送。在回测模式中这是立即的，但在实际 Broker 中可能需要时间，可能在转发给交易所时才通知。 Order.Accepted：Broker 已接受订单，并在系统中（或已在交易所）等待执行，参数如执行类型、大小、价格和有效期。 Order.Partial：订单已部分执行。order.executed 包含当前填充的大小和平均价格。 order.executed.exbits 包含部分填充的完整执行位列表。 Order.Complete：订单已完全填充平均价格。 Order.Rejected：Broker 拒绝了订单。可能是某个参数（如有效期）不被接受，订单无法接受。 原因会通过策略的 notify_store 方法通知。虽然这可能显得奇怪，但实际 Broker 会通过事件通知，这可能与订单直接相关或无关。但可以在 notify_store 中看到 Broker 的通知。 在回测 Broker 中不会看到此状态。 Order.Margin：订单执行将导致保证金要求，之前接受的订单已从系统中移除。 Order.Cancelled（或 Order.Canceled）：用户请求取消的确认。 必须考虑，通过策略的 cancel 方法请求取消订单并不保证取消。订单可能已经执行，但此执行可能尚未被 Broker 通知，并且通知可能尚未传递给策略。 Order.Expired：之前接受的订单具有时间有效性，已过期并被从系统中移除。 引用：Order 及相关类# 这些对象是 backtrader 生态系统中的通用类。在与其他 Broker 操作时，它们可能已扩展和/或包含额外的嵌入信息。请参阅相应 Broker 的参考。\nclass backtrader.order.Order()持有创建/执行数据和订单类型的类。\n订单可能具有以下状态：\nSubmitted：发送给 Broker，等待确认。 Accepted：被 Broker 接受。 Partial：部分执行。 Completed：完全执行。 Canceled/Cancelled：被用户取消。 Expired：过期。 Margin：没有足够的现金执行订单。 Rejected：被 Broker 拒绝。 这可能发生在订单提交期间（因此订单不会达到 Accepted 状态），或者在执行前因每根新K线价格变化，现金被其他来源（如期货类工具）抽取导致拒绝。 成员属性：\nref：唯一订单标识符。 created：持有创建数据的 OrderData。 executed：持有执行数据的 OrderData。 info：通过 addinfo() 方法传递的自定义信息。以子类化的 OrderedDict 形式保存，键也可以使用.符号指定。 用户方法：\nisbuy()：返回一个布尔值，指示订单是否买入。 issell()：返回一个布尔值，指示订单是否卖出。 alive()：返回一个布尔值，如果订单状态为 Partial 或 Accepted。 class backtrader.order.OrderData(dt=None, size=0, price=0.0, pricelimit=0.0, remsize =0, pclose=0.0, trailamount=0.0, trailpercent=0.0)持有创建和执行实际订单数据。\n在创建情况下，请求的数据，在执行情况下，实际结果。\n成员属性：\nexbits：此 OrderData 的 OrderExecutionBits 的可迭代对象。 dt：日期时间（浮点数）创建/执行时间。 size：请求/执行大小。 price：执行价格。注意：如果没有价格和 pricelimit，订单创建时的收盘价将作为参考。 pricelimit：StopLimit 的价格限制（首先有触发）。 trailamount：追踪止损的绝对价格距离。 trailpercent：追踪止损的百分比价格距离。 value：整个位大小的市场价值。 comm：整个位执行的佣金。 pnl：此位产生的盈亏（如果有关闭）。 margin：订单产生的保证金（如果有）。 psize：当前未平仓头寸大小。 pprice：当前未平仓头寸价格。 class backtrader.order.OrderExecutionBit(dt=None, size=0, price=0.0, closed=0, closedvalue=0.0, closedcomm=0.0, opened=0, openedvalue=0.0, openedcomm=0.0, pnl=0.0, psize=0, pprice=0.0)旨在持有订单执行信息。“位”不确定订单是否已完全/部分执行，只是持有信息。\n成员属性：\ndt：日期时间（浮点数）执行时间。 size：执行数量。 price：执行价格。 closed：执行关闭了多少现有头寸。 opened：执行打开了多少新头寸。 openedvalue：新开部分的市场价值。 closedvalue：关闭部分的市场价值。 closedcomm：关闭部分的佣金。 openedcomm：打开部分的佣金。 value：整个位大小的市场价值。 comm：整个位执行的佣金。 pnl：此位产生的盈亏（如果有关闭）。 psize：当前未平仓头寸大小。 pprice：当前未平仓头寸价格。 "},{"id":18,"href":"/backtrader/docs/19-articles/01-out-of-memory/","title":"超大内存","section":"官方文章","content":"关于回测性能和超大内存执行# 最近在 Reddit 上有两个相关的帖子，启发了本文的写作：\n一个声称 backtrader 无法处理 160 万根 K线的帖子：reddit/r/algotrading - A performant backtesting system? 另一个要求一个能回测 8000 支股票的工具：reddit/r/algotrading - Backtesting libs that supports 1000+ stocks? 其中有一位作者询问如何使用一个可以回测“超大内存”的框架，“因为显然不能将所有这些数据加载到内存中。”\n我们将会在本文中讨论这些概念，结合 backtrader 来解决。\n2M K线# 为了验证这一点，首先需要生成这么多的 K线。考虑到第一个发帖者提到 77 支股票和 160 万根 K线，这意味着每支股票大约有 20,779 根 K线，因此我们将进行以下操作来使数据更加简洁：\n为 100 支股票生成 K线数据 每支股票生成 20,000 根 K线 即：生成 100 个文件，总共 200 万根 K线。 生成数据的脚本如下：\nimport numpy as np import pandas as pd COLUMNS = [\u0026#39;open\u0026#39;, \u0026#39;high\u0026#39;, \u0026#39;low\u0026#39;, \u0026#39;close\u0026#39;, \u0026#39;volume\u0026#39;, \u0026#39;openinterest\u0026#39;] CANDLES = 20000 STOCKS = 100 dateindex = pd.date_range(start=\u0026#39;2010-01-01\u0026#39;, periods=CANDLES, freq=\u0026#39;15min\u0026#39;) for i in range(STOCKS): data = np.random.randint(10, 20, size=(CANDLES, len(COLUMNS))) df = pd.DataFrame(data * 1.01, dateindex, columns=COLUMNS) df = df.rename_axis(\u0026#39;datetime\u0026#39;) df.to_csv(\u0026#39;candles{:02d}.csv\u0026#39;.format(i))该脚本生成了 100 个文件，从 candles00.csv 到 candles99.csv。实际的数据值不重要，重要的是保持标准的日期时间格式、OHLCV 数据（包括未平仓合约）。\n测试系统# 硬件/操作系统：使用的是一台 Windows 10 15.6 英寸的笔记本，配备 Intel i7 处理器和 32GB 内存。\nPython 版本：CPython 3.6.1 和 pypy3 6.0.0。\n其他：持续运行的应用程序占用约 20% 的 CPU，浏览器（Chrome 102 个进程）、Edge、Word、PowerPoint、Excel 及其他一些小程序正在运行。\nbacktrader 默认配置# 让我们回顾一下 backtrader 的默认运行时配置：\n如果可能，预加载所有数据源 如果所有数据源都可以预加载，则以批处理模式运行（命名为 runonce） 先计算所有指标 按步骤执行策略逻辑和经纪人 在默认批处理模式下执行挑战# 我们的测试脚本（见下文完整源代码）将打开这 100 个文件并使用 backtrader 的默认配置处理它们。\n$ ./two-million-candles.py Cerebro Start Time: 2019-10-26 08:33:15.563088 Strat Init Time: 2019-10-26 08:34:31.845349 Time Loading Data Feeds: 76.28 Number of data feeds: 100 Strat Start Time: 2019-10-26 08:34:31.864349 Pre-Next Start Time: 2019-10-26 08:34:32.670352 Time Calculating Indicators: 0.81 Next Start Time: 2019-10-26 08:34:32.671351 Strat warm-up period Time: 0.00 Time to Strat Next Logic: 77.11 End Time: 2019-10-26 08:35:31.493349 Time in Strategy Next Logic: 58.82 Total Time in Strategy: 58.82 Total Time: 135.93 Length of data feeds: 20000 Memory Usage: A peak of 348 Mbytes was observed大部分时间实际上是在预加载数据（98.63 秒），其余时间用于策略执行（包括在每次迭代中通过经纪人进行处理，耗时 73.63 秒）。总时间为 173.26 秒。\n性能为：每秒 14,713 根 K线。\n结论：上述第一个 Reddit 线程中声称 backtrader 无法处理 160 万根 K线的说法是错误的。\n使用 pypy# 既然有线程声称使用 pypy 没有帮助，我们来看看使用 pypy 时的表现。\n$ ./two-million-candles.py Cerebro Start Time: 2019-10-26 08:39:42.958689 Strat Init Time: 2019-10-26 08:40:31.260691 Time Loading Data Feeds: 48.30 Number of data feeds: 100 Strat Start Time: 2019-10-26 08:40:31.338692 Pre-Next Start Time: 2019-10-26 08:40:31.612688 Time Calculating Indicators: 0.27 Next Start Time: 2019-10-26 08:40:31.612688 Strat warm-up period Time: 0.00 Time to Strat Next Logic: 48.65 End Time: 2019-10-26 08:40:40.150689 Time in Strategy Next Logic: 8.54 Total Time in Strategy: 8.54 Total Time: 57.19 Length of data feeds: 20000总时间已经从 135.93 秒降到了 57.19 秒，性能提升了超过一倍。\n性能为：每秒 34,971 根 K线。\n内存使用：最大内存峰值为 269 MB。\n这也相较于标准 CPython 解释器，内存使用有所改善。\n处理 2M K线时的超大内存# 所有这些都可以通过 backtrader 的几种配置选项进一步优化，其中包括优化缓冲区并只使用最小的数据集（理想情况下，缓冲区大小为 1，这通常发生在理想场景下）。\n优化选项为 exactbars=True。关于 exactbars 的文档中有如下描述：\nTrue 或 1：所有“线”对象将减少内存使用至自动计算的最小周期。 如果某个简单移动平均线周期为 30，则底层数据将始终保留一个包含 30 根 K线的运行缓冲区，以便计算该简单移动平均线。 这一设置会禁用 preload 和 runonce。\n为了进一步优化，并因为绘图会被禁用，以下设置也将被使用：stdstats=False，禁用标准观察者（用于现金、资产价值和交易，绘图不再需要）。\n$ ./two-million-candles.py --cerebro exactbars=False,stdstats=False Cerebro Start Time: 2019-10-26 08:37:08.014348 Strat Init Time: 2019-10-26 08:38:21.850392 Time Loading Data Feeds: 73.84 Number of data feeds: 100 Strat Start Time: 2019-10-26 08:38:21.851394 Pre-Next Start Time: 2019-10-26 08:38:21.857393 Time Calculating Indicators: 0.01 Next Start Time: 2019-10-26 08:38:21.857393 Strat warm-up period Time: 0.00 Time to Strat Next Logic: 73.84 End Time: 2019-10-26 08:39:02.334936 Time in Strategy Next Logic: 40.48 Total Time in Strategy: 40.48 Total Time: 114.32 Length of data feeds: 20000性能为：每秒 17,494 根 K线。\n内存使用：固定为 75 MB。\n与之前未经优化的运行对比，预加载数据的时间已经不再是瓶颈，回测过程几乎可以立刻开始。\n总时间为 114.32 秒，相较于 135.93 秒，改善了 15.90%。\n内存使用改善了 68.5%。\n再次使用 pypy# 现在我们已经知道如何优化，接下来再次用 pypy 来做测试。\n$ ./two-million-candles.py --cerebro exactbars=True,stdstats=False Cerebro Start Time: 2019-10-26 08:44:32.309689 Strat Init Time: 2019-10 -26 08:45:22.177687 Time Loading Data Feeds: 58.80 Number of data feeds: 100 Strat Start Time: 2019-10-26 08:45:22.178689 Pre-Next Start Time: 2019-10-26 08:45:22.181688 Time Calculating Indicators: 0.26 Next Start Time: 2019-10-26 08:45:22.181688 Strat warm-up period Time: 0.00 Time to Strat Next Logic: 58.79 End Time: 2019-10-26 08:45:42.316689 Time in Strategy Next Logic: 20.14 Total Time in Strategy: 20.14 Total Time: 78.90 Length of data feeds: 20000性能：每秒 50,956 根 K线。\n"},{"id":19,"href":"/backtrader/docs/06-datafeed/09-datafeed-filters/01-datafeed-filters/","title":"过滤器 Filters","section":"过滤器 Filters","content":"过滤器 Filters# 该功能是较晚加入到 Backtrader 中的，且为了适应已有的内部结构进行了一些调整。因此，它在灵活性和功能完备性上可能不如预期，但在许多情况下仍然能达到目的。\n尽管实现时尝试支持即插即用的过滤器链，但由于原有内部结构的限制，始终无法保证每次都能实现。因此，有些过滤器可以链式使用，而有些则不能。\n目的# 将数据源提供的值转换为不同的数据流。\n该实现最初是为了简化两个明显的过滤器的实现，这两个过滤器可以通过cerebro API直接使用，分别是 重采样 和 重放。\n重采样（cerebro.resampledata）：这个过滤器会改变传入数据流的时间框架和压缩比例，如：(秒，1) -\u0026gt; (天，1)。这意味着原始数据流是以1秒为周期的数据条。重采样过滤器会拦截数据并进行缓冲，直到能够提供1天的条形数据。这发生在看到第二天的1秒条形数据时。\n重放（cerebro.replaydata），在上面相同的时间框架下，过滤器会利用1秒的分辨率条形数据重建1天的条形数据。也就是说，1天的条形数据会被反复传递，直到显示出所有1秒的条形数据，并且数据内容会更新。这种方法模拟了实际交易日的发展。\n注意，在日期没有变化的情况下，数据的长度（len(data)）以及策略的长度保持不变。\n工作原理# 给定一个已有的数据源，你可以使用addfilter方法来添加过滤器：\ndata = MyDataFeed(dataname=myname) data.addfilter(filter, *args, **kwargs) cerebro.adddata(data)即使它与重采样或重放过滤器兼容，你也可以做如下操作：\ndata = MyDataFeed(dataname=myname) data.addfilter(filter, *args, **kwargs) cerebro.replaydata(data)过滤器接口# 过滤器必须符合以下接口要求。首先，要是一个可调用的对象，接受如下签名：\ncallable(data, *args, **kwargs)或一个可以实例化并被调用的类，在实例化时其__init__方法必须支持以下签名：\ndef __init__(self, data, *args, **kwargs)__call__方法的签名为：\ndef __call__(self, data, *args, **kwargs)每当新的数据流值到来时，实例都会被调用。*args和**kwargs与__init__方法传递的参数相同。\n返回值 描述 True 表示数据流的内部数据获取循环需要重新尝试从数据源中获取数据，因为数据流的长度被修改了。 False 即使数据可能已经被编辑（例如：修改了close价格），数据流的长度保持不变。 如果是基于类的过滤器，还可以实现两个额外的方法：\nlast，其签名为：\ndef last(self, data, *args, **kwargs)当数据流结束时，这个方法会被调用，允许过滤器推送它可能缓冲的数据。例如在重采样的情况下，一个条形数据会被缓冲，直到看到下一个时间段的数据。如果数据流结束，就没有新的数据可以推动缓冲的数据，last方法提供了推送缓冲数据的机会。\n注意\n如果过滤器没有任何参数，且在添加时没有额外的参数，签名可以简化为：\ndef __init__(self, data) -\u0026gt; def __init__(self, data)示例过滤器# 以下是一个非常简单的过滤器实现：\nclass SessionFilter(object): def __init__(self, data): pass def __call__(self, data): if data.p.sessionstart \u0026lt;= data.datetime.time() \u0026lt;= data.p.sessionend: # 在交易时段内 return False # 告诉外部数据循环，当前条形数据可以继续处理 # 在常规交易时段外 data.backwards() # 从数据堆栈中移除该条形数据 return True # 告诉外部数据循环，必须获取新的条形数据该过滤器：\n使用data.p.sessionstart和data.p.sessionend判断 Bar 否在交易时段。 如果在交易时段内，返回False，表示没有做任何修改，当前条形数据可以继续处理。 如果不在交易时段内，条形数据会被移除，返回True表示需要获取新数据。 注意，data.backwards()使用了LineBuffer接口，深入了backtrader的内部实现。\n使用场景# 有些数据源包含了非交易时段的数据，这些数据可能对交易者没有意义。使用此过滤器，只有在交易时段内的条形数据才会被考虑。\n数据伪API for 过滤器\n在上面的示例中，展示了如何通过data.backwards()方法从数据流中移除当前条形数据。数据源对象中有一些有用的调用，作为过滤器的伪API，具体如下：\ndata.backwards(size=1, force=False)：从数据流中移除size条数据（默认为1），通过将逻辑指针向后移动。如果force=True，则物理存储也会被移除。 data.forward(value=float('NaN'), size=1)：将size条数据移到数据流的前面，如果需要会增加物理存储，并用value填充。 data._addtostack(bar, stash=False)：将条形数据bar添加到堆栈中，以便以后处理。如果stash=False，条形数据将在下一轮迭代时立即被处理；如果stash=True，则会经过完整的处理循环，包括可能被过滤器重新解析。 data._save2stack(erase=False, force=False)：将当前条形数据保存到堆栈中，以便稍后处理。如果erase=True，则会调用data.backwards()，并接收force参数。 data._updatebar(bar, forward=False, ago=0)：使用bar中的值覆盖数据流中相应位置的数据。如果ago=0，则更新当前条形数据。如果ago=-1，则更新前一个条形数据。 另一个示例：Pinkfish过滤器# 这是一个可以链式使用的过滤器示例，特别是与重放过滤器一起使用。Pinkfish的名字来源于该库的主页面，它的概念是通过使用每日数据来执行仅能通过即时数据完成的操作。\n实现方法：\n将每日条形数据分成两个部分：OHL和C。\n这些部分与重放一起被串联，在数据流中呈现出以下形式：\nWith Len X -\u0026gt; OHL With Len X -\u0026gt; OHLC With Len X + 1 -\u0026gt; OHL With Len X + 1 -\u0026gt; OHLC With Len X + 2 -\u0026gt; OHL With Len X + 2 -\u0026gt; OHLC ...逻辑：\n当接收到一个OHLC条形数据时，会复制它，并拆解成两个部分：OHL和C。 OHL条形数据的关闭价格被替换为开盘、最高和最低价格的平均值。 C条形数据即为“tick”，关闭价格会用来填充四个价格字段。 这两个部分被分别处理，OHL部分会立即加入堆栈，C部分则被推迟处理。 该过滤器与以下功能一起工作：\n重放过滤器，合并OHLO和CCCC部分，最终输出OHLC条形数据。 使用场景# 例如，当今天最大值是过去20个交易日中的最高值时，可发出“关闭”订单，并在第二次tick时执行。\nclass DaySplitter_Close(bt.with_metaclass(bt.MetaParams, object)): \u0026#39;\u0026#39;\u0026#39; Splits a daily bar in two parts simulating 2 ticks which will be used to replay the data: - First tick: ``OHLX`` The ``Close`` will be replaced by the *average* of ``Open``, ``High`` and ``Low`` The session opening time is used for this tick and - Second tick: ``CCCC`` The ``Close`` price will be used for the four components of the price The session closing time is used for this tick The volume will be split amongst the 2 ticks using the parameters: - ``closevol`` (default: ``0.5``) The value indicate which percentage, in absolute terms from 0.0 to 1.0, has to be assigned to the *closing* tick. The rest will be assigned to the ``OHLX`` tick. **This filter is meant to be used together with** ``cerebro.replaydata`` \u0026#39;\u0026#39;\u0026#39; params = ( (\u0026#39;closevol\u0026#39;, 0.5), # 0 -\u0026gt; 1 amount of volume to keep for close ) # replaying = True def __init__(self, data): self.lastdt = None def __call__(self, data): # Make a copy of the new bar and remove it from stream datadt = data.datetime.date() # keep the date if self.lastdt == datadt: return False # skip bars that come again in the filter self.lastdt = datadt # keep ref to last seen bar # Make a copy of current data for ohlbar ohlbar = [data.lines[i][0] for i in range(data.size())] closebar = ohlbar[:] # Make a copy for the close # replace close price with o-h-l average ohlprice = ohlbar[data.Open] + ohlbar[data.High] + ohlbar[data.Low] ohlbar[data.Close] = ohlprice / 3.0 vol = ohlbar[data.Volume] # adjust volume ohlbar[data.Volume] = vohl = int(vol * (1.0 - self.p.closevol)) oi = ohlbar[data.OpenInterest] # adjust open interst ohlbar[data.OpenInterest] = 0 # Adjust times dt = datetime.datetime.combine(datadt, data.p.sessionstart) ohlbar[data.DateTime] = data.date2num(dt) # Ajust closebar to generate a single tick -\u0026gt; close price closebar[data.Open] = cprice = closebar[data.Close] closebar[data.High] = cprice closebar[data.Low] = cprice closebar[data.Volume] = vol - vohl ohlbar[data.OpenInterest] = oi # Adjust times dt = datetime.datetime.combine(datadt, data.p.sessionend) closebar[data.DateTime] = data.date2num(dt) # Update stream data.backwards(force=True) # remove the copied bar from stream data._add2stack(ohlbar) # add ohlbar to stack # Add 2nd part to stash to delay processing to next round data._add2stack(closebar, stash=True) return False # initial tick can be further processed from stack"},{"id":20,"href":"/backtrader/docs/12-analyzers/02-pyfolio/","title":"Pyfolio","section":"Analyzer","content":"PyFolio# 注意，截至（至少）2017-07-25，pyfolio 的 API 已更改，create_full_tear_sheet 不再有 gross_lev 作为命名参数。因此，集成示例无法正常工作。\n引用 pyfolio 主页面 http://quantopian.github.io/pyfolio/ 的内容： pyfolio 是一个由 Quantopian Inc. 开发的用于金融投资组合的表现和风险分析的 Python 库。它与开源回测库 Zipline 配合良好，现在它也可以很好地与 backtrader 配合。所需的内容包括：\n显然需要 pyfolio 以及它的依赖项（如 pandas、seaborn 等） 注意，在与 0.5.1 版本集成期间，需要更新依赖项的最新版本，例如将之前安装的 seaborn 从 0.7.0-dev 更新到 0.7.1，显然是由于缺少方法 swarmplot。\n用法# 将 PyFolio 分析器添加到 cerebro 中：\ncerebro.addanalyzer(bt.analyzers.PyFolio)运行并检索第一个策略：\nstrats = cerebro.run() strat0 = strats[0]使用你给分析器命名的名称或默认名称（pyfolio）来检索分析器。例如：\npyfolio = strats.analyzers.getbyname(\u0026#39;pyfolio\u0026#39;)使用分析器方法 get_pf_items 检索 pyfolio 后续需要的四个组件：\nreturns, positions, transactions, gross_lev = pyfolio.get_pf_items()注意\n集成是通过查看 pyfolio 的测试样本并复制相同的标题（或缺少的部分）来完成的。\n与 pyfolio 一起工作（这已经超出了 backtrader 生态系统的范围）\n一些与 backtrader 无关的使用注意事项：\npyfolio 自动绘图在 Jupyter Notebook 之外也能工作，但在 Notebook 内部效果最好。 pyfolio 数据表的输出在 Jupyter Notebook 之外几乎不起作用，但在 Notebook 内部可以正常工作。 结论很简单，如果希望使用 pyfolio：在 Jupyter Notebook 内工作。\n示例代码 代码看起来像这样：\n... cerebro.addanalyzer(bt.analyzers.PyFolio, _name=\u0026#39;pyfolio\u0026#39;) ... results = cerebro.run() strat = results[0] pyfoliozer = strat.analyzers.getbyname(\u0026#39;pyfolio\u0026#39;) returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items() ... ... # pyfolio showtime import pyfolio as pf pf.create_full_tear_sheet( returns, positions=positions, transactions=transactions, gross_lev=gross_lev, live_start_date=\u0026#39;2005-05-01\u0026#39;, # 此日期是样本特定的 round_trips=True) # 此时表格和图表将显示参考# 查看分析器参考以了解 PyFolio 分析器及其内部使用的分析器。\n"},{"id":21,"href":"/backtrader/docs/15-livetrading/02-qanda-v1-0/","title":"Qanda","section":"实盘","content":"Oanda# Oanda的集成支持以下功能：\n实时数据馈送 实时交易 要求# oandapy：可以通过以下命令安装：pip install git+https://github.com/oanda/oandapy.git pytz（可选，不推荐）：由于外汇市场的全球性和24x7的特点，选择使用UTC时间。如果愿意，仍然可以使用所需的输出时区。 示例代码# 源代码中包含完整示例：\nsamples/oandatest/oandatest.py\nOanda - 存储# 存储是实时数据馈送和交易支持的核心，提供了Oanda API和数据馈送及经纪代理之间的适配层。\n可以通过以下方法获取经纪商实例：\nOandaStore.getbroker(*args, **kwargs)可以通过以下方法获取数据馈送实例：\nOandaStore.getdata(*args, **kwargs)在这种情况下，许多**kwargs是数据馈送的常见参数，如dataname、fromdate、todate、sessionstart、sessionend、timeframe、compression。\n数据可能提供其他参数。请参阅下面的参考。\n必要参数# 为了成功连接到Oanda，以下参数是必要的：\ntoken（默认：无）：API访问令牌 account（默认：无）：账户ID 这些由Oanda提供。\n无论是连接到模拟服务器还是真实服务器，请使用：\npractice（默认：False）：使用测试环境 账户需要定期检查以获取现金和价值。周期性可以通过以下方式控制：\naccount_tmout（默认：10.0）：刷新账户价值/现金刷新周期 Oanda数据馈送# 实例化数据时：\n按照Oanda指南传递符号。例如，EUR/USD根据Oanda的指南需要指定为EUR_USD。实例化如下：\ndata = oandastore.getdata(dataname=\u0026#39;EUR_USD\u0026#39;, ...)时间管理# 除非传递了tz参数（一个pytz兼容对象）给数据馈送，否则所有时间输出都以UTC格式表示，如上所述。\n回填# backtrader不会向Oanda发出特殊请求。对于小时间框架，Oanda在模拟服务器上返回的回填数据长度为500个柱。\nOandaBroker - 实时交易# 使用经纪商# 要使用OandaBroker，需要替换cerebro创建的标准经纪商模拟实例。\n使用存储模型（推荐）：\nimport backtrader as bt cerebro = bt.Cerebro() oandastore = bt.stores.OandaStore() cerebro.broker = oandastore.getbroker() # 或 cerebro.setbroker(...)经纪商 - 初始头寸# 经纪商支持一个参数：\nuse_positions（默认：True）：连接到经纪商提供商时使用现有头寸来启动经纪商。 在实例化时设置为False以忽略任何现有头寸。 操作# 使用方面没有变化。只需使用策略中提供的方法（请参阅策略参考以获取完整说明）：\nbuy sell close cancel 订单执行类型# Oanda支持几乎所有backtrader需要的订单执行类型，除了Close。因此，订单执行类型限于：\nOrder.Market Order.Limit Order.Stop Order.StopLimit（使用Stop和upperBound/lowerBound价格） Order.StopTrail 通过使用takeprofit和stoploss订单成员并创建内部模拟订单来支持括号订单。\n订单有效期# backtrader在回测期间可用的相同有效期概念（使用valid参数买入和卖出）在此也可用，并具有相同含义。因此，Oanda订单的有效期参数转换如下：\nNone 转换为 Good Til Cancelled 因为未指定有效期，理解为订单必须有效直到取消。 datetime/date 转换为 Good Til Date timedelta(x) 转换为 Good Til Date（这里timedelta(x)不等于timedelta()） 解释为订单有效从现在起加上timedelta(x)。 timedelta() 或 0 转换为 Session 传递了一个值（而不是None），但为空值，解释为当天（会话）有效的订单。 通知# 标准订单状态将通过策略的notify_order方法通知（如果覆盖）。\nSubmitted - 订单已发送到TWS Accepted - 订单已被放置 Rejected - 用于真正的拒绝以及在订单创建过程中没有其他已知状态时 Partial - 部分执行已发生 Completed - 订单已完全执行 Canceled（或 Cancelled） Expired - 当订单因过期而取消时 参考# OandaStore# class backtrader.stores.OandaStore()控制与Oanda连接的单例类。\n参数：\ntoken（默认：无）：API访问令牌 account（默认：无）：账户ID practice（默认：False）：使用测试环境 account_tmout（默认：10.0）：刷新账户价值/现金刷新周期 OandaBroker# class backtrader.brokers.OandaBroker(**kwargs)Oanda的经纪商实现。\n该类将Oanda的订单/头寸映射到backtrader的内部API。\n参数：\nuse_positions（默认：True）：连接到经纪商提供商时使用现有头寸来启动经纪商。 在实例化时设置为False以忽略任何现有头寸。 OandaData# class backtrader.feeds.OandaData(**kwargs)Oanda数据馈送。\n参数：\nqcheck（默认：0.5）：在没有数据接收时唤醒的时间（秒），以便适当地重采样/重放数据包并将通知上传到链中。 historical（默认：False）：如果设置为True，数据馈送将在首次下载数据后停止。 将使用标准数据馈送参数fromdate和todate作为参考。 如果请求的持续时间大于IB在给定时间框架/压缩组合下允许的持续时间，数据馈送将进行多次请求。 backfill_start（默认：True）：在启动时执行回填。将通过单个请求获取最大可能的历史数据。 backfill（默认：True）：在断开/重新连接周期后执行回填。将使用间隙持续时间下载最小可能的数据量。 backfill_from（默认：None）：可以传递另一个数据源以进行初始回填。一旦数据源耗尽，如果需要，将从IB回填。理想情况下，这意味着从已存储的来源（如磁盘上的文件）进行回填，但不限于此。 bidask（默认：True）：如果为True，则历史/回填请求将请求服务器的买卖价。 如果为False，则请求中间价。 useask（默认：False）：如果为True，则使用买卖价的卖价部分，而不是默认使用买价。 includeFirst（默认：True）：通过直接将参数设置为Oanda API调用，影响历史/回填请求的第一个柱的交付。 reconnect（默认：True）：当网络连接断开时重新连接。 reconnections（默认：-1）：尝试重新连接的次数：-1表示永远。 reconntimeout（默认：5.0）：重新连接尝试之间的等待时间（秒）。 此数据馈送仅支持以下时间框架和压缩的映射，这符合OANDA API开发者指南中的定义：\n(TimeFrame.Seconds, 5): 'S5' (TimeFrame.Seconds, 10): 'S10' (TimeFrame.Seconds, 15): 'S15' (TimeFrame.Seconds, 30): 'S30' (TimeFrame.Minutes, 1): 'M1' (TimeFrame.Minutes, 2): 'M3' (TimeFrame.Minutes, 3): 'M3' (TimeFrame.Minutes, 4): 'M4' (TimeFrame.Minutes, 5): 'M5' (TimeFrame.Minutes, 10): 'M10' (TimeFrame.Minutes, 15): 'M15' (TimeFrame.Minutes, 30): 'M30' (TimeFrame.Minutes, 60): 'H1' (TimeFrame.Minutes, 120): 'H2' (TimeFrame.Minutes, 180): 'H3' (TimeFrame.Minutes, 240): 'H4' (TimeFrame.Minutes, 360): 'H6'\n(TimeFrame.Minutes, 480): 'H8' (TimeFrame.Days, 1): 'D' (TimeFrame.Weeks, 1): 'W' (TimeFrame.Months, 1): 'M' 其他任何组合将被拒绝。\n"},{"id":22,"href":"/backtrader/docs/07-strategy/02-strategy-with-signals/","title":"信号策略","section":"Strategy","content":"信号策略# 使用 backtrader 进行操作不一定非得编写一个策略类。虽然这是首选方式，但由于对象层次结构的原因，使用信号也是可行的。\n快速总结：# 不需要编写策略类、实例化指标、编写买卖逻辑等。 添加信号（无论如何也是指标），其余部分在后台完成。 快速示例：# import backtrader as bt data = bt.feeds.OneOfTheFeeds(dataname=\u0026#39;mydataname\u0026#39;) cerebro.adddata(data) cerebro.add_signal(bt.SIGNAL_LONGSHORT, MySignal) cerebro.run()这就完成了。当然，信号本身还没有定义。\n让我们定义一个非常简单的信号：\n如果收盘价高于简单移动平均线 (SMA)，则发出多头信号。 如果收盘价低于 SMA，则发出空头信号。 定义如下：\nclass MySignal(bt.Indicator): lines = (\u0026#39;signal\u0026#39;,) params = ((\u0026#39;period\u0026#39;, 30),) def __init__(self): self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period)现在真的完成了。\n当运行 run 时，Cerebro 会处理实例化一个特殊的策略实例，它知道如何处理这些信号。\n常见问题# 买卖操作的数量是如何确定的？\nCerebro 实例自动为策略添加一个固定大小 (FixedSize) 的定量器。最终用户可以通过 cerebro.addsizer 更改定量器以改变策略。\n订单是如何执行的？\n执行类型为市价单，订单的有效期为“直到取消” (Good Until Canceled)。\n信号细节# 从技术和理论角度来看，可以描述为：\n一个可调用对象，当被调用时返回另一个对象（只调用一次）。 在大多数情况下，这是一个类的实例化，但不一定非得是。 支持 __getitem__ 接口。唯一请求的键/索引将是 0。 从实际角度来看，信号是：\n来自 backtrader 生态系统的 lines 对象，主要是指标。 这在使用其他指标时很有帮助，比如示例中的简单移动平均线。\n信号指示# 信号在使用 signal[0] 查询时提供指示，含义如下：\n\u0026gt; 0 -\u0026gt; 多头指示 \u0026lt; 0 -\u0026gt; 空头指示 == 0 -\u0026gt; 无指示 示例中，简单地用 self.data - SMA 进行算术运算：\n当数据高于 SMA 时发出多头指示。 当数据低于 SMA 时发出空头指示。 注意，当未为数据指示特定价格字段时，默认参考价格为收盘价。\n信号类型# 如下示例中的常量，直接从主 backtrader 模块获取：\nimport backtrader as bt bt.SIGNAL_LONG有 5 种类型的信号，分为 2 组。\n主要组# LONGSHORT：接受来自该信号的多头和空头指示。\nLONG：\n接受多头指示进行做多。\n接受空头指示平仓多头。但：\n如果系统中有 LONGEXIT 信号，将用它来平仓多头。 如果有 SHORT 信号且没有 LONGEXIT 信号，它将被用来平仓多头再开空头。 SHORT：\n接受空头指示进行做空。 接受多头指示平仓空头。但：\n如果系统中有 SHORTEXIT 信号，将用它来平仓空头。 如果有 LONG 信号且没有 SHORTEXIT 信号，它将被用来平仓空头再开多头。 退出组# 这两个信号旨在覆盖其他信号，并为平仓提供标准。\nLONGEXIT：接受空头指示平仓多头。 SHORTEXIT：接受多头指示平仓空头。 累积和订单并发# 上面展示的示例信号会不断发出多头和空头指示，因为它只是简单地用收盘价减去 SMA 值，这总是会得到 \u0026gt; 0 或 \u0026lt; 0 的结果（0 在数学上是可能的，但实际发生的可能性很小）。\n这将导致连续生成订单，从而产生两种情况：\n累积：即使已经在市场中，信号也会产生新订单，增加市场仓位。 并发：在其他订单执行之前会生成新订单。 为了避免这种情况，默认行为是：\n不累积。 不允许并发。 如果需要其中任何一种行为，可以通过 Cerebro 控制：\ncerebro.signal_accumulate(True) # 或 False 禁用 cerebro.signal_concurrency(True) # 或 False 禁用示例# backtrader 源代码包含一个测试功能的示例。\n主要信号如下：\nclass SMACloseSignal(bt.Indicator): lines = (\u0026#39;signal\u0026#39;,) params = ((\u0026#39;period\u0026#39;, 30),) def __init__(self): self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period)如果指定了退出信号，代码如下：\nclass SMAExitSignal(bt.Indicator): lines = (\u0026#39;signal\u0026#39;,) params = ((\u0026#39;p1\u0026#39;, 5), (\u0026#39;p2\u0026#39;, 30),) def __init__(self): sma1 = bt.indicators.SMA(period=self.p.p1) sma2 = bt.indicators.SMA(period=self.p.p2) self.lines.signal = sma1 - sma2第一次运行：多头和空头\n$ ./signals-strategy.py --plot --signal longshort输出：\n信号被绘制。因为它只是一个指标，所以适用绘图规则。 策略确实做多和做空。因为现金水平从未回到价值水平。 第二次运行：仅多头\n$ ./signals-strategy.py --plot --signal longonly输出：\n现金水平在每次卖出后回到价值水平，说明策略在市场之外。 第三次运行：仅空头\n$ ./signals-strategy.py --plot --signal shortonly输出：\n第一次操作是卖出，发生在收盘价低于 SMA 且简单减法得到负值之后。 现金水平在每次买入后回到价值水平，说明策略在市场之外。 第四次运行：多头 + 多头退出\n$ ./signals-strategy.py --plot --signal longonly --exitsignal longexit输出：\n许多交易是相同的，但一些较早被中断，因为退出信号中的快速移动平均线向下穿过慢速移动平均线。 系统显示其仅做多特性，每笔交易结束时现金成为价值。 使用方法# $ ./signals-strategy.py --help完整示例# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import collections import datetime import backtrader as bt MAINSIGNALS = collections.OrderedDict( ((\u0026#39;longshort\u0026#39;, bt.SIGNAL_LONGSHORT), (\u0026#39;longonly\u0026#39;, bt.SIGNAL_LONG), (\u0026#39;shortonly\u0026#39;, bt.SIGNAL_SHORT),) ) EXITSIGNALS = { \u0026#39;longexit\u0026#39;: bt.SIGNAL_LONGEXIT, \u0026#39;shortexit\u0026#39;: bt.SIGNAL_LONGEXIT, } class SMACloseSignal(bt.Indicator): lines = (\u0026#39;signal\u0026#39;,) params = ((\u0026#39;period\u0026#39;, 30),) def __init__(self): self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period) class SMAExitSignal(bt.Indicator): lines = (\u0026#39;signal\u0026#39;,) params = ((\u0026#39;p1\u0026#39;, 5), (\u0026#39;p2\u0026#39;, 30),) def __init__(self): sma1 = bt.indicators.SMA(period=self.p.p1) sma2 = bt.indicators.SMA(period=self.p.p2) self.lines.signal = sma1 - sma2 def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() cerebro.broker.set_cash(args.cash) dkwargs = dict() if args.fromdate is not None: fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;fromdate\u0026#39;] = fromdate if args.todate is not None: todate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;todate\u0026#39;] = todate data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs) cerebro.adddata(data) cerebro.add_signal(MAINSIGNALS[args.signal], SMACloseSignal, period=args.smaperiod) if args.ex itsignal is not None: cerebro.add_signal(EXITSIGNALS[args.exitsignal], SMAExitSignal, p1=args.exitperiod, p2=args.smaperiod) cerebro.run() if args.plot: pkwargs = dict(style=\u0026#39;bar\u0026#39;) if args.plot is not True: npkwargs = eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;) pkwargs.update(npkwargs) cerebro.plot(**pkwargs) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample for Signal concepts\u0026#39;) parser.add_argument(\u0026#39;--data\u0026#39;, required=False, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, help=\u0026#39;Specific data to be read in\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=None, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=None, help=\u0026#39;Ending date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--cash\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=float, default=50000, help=(\u0026#39;Cash to start with\u0026#39;)) parser.add_argument(\u0026#39;--smaperiod\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=int, default=30, help=(\u0026#39;Period for the moving average\u0026#39;)) parser.add_argument(\u0026#39;--exitperiod\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=int, default=5, help=(\u0026#39;Period for the exit control SMA\u0026#39;)) parser.add_argument(\u0026#39;--signal\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=MAINSIGNALS.keys()[0], choices=MAINSIGNALS, help=(\u0026#39;Signal type to use for the main signal\u0026#39;)) parser.add_argument(\u0026#39;--exitsignal\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=None, choices=EXITSIGNALS, help=(\u0026#39;Signal type to use for the exit signal\u0026#39;)) parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, nargs=\u0026#39;?\u0026#39;, required=False, metavar=\u0026#39;kwargs\u0026#39;, const=True, help=(\u0026#39;Plot the read data applying any kwargs passed\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39;For example:\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39; --plot style=\u0026#34;candle\u0026#34; (to plot candles)\\n\u0026#39;)) if pargs is not None: return parser.parse_args(pargs) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":23,"href":"/backtrader/docs/09-orders/02-creation-execution/","title":"创建/执行","section":"Order","content":"订单管理和执行# 对于订单管理，Backtrader 提供了3种基本操作：\nbuy sell cancel 注意：：一个更新操作显然是合乎逻辑的，但常识告诉我们，这种方法主要用于使用判断性交易方法的手动操作员。\n对于订单执行逻辑，提供以下执行类型：\n市价订单（Market） 收盘价订单（Close） 限价订单（Limit） 止损订单（Stop） 止损限价订单（StopLimit） 订单管理# 一些示例：\n# 购买主数据，使用sizer的默认股份，市价订单 order = self.buy() # 市价订单 - 有效期将被 \u0026#34;忽略\u0026#34; order = self.buy(valid=datetime.datetime.now() + datetime.timedelta(days=3)) # 市价订单 - 价格将被忽略 order = self.buy(price=self.data.close[0] * 1.02) # 市价订单 - 手动股份 order = self.buy(size=25) # 限价订单 - 想要设置价格并可以设置有效期 order = self.buy(exectype=Order.Limit, price=self.data.close[0] * 1.02, valid=datetime.datetime.now() + datetime.timedelta(days=3)) # 止损限价订单 - 想要设置价格，价格限制 order = self.buy(exectype=Order.StopLimit, price=self.data.close[0] * 1.02, plimit=self.data.close[0] * 1.07) # 取消现有订单 self.broker.cancel(order)注意：\n所有订单类型都可以通过创建一个订单实例（或其子类之一）并传递给 broker 来创建：\norder = self.broker.submit(order)注意：\nBroker 中也有 buy 和 sell 操作，但它们对默认参数的容忍度较低。\n订单执行逻辑# Broker 使用两个主要指导原则（假设？）进行订单执行。\n原则一# 当前数据已经发生，不能用于执行订单。\n如果策略中的逻辑类似于：\nif self.data.close \u0026gt; self.sma: # 其中 sma 是简单移动平均线 self.buy()期望不能是订单将以逻辑中检查的收盘价执行，因为它已经发生。\n原则二# 订单可以在下一组开盘/最高/最低/收盘价格范围内首先执行（以及订单中设置的条件）。\n原则三# 成交量不起作用，实际交易中，如果交易者选择非流动性资产或恰好触及价格栏的高/低点，它实际上会起作用。\n但触及高/低点的情况很少发生（如果发生……你不需要 backtrader），所选择的资产将有足够的流动性来吸收任何正常交易的订单。\n市价订单（Market）# 执行：\n下一个价格栏的开盘价（通常称为 bar） 理由：\n如果逻辑在时间点 X 执行并发出市价订单，下一个将发生的价格点是即将到来的开盘价。 注意：\n该订单始终执行，并忽略任何用于创建它的价格和有效期参数。 收盘价订单（Close）# 执行：\n使用下一个价格栏的收盘价，当下一个价格栏实际关闭时。 理由：\n大多数回测数据源已经包含已关闭的价格栏，订单将立即以下一个价格栏的收盘价执行。日数据源是最常见的示例。 但系统可以被“tick”价格喂入，实际的价格栏（时间/日期）不断被新 tick 更新，而不会移动到下一个价格栏（因为时间和/或日期未改变）。 只有当时间或日期改变时，价格栏才真正关闭，订单才执行。 限价订单（Limit）# 执行：\n如果数据触及在订单创建时设置的价格，则从下一个价格栏开始执行。 如果设置了有效期并到达时间点，订单将被取消。 价格匹配：\nbacktrader 尝试为限价订单提供最现实的执行价格。 使用4个价格点（开盘价/最高价/最低价/收盘价）可以部分推断出请求的价格是否可以改进。 对于买入订单： 情况1：如果价格栏的开盘价低于限价，订单立即以开盘价执行。订单在会话的开盘阶段被扫除。 情况2：如果开盘价没有低于限价，但最低价低于限价，那么限价在会话期间已经出现，订单可以执行。 对于卖出订单，逻辑显然是相反的。 止损订单（Stop）# 执行：\n如果数据触及在订单创建时设置的触发价格，则从下一个价格栏开始执行。 如果设置了有效期并到达时间点，订单将被取消。 价格匹配：\nbacktrader 尝试为止损订单提供最现实的触发价格。 使用4个价格点（开盘价/最高价/最低价/收盘价）可以部分推断出请求的价格是否可以改进。 对于买入的止损订单： 情况1：如果价格栏的开盘价高于止损价，订单立即以开盘价执行。旨在停止亏损，如果价格上涨对现有空头头寸不利。 情况2：如果开盘价没有高于止损价，但最高价高于止损价，那么止损价在会话期间已经出现，订单可以执行。 对于卖出订单，逻辑显然是相反的。 止损限价订单（StopLimit）# 执行：\n触发价格从下一个价格栏开始启动订单。 价格匹配：\n触发：使用止损匹配逻辑（但仅触发并将订单转变为限价订单）。 限价：使用限价匹配逻辑。 一些示例# 正如图片（带代码）所示，总是胜过几百万字的长篇解释。请注意，代码段集中在订单创建部分。完整代码在底部。\n将使用一个价格在简单移动平均线上/下方收盘的策略来生成买入/卖出信号。\n信号在图表底部可见：使用交叉指示器的交叉信号。\n将保存生成的“买入”订单的引用，以只允许系统中最多同时存在一个订单。\n执行类型：市价订单（Market）# 在图表中可以看到订单在生成信号后一根价格栏后以开盘价执行。\nif self.p.exectype == \u0026#39;Market\u0026#39;: self.buy(exectype=bt.Order.Market) # 如果未给定，则默认 self.log(\u0026#39;BUY CREATE, exectype Market, price %.2f\u0026#39; % self.data.close[0])执行类型：收盘价订单（Close）# 现在订单也是在生成信号后一根价格栏后执行，但以收盘价执行。\nelif self.p.exectype == \u0026#39;Close\u0026#39;: self.buy(exectype=bt.Order.Close) self.log(\u0026#39;BUY CREATE, exectype Close, price %.2f\u0026#39; % self.data.close[0])执行类型：限价订单（Limit）# 有效期在传递为参数时会提前计算。\nif self.p.valid: valid = self.data.datetime.date(0) + datetime.timedelta(days=self.p.valid) else: valid = None设置一个比信号生成价格（信号栏的收盘价）低1%的限价。请注意，这阻止了上面许多订单的执行。\nelif self.p.exectype == \u0026#39;Limit\u0026#39;: price = self.data.close * (1.0 - self.p.perc1 / 100.0) self.buy(exectype=bt.Order.Limit, price=price, valid=valid) if self.p.valid: txt = \u0026#39;BUY CREATE, exectype Limit, price %.2f, valid: %s\u0026#39; self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;))) else: txt = \u0026#39;BUY CREATE, exectype Limit, price %.2f\u0026#39; self.log(txt % price)执行类型：带有效期的限价订单# 为了不永远等待一个可能只在价格对“买入”订单不利时执行的限价订单，订单只会有效4个（日历）天。\n$ ./order-execution-samples.py --exectype Limit --perc1 1 --valid 4执行类型：止损订单（Stop）# 设置一个比信号价格\n高1%的止损价格。这意味着策略只有在信号生成后价格继续上涨时才买入，这可以解释为一种强劲信号。\nelif self.p.exectype == \u0026#39;Stop\u0026#39;: price = self.data.close * (1.0 + self.p.perc1 / 100.0) self.buy(exectype=bt.Order.Stop, price=price, valid=valid) if self.p.valid: txt = \u0026#39;BUY CREATE, exectype Stop, price %.2f, valid: %s\u0026#39; self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;))) else: txt = \u0026#39;BUY CREATE, exectype Stop, price %.2f\u0026#39; self.log(txt % price)执行类型：止损限价订单（StopLimit）# 设置一个比信号价格高1%的止损价格。但限价设置为比信号（收盘）价格高0.5%，这可以解释为：等待强劲信号的出现，但不要买入高点。等待下跌。\nelif self.p.exectype == \u0026#39;StopLimit\u0026#39;: price = self.data.close * (1.0 + self.p.perc1 / 100.0) plimit = self.data.close * (1.0 + self.p.perc2 / 100.0) self.buy(exectype=bt.Order.StopLimit, price=price, valid=valid, plimit=plimit) if self.p.valid: txt = (\u0026#39;BUY CREATE, exectype StopLimit, price %.2f,\u0026#39; \u0026#39; valid: %s, pricelimit: %.2f\u0026#39;) self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;), plimit)) else: txt = (\u0026#39;BUY CREATE, exectype StopLimit, price %.2f,\u0026#39; \u0026#39; pricelimit: %.2f\u0026#39;) self.log(txt % (price, plimit))测试脚本执行# 详见命令行帮助：\n$ ./order-execution-samples.py --help usage: order-execution-samples.py [-h] [--infile INFILE] [--csvformat {bt,visualchart,sierrachart,yahoo,yahoo_unreversed}] [--fromdate FROMDATE] [--todate TODATE] [--plot] [--plotstyle {bar,line,candle}] [--numfigs NUMFIGS] [--smaperiod SMAPERIOD] [--exectype EXECTYPE] [--valid VALID] [--perc1 PERC1] [--perc2 PERC2]完整代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import os.path import time import sys import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind class OrderExecutionStrategy(bt.Strategy): params = ( (\u0026#39;smaperiod\u0026#39;, 15), (\u0026#39;exectype\u0026#39;, \u0026#39;Market\u0026#39;), (\u0026#39;perc1\u0026#39;, 3), (\u0026#39;perc2\u0026#39;, 1), (\u0026#39;valid\u0026#39;, 4), ) def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39; Logging function for this strategy\u0026#39;\u0026#39;\u0026#39; dt = dt or self.data.datetime[0] if isinstance(dt, float): dt = bt.num2date(dt) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: # Buy/Sell order submitted/accepted to/by broker - Nothing to do self.log(\u0026#39;ORDER ACCEPTED/SUBMITTED\u0026#39;, dt=order.created.dt) self.order = order return if order.status in [order.Expired]: self.log(\u0026#39;BUY EXPIRED\u0026#39;) elif order.status in [order.Completed]: if order.isbuy(): self.log( \u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: # Sell self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) # Sentinel to None: new orders allowed self.order = None def __init__(self): # SimpleMovingAverage on main data # Equivalent to -\u0026gt; sma = btind.SMA(self.data, period=self.p.smaperiod) sma = btind.SMA(period=self.p.smaperiod) # CrossOver (1: up, -1: down) close / sma self.buysell = btind.CrossOver(self.data.close, sma, plot=True) # Sentinel to None: new orders allowed self.order = None def next(self): if self.order: # An order is pending ... nothing can be done return # Check if we are in the market if self.position: # In the market - check if it\u0026#39;s the time to sell if self.buysell \u0026lt; 0: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.data.close[0]) self.sell() elif self.buysell \u0026gt; 0: if self.p.valid: valid = self.data.datetime.date(0) + \\ datetime.timedelta(days=self.p.valid) else: valid = None # Not in the market and signal to buy if self.p.exectype == \u0026#39;Market\u0026#39;: self.buy(exectype=bt.Order.Market) # default if not given self.log(\u0026#39;BUY CREATE, exectype Market, price %.2f\u0026#39; % self.data.close[0]) elif self.p.exectype == \u0026#39;Close\u0026#39;: self.buy(exectype=bt.Order.Close) self.log(\u0026#39;BUY CREATE, exectype Close, price %.2f\u0026#39; % self.data.close[0]) elif self.p.exectype == \u0026#39;Limit\u0026#39;: price = self.data.close * (1.0 - self.p.perc1 / 100.0) self.buy(exectype=bt.Order.Limit, price=price, valid=valid) if self.p.valid: txt = \u0026#39;BUY CREATE, exectype Limit, price %.2f, valid: %s\u0026#39; self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;))) else: txt = \u0026#39;BUY CREATE, exectype Limit, price %.2f\u0026#39; self.log(txt % price) elif self.p.exectype == \u0026#39;Stop\u0026#39;: price = self.data.close * (1.0 + self.p.perc1 / 100.0) self.buy(exectype=bt.Order.Stop, price=price, valid=valid) if self.p.valid: txt = \u0026#39;BUY CREATE, exectype Stop, price %.2f, valid: %s\u0026#39; self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;))) else: txt = \u0026#39;BUY CREATE, exectype Stop, price %.2f\u0026#39; self.log(txt % price) elif self.p.exectype == \u0026#39;StopLimit\u0026#39;: price = self.data.close * (1.0 + self.p.perc1 / 100.0) plimit = self.data.close * (1.0 + self.p.perc2 / 100.0) self.buy(exectype=bt.Order.StopLimit, price=price, valid=valid, plimit=plimit) if self.p.valid: txt = (\u0026#39;BUY CREATE, exectype StopLimit, price %.2f,\u0026#39; \u0026#39; valid: %s, pricelimit: %.2f\u0026#39;) self.log(txt % (price, valid.strftime(\u0026#39;%Y-%m-%d\u0026#39;), plimit)) else: txt = (\u0026#39;BUY CREATE, exectype StopLimit, price %.2f,\u0026#39; \u0026#39; pricelimit: %.2f\u0026#39;) self.log(txt % (price, plimit)) def runstrat(): args = parse_args() cerebro = bt.Cerebro() data = getdata(args) cerebro.adddata(data) cerebro.addstrategy( OrderExecutionStrategy, exectype=args.exectype, perc1=args.perc1, perc2=args.perc2, valid=args.valid, smaperiod=args.smaperiod ) cerebro.run() if args.plot: cerebro.plot(numfigs=args.numfigs, style=args.plotstyle) def getdata(args): dataformat = dict( bt=btfeeds.BacktraderCSVData, visualchart=btfeeds.VChartCSVData, sierrachart=btfeeds.SierraChartCSVData, yahoo=btfeeds.YahooFinanceCSVData, yahoo_unreversed=btfeeds.YahooFinanceCSVData ) dfkwargs = dict() if args.csvformat == \u0026#39;yahoo_unreversed\u0026#39;: dfkwargs[\u0026#39;reverse\u0026#39;] = True if args.fromdate: fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) dfkwargs[\u0026#39;fromdate\u0026#39;] = fromdate if args.todate: fromdate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) dfkwargs[\u0026#39;todate\u0026#39;] = todate dfkwargs[\u0026#39;dataname\u0026#39;] = args.infile dfcls = dataformat[args.csvformat] return dfcls(**dfkwargs) def parse_args(): parser = argparse.ArgumentParser( description=\u0026#39;Showcase for Order Execution Types\u0026#39;) parser.add_argument(\u0026#39;--infile\u0026#39;, \u0026#39;-i\u0026#39;, required=False, default=\u0026#39;../../datas/2006-day-001.txt\u0026#39;, help=\u0026#39;File to be read in\u0026#39;) parser.add_argument(\u0026#39;--csvformat\u0026#39;, \u0026#39;-c\u0026#39;, required=False, default=\u0026#39;bt\u0026#39;, choices=[\u0026#39;bt\u0026#39;, \u0026#39;visualchart\u0026#39;, \u0026#39;sierrachart\u0026#39;, \u0026#39;yahoo\u0026#39;, \u0026#39;yahoo_unreversed\u0026#39;], help=\u0026#39;CSV Format\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, \u0026#39;-f\u0026#39;, required=False, default=None, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, \u0026#39;-t\u0026#39;, required=False, default=None, help=\u0026#39;Ending date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, action=\u0026#39;store_false\u0026#39;, required=False, help=\u0026#39;Plot the read data\u0026#39;) parser.add_argument(\u0026#39;--plotstyle\u0026#39;, \u0026#39;-ps\u0026#39;, required=False, default=\u0026#39;bar\u0026#39;, choices=[\u0026#39;bar\u0026#39;, \u0026#39;line\u0026#39;, \u0026#39;candle\u0026#39;], help=\u0026#39;Plot the read data\u0026#39;) parser.add_argument(\u0026#39;--numfigs\u0026#39;, \u0026#39;-n\u0026#39;, required=False, default=1, help=\u0026#39;Plot using n figures\u0026#39;) parser.add_argument(\u0026#39;--smaperiod\u0026#39;, \u0026#39;-s\u0026#39;, required=False, default=15, help=\u0026#39;Simple Moving Average Period\u0026#39;) parser.add_argument(\u0026#39;--exectype\u0026#39;, \u0026#39;-e\u0026#39;, required=False, default=\u0026#39;Market\u0026#39;, help=(\u0026#39;Execution Type: Market (default), Close, Limit,\u0026#39; \u0026#39; Stop, StopLimit\u0026#39;)) parser.add_argument(\u0026#39;--valid\u0026#39;, \u0026#39;-v\u0026#39;, required=False, default=0, type=int, help=\u0026#39;Validity for Limit sample: default 0 days\u0026#39;) parser.add_argument(\u0026#39;--perc1\u0026#39;, \u0026#39;-p1\u0026#39;, required=False, default=0.0, type=float, help=(\u0026#39;%% distance from close price at order creation\u0026#39; \u0026#39; time for the limit/trigger price in Limit/Stop\u0026#39; \u0026#39; orders\u0026#39;)) parser.add_argument(\u0026#39;--perc2\u0026#39;, \u0026#39;-p2\u0026#39;, required=False, default=0.0, type=float, help=(\u0026#39;%% distance from close price at order creation\u0026#39; \u0026#39; time for the limit price in StopLimit orders\u0026#39;)) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":24,"href":"/backtrader/docs/05-cerebro/02-reference/","title":"参数说明","section":"Cerebro","content":"参数说明# 如下是 Cerebro 类的详细说明。\n实例化参数# 参数 默认值 说明 preload True 是否预加载传递给策略的不同数据源。 runonce True 以矢量化模式计算指标，从而提高整个系统的性能。\n注： 策略和观察者将始终基于事件运行。 live False 如果没有数据报告为实时（通过数据的islive方法，但用户仍希望以实时模式运行，可将此参数设为true。 maxcpus None 同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。 stdstats True） 如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。 oldbuysell False 如 stdstats 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。 oldtrades False 如果stdstats为True 且自动添加观察者，此开关控制交易观察者的主要行为。 exactbars False - False：默认值，将存储在 Line 中的值都保存到内存。-True或1：所有Line对象的内存使用减少至计算最小周期。如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。此设置将停用preload和runonce。使用此设置还将停用绘图。 -1：策略级别的数据源和指标/操作将保留所有数据在内存中。如 RSI 通过指标UpDay计算，不会将它的所有数据保留内存。 这允许保持绘图和预加载活动。runonce将被停用。-2：作为策略属性的数据源和指标将保留所有点在内存中。例如：RSI内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。- 这允许保持绘图和预加载活动。runonce将被停用。 objcache False 实验选项，用于实现 Line 对象的缓存并减少它们的数量。示例来自UltimateOscillator：bp = self.data.close - TrueLow(self.data) # -\u0026gt; 创建另一个 TrueLow(self.data)tr = TrueRange(self.data) 如果为True，TrueRange内部的第二个TrueLow(self.data)将匹配bp计算中的签名，并将被重用。可能发生的极端情况是这会使线对象超出其最小周期并导致问题，因此被禁用。 writer False 如果设置为True，将创建一个默认的WriterFile，它将打印到标准输出。它将被添加到策略中（除了用户代码添加的任何其他编写器）。 tradehistory False 如果设置为True，它将激活所有策略中每个交易的更新事件日志记录。也可以通过策略方法set_tradehistory在每个策略基础上完成。 optdatas True 如果为 True 且在优化（并且系统可以预加载和使用runonce），则数据预加载将仅在主进程中完成，以节省时间和资源。测试显示，执行时间从83秒减少到66秒，约20%的速度提升。 optreturn True 如果为True，优化结果将不会是完整的策略对象（和所有数据、指标、观察者\u0026hellip;），而是具有以下属性的对象（与策略相同）： params（或p） 无 执行策略时的参数。 analyzers 无 策略已执行的分析器。大多数情况下，仅需要分析器和参数来评估策略的性能。如果需要详细分析生成的值（例如指标），请将其关闭。测试显示，执行时间提高了13% - 15%。结合optdatas，总收益增加到32%。 oldsync False 从版本1.9.0.99开始，多个数据（相同或不同时间框架）的同步已更改，以允许不同长度的数据。如果希望使用数据0作为系统主控的数据的旧行为，请将此参数设置为True。 tz None 为策略添加全局时区。参数tz可以是：None：在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。pytz实例。将用作将UTC时间转换为所选时区。字符串。将尝试实例化pytz实例。整数。对于策略，使用self.datas可迭代对象中相应数据的相同时区（0将使用data0的时区）。 cheat_on_open False 将调用策略的next_open方法。这发生在next之前，并且在经纪人有机会评估订单之前。指标尚未重新计算。这允许发布考虑前一天指标的订单，但使用开盘价进行股份计算。对于cheat_on_open订单执行，还要调用 cerebro.broker.set_coo(True)或实例化一个BackBroker(coo=True)（coo表示cheat-on-open）或将broker_coo参数设置为True。除非在下文中禁用，否则Cerebro会自动执行此操作。 broker_coo True 这将自动调用经纪人的set_coo方法，并将其设置为True以激活cheat_on_open执行。只有在cheat_on_open也为True时才会执行。 quicknotify False 在传递下一个价格之前立即传递经纪人通知。对于回测没有影响，但对于实时经纪人，通知可能在条传递之前很久就发生。当设置为True时，将尽快传递通知（请参阅实时数据源中的qcheck）。为了兼容性，设置为False。可能会更改为True。 成员方法# addstorecb(callback) 添加一个回调以获取将由notify_store方法处理的消息。回调的签名必须支持以下内容：\ncallback(msg, *args, **kwargs)实际接收的msg、*args和**kwargs是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。\nnotify_store(msg, *args, **kwargs) 在cerebro中接收存储通知。此方法可以在Cerebro子类中覆盖。实际接收的msg、*args和**kwargs是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。\nadddatacb(callback) 添加一个回调以获取将由notify_data方法处理的消息。回调的签名必须支持以下内容：\ncallback(data, status, *args, **kwargs)实际接收的*args和**kwargs是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。\nnotify_data(data, status, *args, **kwargs) 在cerebro中接收数据通知。此方法可以在Cerebro子类中覆盖。实际接收的*args和**kwargs是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。\nadddata(data, name=None) 将数据源实例添加到混合中。如果name不为None，将放入data._name，用于装饰/绘图目的。\nresampledata(dataname, name=None, **kwargs) 添加数据源以供系统重新采样。如果name不为None，将放入data._name，用于装饰/绘图目的。任何其他如timeframe、compression、todate等支持的参数将透明地传递。\nreplaydata(dataname, name=None, **kwargs) 添加数据源以供系统重放。如果name不为None，将放入data._name，用于装饰/绘图目的。任何其他如timeframe、compression、todate等支持的参数将透明地传递。\nchaindata(*args, **kwargs) 将多个数据源链接为一个。如果作为命名参数传递并且name不为None，将放入data._name，用于装饰/绘图目的。如果为None，则使用第一个数据的名称。\nrolloverdata(*args, **kwargs) 将多个数据源链接为一个。如果作为命名参数传递并且name不为None，将放入data._name，用于装饰/绘图目的。如果为None，则使用第一个数据的名称。任何其他kwargs将传递给RollOver类。\naddstrategy(strategy, *args, **kwargs) 为单次运行添加策略类。在运行时进行实例化。args和kwargs将在实例化期间按原样传递给策略。返回的索引可以与添加其他对象（如Sizer）引用兼容。\noptstrategy(strategy, *args, **kwargs) 为优化添加策略类。在运行时进行实例化。args和kwargs必须是包含要检查值的可迭代对象。例如：如果策略接受参数period，为了优化目的，调用optstrategy如下：\ncerebro.optstrategy(MyStrategy, period=(15, 25))这将执行值为15和25的优化。而：\ncerebro.optstrategy(MyStrategy, period=range(15, 25))将以period值15 -\u0026gt; 25（25不包含，因为Python中的范围是半开的）执行MyStrategy。如果传递了一个参数但不应优化，调用如下：\ncerebro.optstrategy(MyStrategy, period=(15,))注意period仍然作为一个可迭代对象传递……只有一个元素。backtrader无论如何都会尝试识别如下情况：\ncerebro.optstrategy(MyStrategy, period=15)如果可能，将创建一个内部伪可迭代对象。\noptcallback(cb) 将回调添加到回调列表中，当每个策略运行时将与优化一起调用。签名：cb(strategy)。\naddindicator(indcls, *args, **kwargs) 添加指标类到混合中。在传递策略中进行实例化。\naddobserver(obscls, *args, **kwargs) 添加观察者类到混合中。在运行时进行实例化。\naddobservermulti(obscls, *args, **kwargs) 添加观察者类到混合中。在运行时进行实例化。将为系统中的每个数据添加一次。一个用例是观察单个数据的买入/卖出观察者。一个反例是观察系统范围值的CashValue。\naddanalyzer(ancls, *args, **kwargs) 添加分析器类到混合中。在运行时进行实例化。\naddwriter(wrtcls, *args, **kwargs) 添加编写器类到混合中。在cerebro中进行实例化。\nrun(**kwargs) 执行回测的核心方法。传递给它的任何kwargs将影响实例化时Cerebro的标准参数值。如果cerebro没有数据，该方法将立即退出。返回值不同：\n无优化： 包含使用addstrategy添加的策略类实例的列表。 优化： 包含使用addstrategy添加的策略类实例的列表的列表。\nrunstop() 如果从策略内部或其他地方（包括其他线程）调用，将尽快停止执行。\nsetbroker(broker) 为此策略设置特定的经纪人实例，替换从cerebro继承的经纪人。\ngetbroker() 返回经纪人实例。也可以通过broker属性访问。\nplot(plotter=None, numfigs=1, iplot=True, start=None, end=None, width=16, height=9, dpi=300, tight=True, use=None, **kwargs) 绘制cerebro中的策略。如果plotter为None，将创建一个默认的Plot实例，并在实例化期间将kwargs传递给它。\n`numfigs`将图表分成所指示的数量，以减少图表密度。\u0026lt;br/\u0026gt; `iplot`：如果为True且在笔记本中运行，图表将内联显示。\u0026lt;br/\u0026gt; `use`：将其设置为所需matplotlib后端的名称。它将优先于`iplot`。\u0026lt;br/\u0026gt; `start`：策略日期时间线数组的索引或表示绘图开始的`datetime.date`、`datetime.datetime`实例。\u0026lt;br/\u0026gt; `end`：策略日期时间线数组的索引或表示绘图结束的`datetime.date`、`datetime.datetime`实例。\u0026lt;br/\u0026gt; `width`：保存图形的宽度（以英寸为单位）。\u0026lt;br/\u0026gt; `height`：保存图形的高度（以英寸为单位）。\u0026lt;br/\u0026gt; `dpi`：保存图形的质量（以每英寸点数为单位）。\u0026lt;br/\u0026gt; `tight`：仅保存实际内容而不保存图形框架。 addsizer(sizercls, *args, **kwargs) 添加一个Sizer类（和args），作为添加到cerebro的任何策略的默认定量器。\naddsizer_byidx(idx, sizercls, *args, **kwargs) 按idx添加一个Sizer类。此idx是与addstrategy返回的索引兼容的引用。只有由idx引用的策略将收到此大小。\nadd_signal(sigtype, sigcls, *sigargs, **sigkwargs) 向系统添加一个信号，稍后将添加到SignalStrategy中。\nsignal_concurrent(onoff) 如果将信号添加到系统并且concurrent值设置为True，将允许并发订单。\nsignal_accumulate(onoff) 如果将信号添加到系统并且accumulate值设置为True，当已在市场中时进入市场，将允许增加头寸。\nsignal_strategy(stratcls, *args, **kwargs) 添加可以接受信号的SignalStrategy子类。\naddcalendar(cal) 向系统添加一个全局交易日历。单个数据源可能有单独的日历覆盖全局日历。cal可以是TradingCalendar的实例、字符串或pandas_market_calendars的实例。字符串将实例化为PandasMarketCalendar（需要系统中安装模块pandas_market_calendar）。如果传递的是TradingCalendarBase的子类（而不是实例），它将被实例化。\naddtz(tz) 也可以使用参数tz完成。为策略添加全局时区。参数tz可以是：\n可选项 描述 None 在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。 pytz 实例 将用作将UTC时间转换为所选时区。 字符串 将尝试实例化pytz实例。 整数 对于策略，使用self.datas中相应数据的时区（0就用data0的时区）。 add_timer(when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, strats=False, cheat=False, *args, **kwargs) 安排一个计时器以调用notify_timer。参数：\n参数 when 可以是datetime.time实例（见下文的tzdata），bt.timer.SESSION_START以参考会话开始，bt.timer.SESSION_END以参考会话结束。 offset 必须是datetime.timedelta实例，用于偏移值when。在与SESSION_START和SESSION_END组合使用时具有有意义的用途，以指示例如在会话开始后15分钟调用计时器。 repeat 必须是datetime.timedelta实例，表示在第一次调用后，是否在同一会话内按计划的重复增量安排进一步的调用。 weekdays 一个排序的可迭代对象，包含表示计时器可以实际调用的天数（iso代码，周一是1，周日是7）。如果未指定，计时器将在所有天都有效。 weekcarry 默认：False，如果为True并且未看到工作日（例如：交易假期），计时器将在第二天执行（即使在新的一周内）。 monthdays 一个排序的可迭代对象，包含表示每月应执行计时器的天数。例如总是在每月的15日。如果未指定，计时器将在所有天都有效。 monthcarry 默认：True，如果未看到该天（周末、交易假期），计时器将在下一个可用日执行。 allow 默认：None，一个回调，接收一个datetime.date实例，如果日期被允许用于计时器则返回True，否则返回False。 tzdata 可以是None（默认）、一个pytz实例或一个数据源实例。 None：按面值解释when（这意味着将其处理为UTC，即使不是）。- pytz实例：when将被解释为在所选时区本地时间指定。数据源实例：when将被解释为在数据源实例的tz参数指定的本地时间。注意，如果when是SESSION_START或SESSION_END并且tzdata为None，将使用系统中的第一个数据源（即self.data0）作为参考，以找出会话时间。 strats 默认：False，也调用策略的notify_timer。 cheat 默认：False）如果为True，将在经纪人有机会评估订单之前调用计时器。这打开了发布基于开盘价的订单的机会，例如在会话开始前。 *args 将传递给notify_timer的任何额外args。 **kwargs 将传递给notify_timer的任何额外kwargs。返回值：创建的计时器。 notify_timer(timer, when, *args, **kwargs) 接收计时器通知，其中timer是由 add_timer 返回的计时器，when是调用时间。args和kwargs是传递给add_timer的任何附加参数。实际的when时间可能稍后，但系统可能无法提前调用计时器。此值是计时器值，而不是系统时间。\nadd_order_history(orders, notify=True) 将订单历史直接添加到经纪人以进行性能评估。\norders：是一个可迭代对象（例如：列表、元组、迭代器、生成器），其中每个元素也是一个具有以下子元素（2种格式可能）的可迭代对象（具有长度）：[datetime, size, price]或[datetime, size, price, data]，注意，必须按日期时间升序排序（或生成排序的元素）。\n具体说明如下：\n参数 描述 datetime 是Python的日期/日期时间实例或格式为YYYY-MM-DD[THH:MM:SS[.us]]的字符串，其中括号内的元素是可选的。 size 是一个整数（正数表示买入，负数表示卖出）。 price 是一个浮点数/整数。 data 如果存在，可以取以下任何值：None - 将使用第一个数据源作为目标。 integer - 将使用该索引（在Cerebro中插入顺序）的数据。string - 将使用具有该名称的数据，例如使用cerebro.adddata(data, name=value)分配的名称。 notify（默认：True）：如果为True，系统中插入的第一个策略将收到根据每个订单的信息创建的人工订单通知。\n注意\n描述中隐含的是添加作为订单目标的数据源。例如，这是分析器（如跟踪回报）的必要条件。\n"},{"id":25,"href":"/backtrader/docs/14-sizers/02-reference/","title":"参考","section":"Sizer","content":"参考# FixedSize# class backtrader.sizers.FixedSize()此 Sizer 仅为任何操作返回固定大小。通过指定 tranches 参数，可以控制系统希望用于逐步进入交易的批次数量。\n参数：\nstake（默认：1） tranches（默认：1） FixedReverser# class backtrader.sizers.FixedReverser()此 Sizer 返回反转已开头寸所需的固定大小或开仓所需的固定大小。\n开仓：返回参数 stake 反转头寸：返回 2 * stake 参数：\nstake（默认：1） PercentSizer# class backtrader.sizers.PercentSizer()此 Sizer 返回可用现金的百分比。\n参数：\npercents（默认：20） AllInSizer# class backtrader.sizers.AllInSizer()此 Sizer 返回经纪人所有可用现金。\n参数：\npercents（默认：100） PercentSizerInt# class backtrader.sizers.PercentSizerInt()此 Sizer 以整数形式返回可用现金的百分比，并将大小截断为整数。\n参数：\npercents（默认：20） AllInSizerInt# class backtrader.sizers.AllInSizerInt()此 Sizer 返回经纪人所有可用现金，并将大小截断为整数。\n参数：\npercents（默认：100） "},{"id":26,"href":"/backtrader/docs/06-datafeed/09-datafeed-filters/02-datafeed-filters-referrence/","title":"参考文档","section":"过滤器 Filters","content":"Filters 参考文档# SessionFilter# class backtrader.filters.SessionFilter(data)\n此类可作为过滤器应用于数据源，将过滤掉落在常规交易时间之外的日内数据（即盘前/盘后数据）。\n这是一个“非简单”过滤器，必须管理数据栈（在初始化和调用期间传递）。 它不需要“last”方法，因为没有需要传递的内容。 SessionFilterSimple# class backtrader.filters.SessionFilterSimple(data)\n此类可作为过滤器应用于数据源，将过滤掉落在常规交易时间之外的日内数据（即盘前/盘后数据）。\n这是一个“简单”过滤器，不需要管理数据栈（在初始化和调用期间传递）。 它不需要“last”方法，因为没有需要传递的内容。 Bar 管理将由 SimpleFilterWrapper 类处理，该类在 DataBase.addfilter_simple 调用期间添加。 SessionFiller# class backtrader.filters.SessionFiller(data)\n为声明的会话开始/结束时间内的数据源填充条。\n参数：\nfill_price (默认: None): 如果传递了 None，将使用前一个条的收盘价。为了得到一个不显示在图表中的条，可以使用 float(\u0026lsquo;NaN\u0026rsquo;)。 fill_vol (默认: float(\u0026lsquo;NaN\u0026rsquo;)): 用于填充缺失交易量的值。 fill_oi (默认: float(\u0026lsquo;NaN\u0026rsquo;)): 用于填充缺失未平仓合约的值。 skip_first_fill (默认: True): 在看到第一个有效条时，不从会话开始填充到该条。 CalendarDays# class backtrader.filters.CalendarDays(data)\n填充缺失日历日到交易日。\n参数：\nfill_price (默认: None): 0: 用给定值填充。 None: 使用上一个已知收盘价。 -1: 使用上一个条的中点（高低平均值）。 fill_vol (默认: float(\u0026lsquo;NaN\u0026rsquo;)): 用于填充缺失交易量的值。 fill_oi (默认: float(\u0026lsquo;NaN\u0026rsquo;)): 用于填充缺失未平仓合约的值。 BarReplayer_Open# class backtrader.filters.BarReplayer_Open(data)\n此过滤器将一个条分为两部分：\nOpen: 条的开盘价将用于交付一个初始价格条，其中四个组件（OHLC）相等。 此初始条的交易量/未平仓合约字段为 0。 OHLC: 原始条完整交付，包含原始交易量/未平仓合约。 分割模拟重播，无需使用重播过滤器。\nDaySplitter_Close# class backtrader.filters.DaySplitter_Close(data)\n将一个每日条分为两部分，模拟两个价格点以重播数据：\n第一个价格点: OHLX 收盘价将替换为开盘价、高价和低价的平均值。 此价格点使用会话的开盘时间。 第二个价格点: CCCC 收盘价将用于四个价格组件。 此价格点使用会话的收盘时间。 交易量将在两个价格点之间分配，使用参数： closevol (默认: 0.5): 值表示百分比，绝对值范围为 0.0 到 1.0，分配给收盘价格点的比例。其余部分将分配给 OHLX 价格点。 此过滤器用于配合 cerebro.replaydata 一起使用。\nHeikinAshi# class backtrader.filters.HeikinAshi(data)\n此过滤器重新建模开盘、高价、低价、收盘价以形成 HeikinAshi 蜡烛图。\n参考：\nHeikin Ashi Candlesticks StockCharts Heikin Ashi Renko# class backtrader.filters.Renko(data)\n修改数据流以绘制 Renko 条（或砖）。\n参数：\nhilo (默认: False): 使用高价和低价而不是收盘价来决定是否需要新砖。 size (默认: None): 每个砖块的大小。 autosize (默认: 20.0): 如果 size 为 None，将使用此值自动计算砖块大小（简单地将当前价格除以给定值）。 dynamic (默认: False): 如果为 True 并且使用 autosize，当移动到新砖块时将重新计算砖块大小。这当然会消除 Renko 砖块的完美对齐。 align (默认: 1.0): 用于对齐砖块价格边界的因子。例如，如果价格为 3563.25 并且 align 为 10.0，则对齐后的价格将为 3560。计算方法： 3563.25 / 10.0 = 356.325 四舍五入并删除小数位 -\u0026gt; 356 356 * 10.0 -\u0026gt; 3560 参考# StockCharts Renko "},{"id":27,"href":"/backtrader/docs/04-concepts/02-operate-the-platform/02-startup/","title":"启动运行","section":"平台操作","content":"启动和运行# Backtrader 的启动和运行过程主要依赖于三个核心组件：\n数据源：提供市场数据，用于回测或实时交易。 策略：定义交易逻辑（基于类继承实现）。 Cerebro：核心管理器，负责整合数据源、策略，并启动回测或实时交易。 数据源# 数据源是回测和策略运行的基础，它为策略提供价格数据（如开盘价、高价、低价、收盘价）及其他市场信息。\n支持的数据源# 本地数据文件：\n支持多种 CSV 格式（如 Yahoo Finance 数据）。 支持从 Pandas DataFrame 加载数据。 在线数据提取：\n提供内置的 Yahoo Finance 在线数据提取功能。 实时数据源：\n支持 Interactive Brokers (IB)、Visual Chart 和 Oanda 等实时数据源。 平台支持通过 时间框架（如日线、5分钟线）和 压缩级别（如1天、5分钟）自定义数据，以适配不同交易策略。\n数据源设置示例# 加载 Yahoo Finance 格式的 CSV 数据# 以下是一个基本的 CSV 数据加载示例：\nimport backtrader as bt import datetime datapath = \u0026#39;path/to/your/yahoo/data.csv\u0026#39; data = bt.feeds.YahooFinanceCSVData( dataname=datapath, reversed=True # 如果数据是从最新日期到最早日期排列，需要设置为 True )如果数据跨越时间范围较长，可限制按时间限制加载的数据：\ndata = bt.feeds.YahooFinanceCSVData( dataname=datapath, reversed=True, # 如果数据是从最新日期到最早日期排列，需要设置为 True fromdate=datetime.datetime(2014, 1, 1), # 数据起始日期 todate=datetime.datetime(2014, 12, 31), # 数据结束日期 timeframe=bt.TimeFrame.Days, # 时间框架设置为日线 compression=1, # 每 1 天作为一个数据单位 name=\u0026#39;Yahoo Data\u0026#39; # 数据源命名（可选） )从 Pandas DataFrame 加载数据# 如果你的数据存储在 Pandas DataFrame 中，可以使用以下方式加载：\nimport pandas as pd import backtrader as bt df = pd.read_csv(\u0026#39;path/to/your/data.csv\u0026#39;, index_col=\u0026#39;Date\u0026#39;, parse_dates=True) data = bt.feeds.PandasData( dataname=df, fromdate=datetime.datetime(2020, 1, 1), todate=datetime.datetime(2020, 12, 31), timeframe=bt.TimeFrame.Days )设置多时间框架# 如果你需要同时加载 5 分钟和日线数据，可以分别加载不同时间框架的数据源：\ndata_5min = bt.feeds.GenericCSVData( dataname=\u0026#39;path/to/5min_data.csv\u0026#39;, timeframe=bt.TimeFrame.Minutes, compression=5 ) data_daily = bt.feeds.GenericCSVData( dataname=\u0026#39;path/to/daily_data.csv\u0026#39;, timeframe=bt.TimeFrame.Days, compression=1 ) cerebro.adddata(data_5min, name=\u0026#39;5min\u0026#39;) cerebro.adddata(data_daily, name=\u0026#39;daily\u0026#39;) 策略（派生类）# 策略 是交易逻辑的核心，它定义了如何根据数据进行买卖操作。Backtrader 中的策略通过继承 bt.Strategy 类实现。\n策略的基本方法# 策略类至少需要实现以下两个方法：\n__init__：初始化方法，用于定义指标和变量。 next：逐条处理数据，用于执行交易逻辑。 当传递不同时间框架（条数不同）的数据源时，next 方法将基于主数据源迭代（即第一个传递给 Cerebro 的数据），主数据源应是时间框架最小的数据源。\n对于 ReplayData，next 方法会被多次调用，特别是当数据跨时间框架时，Backtrader 会在每个数据条上执行 next，模拟数据的发展。\n示例策略# 以下是一个简单的策略示例，基于 20 日简单移动平均线（SMA）进行交易：\nclass MyStrategy(bt.Strategy): def __init__(self): # 定义简单移动平均线（SMA） self.sma = bt.indicators.SimpleMovingAverage(self.data.close, period=20) def next(self): # 如果收盘价高于 SMA，则买入 if self.data.close[0] \u0026gt; self.sma[0]: self.buy() # 如果收盘价低于 SMA，则卖出 elif self.data.close[0] \u0026lt; self.sma[0]: self.sell() 扩展功能# 策略还可以覆盖以下方法，为回测和实时交易添加更多功能：\nstart：回测开始时调用（用于初始化资源）。 stop：回测结束时调用（用于清理资源或总结）。 notify_order：当订单状态发生变化时调用。 notify_trade：当交易状态发生变化时调用。 演示策略如下所示：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma = bt.indicators.SimpleMovingAverage(self.data.close, period=20) def start(self): print(\u0026#39;回测开始！\u0026#39;) def stop(self): print(\u0026#39;回测结束！\u0026#39;) def notify_order(self, order): if order.status in [order.Completed]: print(f\u0026#34;订单完成: {order.info}\u0026#34;) def next(self): if self.data.close[0] \u0026gt; self.sma[0]: self.buy() elif self.data.close[0] \u0026lt; self.sma[0]: self.sell()其他操作# 在 Backtrader 中，策略类还提供各种交易操作。\n买入 / 卖出 / 平仓（buy / sell / close）： 通过这些方法，策略可以向经纪人发送买入、卖出或平仓订单。平台也允许您手动创建订单并将其传递给经纪人，但通过这些内建的方法，可以让操作变得更简单和高效。\nclose：立即关闭当前市场头寸。\ngetposition（或属性 position）：返回当前的市场头寸。通过这个方法，您可以查看当前持有的仓位情况。\nsetsizer / getsizer（或属性 sizer）：这些方法允许您设置或获取底层的股份定量器（Sizer）。定量器负责计算每次交易的仓位大小，您可以根据需要选择不同的定量器类型，如固定大小、与资本成比例或指数等策略。\n策略类本身是一个 Line 对象，支持配置参数。\nclass MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.sma = btind.SimpleMovingAverage(self.data, period=self.params.period) ...现在，SimpleMovingAverage 指标不再是固定的 20，而是根据策略中定义的 period 参数动态设置，这提高了策略的灵活性。\nCerebro# 一旦数据源可用并定义了策略，Cerebro 实例会将所有内容整合并执行。创建一个 Cerebro 实例非常简单：\ncerebro = bt.Cerebro()如果没有特别的需求，默认配置会自动处理以下内容：\n创建一个默认经纪人； 操作不收取佣金； 数据源会被预加载； 默认执行模式为 runonce（批处理模式），这是最优的执行方式。 需要注意的是，所有指标都必须支持 runonce 模式，以确保执行速度达到最佳。平台中已经包含的指标大多都支持此模式。\n典型流程# 创建 Cerebro 实例\ncerebro = bt.Cerebro()添加数据源\ncerebro.adddata(data)添加策略\ncerebro.addstrategy(MyStrategy)配置经纪人\n设置初始资金、佣金等。\ncerebro.broker.set_cash(100000) # 设置初始资金 cerebro.broker.setcommission(commission=0.001) # 设置佣金运行回测\ncerebro.run()绘制回测结果\ncerebro.plot()plot接受一些参数用于自定义：\nnumfigs=1 如果绘图过于密集，可以将其分成多个图\nplotter=None 可以传递一个绘图器实例给，cerebro 将不按默认绘图。\n策略优化# Backtrader 支持对策略参数进行优化。例如，我们可以测试不同的 SMA 周期参数对策略的影响：\ncerebro.optstrategy(MyStrategy, period=range(10, 50, 5))在上例中，period 参数会从 10 到 45（每次递增 5）进行测试，平台会自动运行每个参数组合的回测。\n完整代码示例# 以下是一个完整的代码示例，整合了数据源、策略和 Cerebro：\nimport backtrader as bt from datetime import datetime # 定义策略 class MyStrategy(bt.Strategy): def __init__(self): self.sma = bt.indicators.SimpleMovingAverage(self.data.close, period=20) def next(self): if self.data.close[0] \u0026gt; self.sma[0]: self.buy() elif self.data.close[0] \u0026lt; self.sma[0]: self.sell() # 初始化 Cerebro cerebro = bt.Cerebro() # 加载数据 data = bt.feeds.YahooFinanceCSVData( dataname=\u0026#39;path/to/your/data.csv\u0026#39;, fromdate=datetime(2020, 1, 1), todate=datetime(2021, 1, 1) ) cerebro.adddata(data) # 添加策略 cerebro.addstrategy(MyStrategy) # 配置初始资金和佣金 cerebro.broker.setcash(100000) cerebro.broker.setcommission(commission=0.001) # 启动回测 cerebro.run() # 绘制结果 cerebro.plot() 通过这些核心组件的整合，Backtrader 提供了一个高度灵活的框架，适用于各种回测和实时交易需求。希望这部分的补充对你有所帮助！\n"},{"id":28,"href":"/backtrader/docs/13-observers/02-benchmarking/","title":"基准测试","section":"Observer","content":"基准测试# Ticket #89 是关于添加基准测试以对比一个资产的表现。这个功能非常实用，因为有些策略即使盈利也可能低于单纯追踪资产的收益。\nbacktrader 包含两种不同类型的对象可以帮助进行追踪：\n观察器 分析器 在分析器领域，已经有一个 TimeReturn 对象，用于跟踪整个投资组合价值的回报演变（包括现金）。\n这显然也可以是一个观察器，所以在添加一些基准测试时，也对如何将观察器和分析器组合在一起进行了工作，这两者旨在跟踪相同的内容。\n注意\n观察器和分析器之间的主要区别在于观察器的线条特性，观察器记录每个值，这使得它们适合绘图和实时查询。当然，这会消耗内存。\n另一方面，分析器通过 get_analysis 返回一组结果，并且实现可能直到运行结束时才会提供任何结果。\n分析器 - 基准测试# 标准的 TimeReturn 分析器已扩展为支持跟踪数据源。涉及的两个主要参数：\ntimeframe（默认：无） 如果为 None，将报告整个回测期间的总回报。 data（默认：无） 要跟踪的参考资产，而不是投资组合价值。 注意\n此数据必须已通过 adddata、resampledata 或 replaydata 添加到 cerebro 实例中。\n更多详细信息和参数请参阅：分析器参考。\n因此，可以像这样按年度跟踪投资组合的回报：\nimport backtrader as bt cerebro = bt.Cerebro() cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years) # 添加数据、策略等... results = cerebro.run() strat0 = results[0] # 如果没有指定名称，则名称为类名的小写形式 tret_analyzer = strat0.analyzers.getbyname(\u0026#39;timereturn\u0026#39;) print(tret_analyzer.get_analysis())如果我们想跟踪一个数据的回报：\nimport backtrader as bt cerebro = bt.Cerebro() data = bt.feeds.OneOfTheFeeds(dataname=\u0026#39;abcde\u0026#39;, ...) cerebro.adddata(data) cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years, data=data) # 添加策略等... results = cerebro.run() strat0 = results[0] # 如果没有指定名称，则名称为类名的小写形式 tret_analyzer = strat0.analyzers.getbyname(\u0026#39;timereturn\u0026#39;) print(tret_analyzer.get_analysis())如果要同时跟踪两者，最好为分析器指定名称：\nimport backtrader as bt cerebro = bt.Cerebro() data = bt.feeds.OneOfTheFeeds(dataname=\u0026#39;abcde\u0026#39;, ...) cerebro.adddata(data) cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years, data=data, _name=\u0026#39;datareturns\u0026#39;) cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years, _name=\u0026#39;timereturns\u0026#39;) # 添加策略等... results = cerebro.run() strat0 = results[0] # 获取分析结果 tret_analyzer = strat0.analyzers.getbyname(\u0026#39;timereturns\u0026#39;) print(tret_analyzer.get_analysis()) tdata_analyzer = strat0.analyzers.getbyname(\u0026#39;datareturns\u0026#39;) print(tdata_analyzer.get_analysis())观察器 - 基准测试# 感谢能够在观察器中使用分析器的底层机制，添加了两个新观察器：\nTimeReturn Benchmark 两者都使用 bt.analyzers.TimeReturn 分析器来收集结果。\n与上述代码片段相比，以下是一个完整的示例，以展示它们的功能。\n观察 TimeReturn# 执行：\n$ ./observer-benchmark.py --plot --timereturn --timeframe notimeframe注意执行选项：\n--timereturn 告诉示例仅执行此操作。 --timeframe notimeframe 告诉分析器考虑整个数据集而不考虑时间框架边界。 最后绘制的值是 -0.26。\n起始现金（从图表中显而易见）为 50K 货币单位，策略最终以 36,970 货币单位收尾，因此价值减少了 -26%。\n观察基准测试# 因为基准测试还会显示 timereturn 结果，让我们在激活基准测试的情况下运行相同的操作：\n$ ./observer-benchmark.py --plot --timeframe notimeframe结果显示：\n策略表现优于资产：-0.26 对 -0.33\n这不应该是庆祝的理由，但至少很清楚策略并不比资产差。\n按年度跟踪的情况：\n$ ./observer-benchmark.py --plot --timeframe years注意：\n策略的最后一个值略有变化，从 -0.26 变为 -0.27\n而资产的最后一个值则显示为 -0.35（相对于上面的 -0.33）\n原因是在从 2005 年到 2006 年的过渡中，策略和基准资产在 2005 年初几乎处于起始水平。\n切换到周时间框架时，整个图像发生了变化：\n$ ./observer-benchmark.py --plot --timeframe weeks现在：\n基准观察器显示出更加紧张的情况。事物上下波动，因为现在正在跟踪投资组合和数据的每周回报。\n由于在年底的最后一周没有进行任何交易，且资产几乎没有移动，最后显示的值为 0.00（最后一周之前的最后收盘价为 25.54，而样本数据收盘于 25.55，差异首先在小数点后第四位显现）。\n观察基准测试 - 另一个数据# 示例允许对比不同的数据。默认情况下使用 --benchdata1 基准对比 Oracle。考虑整个数据集时使用 --timeframe notimeframe：\n$ ./observer-benchmark.py --plot --timeframe notimeframe --benchdata1结果显示：\n策略的结果未随 notimeframe 变化，仍为 -26%（-0.26）\n但当与另一个数据进行基准对比时，该数据在同一期间内有 +23%（0.23） 的增长\n要么需要更改策略，要么需要交易另一个更好的资产。\n结论# 现在有两种方式，使用相同的底层代码/计算，来跟踪 TimeReturn 和 Benchmark：\n观察器（TimeReturn 和 Benchmark） 分析器（TimeReturn 和带有 data 参数的 TimeReturn） 当然，基准测试并不保证利润，只是比较。\n示例代码# $ ./observer-benchmark.py --help usage: observer-benchmark.py [-h] [--data0 DATA0] [--data1 DATA1] [--benchdata1] [--fromdate FROMDATE] [--todate TODATE] [--printout] [--cash CASH] [--period PERIOD] [--stake STAKE] [--timereturn] [--timeframe {months,days,notimeframe,years,None,weeks}] [--plot [kwargs]] Benchmark/TimeReturn Observers Sample optional arguments: -h, --help show this help message and exit --data0 DATA0 Data0 to be read in (default: ../../datas/yhoo-1996-2015.txt) --data1 DATA1 Data1 to be read in (default: ../../datas/orcl-1995-2014.txt) --benchdata1 Benchmark against data1 (default: False) --fromdate FROMDATE Starting date in YYYY-MM-DD format (default: 2005-01-01) --todate TODATE Ending date in YYYY-MM-DD format (default: 2006-12-31) --printout Print data lines (default: False) --cash CASH Cash to start with (default: 50000) --period PERIOD Period for the crossover moving average (default: 30) --stake STAKE Stake to apply for the buy operations (default: 1000) --timereturn Use TimeReturn observer instead of Benchmark (default: None) --timeframe {months,days,notimeframe,years,None,weeks} TimeFrame to apply to the Observer (default: None) --plot [kwargs], -p [kwargs] Plot the read data applying any kwargs passed For example: --plot style=\u0026#34;candle\u0026#34; (to plot candles) (default: None)示例代码：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import random import backtrader as bt class St(bt.Strategy): params = ( (\u0026#39;period\u0026#39;, 10), (\u0026#39;printout\u0026#39;, False), (\u0026#39;stake\u0026#39;, 1000), ) def __init__(self): sma = bt.indicators.SMA(self.data, period=self.p.period) self.crossover = bt.indicators.CrossOver(self.data, sma) def start(self): if self.p.printout: txtfields = list() txtfields.append(\u0026#39;Len\u0026#39;) txtfields.append(\u0026#39;Datetime\u0026#39;) txtfields.append(\u0026#39;Open\u0026#39;) txtfields.append(\u0026#39;High\u0026#39;) txtfields.append(\u0026#39;Low\u0026#39;) txtfields.append(\u0026#39;Close\u0026#39;) txtfields.append(\u0026#39;Volume\u0026#39;) txtfields.append(\u0026#39;OpenInterest\u0026#39;) print(\u0026#39;,\u0026#39;.join(txtfields)) def next(self): if self.p.printout: # 仅打印第一个数据... 只是检查运行情况 txtfields = list() txtfields.append(\u0026#39;%04d\u0026#39; % len(self)) txtfields.append(self.data.datetime.datetime(0).isoformat()) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.open[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.high[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.low[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.close[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.volume[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.openinterest[0]) print(\u0026#39;,\u0026#39;.join(txtfields)) if self.position: if self.crossover \u0026lt; 0.0: if self.p.printout: print(\u0026#39;CLOSE {} @%{}\u0026#39;.format(self.p.stake, self.data.close[0])) self.close() else: if self.crossover \u0026gt; 0.0: self.buy(size=self.p.stake) if self.p.printout: print(\u0026#39;BUY {} @%{}\u0026#39;.format(self.p.stake, self.data.close[0])) TIMEFRAMES = { None: None, \u0026#39;days\u0026#39;: bt.TimeFrame.Days, \u0026#39;weeks\u0026#39;: bt.TimeFrame.Weeks, \u0026#39;months\u0026#39;: bt.TimeFrame.Months, \u0026#39;years\u0026#39;: bt.TimeFrame.Years, \u0026#39;notimeframe\u0026#39;: bt.TimeFrame.NoTimeFrame, } def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() cerebro.broker.set_cash(args.cash) dkwargs = dict() if args.fromdate: fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;fromdate\u0026#39;] = fromdate if args.todate: todate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;todate\u0026#39;] = todate data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **dkwargs) cerebro.adddata(data0, name=\u0026#39;Data0\u0026#39;) cerebro.addstrategy(St, period=args.period, stake=args.stake, printout=args.printout) if args.timereturn: cerebro.addobserver(bt.observers.TimeReturn, timeframe=TIMEFRAMES[args.timeframe]) else: benchdata = data0 if args.benchdata1: data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1, **dkwargs) cerebro.adddata(data1, name=\u0026#39;Data1\u0026#39;) benchdata = data1 cerebro.addobserver(bt.observers.Benchmark, data=benchdata, timeframe=TIMEFRAMES[args.timeframe]) cerebro.run() if args.plot: pkwargs = dict() if args.plot is not True: # 评估为 True 但不是 True pkwargs = eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;) # 传递的参数 cerebro.plot(**pkwargs) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Benchmark/TimeReturn Observers Sample\u0026#39;) parser.add_argument(\u0026#39;--data0\u0026#39;, required=False, default=\u0026#39;../../datas/yhoo-1996-2015.txt\u0026#39;, help=\u0026#39;Data0 to be read in\u0026#39;) parser.add_argument(\u0026#39;--data1\u0026#39;, required=False, default=\u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;, help=\u0026#39;Data1 to be read in\u0026#39;) parser.add_argument(\u0026#39;--benchdata1\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Benchmark against data1\u0026#39;)) parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;2005-01-01\u0026#39;, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;2006-12-31\u0026#39;, help=\u0026#39;Ending date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--printout\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Print data lines\u0026#39;)) parser.add_argument(\u0026#39;--cash\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=float, default=50000, help=(\u0026#39;Cash to start with\u0026#39;)) parser.add_argument(\u0026#39;--period\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=int, default=30, help=(\u0026#39;Period for the crossover moving average\u0026#39;)) parser.add_argument(\u0026#39;--stake\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=int, default=1000, help=(\u0026#39;Stake to apply for the buy operations\u0026#39;)) parser.add_argument(\u0026#39;--timereturn\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, default=None, help=(\u0026#39;Use TimeReturn observer instead of Benchmark\u0026#39;)) parser.add_argument(\u0026#39;--timeframe\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=None, choices=TIMEFRAMES.keys(), help=(\u0026#39;TimeFrame to apply to the Observer\u0026#39;)) parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, nargs=\u0026#39;?\u0026#39;, required=False, metavar=\u0026#39;kwargs\u0026#39;, const=True, help=(\u0026#39;Plot the read data applying any kwargs passed\\nFor example:\\n\\n --plot style=\u0026#34;candle\u0026#34; (to plot candles)\\n\u0026#39;)) if pargs: return parser.parse_args(pargs) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":29,"href":"/backtrader/docs/02-installation/","title":"安装指南","section":"介绍","content":"安装指南# 本文是 Backtrader 的安装指南，介绍如何安装 Backtrader。\n需求和版本# 官方仓库注明是 Backtrader 可运行在 Python 3.2-3.7，但它目前也能在 Python 3.10 及以上版本中正常运行。如需绘图，请安装 Matplotlib \u0026gt;= 1.4.1；\n如果你追求更快的回测速度，可尝试使用 PyPy3 环境运行，但需注意它的绘图支持较弱。\n兼容性# Backtrader 在 Python 2.x 和 3.x 上的兼容行如何呢？\nBacktrader 的开发主要在 Python 2.7 下进行，有时也会在 3.4 下进行测试。为了确保兼容性，本地测试环境会使用这两个版本。\nBacktrader 的开发过程通过 Travis 持续集成系统，确保了与 Python 3.2 / 3.3 / 3.5 以及 pypy/pypy3 的兼容性。\n从 PyPI 安装# 您可以使用 pip 轻松安装 Backtrader：\npip install backtrader或者，您也可以使用 easy_install 安装：\neasy_install backtrader如果需要绘图功能：\npip install \u0026#34;backtrader[plotting]\u0026#34;这会自动安装 Matplotlib 及其依赖项。\n源码安装# 从 GitHub 通过 git 下载发布最新版本，访问 GitHub 仓库地址。\n运行命令安装：\ngit clone https://github.com:mementum/backtrader cd backtrader python setup.py install源码运行# 如果你希望将 Backtrader 直接包含在你的项目源码中，可从 GitHub 下载发布版本，并将 backtrader 复制到您的项目中。\ngit clone https://github.com:mementum/backtrader cp -r backtrader project_directory 请记住，如果需要绘图功能，还需手动安装 Matplotlib。\n这种运行方式的最大好处是，开发策略时，也能非常方便的调试和阅读 Backtrader 的核心源码。\n"},{"id":30,"href":"/backtrader/docs/17-datetime/02-timer/","title":"定时器","section":"日期时间","content":"定时器# 在版本 1.9.44.116 中，backtrader 添加了定时器功能。这使得在特定时间点调用 notify_timer（在 Cerebro 和 Strategy 中可用）成为可能，用户可以进行精细控制。\n选项# 基于绝对时间输入或相对于会话开始/结束时间的定时器。 时间规范的时区指定，可以直接通过 pytz 兼容对象或通过数据源会话结束时间进行指定。 相对于指定时间的起始偏移。 重复间隔。 工作日过滤器（带有结转选项）。 月份天数过滤器（带有结转选项）。 自定义回调过滤器。 使用模式# 在 Cerebro 和 Strategy 子类中，定时器回调将在以下方法中接收：\ndef notify_timer(self, timer, when, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39;接收定时器通知，其中 `timer` 是通过 `add_timer` 返回的定时器，`when` 是调用时间。 `args` 和 `kwargs` 是传递给 `add_timer` 的额外参数。 实际的 `when` 时间可能稍后，但系统可能无法在之前调用定时器。 此值是定时器值，而不是系统时间。 \u0026#39;\u0026#39;\u0026#39;添加定时器 - 通过 Strategy# 使用以下方法完成：\ndef add_timer(self, when, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39;它返回创建的 Timer 实例。下面是参数的解释。\n添加定时器 - 通过 Cerebro# 使用相同的方法，只是增加了参数 strats。如果设置为 True，定时器不仅会通知给 cerebro，还会通知系统中运行的所有策略。\ndef add_timer(self, when, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, strats=False, *args, **kwargs): \u0026#39;\u0026#39;\u0026#39;它返回创建的 Timer 实例。\n定时器调用时间# 如果 cheat=False# 这是默认设置。在这种情况下，定时器将在以下情况后调用：\n数据源加载当前柱的新值之后。 经纪人评估订单并重新计算投资组合价值之后。 指标重新计算之前（因为这由策略触发）。 调用任何策略的 next 方法之前。 如果 cheat=True# 在这种情况下，定时器将在以下情况后调用：\n数据源加载当前柱的新值之后。 经纪人评估订单并重新计算投资组合价值之前。 因此，在指标重新计算和调用任何策略的 next 方法之前调用定时器，这样可以实现以下场景：\n在新柱被经纪人评估之前调用定时器。 指标具有前一天收盘时的值，并可用于生成进出信号（或在上次评估 next 时设置标志）。 因为新价格可用，可以使用开盘价计算股份。这假设一个人通过观察开盘拍卖得到良好的开盘指示。 使用每日柱# 示例 scheduled.py 默认使用 backtrader 发行版中提供的标准每日柱。策略参数如下：\nclass St(bt.Strategy): params = dict( when=bt.timer.SESSION_START, timer=True, cheat=False, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], )数据具有以下会话时间：\n开始：09:00 结束：17:30 运行只带时间的情况：\n$ ./scheduled.py --strat when=\u0026#39;datetime.time(15,30)\u0026#39;输出结果：\nstrategy notify_timer with tid 0, when 2005-01-03 15:30:00 cheat False 1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02 strategy notify_timer with tid 0, when 2005-01-04 15:30:00 cheat False 2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12 strategy notify_timer with tid 0, when 2005-01-05 15:30:00 cheat False 3, 2005-01-05 17:30:00, Week 1, Day 3, O 2969.0, H 2969.0, L 2942.69, C 2947.19 strategy notify_timer with tid 0, when 2005-01-06 15:30:00 cheat False ...指定的定时器在 15:30 触发。没有惊喜。让我们增加 30 分钟的偏移：\n$ ./scheduled.py --strat when=\u0026#39;datetime.time(15,30)\u0026#39;,offset=\u0026#39;datetime.timedelta(minutes=30)\u0026#39;输出结果：\nstrategy notify_timer with tid 0, when 2005-01-03 16:00:00 cheat False 1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02 strategy notify_timer with tid 0, when 2005-01-04 16:00:00 cheat False 2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12 strategy notify_timer with tid 0, when 2005-01-05 16:00:00 cheat False ...定时器的时间从 15:30 变为 16:00。没有惊喜。让我们以会话开始为参考：\n$ ./scheduled.py --strat when=\u0026#39;bt.timer.SESSION_START\u0026#39;,offset=\u0026#39;datetime.timedelta(minutes=30)\u0026#39;输出结果：\nstrategy notify_timer with tid 0, when 2005-01-03 09:30:00 cheat False 1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02 strategy notify_timer with tid 0, when 2005-01-04 09:30:00 cheat False 2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12 ...定时器回调时间为 09:30。会话开始时间为 09:00。这样可以简单地说希望在会话开始后 30 分钟执行一个操作。\n运行带有 5 分钟柱的数据# 示例 scheduled-min.py 默认运行 backtrader 发行版中的标准 5 分钟柱。策略参数如下：\nclass St(bt.Strategy): params = dict( when=bt.timer.SESSION_START, timer=True, cheat=False, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, )数据具有相同的会话时间：\n开始：09:00 结束：17:30 让我们进行一些实验。首先是一个定时器。\n$ ./scheduled-min.py --strat when=\u0026#39;datetime.time(15, 30)\u0026#39;输出结果：\n1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99 2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583.01, C 3588.03 ... 77, 2006-01-02 15:25:00, Week 1, Day 1, O 3599.07, H 3599.68, L 3598.47, C 3599.68 strategy notify_timer with tid 0, when 2006-01-02 15:30:00 cheat False 78, 2006-01-02 15:30:00, Week 1, Day 1, O 3599.64, H 3599.73, L 3599.0, C 3599.67 ... 179 , 2006-01-03 15:25:00, Week 1, Day 2, O 3634.72, H 3635.0, L 3634.06, C 3634.87 strategy notify_timer with tid 0, when 2006-01-03 15:30:00 cheat False 180, 2006-01-03 15:30:00, Week 1, Day 2, O 3634.81, H 3634.89, L 3634.04, C 3634.23 ...定时器在 15:30 触发。日志显示了它在前两天的触发情况。\n增加 15 分钟的重复间隔# $ ./scheduled-min.py --strat when=\u0026#39;datetime.time(15, 30)\u0026#39;,repeat=\u0026#39;datetime.timedelta(minutes=15)\u0026#39;输出结果：\n... 74, 2006-01-02 15:10:00, Week 1, Day 1, O 3596.12, H 3596.63, L 3595.92, C 3596.63 75, 2006-01-02 15:15:00, Week 1, Day 1, O 3596.36, H 3596.65, L 3596.19, C 3596.65 76, 2006-01-02 15:20:00, Week 1, Day 1, O 3596.53, H 3599.13, L 3596.12, C 3598.9 77, 2006-01-02 15:25:00, Week 1, Day 1, O 3599.07, H 3599.68, L 3598.47, C 3599.68 strategy notify_timer with tid 0, when 2006-01-02 15:30:00 cheat False 78, 2006-01-02 15:30:00, Week 1, Day 1, O 3599.64, H 3599.73, L 3599.0, C 3599.67 79, 2006-01-02 15:35:00, Week 1, Day 1, O 3599.61, H 3600.29, L 3599.52, C 3599.92 80, 2006-01-02 15:40:00, Week 1, Day 1, O 3599.96, H 3602.06, L 3599.76, C 3602.05 strategy notify_timer with tid 0, when 2006-01-02 15:45:00 cheat False 81, 2006-01-02 15:45:00, Week 1, Day 1, O 3601.97, H 3602.07, L 3601.45, C 3601.83 82, 2006-01-02 15:50:00, Week 1, Day 1, O 3601.74, H 3602.8, L 3601.63, C 3602.8 83, 2006-01-02 15:55:00, Week 1, Day 1, O 3602.53, H 3602.74, L 3602.33, C 3602.61 strategy notify_timer with tid 0, when 2006-01-02 16:00:00 cheat False 84, 2006-01-02 16:00:00, Week 1, Day 1, O 3602.58, H 3602.75, L 3601.81, C 3602.14 85, 2006-01-02 16:05:00, Week 1, Day 1, O 3602.16, H 3602.16, L 3600.86, C 3600.96 86, 2006-01-02 16:10:00, Week 1, Day 1, O 3601.2, H 3601.49, L 3600.94, C 3601.27 ... strategy notify_timer with tid 0, when 2006-01-02 17:15:00 cheat False 99, 2006-01-02 17:15:00, Week 1, Day 1, O 3603.96, H 3603.96, L 3602.89, C 3603.79 100, 2006-01-02 17:20:00, Week 1, Day 1, O 3603.94, H 3605.95, L 3603.87, C 3603.91 101, 2006-01-02 17:25:00, Week 1, Day 1, O 3604.0, H 3604.76, L 3603.85, C 3604.64 strategy notify_timer with tid 0, when 2006-01-02 17:30:00 cheat False 102, 2006-01-02 17:30:00, Week 1, Day 1, O 3604.06, H 3604.41, L 3603.95, C 3604.33 103, 2006-01-03 09:05:00, Week 1, Day 2, O 3604.08, H 3609.6, L 3604.08, C 3609.6 104, 2006-01-03 09:10:00, Week 1, Day 2, O 3610.34, H 3617.31, L 3610.34, C 3617.31 105, 2006-01-03 09:15:00, Week 1, Day 2, O 3617.61, H 3617.87, L 3616.03, C 3617.51 106, 2006-01-03 09:20:00, Week 1, Day 2, O 3617.24, H 3618.86, L 3616.09, C 3618.42 ... 179, 2006-01-03 15:25:00, Week 1, Day 2, O 3634.72, H 3635.0, L 3634.06, C 3634.87 strategy notify_timer with tid 0, when 2006-01-03 15:30:00 cheat False 180, 2006-01-03 15:30:00, Week 1, Day 2, O 3634.81, H 3634.89, L 3634.04, C 3634.23 ...使用作弊模式# $ ./scheduled-min.py --strat when=\u0026#39;bt.timer.SESSION_START\u0026#39;,cheat=True输出结果：\nstrategy notify_timer with tid 1, when 2006-01-02 09:00:00 cheat True -- 2006-01-02 09:05:00 Create buy order strategy notify_timer with tid 0, when 2006-01-02 09:00:00 cheat False 1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99 -- 2006-01-02 09:10:00 Buy Exec @ 3583.01 2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583.01, C 3588.03 ...创建订单时间为 09:05:00，执行时间为 09:10:00，因为经纪人没有在开盘时作弊模式。让我们设置它……\n$ ./scheduled-min.py --strat when=\u0026#39;bt.timer.SESSION_START\u0026#39;,cheat=True --broker coo=True输出结果：\nstrategy notify_timer with tid 1, when 2006-01-02 09:00:00 cheat True -- 2006-01-02 09:05:00 Create buy order strategy notify_timer with tid 0, when 2006-01-02 09:00:00 cheat False -- 2006-01-02 09:05:00 Buy Exec @ 3578.73 1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99 2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583. 01, C 3588.03 ...下达时间和执行时间均为 09:05:00，执行价格为 09:05:00 的开盘价。\n其他场景# 定时器允许通过传递一个整数列表来指定哪些天（iso 代码，周一为 1，周日为 7）定时器可以实际触发。例如：\nweekdays=[5] # 这将请求定时器仅在周五有效如果周五是非交易日，并且定时器应在下一个交易日触发，可以添加 weekcarry=True。\n类似地，可以决定每月的某一天，例如：\nmonthdays=[15] # 每月的 15 日如果 15 日是非交易日，并且定时器应在下一个交易日触发，可以添加 monthcarry=True。\n目前没有实现像以下规则的功能：3 月、6 月、9 月和 12 月的第三个星期五（期货/期权到期日），但可以通过传递一个回调函数来实现规则：\nallow=callable # 回调函数接收一个 datetime.date 实例，如果日期适用于定时器，则返回 True，否则返回 False实现上述规则的代码：\nclass FutOpExp(object): def __init__(self): self.fridays = 0 self.curmonth = -1 def __call__(self, d): _, _, isowkday = d.isocalendar() if d.month != self.curmonth: self.curmonth = d.month self.fridays = 0 # 周一=1 ... 周日=7 if isowkday == 5 and self.curmonth in [3, 6, 9, 12]: self.fridays += 1 if self.fridays == 3: # 第三个星期五 return True # 定时器允许 return False # 定时器不允许然后将 allow=FutOpExp() 传递给定时器的创建。\nadd_timer 的参数# when：可以是 datetime.time 实例（见下文的 tzdata） bt.timer.SESSION_START 引用会话开始时间 bt.timer.SESSION_END 引用会话结束时间 offset：必须是 datetime.timedelta 实例，用于偏移 when 的值。与 SESSION_START 和 SESSION_END 结合使用时很有意义，表示定时器在会话开始后 15 分钟被调用。 repeat：必须是 datetime.timedelta 实例，指示首次调用后，在同一会话内重复调用的间隔。 weekdays：一个排序的可迭代对象，包含整数，指示定时器在星期几（iso 代码，周一为 1，周日为 7）实际有效。如果未指定，定时器将在所有天数有效。 weekcarry（默认值：False）：如果为 True，并且在一周内未看到指定的日期（例如交易假日），定时器将在下一天执行（即使在新的一周内）。 monthdays：一个排序的可迭代对象，包含整数，指示定时器在每月的哪些天实际有效。如果未指定，定时器将在所有天数有效。 monthcarry（默认值：True）：如果未看到指定日期（周末、交易假日），定时器将在下一个可用的日子执行。 allow（默认值：None）：一个回调函数，接收一个 datetime.date 实例，如果日期适用于定时器，则返回 True，否则返回 False。 tzdata：可以是 None（默认），pytz 实例或数据源实例。 None：when 按原样解释（这相当于将其视为 UTC，即使它不是）。 pytz 实例：when 将解释为在指定时区的本地时间。 数据源实例：when 将解释为在数据源实例的 tz 参数指定的本地时间。 strats（默认值：False）：是否调用策略的 notify_timer。 cheat（默认值：False）：如果为 True，定时器将在经纪人有机会评估订单之前调用。这打开了在会话开始前基于开盘价下单的机会。 *args：任何额外的参数将传递给 notify_timer。 **kwargs：任何额外的关键字参数将传递给 notify_timer。 示例用法 scheduled.py# $ ./scheduled.py --help输出结果：\nusage: scheduled.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Sample Skeleton optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例源代码 scheduled.py# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( when=bt.timer.SESSION_START, timer=True, cheat=False, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], ) def __init__(self): bt.ind.SMA() if self.p.timer: self.add_timer( when=self.p.when, offset=self.p.offset, repeat=self.p.repeat, weekdays=self.p.weekdays, ) if self.p.cheat: self.add_timer( when=self.p.when, offset=self.p.offset, repeat=self.p.repeat, cheat=True, ) self.order = None def prenext(self): self.next() def next(self): _, isowk, isowkday = self.datetime.date().isocalendar() txt = \u0026#39;{}, {}, Week {}, Day {}, O {}, H {}, L {}, C {}\u0026#39;.format( len(self), self.datetime.datetime(), isowk, isowkday, self.data.open[0], self.data.high[0], self.data.low[0], self.data.close[0]) print(txt) def notify_timer(self, timer, when, *args, **kwargs): print(\u0026#39;strategy notify_timer with tid {}, when {} cheat {}\u0026#39;. format(timer.p.tid, when, timer.p.cheat)) if self.order is None and timer.p.cheat: print(\u0026#39;-- {} Create buy order\u0026#39;.format(self.data.datetime.date())) self.order = self.buy() def notify_order(self, order): if order.status == order.Completed: print(\u0026#39;-- {} Buy Exec @ {}\u0026#39;.format( self.data.datetime.date(), order.executed.price)) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 数据源 kwargs kwargs = dict( timeframe=bt.TimeFrame.Days, compression=1, sessionstart=datetime.time(9, 0), sessionend=datetime.time(17, 30), ) # 解析 from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # 数据源 data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # 经纪人 cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # 调整器 cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # 策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 执行 cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # 如果请求则绘图 cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Sample Skeleton\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # 日期默认值 parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()示例源代码 scheduled-min.py# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( when=bt.timer.SESSION_START, timer=True, cheat=False, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, ) def __init__(self): bt.ind.SMA() if self.p.timer: self.add_timer( when=self.p.when, offset=self.p.offset, repeat=self.p.repeat, weekdays=self.p.weekdays, weekcarry=self.p.weekcarry, monthdays=self.p.monthdays, monthcarry=self.p.monthcarry, # tzdata=self.data0, ) if self.p.cheat: self.add_timer( when=self.p.when, offset=self.p.offset, repeat=self.p.repeat, weekdays=self.p.weekdays, weekcarry=self.p.weekcarry, monthdays=self.p.monthdays, monthcarry=self.p.monthcarry, # tzdata=self.data0, cheat=True, ) self.order = None def prenext(self): self.next() def next(self): _, isowk, isowkday = self.datetime.date().isocalendar() txt = \u0026#39;{}, {}, Week {}, Day {}, O {}, H {}, L {}, C {}\u0026#39;.format( len(self), self.datetime.datetime(), isowk, isowkday, self.data.open[0], self.data.high[0], self.data.low[0], self.data.close[0]) print(txt) def notify_timer(self, timer, when, *args, **kwargs): print(\u0026#39;strategy notify_timer with tid {}, when {} cheat {}\u0026#39;. format(timer.p.tid, when, timer.p.cheat)) if self.order is None and timer.params.cheat: print(\u0026#39;-- {} Create buy order\u0026#39;.format( self.data.datetime.datetime())) self.order = self.buy() def notify_order(self, order): if order.status == order.Completed: print(\u0026#39;-- {} Buy Exec @ {}\u0026#39;.format( self.data.datetime.datetime(), order.executed.price)) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 数据源 kwargs kwargs = dict( timeframe=bt.TimeFrame.Minutes, compression=5, sessionstart=datetime.time(9, 0), sessionend=datetime.time(17, 30), ) # 解析 from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # 数据源 data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # 经纪人 cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # 调整器 cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # 策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 执行 cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # 如果请求则绘图 cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Timer Test Intraday\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2006-min-005.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # 日期默认值 parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":31,"href":"/backtrader/docs/04-concepts/02-operate-the-platform/","title":"平台操作","section":"核心概念","content":"启动和运行# 如果使用数据重播功能，将为同一个条多次调用next方法，因为条的发展被重播。\n一个基本的策略派生类：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma = btind.SimpleMovingAverage(self.data, period=20) def next(self): if self.sma \u0026gt; self.data.close: self.buy() elif self.sma \u0026lt; self.data.close: self.sell()策略还有其他方法（或挂钩点），可以覆盖：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma = btind.SimpleMovingAverage(self.data, period=20) def next(self): if self.sma \u0026gt; self.data.close: submitted_order = self.buy() elif self.sma \u0026lt; self.data.close: submitted_order = self.sell() def start(self): print(\u0026#39;回测即将开始\u0026#39;) def stop(self): print(\u0026#39;回测已结束\u0026#39;) def notify_order(self, order): print(\u0026#39;已收到新订单/更改/执行/取消通知\u0026#39;)start和stop方法应该是不言自明的。正如预期的那样，并遵循打印函数中的文本，当策略需要通知时将调用notify_order方法。用例：\n请求买入或卖出（如在next中所见） buy/sell将返回一个提交给经纪人的订单。保持对这个提交订单的引用由调用 者决定。\n它可以用于确保如果订单仍在待处理状态，则不提交新订单。 如果订单被接受/执行/取消/更改，经纪人将通过notify方法将状态变化（例如执行规模）通知策略。 快速入门指南在notify_order方法中有一个完整的功能示例来进行订单管理。\n可以通过其他策略类做更多事情：\nbuy / sell / close 使用底层经纪人和定量器发送买入/卖出订单给经纪人\n同样可以通过手动创建订单并将其传递给经纪人来完成。但平台的目的是使使用它的人更容易。\nclose将获取当前市场头寸并立即关闭它。\ngetposition（或属性“position”） 返回当前市场头寸\nsetsizer/getsizer（或属性“sizer”） 这些允许设置/获取底层股份定量器。可以检查相同情况的不同股份定量器逻辑（固定大小、与资本成比例、指数等）\n有很多文献，但Van K. Tharp在这方面有很好的书籍。\n策略是一个线对象，这些对象支持参数，使用标准Python kwargs 参数收集：\nclass MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.sma = btind.SimpleMovingAverage(self.data, period=self.params.period) ...请注意，SimpleMovingAverage不再以固定值20实例化，而是以策略定义的参数“period”实例化。\nCerebro# 一旦数据源可用并定义了策略，Cerebro实例就将所有内容结合在一起并执行操作。实例化一个非常简单：\ncerebro = bt.Cerebro()如果没有特别的需求，默认值将照顾一切。\n创建一个默认经纪人 操作无佣金 数据源将被预加载 默认执行模式将是runonce（批处理操作），这是最快的 所有指标都必须支持runonce模式以达到全速。平台中包含的那些支持。\n自定义指标不需要实现runonce功能。Cerebro将模拟它，这意味着那些不兼容runonce的指标将运行得更慢。但系统的大部分仍将在批处理模式下运行。\n由于数据源已经可用，策略也已经创建，标准的将它们结合在一起并启动运行的方法是：\ncerebro.adddata(data) cerebro.addstrategy(MyStrategy, period=25) cerebro.run()请注意以下几点：\n添加数据源“实例” 添加MyStrategy“类”及将传递给它的参数（kwargs）。 MyStrategy的实例化将在后台由cerebro完成，addstrategy中的任何kwargs将传递给它。 用户可以根据需要添加任意多个策略和数据源。策略如何相互通信以实现协调（如果需要）不受平台的强制/限制。\n当然，Cerebro提供额外的可能性：\n决定预加载和操作模式： cerebro = bt.Cerebro(runonce=True, preload=True)这里有一个限制：runonce需要预加载（如果没有，不能运行批处理操作）。当然，预加载数据源并不强制runonce。\nsetbroker / getbroker（和broker属性） 如果需要，可以设置自定义经纪人。也可以访问实际的经纪人实例。\n绘图。常规情况下只需： cerebro.run() cerebro.plot()plot接受一些参数用于自定义：\nnumfigs=1 如果绘图过于密集，可以将其分成多个图\nplotter=None 可以传递一个客户绘图器实例，cerebro将不实例化默认的。\n**kwargs - 标准关键字参数\n将传递给绘图器。\n请参阅绘图部分了解更多信息。\n策略优化# 如上所述，Cerebro获取一个策略派生类（不是实例）以及将在实例化时传递给它的关键字参数，这将在调用“run”时发生。\n这是为了启用优化。相同的策略类将根据需要实例化多次，并带有新参数。如果将实例传递给cerebro\u0026hellip;这将是不可能的。\n请求优化如下：\ncerebro.optstrategy(MyStrategy, period=xrange(10, 20))optstrategy方法的签名与addstrategy相同，但执行额外的内部操作以确保优化按预期运行。策略可能会将范围视为策略的常规参数，而addstrategy不会对传递的参数做出假设。\n另一方面，optstrategy将理解一个可迭代对象是一组值，必须按顺序传递给策略类的每个实例化。\n注意，传递的是一系列值而不是单个值。在这个简单的例子中，将为此策略尝试10个值10 -\u0026gt; 19（20是上限）。\n如果开发了具有额外参数的更复杂策略，它们都可以传递给optstrategy。必须不进行优化的参数可以直接传递，无需终端用户创建只有一个值的虚拟可迭代对象。例如：\ncerebro.optstrategy(MyStrategy, period=xrange(10, 20), factor=3.5)optstrategy方法看到factor并在后台为factor创建（需要的）虚拟可迭代对象，该对象只有一个元素（在示例中为3.5）。\n注意\n交互式Python shell和某些类型的Windows下冻结的可执行文件在使用Python多进程模块时存在问题。\n请阅读Python文档了解多进程模块。\n"},{"id":32,"href":"/backtrader/docs/03-quickstart/","title":"快速开始","section":"介绍","content":"快速开始# 本文是一份 Backtrader 的快速入门指南，将通过一个完整的示例，带你从零构建一个交易系统，希望在此过程中掌握 Backtrader 的基础使用。\n初始设置： 配置 Backtrader，实例化 Cerebro 准备运行环境； 账户资金： Cerebro 配置初始资金、手续费与滑点； 配置数据：加载历史行情数据（CSV 或 Pandas）并定义时间周期； 演示策略：编写基础策略类，实现最简单的买入逻辑； 开始交易：运行策略，完成第一轮回测； 卖出操作：添加卖出逻辑，支持止盈止损与仓位管理； 交易监控：通过 notify_order 和 notify_trade 实时跟踪成交情况； 参数定义：为策略添加可调参数，为后续优化做准备； 技术指标：引入常用指标（SMA、EMA、RSI 等），完善信号判断； 可视化： 绘制回测结果图，展示每笔交易盈亏与指标变化； 策略优化：利用 optstrategy 功能自动化优化参数，比较收益表现； 在正式动手前，我们需要先理解两个极其关键的概念：Line（线） 和 索引 0（Index 0）。\nLine# 在 Backtrader 的世界中，几乎一切都由 线（Line） 构成。无论是价格数据、指标还是策略内部变量，它们都以 Line 的形式存在。\n你可以把 Line 理解为一条随时间变化的数据序列，就像价格走势图上的那条曲线。一条 Line 是由一系列点（即时间序列数据）构成的，例如收盘价随时间变化的轨迹。\n对于一个典型的行情数据源（DataFeed），每天包含以下几个关键数据点：\n开盘价（Open） 最高价（High） 最低价（Low） 收盘价（Close） 成交量（Volume） 未平仓量（OpenInterest） 沿着时间轴看，这些数据点各自形成一条独立的“线”：如所有的收盘价构成了 Close Line，所有的开盘价构成了 Open Line。\n例如，沿时间轴上的“开盘价”形成了一条线（Line）。因此，一个数据源通常包含6条线。如果再考虑“日期时间” (DateTime)（作为单个点的实际参考），就可以得到7条线（Line）。\n因此，一个完整的数据源通常包含 6 条线。如果再加上用于标识时间的 DateTime，那么一共就是 7 条线。\n在指标（Indicator）中，这一概念同样适用。如简单移动平均线（SMA） 会根据收盘价计算一个平均值序列，这个序列同样是一条 Line。再如布林带、RSI、MACD 等指标，都会在内部生成若干条 Line，分别表示不同的计算结果。\n在 Backtrader 中，Line 是一切的基础结构单位。\n数据 → Line\u0026lt;br/\u0026gt; 指标 → Line 的运算结果\u0026lt;br/\u0026gt; 策略 → 对多条 Line 的逻辑组合与判断\u0026lt;br/\u0026gt;索引0# 理解 Line 之后，另一个必须掌握的核心概念是 索引（Index）。在 Python 中，索引 [0] 通常表示第一个元素，而 [-1] 表示最后一个元素。但 Backtrader 中，索引的语义稍有不同：\n索引 0（[0]）表示当前时刻的值 索引 -1（[-1]）表示上一个时间点的值 索引 -2（[-2]）表示再上一个时间点的值 以此类推。\n例如，假设在策略初始化阶段创建了一个简单移动平均线（SMA）：\nself.sma = bt.indicators.SimpleMovingAverage(self.data.close, period=15)当前的 SMA 值是：\ncurrent_value = self.sma[0]上一个时间点的 SMA 值：\nprevious_value = self.sma[-1]继续往前推：\ntwo_bars_ago = self.sma[-2]这样，我们就可方便地比较过去几个时间点，判断趋势变化、触发信号等。\n# 收盘价刚刚从下方突破均线，则买入 if self.data.close[0] \u0026gt; self.sma[0] and self.data.close[-1] \u0026lt;= self.sma[-1]: self.buy()这段逻辑就是一个典型的 \u0026ldquo;均线突破买入信号\u0026rdquo;。通过索引操作，我们无需关心当前是哪一天或第几根K线，只需直接比较“现在”和“过去”的数值即可。\nLine 和索引的应用# 理解了 Line 和 索引 0，你就掌握了 Backtrader 的“语言”。当编写指标或策略逻辑时，就会经常看到类似这样的写法：\nself.rsi = bt.indicators.RSI(self.data.close)RSI 指标生成了一条新的 Line。\nif self.rsi[0] \u0026gt; 70: self.sell()我们通过 rsi[0] 访问当前 RSI 值，当 RSI 超过 70 时，执行卖出操作。\n无论是移动平均、布林带、RSI，还是你的自定义指标，最终都是 Line + 索引访问 的形式。\n"},{"id":33,"href":"/backtrader/docs/11-commission-schemes/02-commission-schemes-extending/","title":"扩展","section":"Commission","content":"扩展佣金# 佣金及相关功能由一个单一的类 CommissionInfo 管理，通常通过调用 broker.setcommission 实例化。\n这个概念限于带有保证金和每合同固定佣金的期货和基于价格/数量百分比佣金的股票。这不是最灵活的方案，但它已经发挥了它的作用。\nGitHub 上的一个增强请求（#29）导致了一些重构，以便：\n保持 CommissionInfo 和 broker.setcommission 与原始行为兼容 对代码进行一些清理 使佣金方案灵活，以支持增强请求和进一步的可能性 在进入示例之前的实际工作：\nclass CommInfoBase(with_metaclass(MetaParams)): COMM_PERC, COMM_FIXED = range(2) params = ( (\u0026#39;commission\u0026#39;, 0.0), (\u0026#39;mult\u0026#39;, 1.0), (\u0026#39;margin\u0026#39;, None), (\u0026#39;commtype\u0026#39;, None), (\u0026#39;stocklike\u0026#39;, False), (\u0026#39;percabs\u0026#39;, False), )引入了一个 CommissionInfo 的基类，该类添加了新的参数：\ncommtype（默认值：None）\n这是兼容性的关键。如果值为 None，CommissionInfo 对象和 broker.setcommission 的行为将与以前相同。具体如下：\n如果设置了 margin，则佣金方案是期货，每合同有固定佣金 如果未设置 margin，则佣金方案是股票，采用百分比方法 如果值是 COMM_PERC 或 COMM_FIXED（或派生类中的任何其他值），则显然决定了佣金是固定的还是基于百分比的 stocklike（默认值：False）\n如上所述，旧 CommissionInfo 对象中的实际行为由 margin 参数决定。\n如果 commtype 设置为其他值，则此值指示资产是类似期货的资产（将使用保证金并进行基于条形图的现金调整）还是类似股票的资产。\npercabs（默认值：False）\n如果为 False，则百分比必须以相对术语传递（xx%）\n如果为 True，则百分比必须以绝对值传递（0.xx）\nCommissionInfo 是从 CommInfoBase 派生的，将此参数的默认值更改为 True 以保持兼容行为。\n所有这些参数也可以在 broker.setcommission 中使用，现在看起来像这样：\ndef setcommission(self, commission=0.0, margin=None, mult=1.0, commtype=None, percabs=True, stocklike=False, name=None):注意以下几点：\npercabs 为 True，以保持与上述 CommissionInfo 对象的旧调用的兼容行为 旧的测试佣金方案的示例已重新编写以支持命令行参数和新行为。使用帮助如下：\n$ ./commission-schemes.py --help usage: commission-schemes.py [-h] [--data DATA] [--fromdate FROMDATE] [--todate TODATE] [--stake STAKE] [--period PERIOD] [--cash CASH] [--comm COMM] [--mult MULT] [--margin MARGIN] [--commtype {none,perc,fixed}] [--stocklike] [--percrel] [--plot] [--numfigs NUMFIGS] Commission schemes optional arguments: -h, --help show this help message and exit --data DATA, -d DATA data to add to the system (default: ../../datas/2006-day-001.txt) --fromdate FROMDATE, -f FROMDATE Starting date in YYYY-MM-DD format (default: 2006-01-01) --todate TODATE, -t TODATE Starting date in YYYY-MM-DD format (default: 2006-12-31) --stake STAKE Stake to apply in each operation (default: 1) --period PERIOD Period to apply to the Simple Moving Average (default: 30) --cash CASH Starting Cash (default: 10000.0) --comm COMM Commission factor for operation, either apercentage or a per stake unit absolute value (default: 2.0) --mult MULT Multiplier for operations calculation (default: 10) --margin MARGIN Margin for futures-like operations (default: 2000.0) --commtype {none,perc,fixed} Commission - choose none for the old CommissionInfo behavior (default: none) --stocklike If the operation is for stock-like assets orfuture- like assets (default: False) --percrel If perc is expressed in relative xx% ratherthan absolute value 0.xx (default: False) --plot, -p Plot the read data (default: False) --numfigs NUMFIGS, -n NUMFIGS Plot using numfigs figures (default: 1)让我们进行一些运行来重新创建原始佣金方案的原始行为。\n期货佣金（固定且带保证金）# 执行和图表：\n$ ./commission-schemes.py --comm 2.0 --margin 2000.0 --mult 10 --plot输出显示固定佣金为 2.0 货币单位（默认 stake 为 1）：\n2006-03-09, BUY CREATE, 3757.59 2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 2000.00, Comm 2.00 2006-04-11, SELL CREATE, 3788.81 2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 2000.00, Comm 2.00 2006-04-12, TRADE PROFIT, GROSS 328.00, NET 324.00 ...股票佣金（百分比且无保证金）# 执行和图表：\n$ ./commission-schemes.py --comm 0.005 --margin 0 --mult 1 --plot为了提高可读性，可以使用相对百分比值：\n$ ./commission-schemes.py --percrel --comm 0.5 --margin 0 --mult 1 --plot现在 0.5 直接表示 0.5%\n输出在两种情况下都是：\n2006-03-09, BUY CREATE, 3757.59 2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 3754.13, Comm 18.77 2006-04-11, SELL CREATE, 3788.81 2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 3754.13, Comm 18.93 2006-04-12, TRADE PROFIT, GROSS 32.80, NET -4.91 ...期货佣金（百分比且带保证金）# 使用新参数，基于百分比的期货方案：\n$ ./commission-schemes.py --commtype perc --percrel --comm 0.5 --margin 2000 --mult 10 --plot不意外的是，通过改变佣金……最终结果也改变了\n输出显示佣金现在是可变的：\n2006-03-09, BUY CREATE, 3757.59 2006-03-10, BUY EXECUTED, Price: 3754.13, Cost: 2000.00, Comm 18.77 2006-04-11, SELL CREATE, 3788.81 2006-04-12, SELL EXECUTED, Price: 3786.93, Cost: 2000.00, Comm 18.93 2006-04-12, TRADE PROFIT, GROSS 328.00, NET 290.29 ...在之前的运行中设置了 2.0 货币单位（对于默认 stake 为 1）\n另一个帖子将详细说明新类和自定义佣金方案的实现。\n示例# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind class SMACrossOver(bt.Strategy): params = ( (\u0026#39;stake\u0026#39;, 1), (\u0026#39;period\u0026#39;, 30), ) def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39; Logging function for this strategy\u0026#39;\u0026#39;\u0026#39; dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: # Buy/Sell order submitted/accepted to/by broker - Nothing to do return # Check if an order has been completed # Attention: broker could reject order if not enougth cash if order.status in [order.Completed, order.Canceled, order.Margin]: if order.isbuy(): self.log( \u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: # Sell self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) def notify_trade(self, trade): if trade.isclosed: self.log(\u0026#39;TRADE PROFIT, GROSS %.2f, NET %.2f\u0026#39; % (trade.pnl, trade.pnlcomm)) def __init__(self): sma = btind.SMA(self.data, period=self.p.period) # \u0026gt; 0 crossing up / \u0026lt; 0 crossing down self.buysell_sig = btind.CrossOver(self.data, sma) def next(self): if self.buysell_sig \u0026gt; 0: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.data.close[0]) self.buy(size=self.p.stake) # keep order ref to avoid 2nd orders elif self.position and self.buysell_sig \u0026lt; 0: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.data.close[0]) self.sell(size=self.p.stake) def runstrategy(): args = parse_args() # Create a cerebro cerebro = bt.Cerebro() # Get the dates from the args fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) todate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) # Create the 1st data data = btfeeds.BacktraderCSVData( dataname=args.data, fromdate=fromdate, todate=todate) # Add the 1st data to cerebro cerebro.adddata(data) # Add a strategy cerebro.addstrategy(SMACrossOver, period=args.period, stake=args.stake) # Add the commission - only stocks like a for each operation cerebro.broker.setcash(args.cash) commtypes = dict( none=None, perc=bt.CommInfoBase.COMM_PERC, fixed=bt.CommInfoBase.COMM_FIXED) # Add the commission - only stocks like a for each operation cerebro.broker.setcommission(commission=args.comm, mult=args.mult, margin=args.margin, percabs=not args.percrel, commtype=commtypes[args.commtype], stocklike=args.stocklike) # And run it cerebro.run() # Plot if requested if args.plot: cerebro.plot(numfigs=args.numfigs, volume=False) def parse_args(): parser = argparse.ArgumentParser( description=\u0026#39;Commission schemes\u0026#39;, formatter_class=argparse.ArgumentDefaultsHelpFormatter,) parser.add_argument(\u0026#39;--data\u0026#39;, \u0026#39;-d\u0026#39;, default=\u0026#39;../../datas/2006-day-001.txt\u0026#39;, help=\u0026#39;data to add to the system\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, \u0026#39;-f\u0026#39;, default=\u0026#39;2006-01-01\u0026#39;, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, \u0026#39;-t\u0026#39;, default=\u0026#39;2006-12-31\u0026#39;, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--stake\u0026#39;, default=1, type=int, help=\u0026#39;Stake to apply in each operation\u0026#39;) parser.add_argument(\u0026#39;--period\u0026#39;, default=30, type=int, help=\u0026#39;Period to apply to the Simple Moving Average\u0026#39;) parser.add_argument(\u0026#39;--cash\u0026#39;, default=10000.0, type=float, help=\u0026#39;Starting Cash\u0026#39;) parser.add_argument(\u0026#39;--comm\u0026#39;, default=2.0, type=float, help=(\u0026#39;Commission factor for operation, either a\u0026#39; \u0026#39;percentage or a per stake unit absolute value\u0026#39;)) parser.add_argument(\u0026#39;--mult\u0026#39;, default=10, type=int, help=\u0026#39;Multiplier for operations calculation\u0026#39;) parser.add_argument(\u0026#39;--margin\u0026#39;, default=2000.0, type=float, help=\u0026#39;Margin for futures-like operations\u0026#39;) parser.add_argument(\u0026#39;--commtype\u0026#39;, required=False, default=\u0026#39;none\u0026#39;, choices=[\u0026#39;none\u0026#39;, \u0026#39;perc\u0026#39;, \u0026#39;fixed\u0026#39;], help=(\u0026#39;Commission - choose none for the old\u0026#39; \u0026#39; CommissionInfo behavior\u0026#39;)) parser.add_argument(\u0026#39;--stocklike\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;If the operation is for stock-like assets or\u0026#39; \u0026#39;future-like assets\u0026#39;)) parser.add_argument(\u0026#39;--percrel\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;If perc is expressed in relative xx% rather\u0026#39; \u0026#39;than absolute value 0.xx\u0026#39;)) parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Plot the read data\u0026#39;) parser.add_argument(\u0026#39;--numfigs\u0026#39;, \u0026#39;-n\u0026#39;, default=1, help=\u0026#39;Plot using numfigs figures\u0026#39;) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrategy()"},{"id":34,"href":"/backtrader/docs/06-datafeed/02-datafeed-extending/","title":"扩展数据源","section":"DataFeed","content":"扩展数据源# 用户是否可以轻松扩展现有机制，以添加额外的信息，将其与现有的价格信息（如开盘价、高价等）一起传递？\n据我了解，答案是：可以。\n一个数据源，正在解析为 CSV 格式 使用 GenericCSVData 加载信息 这种通用 CSV 支持是为了响应 Issue #6 开发的 一个额外的字段，显然包含 P/E 信息，需要与解析的 CSV 数据一起传递 让我们基于 CSV 数据源开发和 GenericCSVData 示例帖子构建。\n步骤：# 假设 P/E 信息已设置在被解析的 CSV 数据中 使用 GenericCSVData 作为基类 使用 pe 扩展现有的行（开盘价/最高价/最低价/收盘价/成交量/持仓兴趣） 添加一个参数，让调用者确定 P/E 信息的列位置 结果如下：\nfrom backtrader.feeds import GenericCSVData class GenericCSV_PE(GenericCSVData): # 添加 \u0026#39;pe\u0026#39; 行到从基类继承的行中 lines = (\u0026#39;pe\u0026#39;,) # GenericCSVData 中的 openinterest 索引为 7 ... 添加 1 # 将参数添加到从基类继承的参数中 params = ((\u0026#39;pe\u0026#39;, 8),)这样工作就完成了\u0026hellip;\n稍后在策略中使用此数据源时：\nimport backtrader as bt .... class MyStrategy(bt.Strategy): ... def next(self): if self.data.close \u0026gt; 2000 and self.data.pe \u0026lt; 12: # TORA TORA TORA --- 退出市场 self.sell(stake=1000000, price=0.01, exectype=Order.Limit) ...绘制额外的 P/E 行# 显然，数据源中没有自动绘制支持这个额外的行。\n最好的替代方法是在该行上进行简单移动平均并在单独的轴上绘制：\nimport backtrader as bt import backtrader.indicators as btind .... class MyStrategy(bt.Strategy): def __init__(self): # 指标自动注册，即使在类中没有保留明显的引用也会绘制 btind.SMA(self.data.pe, period=1, subplot=False) ... def next(self): if self.data.close \u0026gt; 2000 and self.data.pe \u0026lt; 12: # TORA TORA TORA --- 退出市场 self.sell(stake=1000000, price=0.01, exectype=Order.Limit) ..."},{"id":35,"href":"/backtrader/docs/08-indicators/02-indicators-development/","title":"指标开发","section":"Indicator","content":"指标开发# 如果需要开发任何内容（除了一个或多个获胜策略），这个内容就是自定义指标。在平台内开发此类内容很容易。\n开发要点：\n从 Indicator 类（直接或从现有子类）派生一个类； 定义它将包含的 Line； 一个指标至少要有一条线。如果从现有的类派生，线条可能已经定义好了 可选地定义可以改变行为的参数 可选地提供/自定义一些用于合理绘制指标的元素 在 __init__ 中提供一个完全定义的操作，并绑定（分配）到指标的线条，或者提供 next 方法和（可选的）once 方法 如果一个指标可以在初始化期间通过逻辑/算术操作完全定义，且结果分配给线条：完成。如果情况不是这样，至少要提供一个 next 方法，其中指标必须在索引 0 处分配一个值给线条。可以通过提供 once 方法来优化运行一次模式（批处理操作）的计算。\n重要说明：幂等性# 指标为每个接收到的条生成一个输出。不能假设同一个条会被发送多少次。操作必须是幂等的。\n其背后的理由：\n同一个条（索引-wise）可以多次发送，并且值会变化（即变化的值是收盘价） 这使得可以“重放”一个日内会话，但使用由 5 分钟条组成的日内数据。 这也允许平台从实时数据源获取值。\n一个简单（但功能齐全）的指标# 可以这样：\nclass DummyInd(bt.Indicator): lines = (\u0026#39;dummyline\u0026#39;,) params = ((\u0026#39;value\u0026#39;, 5),) def __init__(self): self.lines.dummyline = bt.Max(0.0, self.params.value)完成！\n该指标将始终输出相同的值：要么是 0.0，要么是 self.params.value（如果它恰好大于 0.0）。\n使用 next 方法的相同指标：\nclass DummyInd(bt.Indicator): lines = (\u0026#39;dummyline\u0026#39;,) params = ((\u0026#39;value\u0026#39;, 5),) def next(self): self.lines.dummyline[0] = max(0.0, self.params.value)完成！相同行为。\n注意： 请注意在 __init__ 版本中，使用 bt.Max 将值分配给线条对象 self.lines.dummyline。 bt.Max 返回一个线条对象，它会为传递给指标的每个条自动迭代。如果使用 max，赋值将毫无意义，因为指标将有一个固定值的成员变量，而不是线条。在 next 期间，直接使用浮点值进行工作，可以使用标准的 max 内置函数。\n回顾一下，self.lines.dummyline 是长表示法，可以缩短为：\nself.l.dummyline甚至可以缩短为：\nself.dummyline只有在代码没有用成员属性遮蔽这个变量时，后者才有可能。\n第三个也是最后一个版本提供了一个额外的 once 方法来优化计算：\nclass DummyInd(bt.Indicator): lines = (\u0026#39;dummyline\u0026#39;,) params = ((\u0026#39;value\u0026#39;, 5),) def next(self): self.lines.dummyline[0] = max(0.0, self.params.value) def once(self, start, end): dummy_array = self.lines.dummyline.array for i in range(start, end): dummy_array[i] = max(0.0, self.params.value)更有效，但开发 once 方法迫使深入研究。实际上，已经深入到内部。\n__init__ 版本无论如何都是最好的：\n所有内容都限制在初始化期间 自动提供 next 和 once（都已优化，因为 bt.Max 已经有它们），无需处理索引和/或公式 如果需要开发，指标也可以覆盖与 next 和 once 相关的方法：\nprenext 和 nextstart preonce 和 oncestart 手动/自动最小周期# 如果可能，平台将计算它，但可能需要手动操作。\n以下是一个简单移动平均线的实现：\nclass SimpleMovingAverage1(Indicator): lines = (\u0026#39;sma\u0026#39;,) params = ((\u0026#39;period\u0026#39;, 20),) def next(self): datasum = math.fsum(self.data.get(size=self.p.period)) self.lines.sma[0] = datasum / self.p.period虽然看起来合理，但平台不知道最小周期是什么，即使参数被命名为“period”（名称可能具有误导性，一些指标接收多个“period”，它们有不同的用途）。\n在这种情况下，next 将在第一个条已经进入系统时被调用，并且所有事情都会爆炸，因为 get 不能返回所需的 self.p.period。\n在解决情况前，需要考虑：\n传递给指标的数据源可能已经携带最小周期。示例 SimpleMovingAverage 可以在以下情况下进行：\n常规数据源：默认最小周期为 1（只等待进入系统的第一个条）。 另一个移动平均线：它已经有一个周期。如果是 20，再次我们的示例移动平均线也是 20，我们最终得到的最小周期是 40 条。 实际上，内部计算说是 39……因为一旦第一个移动平均线生成了一个条，这个条将计入下一个移动平均线，这就创建了一个重叠条，因此需要 39。其他指标/对象也携带周期。\n缓解情况如下：\nclass SimpleMovingAverage1(Indicator): lines = (\u0026#39;sma\u0026#39;,) params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.addminperiod(self.params.period) def next(self): datasum = math.fsum(self.data.get(size=self.p.period)) self.lines.sma[0] = datasum / self.p.periodaddminperiod 方法告诉系统考虑该指标所需的额外周期条，无论现有的最小周期是什么。有时这完全不需要，如果所有计算都使用已经向系统传达其周期需求的对象。\n一个快速的 MACD 实现带有直方图：\nfrom backtrader.indicators import EMA class MACD(Indicator): lines = (\u0026#39;macd\u0026#39;, \u0026#39;signal\u0026#39;, \u0026#39;histo\u0026#39;,) params = ((\u0026#39;period_me1\u0026#39;, 12), (\u0026#39;period_me2\u0026#39;, 26), (\u0026#39;period_signal\u0026#39;, 9),) def __init__(self): me1 = EMA(self.data, period=self.p.period_me1) me2 = EMA(self.data, period=self.p.period_me2) self.l.macd = me1 - me2 self.l.signal = EMA(self.l.macd, period=self.p.period_signal) self.l.histo = self.l.macd - self.l.signal完成！无需考虑最小周期。\nEMA 代表指数移动平均线（平台内置别名），这个（已经在平台中）已经声明了它的需求。指标的命名线条“macd”和“signal”被分配了已经携带声明（幕后）的周期的对象。\nmacd 从操作“me1 - me2”中获取周期，而 me1 和 me2 都是具有不同周期的指数移动平均线。signal 直接从 macd 上的指数移动平均线获取周期。这个 EMA 也考虑到现有的 macd 周期和计算自身所需的样本量（period_signal）。histo 获取两个操作数“signal - macd”的最大值。一旦两者准备好，histo 也可以生成一个值\n一个完整的自定义指标# 让我们开发一个简单的自定义指标，它“指示”一个移动平均线（可以通过参数修改）是否在给定数据之上：\nimport backtrader as bt import backtrader.indicators as btind class OverUnderMovAv(bt.Indicator): lines = (\u0026#39;overunder\u0026#39;,) params = dict(period=20, movav=btind.MovAv.Simple) def __init__(self): movav = self.p.movav(self.data, period=self.p.period) self.l.overunder = bt.Cmp(movav, self.data)完成！\n如果平均线在数据之上，指标将具有值“1”；如果在数据之下，则为“-1”。如果数据是常规数据源，则比较收盘价将生成 1 和 -1。\n虽然在绘图部分可以看到更多内容，为了在绘图世界中有一个良好和漂亮的公民，可以添加一些内容：\nimport backtrader as bt import backtrader.indicators as btind class OverUnderMovAv(bt.Indicator): lines = (\u0026#39;overunder\u0026#39;,) params = dict(period=20, movav=btind.MovAv.Simple) plotinfo = dict( # 在 1 和 -1 之上和之下添加额外的边距 plotymargin=0.15, # 绘制参考水平线在 1.0 和 -1.0 plothlines=[1.0, -1.0], # 简化 y 轴刻度为 1.0 和 -1.0 plotyticks=[1.0, -1.0]) # 使用虚线样式绘制 \u0026#34;overunder\u0026#34; 线（唯一的一个） # ls 代表线条样式，并直接传递给 matplotlib plotlines = dict(overunder=dict(ls=\u0026#39;--\u0026#39;)) def _plotlabel(self): # 此方法返回将在绘图上显示的标签列表 # 在指标名称之后 # 周期必须始终存在 plabels = [self.p.period] # 如果不是默认移动平均线，只放移动平均线 plabels += [self.p.movav] * self.p.notdefault(\u0026#39;movav\u0026#39;) return plabels def __init__(self): movav = self.p.movav(self.data, period=self.p.period) self.l.overunder = bt.Cmp(movav, self.data)完成！\n这个指标将具有 1 和 -1 的值，并且在绘图中有良好的表现。\n"},{"id":36,"href":"/backtrader/docs/10-broker/02-slippage/","title":"滑点","section":"Broker","content":"滑点# 回测无法保证真实市场条件。无论市场模拟有多好，在真实市场条件下滑点可能发生。这意味着，请求的价格可能无法匹配。\n集成的回测经纪商支持滑点，以下参数可以传递给经纪商：\n参数名 默认值 描述 slip_perc 0.0 应用于买卖订单的价格上下滑动的绝对百分比（且为正值），注意：0.01 是 1%，0.001 是 0.1%； slip_fixed 0.0 应用于买卖订单的价格上下滑动的单位百分比（且为正值），注意：如果 slip_perc 非零，则优先于此。 slip_open False 是否为专门使用下一个柱的开盘价执行的订单滑动价格。例如，市场订单将在下一个可用tick执行，即柱的开盘价。这也适用于其他一些执行，因为逻辑尝试检测开盘价是否会匹配请求的价格/执行类型在移动到新柱时。 slip_match True - 如果为 True，经纪商将通过在高/低价位封顶滑点来提供匹配，以防它们超出。- 如果为 False，经纪商将不会使用当前价格匹配订单，并将在下一次迭代中尝试执行 slip_limit True - 限价订单，给定确切的匹配价格请求，即使 slip_match 为 False，也会被匹配。- 此选项控制该行为。- 如果为 True，那么限价订单将通过在限价/高低价位封顶价格进行匹配。- 如果为 False 且滑点超出上限，则不会有匹配 slip_out False 即使价格超出高-低范围，也提供滑点。 工作原理# 为了决定何时应用滑点，考虑了订单执行类型：\nClose - 不应用滑点\n这种订单匹配收盘价，而这个价格是当天的最后一个。滑点无法发生，因为订单只能在会话的最后一个tick发生，而这是唯一的价格，没有容忍度。 Market - 应用滑点\n请检查 slip_open 例外情况。因为市场订单将匹配下一个柱的开盘价。 Limit - 按以下逻辑应用滑点\n如果匹配价格是开盘价，则根据参数 slip_open 应用滑点。如果应用，价格不会比请求的限价更差。 如果匹配价格不是限价，则应用滑点在高/低点封顶。在这种情况下，slip_limit 应用以决定在超过封顶时是否会发生匹配。 如果匹配价格是限价，则不应用滑点。 Stop - 一旦订单触发，应用与市场订单相同的逻辑\nStopLimit - 一旦订单触发，应用与限价订单相同的逻辑\n这种方法试图在模拟和可用数据的限制范围内提供最现实的方法。\n配置滑点# 每次运行时，Cerebro 引擎已实例化一个经纪商，使用默认参数。有两种方法配置滑点。\n配置滑点为基于百分比的方法\nBackBroker.set_slippage_perc( perc, slip_open=True, slip_limit=True, slip_match=True, slip_out=False, )配置滑点为固定点数的方法：\nBackBroker.set_slippage_fixed( fixed, slip_open=True, slip_limit=True, slip_match=True, slip_out=False, )替换经纪商，例如：\nimport backtrader as bt cerebro = bt.Cerebro() cerebro.broker = bt.brokers.BackBroker(slip_perc=0.005) # 0.5%实际示例# 源码包含一个使用订单执行类型 Market 和使用信号的多/空方法的示例。这应该可以理解逻辑。\n没有滑点的运行和初始图表供以后参考：\n$ ./slippage.py --plot 01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3040.55 02 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 03 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 06 2005-05-19 23:59:59 BUY Size: +1 / Price: 3034.88 ... 35 2006-12-19 23:59:59 BUY Size: +1 / Price: 4121.01\n使用配置为 1.5% 滑点的相同运行：\n$ ./slippage.py --slip_perc 0.015 01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3040.55 02 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 03 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 06 2005-05-19 23:59:59 BUY Size: +1 / Price: 3034.88 ... 35 2006-12-19 23:59:59 BUY Size: +1 / Price: 4121.01没有变化。这是预期的行为。\n执行类型：Market\n且未设置 slip_open 为 True\n市场订单匹配下一个柱的开盘价，我们不允许开盘价移动。\n设置 slip_open 为 True 的运行：\n$ ./slippage.py --slip_perc 0.015 --slip_open 01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3021.66 02 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 03 2005-04-11 23:59:59 BUY Size: +1 / Price: 3088.47 04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38 06 2005-05-19 23:59:59 BUY Size: +1 / Price: 3055.14 ... 35 2006-12-19 23:59:59 BUY Size: +1 / Price: 4121.01可以立即看到价格已经移动。分配的价格更差或相同，例如操作 35。打开和高点在 2016-12-19 是相同的。价格不能高于高点，因为这将返回不存在的价格。\n当然，如果需要，Backtrader 允许在高-低范围之外匹配。启用 slip_out 的运行：\n$ ./slippage.py --slip_perc 0.015 --slip_open --slip_out 01 2005-03-22 23:59:59 SELL Size: -1 / Price: 2994.94 02 2005-04-11 23:59:59 BUY Size: +1 / Price: 3134.80 03 2005-04-11 23:59:59 BUY Size: +1 / Price: 3134.80 04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2904.15 05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2904.15 06 2005-05-19 23:59:59 BUY Size: +1 / Price: 3080.40 ... 35 2006-12-19 23:59:59 BUY Size: +1 / Price: 4182.83匹配价格的表达式将是：OMG！（我的天！）。价格明显超出范围。足以看操作 35，匹配在 4182.83\n。快速检查图表显示，资产从未接近过该价格。\nslip_match 默认值为 True，这意味着 Backtrader 提供匹配，无论价格是封顶还是未封顶。禁用它：\n$ ./slippage.py --slip_perc 0.015 --slip_open --no-slip_match 01 2005-04-15 23:59:59 SELL Size: -1 / Price: 3028.10 02 2005-05-18 23:59:59 BUY Size: +1 / Price: 3029.40 03 2005-06-01 23:59:59 BUY Size: +1 / Price: 3124.03 04 2005-10-06 23:59:59 SELL Size: -1 / Price: 3365.57 05 2005-10-06 23:59:59 SELL Size: -1 / Price: 3365.57 06 2005-12-01 23:59:59 BUY Size: +1 / Price: 3499.95 07 2005-12-01 23:59:59 BUY Size: +1 / Price: 3499.95 08 2006-02-28 23:59:59 SELL Size: -1 / Price: 3782.71 09 2006-02-28 23:59:59 SELL Size: -1 / Price: 3782.71 10 2006-05-23 23:59:59 BUY Size: +1 / Price: 3594.68 11 2006-05-23 23:59:59 BUY Size: +1 / Price: 3594.68 12 2006-11-27 23:59:59 SELL Size: -1 / Price: 3984.37 13 2006-11-27 23:59:59 SELL Size: -1 / Price: 3984.37下滑至 13 从 35。原理：\n禁用 slip_match 不允许在滑点会推高于高点或低于低点时匹配操作。似乎1.5%的请求滑点，有约22个操作无法执行。\n这些例子应该显示了不同滑点选项如何协同工作。\n"},{"id":37,"href":"/backtrader/docs/04-concepts/01-platform-concepts/02-params/","title":"策略参数","section":"平台概念","content":"策略参数# 策略基本上都需要参数，而在 backtrader 中，这些参数可作为类属性进行声明。我们可以通过元组或字典的形式声明这些策略变量。\n元组：\nclass MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),)字典：\nclass MyStrategy(bt.Strategy): params = dict(period=20)无论是元组还是字典，参数声明后，都可以通过 self.params 或 self.p 访问参数的值。\nclass MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=self.p.period)在这个例子中，self.p.period 就是获取 period 参数的值。\n参数继承# 如果你在一个类中定义了参数，子类会自动继承这些参数。你可以在子类中重写这些参数的默认值。\nclass BaseStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) class MyStrategy(BaseStrategy): params = ((\u0026#39;period\u0026#39;, 30),) # 重写父类的 period 参数如果你使用多重继承，子类会继承所有父类的参数。如果多个父类定义了相同的参数，子类会使用继承列表中最后一个类的默认值。\n"},{"id":38,"href":"/backtrader/docs/16-plotting/02-ploting-date-ranges/","title":"绘制日期范围","section":"绘图","content":"日期范围# 在 1.9.31.x 版本中，backtrader 增加了部分绘图的功能。\n可以使用策略实例中保存的完整时间戳数组的索引来指定绘图范围\n也可以使用实际的 datetime.date 或 datetime.datetime 实例来限制绘图范围。\n仍然通过标准的 cerebro.plot 进行。例如：\ncerebro.plot(start=datetime.date(2005, 7, 1), end=datetime.date(2006, 1, 31))这对人类来说是最直接的方法。具有扩展能力的人类实际上可以尝试使用时间戳的索引，如下所示：\ncerebro.plot(start=75, end=185)下面是一个非常标准的示例，其中包含一个简单移动平均线（在数据上绘图）、一个随机指标（独立绘图）以及随机指标线的交叉。在命令行参数中传递给 cerebro.plot 的参数。\n使用日期方法的执行：\n./partial-plot.py --plot \u0026#39;start=datetime.date(2005, 7, 1),end=datetime.date(2006, 1, 31)\u0026#39;Python 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有意义的内容。输出图表如下所示：\n让我们将其与完整的绘图进行比较，以查看数据是否确实从两端跳过：\n./partial-plot.py --plotPython 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有意义的内容。输出图表如下所示：\n示例用法# $ ./partial-plot.py --help usage: partial-plot.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Sample for partial plotting optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = () def __init__(self): bt.ind.SMA() stoc = bt.ind.Stochastic() bt.ind.CrossOver(stoc.lines.percK, stoc.lines.percD) def next(self): pass def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 数据馈送 kwargs kwargs = dict() # 解析 from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # 数据馈送 data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # 经纪人 cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # 大小调整器 cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # 策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 执行 cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # 如果请求绘图，则绘制 cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Sample for partial plotting\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # 日期的默认值 parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":39,"href":"/backtrader/docs/03-quickstart/02-cash/","title":"账户资金","section":"快速开始","content":"设置初始账户资金# 上节中，账户资金使是默认值 10,000 货币单位。当然，这个默认值是可以更改的，通过 cerebro.broker 的 setcash 方法即可。\ncerebro.broker.setcash(100000.0)完整示例# import backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.broker.setcash(100000.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出：\nStarting Portfolio Value: 100000.00 Final Portfolio Value: 100000.00让我们继续进入下一节，配置数据源（DataFeed）。\n"},{"id":40,"href":"/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/","title":"跨平台回测的陷进","section":"官方文章","content":"跨平台回测的陷阱# 在 Backtrader 社区中，经常有用户希望将 TradingView 等流行的回测平台上的回测结果进行复制。TradingView 使用的脚本语言是 Pinescript，而用户往往并不了解该语言的具体实现，也未接触过回测引擎的内部机制。因此，即使用户有意复制回测结果，也必须明白跨平台编程有其局限性。\n指标：并不总是忠实于原始定义# 当在 Backtrader 中实现新指标时，开发者会特别强调尊重指标的原始定义。例如，RSI 指标就是一个典型的例子。\nWelles Wilder 设计 RSI 时使用了修改过的移动平均（即平滑移动平均，参见 Wikipedia - Modified Moving Average）。然而，许多平台提供的 RSI 指标，实际上使用的是经典的指数移动平均（EMA），而非书中的定义。\n尽管两者的差别并不算巨大，但这并不是 Wilder 原始定义的 RSI。它可能仍然有用，甚至可能更好，但它并不等同于 Wilder 所定义的 RSI。而且，大多数文档（如果有的话）并未提到这一点。\n在 Backtrader 中，RSI 的默认配置使用 MMA，以保持忠实于原始定义。不过，开发者可以通过子类化或者在运行时实例化时，选择使用 EMA 或者简单移动平均（SMA）来替代。\n例子：唐奇安通道# Wikipedia 中的定义是这样的：Wikipedia - Donchian Channel。但是，它只是一些文字，未提到如何使用通道突破作为交易信号。\n另外，以下两个定义明确说明，计算通道时数据不包括当前的柱线，因为如果包括了，突破就无法被反映出来：\nStockCharts - School - Price Channels IncredibleCharts - Donchian Channels 这些来源明确指出，计算通道时不包含当前的价格柱线，这样突破才会被正确显示。以下是来自 StockCharts 的示例图表：\nStockCharts - Donchian Channels - Breakouts\n然后，我们看看 TradingView。首先是链接： TradingView - Wiki - Donchian Channels\n以及该页面的图表：\nTradingView - Donchian Channels - No Breakouts\n甚至 Investopedia 也使用了来自 TradingView 的图表，显示没有突破：\nInvestopedia - Donchian Channels\n许多人可能会惊讶，因为 TradingView 中没有显示突破。这意味着 TradingView 的 Donchian 通道实现方式将当前的价格柱线也考虑进了计算。\nBacktrader 中的唐奇安通道# Backtrader 中没有内置的 DonchianChannels 实现，但我们可以轻松地创建一个。是否将当前柱线用于通道计算，是一个可以调节的参数。\n以下是代码示例：\nclass DonchianChannels(bt.Indicator): \u0026#39;\u0026#39;\u0026#39; 参数说明： - ``lookback``（默认：-1） 如果是 `-1`，则考虑从过去一根柱线开始计算，当前的高/低价可能突破通道。 如果是 `0`，则当前的价格将被用于计算 Donchian 通道。这意味着价格**永远**不会突破上下通道带。 \u0026#39;\u0026#39;\u0026#39; alias = (\u0026#39;DCH\u0026#39;, \u0026#39;DonchianChannel\u0026#39;,) lines = (\u0026#39;dcm\u0026#39;, \u0026#39;dch\u0026#39;, \u0026#39;dcl\u0026#39;,) # dc 中线，dc 高线，dc 低线 params = dict( period=20, lookback=-1, # 是否考虑当前柱线 ) plotinfo = dict(subplot=False) # 与数据一起绘制 plotlines = dict( dcm=dict(ls=\u0026#39;--\u0026#39;), # 虚线 dch=dict(_samecolor=True), # 使用与前一个线条相同的颜色（dcm） dcl=dict(_samecolor=True), # 使用与前一个线条相同的颜色（dch） ) def __init__(self): hi, lo = self.data.high, self.data.low if self.p.lookback: # 根据需要向后移动 hi, lo = hi(self.p.lookback), lo(self.p.lookback) self.l.dch = bt.ind.Highest(hi, period=self.p.period) self.l.dcl = bt.ind.Lowest(lo, period=self.p.period) self.l.dcm = (self.l.dch + self.l.dcl) / 2.0 # 上下通道的平均值使用 lookback=-1 的配置，生成的图表如下（放大查看）：\nBacktrader - Donchian Channels - Breakouts\n可以清晰地看到突破，而使用 lookback=0 时则看不到突破。\nBacktrader - Donchian Channels - No Breakouts\n编码中的隐含问题# 如果程序员首先在商业平台上实现策略，并且由于图表未显示突破，他们就可能会进行如下的代码编写：\nif price0 \u0026gt; channel_high_1: sell() elif price0 \u0026lt; channel_low_1: buy()其中，price0 会与前一周期的通道高/低进行比较（因此 _1 后缀表示前一周期）。\n然而，在不了解 Backtrader 中 Donchian 通道默认包含突破的情况下，程序员会编写如下代码：\ndef __init__(self): self.donchian = DonchianChannels() def next(self): if self.data[0] \u0026gt; self.donchian.dch[-1]: self.sell() elif self.data[0] \u0026lt; self.donchian.dcl[-1]: self.buy()这是错误的！因为突破是在进行比较的同时就已经发生了。正确的代码应该是：\ndef __init__(self): self.donchian = DonchianChannels() def next(self): if self.data[0] \u0026gt; self.donchian.dch[0]: self.sell() elif self.data[0] \u0026lt; self.donchian.dcl[0]: self.buy()虽然这只是一个小例子，但它揭示了回测结果如何因指标实现的差异而产生不同的情况。虽然差别看起来不大，但错误的交易判断可能会带来巨大的影响。\n"},{"id":41,"href":"/backtrader/docs/12-analyzers/03-pyfolio-integration/","title":"Pyfolio 集成","section":"Analyzer","content":"Pyfolio 集成# 在 Ticket #108 中提出了一个投资组合工具，即 pyfolio 的集成。\n一开始看教程觉得很难，因为 zipline 和 pyfolio 之间的紧密集成，但 pyfolio 提供的一些其他用途的示例测试数据实际上非常有用，可以解码幕后运行的内容，从而实现集成。\n在 backtrader 中大多数部分已经就位：\n分析器基础设施 子分析器 TimeReturn 分析器 只需要一个主 PyFolio 分析器和三个简单的子分析器。再加上依赖于 pyfolio 所需的依赖项之一，即 pandas 的方法。\n最具挑战的部分是…“正确获取所有依赖项”。\n更新 pandas 更新 numpy 更新 scikit-lean 更新 seaborn 在类似 Unix 的环境中，有一个 C 编译器，一切都是时间问题。在 Windows 上，即使安装了特定的 Microsoft 编译器（在这种情况下是 Python 2.7 的链），事情也失败了。但一个知名网站拥有最新的 Windows 软件包集合，提供了帮助。如果你需要它，可以访问：\nhttp://www.lfd.uci.edu/~gohlke/pythonlibs/\n如果没有测试集成，它就不会完成，这就是为什么通常的示例总是存在的原因。\n没有 PyFolio# 示例使用 random.randint 来决定何时买卖，因此这只是检查事情是否正常运行：\n$ ./pyfoliotest.py --printout --no-pyfolio --plot输出：\nLen,Datetime,Open,High,Low,Close,Volume,OpenInterest 0001,2005-01-03T23:59:59,38.36,38.90,37.65,38.18,25482800.00,0.00 BUY 1000 @%23.58 0002,2005-01-04T23:59:59,38.45,38.54,36.46,36.58,26625300.00,0.00 BUY 1000 @%36.58 SELL 500 @%22.47 0003,2005-01-05T23:59:59,36.69,36.98,36.06,36.13,18469100.00,0.00 ... SELL 500 @%37.51 0502,2006-12-28T23:59:59,25.62,25.72,25.30,25.36,11908400.00,0.00 0503,2006-12-29T23:59:59,25.42,25.82,25.33,25.54,16297800.00,0.00 SELL 250 @%17.14 SELL 250 @%37.01有 3 个数据，多个买卖操作在测试运行的默认两年期间随机选择和分散。\n一个 PyFolio 运行# pyfolio 在 Jupyter Notebook 内运行效果很好，包括内联绘图。以下是 notebook 示例：\n%matplotlib inline from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import random import backtrader as bt class St(bt.Strategy): params = ( (\u0026#39;printout\u0026#39;, False), (\u0026#39;stake\u0026#39;, 1000), ) def __init__(self): pass def start(self): if self.p.printout: txtfields = list() txtfields.append(\u0026#39;Len\u0026#39;) txtfields.append(\u0026#39;Datetime\u0026#39;) txtfields.append(\u0026#39;Open\u0026#39;) txtfields.append(\u0026#39;High\u0026#39;) txtfields.append(\u0026#39;Low\u0026#39;) txtfields.append(\u0026#39;Close\u0026#39;) txtfields.append(\u0026#39;Volume\u0026#39;) txtfields.append(\u0026#39;OpenInterest\u0026#39;) print(\u0026#39;,\u0026#39;.join(txtfields)) def next(self): if self.p.printout: txtfields = list() txtfields.append(\u0026#39;%04d\u0026#39; % len(self)) txtfields.append(self.data.datetime.datetime(0).isoformat()) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.open[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.high[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.low[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.close[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.volume[0]) txtfields.append(\u0026#39;%.2f\u0026#39; % self.data0.openinterest[0]) print(\u0026#39;,\u0026#39;.join(txtfields)) for data in self.datas: toss = random.randint(1, 10) curpos = self.getposition(data) if curpos.size: if toss \u0026gt; 5: size = curpos.size // 2 self.sell(data=data, size=size) if self.p.printout: print(\u0026#39;SELL {} @%{}\u0026#39;.format(size, data.close[0])) elif toss \u0026lt; 5: self.buy(data=data, size=self.p.stake) if self.p.printout: print(\u0026#39;BUY {} @%{}\u0026#39;.format(self.p.stake, data.close[0])) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() cerebro.broker.set_cash(args.cash) dkwargs = dict() if args.fromdate: fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;fromdate\u0026#39;] = fromdate if args.todate: todate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;todate\u0026#39;] = todate data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **dkwargs) cerebro.adddata(data0, name=\u0026#39;Data0\u0026#39;) data1 = bt.feeds.BacktraderCSVData(dataname=args.data1, **dkwargs) cerebro.adddata(data1, name=\u0026#39;Data1\u0026#39;) data2 = bt.feeds.BacktraderCSVData(dataname=args.data2, **dkwargs) cerebro.adddata(data2, name=\u0026#39;Data2\u0026#39;) cerebro.addstrategy(St, printout=args.printout) if not args.no_pyfolio: cerebro.addanalyzer(bt.analyzers.PyFolio, _name=\u0026#39;pyfolio\u0026#39;) results = cerebro.run() if not args.no_pyfolio: strat = results[0] pyfoliozer = strat.analyzers.getbyname(\u0026#39;pyfolio\u0026#39;) returns, positions, transactions, gross_lev = pyfoliozer.get_pf_items() if args.printout: print(\u0026#39;-- RETURNS\u0026#39;) print(returns) print(\u0026#39;-- POSITIONS\u0026#39;) print(positions) print(\u0026#39;-- TRANSACTIONS\u0026#39;) print(transactions) print(\u0026#39;-- GROSS LEVERAGE\u0026#39;) print(gross_lev) import pyfolio as pf pf.create_full_tear_sheet( returns, positions=positions, transactions=transactions, gross_lev=gross_lev, live_start_date=\u0026#39;2005-05-01\u0026#39;, round_trips=True) if args.plot: cerebro.plot(style=args.plot_style) def parse_args(args=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample for pivot point and cross plotting\u0026#39;) parser.add_argument(\u0026#39;--data0\u0026#39;, required=False, default=\u0026#39;../../datas/yhoo-1996-2015.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--data1\u0026#39;, required=False, default=\u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--data2\u0026#39;, required=False, default=\u0026#39;../../datas/nvda-1999-2014.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;2005-01-01\u0026#39;, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;2006-12-31\u0026#39;, help=\u0026#39;Ending date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--printout\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Print data lines\u0026#39;)) parser.add_argument(\u0026#39;--cash\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, type=float, default=50000, help=(\u0026#39;Cash to start with\u0026#39;)) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Plot the result\u0026#39;)) parser.add_argument(\u0026#39;--plot-style\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=\u0026#39;bar\u0026#39;, choices=[\u0026#39;bar\u0026#39;, \u0026#39;candle\u0026#39;, \u0026#39;line\u0026#39;], help=(\u0026#39;Plot style\u0026#39;)) parser.add_argument(\u0026#39;--no-pyfolio\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Do not do pyfolio things\u0026#39;)) import sys aargs = args if args is not None else sys.argv[1:] return parser.parse_args(aargs) runstrat([])整个数据开始日期：2005-01-03\n整个数据结束日期：2006-12-29\n$ ./pyfoliotest.py --help使用：\nusage: pyfoliotest.py [-h] [--data0 DATA0] [--data1 DATA1] [--data2 DATA2] [--fromdate FROMDATE] [--todate TODATE] [--printout] [--cash CASH] [--plot] [--plot-style { bar,candle,line}] [--no-pyfolio] Sample for pivot point and cross plotting optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to be read in (default: ../../datas/yhoo-1996-2015.txt) --data1 DATA1 Data to be read in (default: ../../datas/orcl-1995-2014.txt) --data2 DATA2 Data to be read in (default: ../../datas/nvda-1999-2014.txt) --fromdate FROMDATE Starting date in YYYY-MM-DD format (default: 2005-01-01) --todate TODATE Ending date in YYYY-MM-DD format (default: 2006-12-31) --printout Print data lines (default: False) --cash CASH Cash to start with (default: 50000) --plot Plot the result (default: False) --plot-style {bar,candle,line} Plot style (default: bar) --no-pyfolio Do not do pyfolio things (default: False)"},{"id":42,"href":"/backtrader/docs/15-livetrading/03-visual-chart/","title":"Visual Chart","section":"实盘","content":"Visual Chart# Visual Chart 的集成支持以下功能：\n实时数据馈送 实时交易 Visual Chart 是一个完整的交易解决方案：\n集成图表、数据馈送和经纪功能于单一平台 有关更多信息，请访问：www.visualchart.com\n要求# VisualChart 6（运行在 Windows 上） comtypes fork： https://github.com/mementum/comtypes 可以通过以下命令安装：\npip install https://github.com/mementum/comtypes/archive/master.zipVisual Chart 的 API 基于 COM。目前 comtypes 主分支不支持解包 VT_ARRAYS of VT_RECORD。这是 Visual Chart 所使用的。Pull Request #104 已提交，但尚未集成。一旦集成，可以使用主分支。\npytz（可选但强烈推荐）：确保每个数据都在市场时间返回。这对于大多数市场来说都是正确的，但有些市场确实是例外（全球指数就是一个很好的例子）。 示例代码# 源代码中包含完整示例：samples/vctest/vctest.py。\nVCStore - 存储# 存储是实时数据馈送/交易支持的核心，提供了 COM API 和数据馈送及经纪代理之间的适配层。\n可以通过以下方法获取经纪商实例：\nVCStore.getbroker(*args, **kwargs)可以通过以下方法获取数据馈送实例：\nVCStore.getdata(*args, **kwargs)在这种情况下，许多 **kwargs 是数据馈送的常见参数，如 dataname、fromdate、todate、sessionstart、sessionend、timeframe、compression。\nVCStore 将尝试：\n使用 Windows 注册表自动定位 VisualChart 在系统中的位置。 如果找到，将扫描安装目录中的 COM DLLs 以创建 COM typelibs 并实例化适当的对象。 如果未找到，将尝试使用已知和硬编码的 CLSIDs 进行相同操作。 注意：即使通过扫描文件系统找到 DLLs，Visual Chart 本身也必须在运行。backtrader 不会启动 Visual Chart。\nVCData feeds# 一般# Visual Chart 提供的数据馈送具有一些有趣的属性：\n重新采样由平台完成 并非所有情况下：秒不支持，仍需由 backtrader 完成 例如：\nvcstore = bt.stores.VCStore() vcstore.getdata(dataname=\u0026#39;015ES\u0026#39;, timeframe=bt.TimeFrame.Ticks) cerebro.resampledata(data, timeframe=bt.TimeFrame.Seconds, compression=5)大多数情况下，只需以下操作：\nvcstore = bt.stores.VCStore() data = vcstore.getdata(dataname=\u0026#39;015ES\u0026#39;, timeframe=bt.TimeFrame.Minutes, compression=2) cerebro.adddata(data)数据将通过比较内部设备时钟和平台提供的 tick 来计算内部时间偏移，以便在没有新 tick 进入时尽早传递自动重新采样的 bar。\n实例化数据# 按 VisualChart 左上角显示的符号（无空格）传递。例如：\nES-Mini 显示为 001 ES。实例化为：\ndata = vcstore.getdata(dataname=\u0026#39;001ES\u0026#39;, ...)EuroStoxx 50 显示为 015 ES。实例化为：\ndata = vcstore.getdata(dataname=\u0026#39;015ES\u0026#39;, ...)注意：backtrader 会努力清除第四位置的空格（如果名称直接从 Visual Chart 粘贴）。\n时间管理# 时间管理遵循 backtrader 的一般规则。为了确保代码不依赖于 DST 转换，请使用市场时间。\n数据通知# 数据馈送将通过以下一种或多种方式报告当前状态（检查 Cerebro 和策略参考）：\nCerebro.notify_data（如果覆盖） Cerebro.adddatacb 添加的回调 Strategy.notify_data（如果覆盖） 策略中的示例：\nclass VCStrategy(bt.Strategy): def notify_data(self, data, status, *args, **kwargs): if status == data.LIVE: # 数据已切换到实时数据 # 做某些事 pass以下通知将根据系统中的更改发送：\nCONNECTED：成功初始连接时发送 DISCONNECTED：无法检索数据时发送 CONNBROKEN：连接丢失时发送 NOTSUBSCRIBED：无权限检索数据时发送 DELAYED：历史/回填操作正在进行时发送 LIVE：数据已切换到实时数据时发送 VCBroker - 实时交易# 使用经纪商# 要使用 VCBroker，需要替换 cerebro 创建的标准经纪商模拟实例。\n使用存储模型（推荐）：\nimport backtrader as bt cerebro = bt.Cerebro() vcstore = bt.stores.VCStore() cerebro.broker = vcstore.getbroker() # 或 cerebro.setbroker(...)经纪商参数# VCBroker 不支持任何参数，因为经纪商只是实际经纪商的代理。实际经纪商提供的功能不会被去除。\n限制# 头寸# Visual Chart 报告未平仓头寸，但缺少头寸已关闭的最终事件。因此，backtrader 需要完全记录头寸，并与账户中的任何先前头寸分开。\n佣金# COM 交易接口不报告佣金。除非在实例化经纪商时提供了表示实际佣金的 Commission 实例，否则 backtrader 无法准确估算佣金。\n交易操作# 使用方面没有变化。只需使用策略中提供的方法（请参阅策略参考以获取完整说明）：\nbuy sell close cancel 订单执行类型# Visual Chart 支持 backtrader 需要的最小订单执行类型，因此任何经过回测的内容都可以上线。限于：\nOrder.Market Order.Close Order.Limit Order.Stop（触发 Stop 时跟随市价单） Order.StopLimit（触发 Stop 时跟随限价单） 订单有效期# backtrader 在回测期间可用的相同有效期概念（使用 valid 参数买入和卖出）在此也可用，并具有相同含义。\n通知# 标准订单状态将通过策略的 notify_order 方法通知（如果覆盖）：\nSubmitted - 订单已发送到 TWS Accepted - 订单已被放置 Rejected - 订单放置失败或在其生命周期内被系统取消 Partial - 已部分执行 Completed - 订单已完全执行 Canceled（或 Cancelled） 参考# VCStore# class backtrader.stores.VCStore()封装 ibpy ibConnection 实例的单例类。\nVCBroker# class backtrader.brokers.VCBroker(**kwargs)VisualChart 的经纪商实现。\nVCData# class backtrader.feeds.VCData(**kwargs)VisualChart 数据馈送。\n参数：\nqcheck（默认：0.5）：默认唤醒超时以让重采样/重放器检查当前 bar 是否可以交付。 historical（默认：False）：如果未提供 todate 参数（在基类中定义），则如果设置为 True，将强制仅进行历史下载。 milliseconds（默认：True）：Visual Chart 构建的 bar 具有以下格式：HH:MM:59.999000。如果该参数为 True，将添加一毫秒，使其显示为：HH:MM:59.999000。 tradename（默认：无）：无法交易连续期货，但它们非常适合数据跟踪。如果提供该参数，它将是当前期货的名称，该期货将是交易资产。 usetimezones（默认：True）：对于大多数市场，Visual Chart 提供的时间偏移信息允许将日期时间转换为市场时间。 "},{"id":43,"href":"/backtrader/docs/17-datetime/03-trading-calendars/","title":"交易日历","section":"日期时间","content":"交易日历# 版本 1.9.42.116 增加了对交易日历的支持。这在以下场景中的重采样时非常有用：\n从每日到每周的重采样现在可以将每周的K线与本周的最后一根K线一起交付。 这是因为交易日历可以识别下一个交易日，并且可以提前识别出本周的最后一个交易日。 当交易会话的结束时间不是常规时间（可以通过数据源来指定）时，从子日内到每日的重采样。 交易日历接口# 有一个基类 TradingCalendarBase 用作任何交易日历的基类。它定义了两个必须被重写的方法：\nclass TradingCalendarBase(with_metaclass(MetaParams, object)): def _nextday(self, day): \u0026#39;\u0026#39;\u0026#39; 返回在 `day`（datetime/date 实例）之后的下一个交易日（datetime/date 实例）以及 isocalendar 组件。 返回值是一个包含两个组件的元组：(nextday, (y, w, d))，其中 (y, w, d)。 \u0026#39;\u0026#39;\u0026#39; raise NotImplementedError def schedule(self, day): \u0026#39;\u0026#39;\u0026#39; 返回给定日期（datetime/date 实例）的开盘和收盘时间（`datetime.time`）。 \u0026#39;\u0026#39;\u0026#39; raise NotImplementedError实现# PandasMarketCalendar# 这个实现基于一个不错的包，这是从 Quantopian 的初始功能衍生出来的。包位于 pandas_market_calendars，可以很容易地安装：\npip install pandas_market_calendars实现的接口如下：\nclass PandasMarketCalendar(TradingCalendarBase): \u0026#39;\u0026#39;\u0026#39; `pandas_market_calendars` 的交易日历包装器。必须安装 `pandas_market_calendar` 包。 参数： - `calendar` (默认 `None`) 参数 `calendar` 接受以下内容： - 字符串：支持的日历名称，例如 `NYSE`。包装器会尝试获取一个日历实例。 - 日历实例：由 `get_calendar(\u0026#39;NYSE\u0026#39;)` 返回。 - `cachesize` (默认 `365`) 缓存查找提前天数。 参见： - https://github.com/rsheftel/pandas_market_calendars - http://pandas-market-calendars.readthedocs.io/ \u0026#39;\u0026#39;\u0026#39; params = ( (\u0026#39;calendar\u0026#39;, None), # 一个 pandas_market_calendars 实例或交易所名称 (\u0026#39;cachesize\u0026#39;, 365), # 缓存查找提前天数 )TradingCalendar# 这个实现允许通过指定假期、早市天数、非交易工作日以及开盘和收盘时间来构建一个日历：\nclass TradingCalendar(TradingCalendarBase): \u0026#39;\u0026#39;\u0026#39; 交易日历的包装器。必须安装 `pandas_market_calendars` 包。 参数： - `open` (默认 `time.min`) 常规开盘时间。 - `close` (默认 `time.max`) 常规收盘时间。 - `holidays` (默认 `[]`) 非交易日列表（`datetime.datetime` 实例）。 - `earlydays` (默认 `[]`) 确定日期和开盘/收盘时间的不符合常规交易时间的天数列表，每个元组包含 (`datetime.datetime`, `datetime.time`, `datetime.time`)。 - `offdays` (默认 `ISOWEEKEND`) 一周中市场不交易的工作日的 ISO 格式列表（周一：1 -\u0026gt; 周日：7）。这通常是周六和周日，因此为默认值。 \u0026#39;\u0026#39;\u0026#39; params = ( (\u0026#39;open\u0026#39;, time.min), (\u0026#39;close\u0026#39;, _time_max), (\u0026#39;holidays\u0026#39;, []), # 非交易日列表（日期） (\u0026#39;earlydays\u0026#39;, []), # 元组列表（日期，开盘时间，收盘时间） (\u0026#39;offdays\u0026#39;, ISOWEEKEND), # 非交易日列表（ISO 工作日） )使用模式# 全局交易日历# 通过 Cerebro，可以添加一个全局日历，作为所有数据源的默认日历，除非为数据源指定了一个日历：\ndef addcalendar(self, cal): \u0026#39;\u0026#39;\u0026#39;向系统添加全局交易日历。个别数据源可以有单独的日历覆盖全局日历。 `cal` 可以是 `TradingCalendar` 的一个实例、一个字符串或一个 `pandas_market_calendars` 的实例。字符串将被实例化为 `PandasMarketCalendar`（需要在系统中安装 `pandas_market_calendar` 模块）。 如果传递的是 `TradingCalendarBase` 的子类（而不是实例），则会被实例化。 \u0026#39;\u0026#39;\u0026#39;每个数据源# 通过指定一个 calendar 参数，遵循与上面描述的 addcalendar 相同的约定。例如：\n... data = bt.feeds.YahooFinanceData(dataname=\u0026#39;YHOO\u0026#39;, calendar=\u0026#39;NYSE\u0026#39;, ...) cerebro.adddata(data) ...示例# 从每日到每周# 让我们看一个示例代码的运行结果。2016 年的复活节星期五（2016-03-25）也是纽约证券交易所的假期。如果运行没有交易日历的示例代码，让我们看看该日期前后的情况。\n在这种情况下，重采样是从每日到每周（使用 YHOO 和 2016 年的每日数据）：\n$ ./tcal.py ... Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18 Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 11 datetime 2016-03-18 Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 2016-03-24 ...在这个输出中，第一个日期是由策略计算的日期。第二个日期是每日数据的日期。\n如预期的那样，周在 2016-03-24（星期四）结束，但是由于没有交易日历，重采样代码无法知道这一点，并且会在 2016-03-18（前一周）的日期交付重采样条形图。当交易移至 2016-03-28（星期一）时，重采样器检测到周变化，并在 2016-03-24 交付一个重采样条形图。\n如果使用 NYSE 的 PandasMarketCalendar 并添加一个绘图，再次运行：\n$ ./tcal.py --plot --pandascal NYSE ... Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18 Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 12 datetime 2016-03-24 Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 2016-03-24 ...有所变化！由于有日历，重采样器知道周在 2016-03-24 结束，并在同一天交付相应的每周重采样条形图。\n绘图结果如下。\nimage\n由于某些信息可能并不总是可用，可以手动编写日历。对于 NYSE 和 2016 年，日历定义如下：\nclass NYSE_2016(bt.TradingCalendar): params = dict( holidays=[ datetime.date(2016, 1, 1), datetime.date(2016, 1, 18), datetime.date(2016, 2, 15), datetime.date(2016, 3, 25), datetime.date(2016, 5, 30), datetime.date(2016, 7, 4), datetime.date(2016, 9, 5), datetime.date(2016, 11, 24), datetime.date(2016, 12, 26), ] )复活节星期五（2016-03-25）被列为假期之一。现在运行示例代码：\n$ ./tcal.py --plot --owncal ... Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18 Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 12 datetime 2016-03-24 Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 201 6-03-24 ...使用手动编写的日历定义得到了相同的结果。\n从分钟到每日# 使用一些私有的日内数据，并且知道市场在 2016-11-25 提前收盘（感恩节后的第二天市场在美国东部时间 13:00 收盘），再进行一个测试运行，这次使用第二个示例。\n注意\n源数据直接来自显示数据，并且在 CET 时区，即使标的资产 YHOO 在美国交易。代码中使用了 tzinput='CET' 和 tz='US/Eastern' 来让平台适当地转换输入并显示输出。\n首先，不使用交易日历：\n$ ./tcal-intra.py ... Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 21 datetime 2016-11-23 16:00:00 Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 21 datetime 20 16-11-23 16:00:00 Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 22 datetime 2016-11-25 16:00:00 Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 22 datetime 2016-11-25 16:00:00 ...如预期的那样，这一天在 13:00 提前结束，但重采样器不知道这一点（官方会话在 16:00 结束），并继续交付前一天（2016-11-23）的重采样日线图，新重采样日线图首次在下一个交易日（2016-11-28）交付，日期为 2016-11-25。\n注意\n数据在 13:01 有一个额外的分钟条，这可能是由于拍卖过程中在市场关闭时间后提供的最后价格。\n我们可以向流中添加一个过滤器，以过滤掉会话时间之外的条形图（过滤器将从交易日历中找出时间）。\n但这不是此示例的重点。\n使用 PandasMarketCalendar 实例再次运行：\n$ ./tcal-intra.py --pandascal NYSE ... Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 15 datetime 2016-11-25 13:00:00 Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 15 datetime 2016-11-25 13:00:00 Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 15 datetime 2016-11-25 13:00:00 Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 15 datetime 2016-11-25 13:00:00 ...现在，当日线条在 2016-11-25 的 13:00 交付时（忽略 13:01 的条形图），重采样代码通过交易日历知道这一天结束了。\n让我们添加一个手动编写的定义。与前面的相同，但扩展了一些早市天数：\nclass NYSE_2016(bt.TradingCalendar): params = dict( holidays=[ datetime.date(2016, 1, 1), datetime.date(2016, 1, 18), datetime.date(2016, 2, 15), datetime.date(2016, 3, 25), datetime.date(2016, 5, 30), datetime.date(2016, 7, 4), datetime.date(2016, 9, 5), datetime.date(2016, 11, 24), datetime.date(2016, 12, 26), ], earlydays=[ (datetime.date(2016, 11, 25), datetime.time(9, 30), datetime.time(13, 1)) ], open=datetime.time(9, 30), close=datetime.time(16, 0), )运行：\n$ ./tcal-intra.py --owncal ... Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 16 datetime 2016-11-25 13:01:00 Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 16 datetime 2016-11-25 13:01:00 Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 16 datetime 2016-11-25 13:01:00 Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 16 datetime 2016-11-25 13:01:00 ...细心的读者会注意到手动编写的定义将 2016-11-25 的结束时间定义为 13:01（使用 datetime.time(13, 1)）。这只是为了展示手动编写的 TradingCalendar 如何帮助适应。\n现在 2016-11-25 的重采样日线条在 13:01 与 1 分钟条一起交付。\n策略的额外奖励# 第一个日期时间，属于策略的，总是在不同的时区，实际上是 UTC。使用这个版本 1.9.42.116，这也可以同步。以下参数已添加到 Cerebro（在实例化期间使用或与 cerebro.run 一起使用：\ntz（默认：None）\n添加策略的全局时区。参数 tz 可以是：\nNone：在这种情况下，策略显示的日期时间将是 UTC，这一直是标准行为。 pytz 实例。它将用于将 UTC 时间转换为所选时区。 string。尝试实例化一个 pytz 实例。 integer。使用相应数据在 self.datas 可迭代对象中的相同时区（0 将使用 data0 的时区）。 也可以通过 cerebro.addtz 方法支持：\ndef addtz(self, tz): \u0026#39;\u0026#39;\u0026#39; 这也可以通过参数 `tz` 完成。 添加策略的全局时区。参数 `tz` 可以是： - `None`：在这种情况下，策略显示的日期时间将是 UTC，这一直是标准行为。 - `pytz` 实例。它将用于将 UTC 时间转换为所选时区。 - `string`。尝试实例化一个 `pytz` 实例。 - `integer`。使用相应数据在 `self.datas` 可迭代对象中的相同时区（`0` 将使用 `data0` 的时区）。 \u0026#39;\u0026#39;\u0026#39;重复上一次的日内示例运行，并使用 0 作为 tz（与 data0 的时区同步），输出如下，关注与上面相同的日期和时间：\n$ ./tcal-intra.py --owncal --cerebro tz=0 ... Strategy len 6838 datetime 2016-11-25 13:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 15 datetime 2016-11-23 16:00:00 Strategy len 6839 datetime 2016-11-25 13:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 16 datetime 2016-11-25 13:01:00 Strategy len 6840 datetime 2016-11-28 09:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data 1 len 16 datetime 2016-11-25 13:01:00 Strategy len 6841 datetime 2016-11-28 09:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 16 datetime 2016-11-25 13:01:00 ...时间戳现在与时区对齐。\n示例使用（tcal.py）# $ ./tcal.py --help usage: tcal.py [-h] [--data0 DATA0] [--offline] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] [--pandascal PANDASCAL | --owncal] [--timeframe {Weeks,Months,Years}] Trading Calendar Sample optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: YHOO) --offline Read from disk with same name as ticker (default: False) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: 2016-01-01) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: 2016-12-31) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: ) --pandascal PANDASCAL Name of trading calendar to use (default: ) --owncal Apply custom NYSE 2016 calendar (default: False) --timeframe {Weeks,Months,Years} Timeframe to resample to (default: Weeks)示例使用（tcal-intra.py）# $ ./tcal-intra.py --help usage: tcal-intra.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] [--pandascal PANDASCAL | --owncal] [--timeframe {Days}] Trading Calendar Sample optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: yhoo-2016-11.csv) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: 2016-01-01) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: 2016-12-31) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: ) --pandascal PANDASCAL Name of trading calendar to use (default: ) --owncal Apply custom NYSE 2016 calendar (default: False) --timeframe {Days} Timeframe to resample to (default: Days)示例代码（tcal.py）# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class NYSE_2016(bt.TradingCalendar): params = dict( holidays=[ datetime.date(2016, 1, 1), datetime.date(2016, 1, 18), datetime.date(2016, 2, 15), datetime.date(2016, 3, 25), datetime.date(2016, 5, 30), datetime.date(2016, 7, 4), datetime.date(2016, 9, 5), datetime.date(2016, 11, 24), datetime.date(2016, 12, 26), ] ) class St(bt.Strategy): params = dict() def __init__(self): pass def start(self): self.t0 = datetime.datetime.utcnow() def stop(self): t1 = datetime.datetime.utcnow() print(\u0026#39;Duration:\u0026#39;, t1 - self.t0) def prenext(self): self.next() def next(self): print(\u0026#39;Strategy len {} datetime {}\u0026#39;.format(len(self), self.datetime.date()), end=\u0026#39; \u0026#39;) print(\u0026#39;Data0 len {} datetime {}\u0026#39;.format(len(self.data0), self.data0.datetime.date()), end=\u0026#39; \u0026#39;) if len(self.data1): print(\u0026#39;Data1 len {} datetime {}\u0026#39;.format(len(self.data1), self.data1.datetime.date())) else: print() def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 数据源参数 kwargs = dict() # 解析 from/to 日期 dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) YahooData = bt.feeds.YahooFinanceData if args.offline: YahooData = bt.feeds.YahooFinanceCSVData # 切换为从文件读取 # 数据源 data0 = YahooData(dataname=args.data0, **kwargs) cerebro.adddata(data0) d1 = cerebro.resampledata(data0, timeframe=getattr(bt.TimeFrame, args.timeframe)) d1.plotinfo.plotmaster = data0 d1.plotinfo.sameaxis = True if args.pandascal: cerebro.addcalendar(args.pandascal) elif args.owncal: cerebro.addcalendar(NYSE_2016) # 经纪商 cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # 大小调整器 cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # 策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 执行 cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # 如果请求则绘图 cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Trading Calendar Sample\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;YHOO\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) parser.add_argument(\u0026#39;--offline\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Read from disk with same name as ticker\u0026#39;) # 日期默认值 parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;2016-01-01\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;2016-12-31\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) pgroup = parser.add_mutually_exclusive_group(required=False) pgroup.add_argument(\u0026#39;--pandascal\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=\u0026#39;\u0026#39;, help=\u0026#39;Name of trading calendar to use\u0026#39;) pgroup.add_argument(\u0026#39;--owncal\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Apply custom NYSE 2016 calendar\u0026#39;) parser.add_argument(\u0026#39;--timeframe\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=\u0026#39;Weeks\u0026#39;, choices=[\u0026#39;Weeks\u0026#39;, \u0026#39;Months\u0026#39;, \u0026#39;Years\u0026#39;], help=\u0026#39;Timeframe to resample to\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()示例代码（tcal-intra.py）# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class NYSE_2016(bt.TradingCalendar ): params = dict( holidays=[ datetime.date(2016, 1, 1), datetime.date(2016, 1, 18), datetime.date(2016, 2, 15), datetime.date(2016, 3, 25), datetime.date(2016, 5, 30), datetime.date(2016, 7, 4), datetime.date(2016, 9, 5), datetime.date(2016, 11, 24), datetime.date(2016, 12, 26), ], earlydays=[ (datetime.date(2016, 11, 25), datetime.time(9, 30), datetime.time(13, 1)) ], open=datetime.time(9, 30), close=datetime.time(16, 0), ) class St(bt.Strategy): params = dict() def __init__(self): pass def prenext(self): self.next() def next(self): print(\u0026#39;Strategy len {} datetime {}\u0026#39;.format(len(self), self.datetime.datetime()), end=\u0026#39; \u0026#39;) print(\u0026#39;Data0 len {} datetime {}\u0026#39;.format(len(self.data0), self.data0.datetime.datetime()), end=\u0026#39; \u0026#39;) if len(self.data1): print(\u0026#39;Data1 len {} datetime {}\u0026#39;.format(len(self.data1), self.data1.datetime.datetime())) else: print() def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 数据源参数 # kwargs = dict(tz=\u0026#39;US/Eastern\u0026#39;) # import pytz # tz = tzinput = pytz.timezone(\u0026#39;Europe/Berlin\u0026#39;) tzinput = \u0026#39;Europe/Berlin\u0026#39; # tz = tzinput tz = \u0026#39;US/Eastern\u0026#39; kwargs = dict(tzinput=tzinput, tz=tz) # 解析 from/to 日期 dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # 数据源 data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) d1 = cerebro.resampledata(data0, timeframe=getattr(bt.TimeFrame, args.timeframe)) # d1.plotinfo.plotmaster = data0 # d1.plotinfo.sameaxis = False if args.pandascal: cerebro.addcalendar(args.pandascal) elif args.owncal: cerebro.addcalendar(NYSE_2016()) # 或者 NYSE_2016() 传递一个实例 # 经纪商 cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # 大小调整器 cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # 策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 执行 cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # 如果请求则绘图 cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Trading Calendar Sample\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;yhoo-2016-11.csv\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # 日期默认值 parser.add"},{"id":44,"href":"/backtrader/docs/19-articles/03-fractional-sizes/","title":"加密货币中的分位仓位","section":"官方文章","content":"在 backtrader 中交易加密货币的分数仓位\n首先，让我们用两句话总结一下 backtrader 的工作方式：\n它像一个构建工具包，包含一个基本构建模块（Cerebro），可以将许多不同的模块插入其中。\n基本分发版包含许多模块，如指标、分析器、观察者、仓位大小计算器、过滤器、数据源、经纪商、佣金/资产信息方案等\u0026hellip;\n可以轻松地从头开始构建新的模块，或者基于现有模块进行构建。\n基本模块（Cerebro）已经实现了一些自动“插拔”，使得用户可以更轻松地使用框架，而不需要关注所有细节。\n因此，该框架已预配置以提供默认行为，例如：\n使用单一的主数据源 1天的时间框架/压缩组合 10,000 单位的货币 股票交易 这些设置可能并不适合每个人，但重要的是：它可以根据每个交易者/程序员的需求进行定制。\n交易股票：整数\n如上所述，默认配置是用于股票交易，当交易股票时，买入/卖出的是完整的股票份额（即：1、2、50、1000 等，而不是像 1.5 或 1001.7589 这样的数量）。\n这意味着，当用户在默认配置下执行以下代码时：\ndef next(self): # 将投资组合的 50% 用于购买主资产 self.order_target_percent(target=0.5)发生的情况是：\n系统会计算出需要多少股票份额，以便该资产在投资组合中的价值尽可能接近 50%。\n但是，由于默认配置是与股票交易配合使用，结果股票的数量将是一个整数。\n注意\n请注意，默认配置是使用单一的主数据源，因此在调用 order_target_percent 时，实际的数据并未指定。当使用多个数据源时，必须指定获取/卖出哪个数据（除非是主数据源）。\n交易加密货币：分数\n显然，在交易加密货币时，即使是小数点后有 20 位数字，也可以购买“半个比特币”。\n好消息是，你可以更改与资产相关的信息。这是通过 CommissionInfo 家族的可插拔模块实现的。\n一些文档：Docs - Commission Schemes\n注意\n不得不承认，名字不太合适，因为这些方案不仅仅包含佣金信息，还包含其他内容。\n在分数方案中，关注的是该方案的 getsize(price, cash) 方法，它有如下文档字符串：\n返回在给定价格下执行现金操作所需的仓位大小这些方案与经纪商密切相关，并且可以通过经纪商 API 将这些方案添加到系统中。\n经纪商文档在这里：Docs - Broker\n相关方法是：addcommissioninfo(comminfo, name=None)。当 name 为 None 时，方案会应用到所有资产；如果指定了名称，则方案仅应用于具有特定名称的资产。\n实现分数方案\n这可以通过扩展现有的基础方案（即 CommissionInfo）轻松实现。\nclass CommInfoFractional(bt.CommissionInfo): def getsize(self, price, cash): \u0026#39;\u0026#39;\u0026#39;返回按价格执行现金操作所需的分数大小\u0026#39;\u0026#39;\u0026#39; return self.p.leverage * (cash / price)就是这样。通过子类化 CommissionInfo 并编写一行代码，目标就实现了。由于原始方案定义支持杠杆，因此杠杆也会被考虑进计算中，万一加密货币能够使用杠杆购买（默认值为 1.0，即无杠杆）。\n稍后的代码中，方案将按如下方式添加（通过命令行参数控制）：\nif args.fractional: # 如果需要使用分数方案 cerebro.broker.addcommissioninfo(CommInfoFractional())即：添加一个子类化方案的实例（注意 () 用于实例化）。如上所述，name 参数未设置，这意味着它将应用于系统中的所有资产。\n测试效果\n下面是一个实现了简单的移动平均交叉策略（用于多头/空头仓位）的完整脚本，可以直接在 shell 中使用。测试的默认数据源来自 backtrader 仓库中的数据源之一。\n整数模式：没有分数 - 没有乐趣\n$ ./fractional-sizes.py --plot 2005-02-14,3079.93,3083.38,3065.27,3075.76,0.00 2005-02-15,3075.20,3091.64,3071.08,3086.95,0.00 ... 2005-03-21,3052.39,3059.18,3037.80,3038.14,0.00 2005-03-21,Enter Short 2005-03-22,Sell Order Completed - Size: -16 @Price: 3040.55 Value: -48648.80 Comm: 0.00 2005-03-22,Trade Opened - Size -16 @Price 3040.55 2005-03-22,3040.55,3053.18,3021.66,3050.44,0.00 ...一个大小为 16 单位的空头交易已经开仓。整个日志（因显而易见的原因未显示）包含了许多其他操作，所有交易都采用整数大小。\n没有分数\n分数模式运行\n经过子类化和一行代码的修改，分数的目标就实现了\u0026hellip;\n$ ./fractional-sizes.py --fractional --plot 2005-02-14,3079.93,3083.38,3065.27,3075.76,0.00 2005-02-15,3075.20,3091.64,3071.08,3086.95,0.00 ... 2005-03-21,3052.39,3059.18,3037.80,3038.14,0.00 2005-03-21,Enter Short 2005-03-22,Sell Order Completed - Size: -16.457437774427774 @Price: 3040.55 Value: -50039.66 Comm: 0.00 2005-03-22,Trade Opened - Size -16.457437774427774 @Price 3040.55 2005-03-22,3040.55,3053.18,3021.66,3050.44,0.00 ...胜利了！空头交易已经开仓，并且这次使用的是大小为 -16.457437774427774 的分数仓位。\n分数\n注意，图表中的最终投资组合价值是不同的，因为实际的交易大小不同。\n结论\n是的，backtrader 完全可以做到。通过可插拔/可扩展的构建工具包方式，用户可以轻松地根据交易者/程序员的具体需求定制行为。\n脚本\n#!/usr/bin/env python # -*- coding: utf-8; py-indent-offset:4 -*- ############################################################################### # Copyright (C) 2019 Daniel Rodriguez - MIT License # - https://opensource.org/licenses/MIT # - https://en.wikipedia.org/wiki/MIT_License ############################################################################### import argparse import logging import sys import backtrader as bt # This defines not only the commission info, but some other aspects # of a given data asset like the \u0026#34;getsize\u0026#34; information from below # params = dict(stocklike=True) # No margin, no multiplier class CommInfoFractional(bt.CommissionInfo): def getsize(self, price, cash): \u0026#39;\u0026#39;\u0026#39;Returns fractional size for cash operation @price\u0026#39;\u0026#39;\u0026#39; return self.p.leverage * (cash / price) class St(bt.Strategy): params = dict( p1=10, p2=30, # periods for crossover ma=bt.ind.SMA, # moving average to use target=0.5, # percentage of value to use ) def __init__(self): ma1, ma2 = [self.p.ma(period=p) for p in (self.p.p1, self.p.p2)] self.cross = bt.ind.CrossOver(ma1, ma2) def next(self): self.logdata() if self.cross \u0026gt; 0: self.loginfo(\u0026#39;Enter Long\u0026#39;) self.order_target_percent(target=self.p.target) elif self.cross \u0026lt; 0: self.loginfo(\u0026#39;Enter Short\u0026#39;) self.order_target_percent(target=-self.p.target) def notify_trade(self, trade): if trade.justopened: self.loginfo(\u0026#39;Trade Opened - Size {} @Price {}\u0026#39;, trade.size, trade.price) elif trade.isclosed: self.loginfo(\u0026#39;Trade Closed - Size {} @Price {} Comm: {:.2f}\u0026#39;, trade.size, trade.price, trade.commission) def logdata(self): if self.position: self.loginfo(\u0026#39;Pos {} Value {:.2f} Cash {:.2f}\u0026#39;, self.position.size, self.position.value, self.broker.cash) def loginfo(self, *args): \u0026#39;\u0026#39;\u0026#39;Logging helper\u0026#39;\u0026#39;\u0026#39; msg = f\u0026#39;{self.datas[0].datetime.datetime(0)} \u0026#39; msg += \u0026#39; \u0026#39;.join([str(arg) for arg in args]) print(msg) def run(): \u0026#39;\u0026#39;\u0026#39;Main execution code\u0026#39;\u0026#39;\u0026#39; parser = argparse.ArgumentParser( description=\u0026#34;Backtrader with fractional order size\u0026#34; ) parser.add_argument( \u0026#39;-p\u0026#39;, \u0026#39;--plot\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, help=\u0026#34;Plot results\u0026#34; ) parser.add_argument( \u0026#39;-f\u0026#39;, \u0026#39;--fractional\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, help=\u0026#34;Enable fractional order sizes\u0026#34; ) args = parser.parse_args() # Create a Cerebro engine cerebro = bt.Cerebro() # Load data from Yahoo Finance data = bt.feeds.YahooFinanceData(dataname=\u0026#39;AAPL\u0026#39;) # Add the data to the engine cerebro.adddata(data) if args.fractional: # Fractional orders mode cerebro.broker.addcommissioninfo(CommInfoFractional()) cerebro.addstrategy(St) # Set starting cash (USD) cerebro.broker.set_cash(100000.0) # Set commission (a flat fee per order) cerebro.broker.set_commission(commission=0.005) # Set slippage model (default to 0.001) cerebro.broker.set_slippage_perc(0.001) # Set the portfolio value cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name=\u0026#39;sharpe\u0026#39;) # Print out the starting portfolio value print(f\u0026#34;Starting Portfolio Value: {cerebro.broker.getvalue()}\u0026#34;) # Run the strategy cerebro.run() # Print out the final portfolio value print(f\u0026#34;Ending Portfolio Value: {cerebro.broker.getvalue()}\u0026#34;) if args.plot: cerebro.plot() if __name__ == \u0026#39;__main__\u0026#39;: run()"},{"id":45,"href":"/backtrader/docs/13-observers/03-reference/","title":"参考","section":"Observer","content":"参考# Benchmark# class backtrader.observers.Benchmark()该观察器存储策略的回报和作为参考资产的回报，这个参考资产是传递给系统的一个数据。\n参数：\ntimeframe（默认：无）：如果为 None，则报告整个回测期间的总回报。 compression（默认：无）：仅用于子日时间框架，例如通过指定 “TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。 data（默认：无）：跟踪的参考资产以便进行比较。 注意：此数据必须已通过 adddata、resampledata 或 replaydata 添加到 cerebro 实例中。\n_doprenext（默认：False）：基准测试将在策略开始运行时进行（即策略的最小周期已达到时）。将其设置为 True 将从数据源的起点记录基准值。 firstopen（默认：False）：保持为 False 确保价值和基准之间的首次比较点从 0% 开始，因为基准不会使用其开盘价。参见 TimeReturn 分析器参考以获得参数的完整解释。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。\nBroker# class backtrader.observers.Broker(*args, **kwargs)该观察器跟踪经纪人中的当前现金金额和投资组合价值（包括现金）。\n参数：无\nBroker - Cash# class backtrader.observers.Cash(*args, **kwargs)该观察器跟踪经纪人中的当前现金金额。\n参数：无\nBroker - Value# class backtrader.observers.Value(*args, **kwargs)该观察器跟踪经纪人中的当前投资组合价值，包括现金。\n参数：\nfund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 BuySell# class backtrader.observers.BuySell(*args, **kwargs)该观察器跟踪单个买入/卖出订单（单个执行）并将在图表上绘制它们，围绕执行价格水平绘制。\n参数：\nbarplot（默认：False）：在最低点下方绘制买入信号，在最高点上方绘制卖出信号。如果为 False，则将在条形的平均执行价格上绘制。 bardist（默认：0.015 1.5%）：当 barplot 为 True 时，与最大值/最小值的距离。 DrawDown# class backtrader.observers.DrawDown()该观察器跟踪当前的回撤水平（绘图）和最大回撤（不绘图）水平。\n参数：\nfund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 TimeReturn# class backtrader.observers.TimeReturn()该观察器存储策略的回报。\n参数：\ntimeframe（默认：无）：如果为 None，则报告整个回测期间的总回报。传递 TimeFrame.NoTimeFrame 以考虑整个数据集而不受时间限制。 compression（默认：无）：仅用于子日时间框架，例如通过指定 “TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。\nTrades# class backtrader.observers.Trades()该观察器跟踪完整的交易，并在交易关闭时绘制实现的损益水平。\n交易在仓位从 0（或跨越 0）变为 X 时开立，然后在回到 0（或反方向跨越 0）时关闭。\n参数：\npnlcomm（默认：True）：显示净利润和亏损，即扣除佣金后的结果。如果设置为 False，将显示扣除佣金前的交易结果。 LogReturns# class backtrader.observers.LogReturns()该观察器存储策略的对数回报。\n参数：\ntimeframe（默认：无）：如果为 None，则报告整个回测期间的总回报。传递 TimeFrame.NoTimeFrame 以考虑整个数据集而不受时间限制。 compression（默认：无）：仅用于子日时间框架，例如通过指定 “TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。\nLogReturns2# class backtrader.observers.LogReturns2()扩展 LogReturns 观察器以显示两个工具。\nFundValue# class backtrader.observers.FundValue(*args, **kwargs)该观察器跟踪当前的基金价值。\n参数：无\nFundShares# class backtrader.observers.FundShares(*args, **kwargs)该观察器跟踪当前的基金份额。\n参数：无\n"},{"id":46,"href":"/backtrader/docs/16-plotting/03-plotting-same-axis/","title":"同轴绘图","section":"绘图","content":"在同轴绘图# 在之前的文章“future-spot”中，我们在同一空间上绘制了原始数据和略微（随机）修改后的数据，但它们并没有在同一轴上绘制。\n恢复该文章的第一张图片：\n我们可以看到：\n图表的左右两侧有不同的刻度。 当观察摆动的红线（随机化数据）时最明显，它在原始数据周围上下摆动大约 50 个点。 在图表上，视觉印象是这种随机化数据大部分时间都在原始数据上方。这只是由于不同刻度导致的视觉印象。 虽然 1.9.32.116 版本已经初步支持完全在同一轴上绘图，但图例标签会重复（仅标签，不是数据），这会让人感到困惑。\n1.9.33.116 版本修复了这个问题，允许完全在同一轴上绘图。使用模式类似于选择使用哪个数据进行绘图。在之前的文章中：\nimport backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFavouriteDataFeed(dataname=\u0026#39;futurename\u0026#39;) cerebro.adddata(data0) data1 = bt.feeds.MyFavouriteDataFeed(dataname=\u0026#39;spotname\u0026#39;) data1.compensate(data0) # 告诉系统 data1 的操作影响 data0 data1.plotinfo.plotmaster = data0 data1.plotinfo.sameaxis = True cerebro.adddata(data1) ... cerebro.run()data1 获取一些 plotinfo 值来：\n与 plotmaster（即 data0）在同一空间绘图。 获取使用 sameaxis 的指示。 原因是平台无法提前知道每个数据的刻度是否兼容。因此，它们会在独立的刻度上绘图。\n在之前的示例中，增加了一个选项在 sameaxis 上绘图。示例执行：\n$ ./future-spot.py --sameaxis结果图表：\n需要注意的是：\n右侧只有一个刻度。 现在，随机化数据似乎明显在原始数据周围摆动，这是预期的视觉行为。 示例用法# $ ./future-spot.py --help usage: future-spot.py [-h] [--no-comp] [--sameaxis] Compensation example optional arguments: -h, --help show this help message and exit --no-comp --sameaxis示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import random import backtrader as bt # 修改收盘价的过滤器 def close_changer(data, *args, **kwargs): data.close[0] += 50.0 * random.randint(-1, 1) return False # 流长度不变 # 重写标准标记 class BuySellArrows(bt.observers.BuySell): plotlines = dict(buy=dict(marker=\u0026#39;$\\u21E7$\u0026#39;, markersize=12.0), sell=dict(marker=\u0026#39;$\\u21E9$\u0026#39;, markersize=12.0)) class St(bt.Strategy): def __init__(self): bt.obs.BuySell(self.data0, barplot=True) # 在此处完成 BuySellArrows(self.data1, barplot=True) # 为不同的数据设置不同的标记 def next(self): if not self.position: if random.randint(0, 1): self.buy(data=self.data0) self.entered = len(self) else: # 在市场中 if (len(self) - self.entered) \u0026gt;= 10: self.sell(data=self.data1) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() dataname = \u0026#39;../../datas/2006-day-001.txt\u0026#39; # 数据馈送 data0 = bt.feeds.BacktraderCSVData(dataname=dataname, name=\u0026#39;data0\u0026#39;) cerebro.adddata(data0) data1 = bt.feeds.BacktraderCSVData(dataname=dataname, name=\u0026#39;data1\u0026#39;) data1.addfilter(close_changer) if not args.no_comp: data1.compensate(data0) data1.plotinfo.plotmaster = data0 if args.sameaxis: data1.plotinfo.sameaxis = True cerebro.adddata(data1) cerebro.addstrategy(St) # 示例策略 cerebro.addobserver(bt.obs.Broker) # 通过 stdstats=False 移除 cerebro.addobserver(bt.obs.Trades) # 通过 stdstats=False 移除 cerebro.broker.set_coc(True) cerebro.run(stdstats=False) # 执行 cerebro.plot(volume=False) # 并绘图 def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=(\u0026#39;Compensation example\u0026#39;)) parser.add_argument(\u0026#39;--no-comp\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;) parser.add_argument(\u0026#39;--sameaxis\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":47,"href":"/backtrader/docs/08-indicators/03-timeframe-mixing/","title":"周期混合","section":"Indicator","content":"周期混合# 如果提供值的数据源有不同的时间框架，在 Cerebro 引擎中有不同的长度，指标将会出错。\n示例计算中，data0 有天的时间框架，data1 有月的时间框架：\npivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close \u0026lt; pivotpoint.s1在这里，当收盘价低于 s1 线（第一个支撑）时，寻求卖出信号。\n注意\nPivotPoint 定义上在较大的时间框架中工作。\n过去，这会导致以下错误：\nreturn self.array[self.idx + ago] IndexError: array index out of range原因很简单：self.data.close 从第一个时刻提供值，但 PivotPoint（以及 s1 线）只有在整个月过去后才会提供值，这大约相当于 22 个 self.data0.close 的值。在这 22 个收盘价期间，s1 还没有值，尝试从底层数组获取它会失败。\n线条对象支持 (ago) 操作符（Python 中的 __call__ 特殊方法）以提供其延迟版本：\nclose1 = self.data.close(-1)在这个例子中，对象 close1（通过 [0] 访问时）始终包含由 close 提供的前一个值（-1）。此语法已被重用以适应时间框架。让我们重写上述的 pivotpoint 代码片段：\npivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close \u0026lt; pivotpoint.s1()请注意，() 无参数执行（在后台提供了一个 None）。正在发生以下情况：\npivotpoint.s1() 返回一个内部 LinesCoupler 对象，该对象遵循较大范围的节奏。该耦合器使用来自实际 s1 的最新提供的值填充自身（以 NaN 为默认值开始）。\n但为了实现这一魔法，还需要额外的东西。Cerebro 必须这样创建：\ncerebro = bt.Cerebro(runonce=False)或这样执行：\ncerebro.run(runonce=False)在这种模式下，指标和延迟评估的自动线条对象按步执行，而不是在紧密循环中执行。这使整个操作变得更慢，但它使其成为可能。\n底部的示例脚本现在可以运行：\n$ ./mixing-timeframes.py输出：\n0021,0021,0001,2005-01-31,2984.75,2935.96,0.00 0022,0022,0001,2005-02-01,3008.85,2935.96,0.00 ... 0073,0073,0003,2005-04-15,3013.89,3010.76,0.00 0074,0074,0003,2005-04-18,2947.79,3010.76,1.00 ...在第 74 行，第一次出现 close \u0026lt; s1。\n脚本还提供了额外的可能性：耦合一个指标的所有线条。之前是：\nself.sellsignal = self.data0.close \u0026lt; pp.s1()替代方法是：\npp1 = pp() self.sellsignal = self.data0.close \u0026lt; pp1.s1现在整个 PivotPoint 指标已被耦合，并且可以访问其任何线条（即 p、r1、r2、s1、s2）。脚本只对 s1 感兴趣，访问是直接的：\n$ ./mixing-timeframes.py --multi输出：\n0021,0021,0001,2005-01-31,2984.75,2935.96,0.00 0022,0022,0001,2005-02-01,3008.85,2935.96,0.00 ... 0073,0073,0003,2005-04-15,3013.89,3010.76,0.00 0074,0074,0003,2005-04-18,2947.79,3010.76,1.00 ...这里没有意外。与之前相同。“耦合”对象甚至可以绘制：\n$ ./mixing-timeframes.py --multi --plot完整耦合语法# 对于具有多条线的线条对象（例如 PivotPoint 指标）：\nobj(clockref=None, line=-1)clockref：如果 clockref 为 None，则周围对象（例如策略）将作为参考，以适应较大时间框架（例如：月）到较小/更快的时间框架（例如：日）。如果需要，可以使用另一个参考。\nline：\n如果默认的 -1 被给定，则所有线条都被耦合。 如果是另一个整数（例如 0 或 1），则单条线将被耦合，并通过索引（来自 obj.lines[x]）获取。 如果传递了字符串，则按名称获取线条。 在示例中，可以这样做：\ncoupled_s1 = pp(line=\u0026#39;s1\u0026#39;)对于只有一条线的线条对象（例如来自 PivotPoint 指标的 s1 线）：\nobj(clockref=None)（见上文的 `clockref`）结论# 在常规的 () 语法中，来自不同时间框架的数据源可以混合在指标中，始终考虑到 cerebro 需要使用 runonce=False 实例化或创建。\n脚本代码和用法# 可以在 backtrader 的源代码中找到示例。用法：\n$ ./mixing-timeframes.py --help usage: mixing-timeframes.py [-h] [--data DATA] [--multi] [--plot] Sample for pivot point and cross plotting optional arguments: -h, --help show this help message and exit --data DATA Data to be read in (default: ../../datas/2005-2006-day-001.txt) --multi Couple all lines of the indicator (default: False) --plot Plot the result (default: False)代码：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind import backtrader.utils.flushfile class St(bt.Strategy): params = dict(multi=True) def __init__(self): self.pp = pp = btind.PivotPoint(self.data1) pp.plotinfo.plot = False # deactivate plotting if self.p.multi: pp1 = pp() # couple the entire indicators self.sellsignal = self.data0.close \u0026lt; pp1.s1 else: self.sellsignal = self.data0.close \u0026lt; pp.s1() def next(self): txt = \u0026#39;,\u0026#39;.join( [\u0026#39;%04d\u0026#39; % len(self), \u0026#39;%04d\u0026#39; % len(self.data0), \u0026#39;%04d\u0026#39; % len(self.data1), self.data.datetime.date(0).isoformat(), \u0026#39;%.2f\u0026#39; % self.data0.close[0], \u0026#39;%.2f\u0026#39; % self.pp.s1[0], \u0026#39;%.2f\u0026#39; % self.sellsignal[0]]) print(txt) def runstrat(): args = parse_args() cerebro = bt.Cerebro() data = btfeeds.BacktraderCSVData(dataname=args.data) cerebro.adddata(data) cerebro.resampledata(data, timeframe=bt.TimeFrame.Months) cerebro.addstrategy(St, multi=args.multi) cerebro.run(stdstats=False, runonce=False) if args.plot: cerebro.plot(style=\u0026#39;bar\u0026#39;) def parse_args(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample for pivot point and cross plotting\u0026#39;) parser.add_argument(\u0026#39;--data\u0026#39;, required=False, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--multi\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Couple all lines of the indicator\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, action=\u0026#39;store_true \u0026#39;, help=(\u0026#39;Plot the result\u0026#39;)) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()希望这能帮助你理解如何在 backtrader 中混合不同时间框架的数据！\n"},{"id":48,"href":"/backtrader/docs/06-datafeed/03-datafeed-development-csv/","title":"开发 CSV 数据源","section":"DataFeed","content":"CSV 数据源开发# Backtrader 已经提供了一些通用 CSV 数据源和特定的 CSV 数据源。\nGenericCSVData VisualChartCSVData YahooFinanceData（用于在线下载） YahooFinanceCSVData（用于已下载的数据） BacktraderCSVData（内部使用\u0026hellip;用于测试目的，但也可以使用） 即使如此，最终用户可能仍希望开发对特定 CSV 数据源的支持。\n通常的格言是：“说起来容易做起来难”。实际上，结构旨在使其变得简单。\n步骤# 从 backtrader.CSVDataBase 继承 根据需要定义任何参数 在 start 方法中进行任何初始化 在 stop 方法中进行任何清理 定义一个 _loadline 方法，其中实际工作发生。此方法接收一个参数：linetokens。 顾名思义，这包含根据分隔符参数（从基类继承）拆分当前行后的标记。\n如果在完成其工作后有新数据……填充相应的行并返回 True。\n如果没有可用的数据，因此解析已结束：返回 False。\n如果后台代码发现没有更多行需要解析，则可能不需要返回 False。\n已考虑的事项：\n打开文件（或接收类似文件的对象） 跳过标头行（如果指示存在） 读取行 标记行 预加载支持（将整个数据源一次性加载到内存中） 通常一个示例胜过千言万语。让我们使用 BacktraderCSVData 中定义的内部 CSV 解析代码的简化版本。这个版本不需要初始化或清理（例如，这可能是打开一个套接字并稍后关闭它）。\n注意：\nbacktrader 数据源包含通常的行业标准源，这些源是要填充的。即：\ndatetime open high low close volume openinterest 如果您的策略/算法或简单数据浏览只需要，例如收盘价，您可以不触碰其他字段（每次迭代会自动用 float('NaN') 值填充它们，然后用户代码有机会进行任何操作）。\n在此示例中，仅支持每日格式：\nimport itertools import backtrader as bt class MyCSVData(bt.CSVDataBase): def start(self): # 对于此数据源类型无需做任何操作 pass def stop(self): # 对于此数据源类型无需做任何操作 pass def _loadline(self, linetokens): i = itertools.count(0) dttxt = linetokens[next(i)] # 格式为 YYYY-MM-DD y = int(dttxt[0:4]) m = int(dttxt[5:7]) d = int(dttxt[8:10]) dt = datetime.datetime(y, m, d) dtnum = date2num(dt) self.lines.datetime[0] = dtnum self.lines.open[0] = float(linetokens[next(i)]) self.lines.high[0] = float(linetokens[next(i)]) self.lines.low[0] = float(linetokens[next(i)]) self.lines.close[0] = float(linetokens[next(i)]) self.lines.volume[0] = float(linetokens[next(i)]) self.lines.openinterest[0] = float(linetokens[next(i)]) return True代码假设所有字段都到位且可转换为浮点数，除了日期时间，它具有固定的 YYYY-MM-DD 格式，可以不使用 datetime.datetime.strptime 进行解析。\n通过添加一些代码行来处理空值和日期格式解析，可以满足更复杂的需求。GenericCSVData 就是这样做的。\n警告# 使用现有的 GenericCSVData 和继承，可以实现很多格式支持。\n让我们添加对 Sierra Chart 每日格式的支持（始终以 CSV 格式存储）。\n定义（通过查看一个 \u0026lsquo;.dly\u0026rsquo; 数据文件）：\n字段：Date, Open, High, Low, Close, Volume, OpenInterest\n行业标准字段以及 GenericCSVData 已支持的字段，顺序相同（也是行业标准）\n分隔符：,\n日期格式：YYYY/MM/DD\n一个用于这些文件的解析器：\nclass SierraChartCSVData(backtrader.feeds.GenericCSVData): params = ((\u0026#39;dtformat\u0026#39;, \u0026#39;%Y/%m/%d\u0026#39;),)参数定义只是重新定义了基类中的一个现有参数。在这种情况下，只需要更改日期格式字符串。\n完成# Sierra Chart 的解析器已经完成。\n下面是 GenericCSVData 的参数定义作为提醒：\nclass GenericCSVData(feed.CSVDataBase): params = ( (\u0026#39;nullvalue\u0026#39;, float(\u0026#39;NaN\u0026#39;)), (\u0026#39;dtformat\u0026#39;, \u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;), (\u0026#39;tmformat\u0026#39;, \u0026#39;%H:%M:%S\u0026#39;), (\u0026#39;datetime\u0026#39;, 0), (\u0026#39;time\u0026#39;, -1), (\u0026#39;open\u0026#39;, 1), (\u0026#39;high\u0026#39;, 2), (\u0026#39;low\u0026#39;, 3), (\u0026#39;close\u0026#39;, 4), (\u0026#39;volume\u0026#39;, 5), (\u0026#39;openinterest\u0026#39;, 6), )"},{"id":49,"href":"/backtrader/docs/10-broker/03-cheat-on-open/","title":"开盘作弊","section":"Broker","content":"Cheat On Open（开盘作弊）# 版本 1.9.44.116 添加了 Cheat-On-Open 支持。这似乎是对那些在计算完一个柱的收盘价后全仓操作的人们的需求，他们期望与开盘价匹配。\n当开盘价跳空（向上或向下，取决于买入或卖出）且现金不足以进行全仓操作时，这种情况会失败。这迫使经纪商拒绝操作。\n虽然人们可以尝试通过正 [1] 索引法查看未来，但这需要预加载数据，而这并不总是可行的。\n模式# cerebro = bt.Cerebro(cheat_on_open=True)这会在系统中激活一个额外的循环，该循环调用策略中的 next_open、nextstart_open 和 prenext_open 方法。\n为了清楚地分离常规方法（这些方法基于所检查的价格不再可用且未来未知）和作弊模式下的操作，决定增加一组额外的方法家族。\n这也避免了对常规 next 方法的两次调用。\n以下情况在 xxx_open 方法内部保持不变：\n指标尚未重新计算，保持上一个循环中在等效的 xxx 常规方法中最后看到的值。 经纪商尚未评估新循环中的待处理订单，并且可以引入新订单，如果可能，将进行评估。 注意：\nCerebro 还有一个名为 broker_coo（默认值：True）参数，它告诉 cerebro 如果激活了 cheat-on-open，它也会尝试在经纪商中激活它（如果可能的话）。 模拟经纪商有一个名为 coo 的参数和一个名为 set_coo 的方法来设置它。 尝试 Cheat-on-open# 下面的示例有一个策略，具有两种不同的行为：\n如果 cheat-on-open 为 True，它将仅从 next_open 操作。 如果 cheat-on-open 为 False，它将仅从 next 操作。 在这两种情况下，匹配价格必须相同：\n如果不作弊，订单在前一天的收盘后发出，并将与下一个到来的价格（开盘价）匹配。 如果作弊，订单在同一天发出并执行。因为订单是在经纪商评估订单之前发出的，所以它也将与下一个到来的价格（开盘价）匹配。 第二种情况下，可以精确计算全仓策略的份额，因为可以直接访问当前的开盘价。\n在这两种情况下，当前的开盘价和收盘价将从 next 中打印。\n常规执行：# $ ./cheat-on-open.py --cerebro cheat_on_open=False ... 2005-04-07 next, open 3073.4 close 3090.72 2005-04-08 next, open 3092.07 close 3088.92 Strat Len 68 2005-04-08 Send Buy, fromopen False, close 3088.92 2005-04-11 Buy Executed at price 3088.47 2005-04-11 next, open 3088.47 close 3080.6 2005-04-12 next, open 3080.42 close 3065.18 ...订单：\n在 2005-04-08 收盘后发出。 在 2005-04-11 以开盘价 3088.47 执行。 作弊执行：# $ ./cheat-on-open.py --cerebro cheat_on_open=True ... 2005-04-07 next, open 3073.4 close 3090.72 2005-04-08 next, open 3092.07 close 3088.92 2005-04-11 Send Buy, fromopen True, close 3080.6 2005-04-11 Buy Executed at price 3088.47 2005-04-11 next, open 3088.47 close 3080.6 2005-04-12 next, open 3080.42 close 3065.18 ...订单：\n在 2005-04-11 开盘前发出。 在 2005-04-11 以开盘价 3088.47 执行。 总结# 开盘作弊允许在开盘前发出订单，这可以例如允许精确计算全仓场景的份额。\n示例用法# $ ./cheat-on-open.py --help usage: cheat-on-open.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Cheat-On-Open Sample optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( periods=[10, 30], matype=bt.ind.SMA, ) def __init__(self): self.cheating = self.cerebro.p.cheat_on_open mas = [self.p.matype(period=x) for x in self.p.periods] self.signal = bt.ind.CrossOver(*mas) self.order = None def notify_order(self, order): if order.status != order.Completed: return self.order = None print(\u0026#39;{} {} Executed at price {}\u0026#39;.format( bt.num2date(order.executed.dt).date(), \u0026#39;Buy\u0026#39; * order.isbuy() or \u0026#39;Sell\u0026#39;, order.executed.price) ) def operate(self, fromopen): if self.order is not None: return if self.position: if self.signal \u0026lt; 0: self.order = self.close() elif self.signal \u0026gt; 0: print(\u0026#39;{} Send Buy, fromopen {}, close {}\u0026#39;.format( self.data.datetime.date(), fromopen, self.data.close[0]) ) self.order = self.buy() def next(self): print(\u0026#39;{} next, open {} close {}\u0026#39;.format( self.data.datetime.date(), self.data.open[0], self.data.close[0]) ) if self.cheating: return self.operate(fromopen=False) def next_open(self): if not self.cheating: return self.operate(fromopen=True) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # Data feed kwargs kwargs = dict() # Parse from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # Data feed data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # Broker cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # Sizer cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # Strategy cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # Execute cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # Plot if requested to cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Cheat-On-Open Sample\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # Defaults for dates parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False , default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":50,"href":"/backtrader/docs/09-orders/03-target-orders/","title":"目标订单","section":"Order","content":"目标订单# 在 1.8.10.96 版本之前，策略方法 buy 和 sell 可通过 sizer 实现智能持仓，sizer 负责确定持仓的大小。然而，Sizer 不能决定操作是买入还是卖出。这就需要一个新的概念，在决策中加入一个小的智能层。这就是策略中的order_target_xxx方法家族。\n受 zipline 的启发，这些方法提供了简单指定最终目标的机会，无论目标是：\nsize -\u0026gt; 特定资产的股份或合约数量 value -\u0026gt; 资产在投资组合中的货币单位价值 percent -\u0026gt; 当前投资组合中资产的百分比值 注意：这些方法的在 Strategy 类的参考文档中可以找到。简言之，这些方法使用与 buy 和 sell 相同的参数签名，只是将 size 参数替换为 target 参数。\n这些方法的核心在于指定最终目标，然后方法决定操作是买入还是卖出。所有三种方法的逻辑相同。以下是order_target_size的工作方式：\n如果目标大于当前仓位，则发出买入指令，买入的数量为target - position_size。例如：\n仓位：0，目标：7 -\u0026gt; buy(size=7 - 0) -\u0026gt; buy(size=7) 仓位：3，目标：7 -\u0026gt; buy(size=7 - 3) -\u0026gt; buy(size=4) 仓位：-3，目标：7 -\u0026gt; buy(size=7 - -3) -\u0026gt; buy(size=10) 仓位：-3，目标：-2 -\u0026gt; buy(size=-2 - -3) -\u0026gt; buy(size=1) 如果目标小于当前仓位，则发出卖出指令，卖出的数量为position_size - target。例如：\n仓位：0，目标：-7 -\u0026gt; sell(size=0 - -7) -\u0026gt; sell(size=7) 仓位：3，目标：-7 -\u0026gt; sell(size=3 - -7) -\u0026gt; sell(size=10) 仓位：-3，目标：-7 -\u0026gt; sell(size=-3 - -7) -\u0026gt; sell(size=4) 仓位：3，目标：2 -\u0026gt; sell(size=3 - 2) -\u0026gt; sell(size=1) 当使用order_target_value设定目标值时，会考虑资产在投资组合中的当前价值和持仓量，以决定最终的操作。逻辑如下：\n如果目标值大于当前值且仓位\u0026gt;=0 -\u0026gt; 买入 如果目标值大于当前值且仓位\u0026lt;0 -\u0026gt; 卖出 如果目标值小于当前值且仓位\u0026gt;=0 -\u0026gt; 卖出 如果目标值小于当前值且仓位\u0026lt;0 -\u0026gt; 买入 order_target_percent 的逻辑与 order_target_value 相同。该方法简单地根据当前投资组合的总价值确定资产的目标价值。\n示例# Backtrader 尝试为每个新功能提供一个示例，这也不例外。该示例在 samples 目录下的 order_target 子目录中。示例逻辑比较简单，仅用于测试结果是否如预期：\n在奇数月（1月、3月等），使用日期作为目标（在 order_target_value 的情况下，将日期乘以1000）； 在偶数月（2月、4月等），使用31减去日期作为目标； order_target_size# 我们来看1月和2月的情况。\n$ ./order_target.py --target-size --plot 0001 - 2005-01-03 - Position Size: 00 - Value 1000000.00 0001 - 2005-01-03 - Order Target Size: 03 0002 - 2005-01-04 - Position Size: 03 - Value 999994.39 0002 - 2005-01-04 - Order Target Size: 04 0003 - 2005-01-05 - Position Size: 04 - Value 999992.48 0003 - 2005-01-05 - Order Target Size: 05 0004 - 2005-01-06 - Position Size: 05 - Value 999988.79 ... 0020 - 2005-01-31 - Position Size: 28 - Value 999968.70 0020 - 2005-01-31 - Order Target Size: 31 0021 - 2005-02-01 - Position Size: 31 - Value 999954.68 0021 - 2005-02-01 - Order Target Size: 30 0022 - 2005-02-02 - Position Size: 30 - Value 999979.65 0022 - 2005-02-02 - Order Target Size: 29 0023 - 2005-02-03 - Position Size: 29 - Value 999966.33 0023 - 2005-02-03 - Order Target Size: 28 ...在1月，目标从年初第一个交易日的3开始增加。持仓量从0增加到3，然后每次增加1。\n在1月结束时，最后一个目标是31，当进入2月时，该持仓量被报告出来，新的目标变为30，并以1的递减变化。\norder_target_value# 期望有类似的行为：\n$ ./order_target.py --target-value --plot 0001 - 2005-01-03 - Position Size: 00 - Value 1000000.00 0001 - 2005-01-03 - data value 0.00 0001 - 2005-01-03 - Order Target Value: 3000.00 0002 - 2005-01-04 - Position Size: 78 - Value 999854.14 0002 - 2005-01-04 - data value 2853.24 0002 - 2005-01-04 - Order Target Value: 4000.00 0003 - 2005-01-05 - Position Size: 109 - Value 999801.68 0003 - 2005-01-05 - data value 3938.17 0003 - 2005-01-05 - Order Target Value: 5000.00 0004 - 2005-01-06 - Position Size: 138 - Value 999699.57 ... 0020 - 2005-01-31 - Position Size: 808 - Value 999206.37 0020 - 2005-01-31 - data value 28449.68 0020 - 2005-01-31 - Order Target Value: 31000.00 0021 - 2005-02-01 - Position Size: 880 - Value 998807.33 0021 - 2005-02-01 - data value 30580.00 0021 - 2005-02-01 - Order Target Value: 30000.00 0022 - 2005-02-02 - Position Size: 864 - Value 999510.21 0022 - 2005-02-02 - data value 30706.56 0022 - 2005-02-02 - Order Target Value: 29000.00 0023 - 2005-02-03 - Position Size: 816 - Value 999130.05 0023 - 2005-02-03 - data value 28633.44 0023 - 2005-02-03 - Order Target Value: 28000.00 ...order_target_percent# 此方法仅计算当前投资组合价值的百分比：\n$ ./order_target.py --target-percent --plot 0001 - 2005-01-03 - Position Size: 00 - Value 1000000.00 0001 - 2005-01-03 - data percent 0.00 0001 - 2005-01-03 - Order Target Percent: 0.03 0002 - 2005-01-04 - Position Size: 785 - Value 998532.05 0002 - 2005-01-04 - data percent 0.03 0002 - 2005-01-04 - Order Target Percent: 0.04 0003 - 2005-01-05 - Position Size: 1091 - Value 998007.44 0003 - 2005-01-05 - data percent 0.04 0003 - 2005-01-05 - Order Target Percent: 0.05 0004 - 2005-01-06 - Position Size: 1381 - Value 996985.64 ... 0020 - 2005-01-31 - Position Size: 7985 - Value 991966.28 0020 - 2005-01-31 - data percent 0.28 0020 - 2005-01-31 - Order Target Percent: 0.31 0021 - 2005-02-01 - Position Size: 8733 - Value 988008.94 0021 - 2005-02-01 - data percent 0.31 0021 - 2005-02-01 - Order Target Percent: 0.30 0022 - 2005-02-02 - Position Size: 8530 - Value 995005.45 0022 - 2005-02-02 - data percent 0.30 0022 - 2005-02-02 - Order Target Percent: 0.29 0023 - 2005-02-03 - Position Size: 8120 - Value 991240.75 0023 - 2005-02-03 - data percent 0.29 0023 - 2005-02-03 - Order Target Percent: 0.28 ...示例使用# $ ./order_target.py --help usage: order_target.py [-h] [--data DATA] [--fromdate FROMDATE] [--todate TODATE] [--cash CASH] (--target-size | --target-value | --target-percent) [--plot [kwargs]] Sample for Order Target optional arguments: -h, --help show this help message and exit --data DATA Specific data to be read in (default: ../../datas/yhoo-1996-2015.txt) --fromdate FROMDATE Starting date in YYYY-MM-DD format (default: 2005-01-01) --todate TODATE Ending date in YYYY-MM-DD format (default: 2006-12-31) --cash CASH Ending date in YYYY-MM-DD format (default: 1000000) --target-size Use order_target_size (default: False) --target-value Use order_target_value (default: False) --target-percent Use order_target_percent (default: False) --plot [kwargs], -p [kwargs] Plot the read data applying any kwargs passed For example: --plot style=\u0026#34;candle\u0026#34; (to plot candles) (default: None)"},{"id":51,"href":"/backtrader/docs/07-strategy/03-strategy-references/","title":"策略参考","section":"Strategy","content":"策略参考# 内置策略参考# MA_CrossOver# 别名：SMA_CrossOver，这是一个仅做多的策略，基于移动平均线交叉操作。\n交易规则# 买入逻辑： 如果无持仓，fast 移动平均线向上穿过 slow 移动平均线。\n卖出逻辑： 有持仓时，fast 移动平均线向下穿过 slow 移动平均线。\n订单类型： 市价单\n参数：\nfast (10)，_movav (\u0026lt;class ‘backtrader.indicators.sma.SMA’\u0026gt;) slow (30)，_movav (\u0026lt;class ‘backtrader.indicators.sma.SMA’\u0026gt;) SignalStrategy# 此策略的子类旨在使用信号自动操作。信号通常是指标，预期输出值为：\n\u0026gt; 0 表示多头指示 \u0026lt; 0 表示空头指示 信号分为两组，共有 5 种类型。\n主要组：\nLONGSHORT：接受来自该信号的多头和空头指示。 LONG： 接受多头指示进行做多。 接受空头指示平仓多头。但： 如果系统中有 LONGEXIT 信号，将用它来平仓多头。 如果有 SHORT 信号且没有 LONGEXIT 信号，它将被用来平仓多头再开空头。 SHORT： 接受空头指示进行做空。 接受多头指示平仓空头。但： 如果系统中有 SHORTEXIT 信号，将用它来平仓空头。 如果有 LONG 信号且没有 SHORTEXIT 信号，它将被用来平仓空头再开多头。 退出组：\n这两个信号旨在覆盖其他信号，并为平仓提供标准。\nLONGEXIT：接受空头指示平仓多头。 SHORTEXIT：接受多头指示平仓空头。 订单发出：\n订单执行类型为市价单，有效期为“直到取消” (Good until Canceled)。 参数：\nsignals (默认值: []): 允许实例化信号并分配到正确类型的列表/元组。 _accumulate (默认值: False): 允许进入市场（多头/空头），即使已经在市场中。 _concurrent (默认值: False): 允许在已有待执行订单时发出新订单。 _data (默认值: None): 如果系统中存在多个数据，目标数据是哪一个。这可以是： None: 将使用系统中的第一个数据。 int: 表示在该位置插入的数据。 str: 创建数据时给定的名称（参数 name），或通过 cerebro.adddata(\u0026hellip;, name=) 添加时给定的名称。 数据实例。 线：\ndatetime 参数：\nsignals ([]) _accumulate (False) _concurrent (False) _data (None) "},{"id":52,"href":"/backtrader/docs/04-concepts/01-platform-concepts/03-line/","title":"线 Line 类","section":"平台概念","content":"线 Line 类# 在 Backtrader 中，许多对象都会生成 Line 对象，而每个 Line 代表的是一个时间序列数据，可以是价格、指标或其他数据。策略逻辑基本都离不开操作 Line 对象。\nLine 的访问# 数据源中的 Line# 数据源中包含了多个 Line，如 close、open、high、low ，通过 self.data.lines 访问它们。\nclass MyStrategy(bt.Strategy): def __init__(self): self.close_line = self.data.lines.close # 访问收盘价线指标中的 Line# 指标同样会生成 Line，如 SimpleMovingAverage 的 sma，通过 self.movav.lines.sma 访问。\nclass MyStrategy(bt.Strategy): def __init__(self): self.movav = btind.SimpleMovingAverage(self.data, period=20) def next(self): if self.movav.lines.sma[0] \u0026gt; self.data.lines.close[0]: print(\u0026#39;移动平均大于收盘价\u0026#39;)访问线的快捷方式# 前面的语法和我们平时使用的不一样，因为我们平时都是通过简写访问，如 self.data.close 实际上是 self.data.lines.close 的快捷方式。\nBacktrader 提供了多种简化访问 Line 的方式：\nxxx.lines 可简写 xxx.l； xxx.lines.name 可简写 xxx.lines_name； xxx.lines[0] 可简写为 xxx xxx.lines[X] 可简写为 xxx.lineX； 还有如：\nself.data_name 等同于 self.data.lines.name； 对于有编号的 data，如 self.data1_name，等同于 self.data1.lines.name。 还有 self.dataX_Y 等同于 self.data[X].lines[Y]； 一些常用的简化写法，通过属性访问这些 Line：\nself.data.close 或 self.data_close 直接访问 close 数据行。 self.movav.sma 或 self.movav_sma 直接访问 sma 数据行。 self.movav 也可直接访问 sma 数据行； 这种访问方式很简洁，但不如原始方法清晰，特别是在区分访问的是否 Line 时。\n线的声明# 在 Backtrader 中，Line 是指标和策略中非常重要的部分。每个自定义指标都要声明自己的线，以便在策略中使用。\n如何声明线# 如何在自定义指标中声明线？\n当你创建一个自定义指标时，需要通过 lines 属性声明该指标会输出的线。通常使用元组声明，元组中的每个元素表示一个线的名称。\n如在 SimpleMovingAverage 指标中，我们声明了一个名为 sma 的线：\nclass SimpleMovingAverage(bt.Indicator): lines = (\u0026#39;sma\u0026#39;,) # 声明一个名为 sma 的线 def __init__(self): self.lines.sma = self.data.close(-1) # 计算并赋值给 sma 线如你想声明多条线，如一个包含两条均线的指标，只需在 lines 中列出多个元素：\nclass MyIndicator(bt.Indicator): lines = (\u0026#39;sma1\u0026#39;, \u0026#39;sma2\u0026#39;) # 声明两个线：sma1 和 sma2 def __init__(self): self.lines.sma1 = btind.SimpleMovingAverage(self.data, period=20) self.lines.sma2 = btind.SimpleMovingAverage(self.data, period=50)注意事项：当声明 Line 时，确保使用元组声明，即使只有一条线也要加上逗号：('sma',)。\n现在，指标的计算结果会被保存在 Line 中，策略可以直接访问这些 Line 计算交易逻辑。\nLine 的长度# 在 Backtrader 中，每条线都包含一个动态增长的点集合。你可以随时获取线的长度，以了解当前的数据处理情况。\n如何获取线的长度：# 使用 len() 函数：使用标准 Python len() 函数即可获取 Line 的长度，这会返回已处理的数据点数。\nclass MyStrategy(bt.Strategy): def next(self): length = len(self.data) print(f\u0026#34;数据源的线长: {length}\u0026#34;)使用 buflen 属性：buflen 返回数据源可用的总数据条数，也就是数据源在加载时的总长度。\nclass MyStrategy(bt.Strategy): def next(self): buflen = self.data.buflen print(f\u0026#34;数据源的总长度: {buflen}\u0026#34;)实盘交易时，对于实时数据源很有用，因为它能让我们显示数据源的实际可用数量。\nlen() 和 buflen 的区别：\nlen() 返回已处理的数据条数，即实际运行到当前时间点的数据长度。 buflen 返回的是数据源加载的总条数，即加载的所有数据的长度。 如果两者的值相同，说明所有数据都已经处理完毕。\nLine 的继承# Backtrader 支持 Line 的继承，我们可以在子类中继承父类的线，且可以在子类中修改。\n示例代码：\nclass BaseIndicator(bt.Indicator): lines = (\u0026#39;sma\u0026#39;,) class MyIndicator(BaseIndicator): lines = (\u0026#39;sma\u0026#39;, \u0026#39;ema\u0026#39;) # 在子类中继承并扩展线如果多个父类定义了相同名称的线，子类只会继承一个版本的线，因此要避免同名的线定义冲突。\nLine 耦合# Backtrader 允许你在多个时间框架下使用数据源，并支持将它们的线进行耦合。线耦合是指将不同时间周期的数据结合起来，以便在策略中进行跨时间框架的计算和分析。\n如何使用线耦合：# 你可以在策略中同时使用多个数据源，每个数据源可能有不同的时间周期。例如，一个数据源是日线数据，另一个是周线数据：\nclass MyStrategy(bt.Strategy): def __init__(self): self.sma_daily = btind.SimpleMovingAverage(self.data0, period=20) # 日线数据 self.sma_weekly = btind.SimpleMovingAverage(self.data1, period=5) # 周线数据Backtrader 提供了 () 运算符来将不同时间框架的数据线耦合在一起。\n例如：\nclass MyStrategy(bt.Strategy): def __init__(self): sma0 = btind.SMA(self.data0, period=15) # 15 天的简单移动平均线 sma1 = btind.SMA(self.data1, period=5) # 5 周的简单移动平均线 self.buysig = sma0 \u0026gt; sma1() # 通过运算符将两个时间框架的线耦合上面的例子中，sma0 和 sma1 分别是基于日线和周线数据计算的简单移动平均线。sma1() 用于将周线数据转换成日线数据的长度，从而进行跨时间框架的计算。\nLine 耦合使得我们能更灵活地在策略中使用多个时间框架的数据，进行更复杂的分析和决策。\n"},{"id":53,"href":"/backtrader/docs/11-commission-schemes/03-customization/","title":"自定义佣金","section":"Commission","content":"自定义佣金# 重新设计 CommInfo 对象以实现当前版本的最重要部分包括：\n保留原始 CommissionInfo 类和行为 为轻松创建用户定义的佣金打开大门 将格式 xx% 作为新佣金方案的默认值，而不是 0.xx（这只是个口味问题），同时保持行为可配置 定义佣金方案# 这涉及 1 到 2 个步骤：\n子类化 CommInfoBase# 仅更改默认参数可能就足够了。backtrader 已经在模块 backtrader.commissions 中使用一些定义进行了此操作。期货的常规行业标准是每合同和每轮固定金额。定义可以这样做：\nclass CommInfo_Futures_Fixed(CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, False), (\u0026#39;commtype\u0026#39;, CommInfoBase.COMM_FIXED), )对于股票和按百分比计算的佣金：\nclass CommInfo_Stocks_Perc(CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, True), (\u0026#39;commtype\u0026#39;, CommInfoBase.COMM_PERC), )如上所述，此处解释百分比的默认值（作为参数 commission 传递）为：xx%。如果需要旧的/其他行为 0.xx，可以轻松实现：\nclass CommInfo_Stocks_PercAbs(CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, True), (\u0026#39;commtype\u0026#39;, CommInfoBase.COMM_PERC), (\u0026#39;percabs\u0026#39;, True), )重写 _getcommission 方法（如有必要）# 定义如下：\ndef _getcommission(self, size, price, pseudoexec): \u0026#39;\u0026#39;\u0026#39;Calculates the commission of an operation at a given price pseudoexec: if True the operation has not yet been executed \u0026#39;\u0026#39;\u0026#39;下面的实际示例中有更多详细信息。\n如何将其应用于平台# 一旦有了 CommInfoBase 子类，诀窍是使用 broker.addcommissioninfo 而不是通常的 broker.setcommission。后者将在内部使用旧版 CommissionInfoObject。\n... comminfo = CommInfo_Stocks_PercAbs(commission=0.005) # 0.5% cerebro.broker.addcommissioninfo(comminfo)addcommissioninfo 方法定义如下：\ndef addcommissioninfo(self, comminfo, name=None): self.comminfo[name] = comminfo设置 name 意味着 comminfo 对象将仅适用于具有该名称的资产。默认值 None 表示它适用于系统中的所有资产。\n实际示例# 问题 #45 询问一种适用于期货的佣金方案，该方案基于百分比，并使用整个“虚拟”合约价值的佣金百分比，即：包括期货乘数在佣金计算中。\nimport backtrader as bt class CommInfo_Fut_Perc_Mult(bt.CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, False), # Futures (\u0026#39;commtype\u0026#39;, bt.CommInfoBase.COMM_PERC), # Apply % Commission # (\u0026#39;percabs\u0026#39;, False), # pass perc as xx% which is the default ) def _getcommission(self, size, price, pseudoexec): return size * price * self.p.commission * self.p.mult将其放入系统中：\ncomminfo = CommInfo_Fut_Perc_Mult( commission=0.1, # 0.1% mult=10, margin=2000 # Margin is needed for futures-like instruments ) cerebro.addcommissioninfo(comminfo)如果更喜欢 0.xx 格式作为默认值，只需将参数 percabs 设置为 True：\nclass CommInfo_Fut_Perc_Mult(bt.CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, False), # Futures (\u0026#39;commtype\u0026#39;, bt.CommInfoBase.COMM_PERC), # Apply % Commission (\u0026#39;percabs\u0026#39;, True), # pass perc as 0.xx ) comminfo = CommInfo_Fut_Perc_Mult( commission=0.001, # 0.1% mult=10, margin=2000 # Margin is needed for futures-like instruments ) cerebro.addcommissioninfo(comminfo)解释 pseudoexec# 让我们回顾 _getcommission 的定义：\ndef _getcommission(self, size, price, pseudoexec): \u0026#39;\u0026#39;\u0026#39;Calculates the commission of an operation at a given price pseudoexec: if True the operation has not yet been executed \u0026#39;\u0026#39;\u0026#39;pseudoexec 参数的目的是在平台可能调用此方法进行可用现金的预计算和其他一些任务时使用。\n这意味着该方法可能（实际上确实会）使用相同的参数多次调用。\npseudoexec 指示调用是否对应于订单的实际执行。尽管乍看之下这似乎不“相关”，但在以下情景中却是如此：\n经纪商在期货往返佣金超过 5000 单位合同时提供 50% 的折扣。\n在这种情况下，如果没有 pseudoexec，对该方法的多次非执行调用将迅速触发折扣到位的假设。\n将此情景付诸实践：\nimport backtrader as bt class CommInfo_Fut_Discount(bt.CommInfoBase): params = ( (\u0026#39;stocklike\u0026#39;, False), # Futures (\u0026#39;commtype\u0026#39;, bt.CommInfoBase.COMM_FIXED), # Apply Commission # Custom params for the discount (\u0026#39;discount_volume\u0026#39;, 5000), # minimum contracts to achieve discount (\u0026#39;discount_perc\u0026#39;, 50.0), # 50.0% discount ) negotiated_volume = 0 # attribute to keep track of the actual volume def _getcommission(self, size, price, pseudoexec): if self.negotiated_volume \u0026gt; self.p.discount_volume: actual_discount = self.p.discount_perc / 100.0 else: actual_discount = 0.0 commission = self.p.commission * (1.0 - actual_discount) commvalue = size * price * commission if not pseudoexec: # keep track of actual real executed size for future discounts self.negotiated_volume += size return commvalueCommInfoBase 文档字符串和参数# 有关 CommInfoBase 的参考，请参见“佣金：股票与期货”。\n"},{"id":54,"href":"/backtrader/docs/05-cerebro/03-saving-memory/","title":"节省内存","section":"Cerebro","content":"内存优化# Backtrader 的开发是在拥有大量RAM的机器上进行的，加上绘图的可视化反馈非常有用，几乎是必需品，这使得设计决策变得容易：将所有内容保存在内存中。但这一决定有一些缺点：\n使用array.array进行数据存储时，当某些边界被超出时，需要分配和移动数据。 内存较少的机器可能会受到影响。 连接到一个可能在线数周/数月、提供数千秒/分钟分辨率tick的实时数据源。 后者比前者更重要，因为backtrader做出了另一个设计决策：\n保持纯Python以便在需要时能够在嵌入式系统中运行。 未来的一个场景可能是backtrader连接到第二台提供实时数据的机器，而backtrader本身运行在Raspberry Pi甚至更有限的设备上，如ADSL路由器（带有Freetz映像的AVM Frit!Box 7490）。\n因此，需要backtrader支持动态内存方案。现在可以使用以下语义实例化或运行Cerebro：\nexactbars 默认值为 False，每个存储在线中的值都保存在内存中。可能的值：\nTrue或1：所有“线”对象将内存使用减少到自动计算的最小周期。\n如果 SMA 的周期为30，则底层将始终有一个30条的运行缓冲区，以允许计算 SMA。 此设置将停用预加载和runonce。 使用此设置还将停用绘图。 -1：在策略级别的数据源和指标/操作将保留所有数据在内存中。\n如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 -2：作为策略属性的数据源和指标将保留所有点在内存中。\n如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 正如往常，示例胜过千言万语。一个示例脚本展示了差异。它针对1996年至2015年的雅虎每日数据运行，共计4965天。\n注意：这是一个小样本。交易14小时的EuroStoxx50期货在一个月内将生成约18000个1分钟条。\n首先执行脚本，查看在不请求内存节省时使用了多少内存位置：\n$ ./memory-savings.py --save 0 Total memory cells used: 506430对于级别1（完全节省）：\n$ ./memory-savings.py --save 1 Total memory cells used: 2041从 50 万降到 2041。确实如此。\n系统中的每个“线”对象使用collections.deque作为缓冲区（而不是array.array），并且长度限制为所需操作的绝对最小值。\n假设，使用周期为30的简单移动平均线的策略。在这种情况下，将进行以下调整：\n数据源将有一个30位置的缓冲区，这是 SMA 生成下一个值所需的数量。 SMA 将有一个位置的缓冲区，因为除非其他指标需要（依赖于 SMA），否则没必要保留更大缓冲区。 注意：此模式最吸引人且可能最重要的特点是，整个脚本生命周期内使用的内存量保持不变。\n无论数据源的大小如何。如如果长时间连接实时数据源，这将非常有用。\n但请注意：\n绘图不可用。 还有其他内存消耗源，如策略生成的订单，随着时间的推移会积累。 此模式只能与runonce=False一起在cerebro中使用。这对于实时数据源也是强制性的，但在简单回测的情况下，这比runonce=True慢。毫无疑问，从某个折衷点来看，内存管理比逐步执行回测更昂贵，但这只能由平台的终端用户根据具体情况判断。 现在是负级别。这些旨在在保持绘图可用的同时仍节省大量内存。第一个级别-1：\n$ ./memory-savings.py --save -1 Total memory cells used: 184623在这种情况下，1 级指标（策略中声明的那些）保留其完整长度缓冲区。但如果这些指标依赖于其他指标（这是情况），则子对象将长度受限。在这种情况下，我们从：\n506430内存位置降至 -\u0026gt; 184623 超过50%的节省。\n注意：当然，array.array对象已被collections.deque替换，后者在内存方面更昂贵，虽然在操作方面更快。但collections.deque对象相当小，节省的内存位置接近大致计算的内存位置使用。\n现在是级别-2，这也是为了节省在策略级别声明且标记为不绘图的指标：\n$ ./memory-savings.py --save -2 Total memory cells used: 174695现在并没有节省多少。这是因为只有一个指标被标记为不绘图：TestInd().plotinfo.plot = False。\n让我们看看最后一个示例的绘图：\n$ ./memory-savings.py --save -2 --plot Total memory cells used: 174695\n对于感兴趣的读者，示例脚本可以详细分析遍历指标层次结构的每个“线”对象。启用绘图运行（在-1保存）：\n$ ./memory-savings.py --save -1 --lendetails -- Evaluating Datas ---- Data 0 Total Cells 34755 - Cells per Line 4965 -- Evaluating Indicators ---- Indicator 1.0 Average Total Cells 30 - Cells per line 30 ---- SubIndicators Total Cells 1 ---- Indicator 1.1 _LineDelay Total Cells 1 - Cells per line 1 ---- SubIndicators Total Cells 1 ... ---- Indicator 0.5 TestInd Total Cells 9930 - Cells per line 4965 ---- SubIndicators Total Cells 0 -- Evaluating Observers ---- Observer 0 Total Cells 9930 - Cells per Line 4965 ---- Observer 1 Total Cells 9930 - Cells per Line 4965 ---- Observer 2 Total Cells 9930 - Cells per Line 4965 Total memory cells used: 184623相同的，但启用最大节省（1）：\n$ ./memory-savings.py --save 1 --lendetails -- Evaluating Datas ---- Data 0 Total Cells 266 - Cells per Line 38 -- Evaluating Indicators ---- Indicator 1.0 Average Total Cells 30 - Cells per line 30 ---- SubIndicators Total Cells 1 ... ---- Indicator 0.5 TestInd Total Cells 2 - Cells per line 1 ---- SubIndicators Total Cells 0 -- Evaluating Observers ---- Observer 0 Total Cells 2 - Cells per Line 1 ---- Observer 1 Total Cells 2 - Cells per Line 1 ---- Observer 2 Total Cells 2 - Cells per Line 1第二个输出立即显示数据源中的线已被限制为38个内存位置，而不是4965个（完整数据源长度）。\n并且在可能的情况下，指标和观察者已被限制为1个，如输出的最后几行所示。\n脚本代码和使用# 在backtrader的源代码中提供了示例。使用方法：\n$ ./memory-savings.py --help usage: memory-savings.py [-h] [--data DATA] [--save SAVE] [--datalines] [--lendetails] [--plot] Check Memory Savings optional arguments: -h, --help show this help message and exit --data DATA Data to be read in (default: ../../datas/yhoo-1996-2015.txt) --save SAVE Memory saving level [1, 0, -1, -2] (default: 0) --datalines Print data lines (default: False) --lendetails Print individual items memory usage (default: False) --plot Plot the result (default: False)代码：\nfrom __future__ import (absolute_import , division, print_function, unicode_literals) import argparse import sys import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind import backtrader.utils.flushfile class TestInd(bt.Indicator): lines = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) def __init__(self): self.lines.a = b = self.data.close - self.data.high self.lines.b = btind.SMA(b, period=20) class St(bt.Strategy): params = ( (\u0026#39;datalines\u0026#39;, False), (\u0026#39;lendetails\u0026#39;, False), ) def __init__(self): btind.SMA() btind.Stochastic() btind.RSI() btind.MACD() btind.CCI() TestInd().plotinfo.plot = False def next(self): if self.p.datalines: txt = \u0026#39;,\u0026#39;.join( [\u0026#39;%04d\u0026#39; % len(self), \u0026#39;%04d\u0026#39; % len(self.data0), self.data.datetime.date(0).isoformat()] ) print(txt) def loglendetails(self, msg): if self.p.lendetails: print(msg) def stop(self): super(St, self).stop() tlen = 0 self.loglendetails(\u0026#39;-- Evaluating Datas\u0026#39;) for i, data in enumerate(self.datas): tdata = 0 for line in data.lines: tdata += len(line.array) tline = len(line.array) tlen += tdata logtxt = \u0026#39;---- Data {} Total Cells {} - Cells per Line {}\u0026#39; self.loglendetails(logtxt.format(i, tdata, tline)) self.loglendetails(\u0026#39;-- Evaluating Indicators\u0026#39;) for i, ind in enumerate(self.getindicators()): tlen += self.rindicator(ind, i, 0) self.loglendetails(\u0026#39;-- Evaluating Observers\u0026#39;) for i, obs in enumerate(self.getobservers()): tobs = 0 for line in obs.lines: tobs += len(line.array) tline = len(line.array) tlen += tdata logtxt = \u0026#39;---- Observer {} Total Cells {} - Cells per Line {}\u0026#39; self.loglendetails(logtxt.format(i, tobs, tline)) print(\u0026#39;Total memory cells used: {}\u0026#39;.format(tlen)) def rindicator(self, ind, i, deep): tind = 0 for line in ind.lines: tind += len(line.array) tline = len(line.array) thisind = tind tsub = 0 for j, sind in enumerate(ind.getindicators()): tsub += self.rindicator(sind, j, deep + 1) iname = ind.__class__.__name__.split(\u0026#39;.\u0026#39;)[-1] logtxt = \u0026#39;---- Indicator {}.{} {} Total Cells {} - Cells per line {}\u0026#39; self.loglendetails(logtxt.format(deep, i, iname, tind, tline)) logtxt = \u0026#39;---- SubIndicators Total Cells {}\u0026#39; self.loglendetails(logtxt.format(deep, i, iname, tsub)) return tind + tsub def runstrat(): args = parse_args() cerebro = bt.Cerebro() data = btfeeds.YahooFinanceCSVData(dataname=args.data) cerebro.adddata(data) cerebro.addstrategy( St, datalines=args.datalines, lendetails=args.lendetails) cerebro.run(runonce=False, exactbars=args.save) if args.plot: cerebro.plot(style=\u0026#39;bar\u0026#39;) def parse_args(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Check Memory Savings\u0026#39;) parser.add_argument(\u0026#39;--data\u0026#39;, required=False, default=\u0026#39;../../datas/yhoo-1996-2015.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--save\u0026#39;, required=False, type=int, default=0, help=(\u0026#39;Memory saving level [1, 0, -1, -2]\u0026#39;)) parser.add_argument(\u0026#39;--datalines\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Print data lines\u0026#39;)) parser.add_argument(\u0026#39;--lendetails\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Print individual items memory usage\u0026#39;)) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Plot the result\u0026#39;)) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":55,"href":"/backtrader/docs/03-quickstart/03-datafeed/","title":"配置数据","section":"快速开始","content":"配置数据 DataFeed# 我们目标是通过策略实现资产增值，这就离不开价格数据，甚至是其他有用的数据。本小节，我们将学习如何系统配置数据源，即添加数据源 DataFeed。\n配置 DataFeed 要用到的是 backtrader.feeds 中提供的数据工具。要用到的数据文件是 orcl-1995-2014（点击下载即可下载）。\n假设，数据文件被下载到当前目录，通过 bt.feeds.YahooFinanceCSVDataFeed 即可创建 datafeed。\ndata = bt.feeds.YahooFinanceCSVData( dataname=\u0026#34;./orcl-1995-2014.txt\u0026#34;, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False )Yahoo 在线下载的 CSV 数据按日期降序排列，YahooFinanceCSVData 也是按这个标准解析。但我们提供的数据是升序排列，故设置参数 reverse=True。\n接下来，我们通过 cerebro.adddata 将数据添加系统即可。\ncerebro.adddata(data)将这部分实现补充到我们的系统中。\n完整示例# import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;./datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(100000.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())运行输出：\nStarting Portfolio Value: 100000.00 Final Portfolio Value: 100000.00系统已经有了数据源，但资产并未增值，为什么？让我们继续下一节，策略（Strategy）类的学习。\n"},{"id":56,"href":"/backtrader/docs/09-orders/04-oco-orders/","title":"OCO 订单","section":"Order","content":"OCO订单# 使用模式尽量保持简单。因此，如果策略中的逻辑决定是时候发布订单，可以像这样使用 OCO：\ndef next(self): ... o1 = self.buy(...) ... o2 = self.buy(..., oco=o1) ... o3 = self.buy(..., oco=o1) # 甚至可以是oco=o2，o2已经在o1组中很简单，第一个订单 o1 将成为组长。通过指定 oco 命名参数，o2 和 o3 成为 OCO 组的一部分。请注意，代码注释指出 o3 也可以通过指定 o2 成为组的一部分（o2已经是组的一部分）。\n一旦成功组成组后，如果组中的任何订单被执行、取消或过期，其他订单将被取消。\n下面的示例展示了OCO概念。一个标准执行并绘图：\n$ ./oco.py --broker cash=50000 --plot注意\n现金增加到50000，因为资产价值达到4000，3个订单的1个项目至少需要12000货币单位（经纪商默认值为10000）。\n以下图表实际上没有提供太多信息（这是一个标准的SMA交叉策略）。\n示例执行，当快速SMA上穿慢速SMA时，发布3个订单。\norder1是一个限价订单，在limdays天后到期，限价为收盘价减少一个百分比。 order2是一个期限更长、限价更低的限价订单。 order3是一个限价更低的限价订单。 因此，order2 和 order3 不会执行，因为：\norder1将首先执行，这将触发其他订单的取消。 或者order1将过期，这将触发其他订单的取消。 系统保存了3个订单的ref标识符，并且只有在notify_order中看到三个ref标识符分别为Completed、Cancelled、Margin或Expired时，才会发布新买单。\n退出是在持有一段时间后后简单完成的。\n为了跟踪实际执行，生成文本输出。部分内容如下：\n2005-01-28: Oref 1 / Buy at 2941.11055 2005-01-28: Oref 2 / Buy at 2896.7722 2005-01-28: Oref 3 / Buy at 2822.87495 2005-01-31: Order ref: 1 / Type Buy / Status Submitted 2005-01-31: Order ref: 2 / Type Buy / Status Submitted 2005-01-31: Order ref: 3 / Type Buy / Status Submitted 2005-01-31: Order ref: 1 / Type Buy / Status Accepted 2005-01-31: Order ref: 2 / Type Buy / Status Accepted 2005-01-31: Order ref: 3 / Type Buy / Status Accepted 2005-02-01: Order ref: 1 / Type Buy / Status Expired 2005-02-01: Order ref: 3 / Type Buy / Status Canceled 2005-02-01: Order ref: 2 / Type Buy / Status Canceled ... 2006-06-23: Oref 49 / Buy at 3532.39925 2006-06-23: Oref 50 / Buy at 3479.147 2006-06-23: Oref 51 / Buy at 3390.39325 2006-06-26: Order ref: 49 / Type Buy / Status Submitted 2006-06-26: Order ref: 50 / Type Buy / Status Submitted 2006-06-26: Order ref: 51 / Type Buy / Status Submitted 2006-06-26: Order ref: 49 / Type Buy / Status Accepted 2006-06-26: Order ref: 50 / Type Buy / Status Accepted 2006-06-26: Order ref: 51 / Type Buy / Status Accepted 2006-06-26: Order ref: 49 / Type Buy / Status Completed 2006-06-26: Order ref: 51 / Type Buy / Status Canceled 2006-06-26: Order ref: 50 / Type Buy / Status Canceled ... 2006-11-10: Order ref: 61 / Type Buy / Status Canceled 2006-12-11: Oref 63 / Buy at 4032.62555 2006-12-11: Oref 64 / Buy at 3971.8322 2006-12-11: Oref 65 / Buy at 3870.50995 2006-12-12: Order ref: 63 / Type Buy / Status Submitted 2006-12-12: Order ref: 64 / Type Buy / Status Submitted 2006-12-12: Order ref: 65 / Type Buy / Status Submitted 2006-12-12: Order ref: 63 / Type Buy / Status Accepted 2006-12-12: Order ref: 64 / Type Buy / Status Accepted 2006-12-12: Order ref: 65 / Type Buy / Status Accepted 2006-12-15: Order ref: 63 / Type Buy / Status Expired 2006-12-15: Order ref: 65 / Type Buy / Status Canceled 2006-12-15: Order ref: 64 / Type Buy / Status Canceled以下情况发生：\n第一批订单发布。订单1到期，订单2和3被取消。预期结果。 几个月后发布另一批3个订单。在这种情况下，订单49完成，订单50和51立即取消。 最后一批订单与第一批订单相同。 现在检查不使用 OCO 的行为：\n$ ./oco.py --strat do_oco=False --broker cash=50000 2005-01-28: Oref 1 / Buy at 2941.11055 2005-01-28: Oref 2 / Buy at 2896.7722 2005-01-28: Oref 3 / Buy at 2822.87495 2005-01-31: Order ref: 1 / Type Buy / Status Submitted 2005-01-31: Order ref: 2 / Type Buy / Status Submitted 2005-01-31: Order ref: 3 / Type Buy / Status Submitted 2005-01-31: Order ref: 1 / Type Buy / Status Accepted 2005-01-31: Order ref: 2 / Type Buy / Status Accepted 2005-01-31: Order ref: 3 / Type Buy / Status Accepted 2005-02-01: Order ref: 1 / Type Buy / Status Expired结果不多（没有订单执行，图表也没有太多需求）。\n发布了一批订单。\n订单1过期，但因为策略参数 do_oco =False，订单2和3未加入OCO组，因此订单2和3未被取消，由于默认到期时间为1000天，样本可用数据（2年数据）内它们永不过期。\n系统从未发布第二批订单。\n示例使用# $ ./oco.py --help usage: oco.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Sample Skeleton optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( ma=bt.ind.SMA, p1=5, p2=15, limit=0.005, limdays=3, limdays2=1000, hold=10, switchp1p2=False, # switch prices of order1 and order2 oco1oco2=False, # False - use order1 as oco for order3, else order2 do_oco=True, # use oco or not ) def notify_order(self, order): print(\u0026#39;{}: Order ref: {} / Type {} / Status {}\u0026#39;.format( self.data.datetime.date(0), order.ref, \u0026#39;Buy\u0026#39; * order.isbuy() or \u0026#39;Sell\u0026#39;, order.getstatusname())) if order.status == order.Completed: self.holdstart = len(self) if not order.alive() and order.ref in self.orefs: self.orefs.remove(order.ref) def __init__(self): ma1, ma2 = self.p.ma(period=self.p.p1), self.p.ma(period=self.p.p2) self.cross = bt.ind.CrossOver(ma1, ma2) self.orefs = list() def next(self): if self.orefs: return # pending orders do nothing if not self.position: if self.cross \u0026gt; 0.0: # crossing up p1 = self.data.close[0] * (1.0 - self.p.limit) p2 = self.data.close[0] * (1.0 - 2 * 2 * self.p.limit) p3 = self.data.close[0] * (1.0 - 3 * 3 * self.p.limit) if self.p.switchp1p2: p1, p2 = p2, p1 o1 = self.buy(exectype=bt.Order.Limit, price=p1, valid=datetime.timedelta(self.p.limdays)) print(\u0026#39;{}: Oref {} / Buy at {}\u0026#39;.format( self.datetime.date(), o1.ref, p1)) oco2 = o1 if self.p.do_oco else None o2 = self.buy(exectype=bt.Order.Limit, price=p2, valid=datetime.timedelta(self.p.limdays2), oco=oco2) print(\u0026#39;{}: Oref {} / Buy at {}\u0026#39;.format( self.datetime.date(), o2.ref, p2)) if self.p.do_oco: oco3 = o1 if not self.p.oco1oco2 else oco2 else: oco3 = None o3 = self.buy(exectype=bt.Order.Limit, price=p3, valid=datetime.timedelta(self.p.limdays2), oco=oco3) print(\u0026#39;{}: Oref {} / Buy at {}\u0026#39;.format( self.datetime.date(), o3.ref, p3)) self.orefs = [o1.ref, o2.ref, o3.ref] else: # in the market if (len(self) - self.holdstart) \u0026gt;= self.p.hold: self.close() def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # Data feed kwargs kwargs = dict() # Parse from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # Data feed data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # Broker cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # Sizer cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # Strategy cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # Execute cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # Plot if requested to cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;Sample Skeleton\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # Defaults for dates parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":57,"href":"/backtrader/docs/12-analyzers/04-reference/","title":"Reference","section":"Analyzer","content":"参考# AnnualReturn# class backtrader.analyzers.AnnualReturn()该分析器通过查看年的起点和终点来计算年度回报率。\n参数：\n无 成员属性：\nrets：计算出的年度回报率列表 ret：年度回报率字典（键：年份） get_analysis： 返回包含年度回报率的字典（键：年份）\nCalmar# class backtrader.analyzers.Calmar()该分析器计算 Calmar 比率，时间框架可以与基础数据使用的不同。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含时间段键和对应滚动 Calmar 比率的 OrderedDict。\nDrawDown# class backtrader.analyzers.DrawDown()该分析器计算交易系统的回撤统计数据，如百分比和美元的回撤值、最大回撤值、回撤长度和最大回撤长度。\n参数：\nfund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：\ndrawdown：回撤值（百分比） moneydown：回撤值（货币单位） len：回撤长度 max.drawdown：最大回撤值（百分比） max.moneydown：最大回撤值（货币单位） max.len：最大回撤长度 TimeDrawDown# class backtrader.analyzers.TimeDrawDown()该分析器计算在选定时间框架上的交易系统回撤，可以与基础数据使用的时间框架不同。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：\ndrawdown：回撤值（百分比） maxdrawdown：最大回撤值（货币单位） maxdrawdownperiod：回撤长度 GrossLeverage# class backtrader.analyzers.GrossLeverage()该分析器计算当前策略的总杠杆。\n参数：\nfund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nPositionsValue# class backtrader.analyzers.PositionsValue()该分析器报告当前数据集的仓位价值。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 headers（默认：False）：在保存结果的字典中添加一个初始键，名称为数据的名称（\u0026lsquo;Datetime\u0026rsquo; 为键）。 cash（默认：False）：包括实际现金作为额外仓位（对于标头，将使用名称 \u0026lsquo;cash\u0026rsquo;）。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nPyFolio# class backtrader.analyzers.PyFolio()该分析器使用 4 个子分析器收集数据，并将其转换为与 pyfolio 兼容的数据集。\n子分析器：\nTimeReturn：用于计算全球投资组合价值的回报。 PositionsValue：用于计算每个数据的仓位价值。设置 headers 和 cash 参数为 True。 Transactions：用于记录每个数据上的每笔交易（数量、价格、价值）。设置 headers 参数为 True。 GrossLeverage：跟踪总杠杆（策略投资的程度）。 参数： 这些参数透明地传递给子分析器。\ntimeframe（默认：bt.TimeFrame.Days）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：1）：如果为 None，将使用系统中第一个数据的压缩。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nget_pf_items： 返回一个包含 4 个元素的元组，可用于进一步处理 pyfolio。\nreturns，positions，transactions，gross_leverage 由于这些对象旨在作为 pyfolio 的直接输入，因此此方法会本地导入 pandas，将内部 backtrader 结果转换为 pandas DataFrames，这是例如 pyfolio.create_full_tear_sheet 预期的输入。如果未安装 pandas，该方法将失败。\nLogReturnsRolling# class backtrader.analyzers.LogReturnsRolling()该分析器计算给定时间框架和压缩的滚动回报。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 data（默认：无）：跟踪的参考资产，而不是投资组合价值。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nPeriodStats# class backtrader.analyzers.PeriodStats()计算给定时间框架的基本统计数据。\n参数：\ntimeframe（默认：Years）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：1）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含以下键的字典：\naverage stddev positive negative nochange best worst 如果参数 zeroispos 设置为 True，则没有变化的周期将计为正数。\nReturns# class backtrader.analyzers.Returns()使用对数方法计算总回报、平均回报、复合回报和年化回报。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 tann（默认：无）：用于年化（归一化）回报的周期数： 天：252 周：52 月：12 年：1 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期\n时间点为键。返回的字典包含以下键：\nrtot：总复合回报 ravg：整个期间的平均回报（特定时间框架） rnorm：年化/归一化回报 rnorm100：以 100% 表示的年化/归一化回报 SharpeRatio# class backtrader.analyzers.SharpeRatio()该分析器使用风险资产（即利率）计算策略的夏普比率。\n参数：\ntimeframe（默认：TimeFrame.Years） compression（默认：1）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 riskfreerate（默认：0.01 -\u0026gt; 1%）：以年利率表示（见下文 convertrate）。 convertrate（默认：True）：将年利率转换为月、周或日利率。不支持子日转换。 factor（默认：无）：如果为 None，将从预定义表中选择年到所选时间框架的转换因子。天：252，周：52，月：12，年：1。否则将使用指定的值。 annualize（默认：False）：如果 convertrate 为 True，夏普比率将在所选时间框架内提供。在大多数情况下，夏普比率以年化形式提供。 stddev_sample（默认：False）：如果设置为 True，将在均值中减少分母 1 来计算标准差。这在计算标准差时使用，如果认为并非所有样本都用于计算。这被称为贝塞尔修正。 daysfactor（默认：无）：旧命名为因子。如果设置为除 None 之外的任何值，并且时间框架为 TimeFrame.Days，将假设这是旧代码并使用该值。 legacyannual（默认：False）：使用 AnnualReturn 分析器，顾名思义仅适用于年份。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含键 “sharperatio” 的字典，其中包含比率。\nSharpeRatio_A# class backtrader.analyzers.SharpeRatio_A()夏普比率的扩展，直接以年化形式返回夏普比率。\n更改的参数：\nannualize（默认：True） SQN# class backtrader.analyzers.SQN()SQN 或系统质量数。由 Van K. Tharp 定义，用于分类交易系统。\n1.6 - 1.9 低于平均水平 2.0 - 2.4 平均水平 2.5 - 2.9 良好 3.0 - 5.0 优秀 5.1 - 6.9 杰出 7.0 - 圣杯？\n公式：\nSquareRoot(NumberTrades) * Average(TradesProfit) / StdDev(TradesProfit)当交易数量 \u0026gt;= 30 时，sqn 值应被认为是可靠的。\nget_analysis： 返回一个包含键 “sqn” 和 “trades” 的字典（已考虑的交易数量）。\nTimeReturn# class backtrader.analyzers.TimeReturn()该分析器通过查看时间框架的起点和终点来计算回报。\n参数：\ntimeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 data（默认：无）：跟踪的参考资产，而不是投资组合价值。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nTradeAnalyzer# class backtrader.analyzers.TradeAnalyzer()提供已平仓交易的统计数据（还保持未平仓交易的计数）。\n总开仓/平仓交易 连胜/连败 当前/最长 总损益/平均损益 胜/负 计数/总损益/平均损益/最大损益 多/空 计数/总损益/平均损益/最大损益 胜/负 计数/总损益/平均损益/最大损益 注意： 分析器使用“自动”字典字段，这意味着如果没有执行交易，则不会生成统计数据。在这种情况下，get_analysis 返回的字典中将有一个单独的字段/子字段：\ndictname[‘total’][‘total’] 将具有值 0（该字段也可以使用点符号 dictname.total.total 访问）。 Transactions# class backtrader.analyzers.Transactions()该分析器报告系统中每个数据的交易情况。\n参数：\nheaders（默认：True）：在保存结果的字典中添加一个初始键，名称为数据的名称。 该分析器旨在便于与 pyfolio 集成，并从用于它的样本中获取标题名称：\n\u0026lsquo;date\u0026rsquo;, \u0026lsquo;amount\u0026rsquo;, \u0026lsquo;price\u0026rsquo;, \u0026lsquo;sid\u0026rsquo;, \u0026lsquo;symbol\u0026rsquo;, \u0026lsquo;value\u0026rsquo; get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。\nVWR# class backtrader.analyzers.VWR()可变性加权回报：使用对数回报的更好的夏普比率。\n别名：\nVariabilityWeightedReturn 参数：\ntimeframe（默认：无）：如果为 None，则整个回测期间的回报将被报告。 compression（默认：无）：仅用于子日时间框架，例如通过指定 \u0026ldquo;TimeFrame.Minutes\u0026rdquo; 和 60 作为压缩在每小时时间框架上工作。 tann（默认：无）：用于年化（归一化）平均回报的周期数。如果为 None，则使用标准 t 值，即： 天：252 周：52 月：12 年：1 tau（默认：2.0）：计算因子（见文献） sdev_max（默认：0.20）：最大标准差（见文献） fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。返回的字典包含以下键：\nvwr：可变性加权回报 "},{"id":58,"href":"/backtrader/docs/08-indicators/04-talib/","title":"TA-Lib","section":"Indicator","content":"TA-Lib# 即使backtrader已经提供了大量内置指标，并且开发一个指标主要是定义输入、输出并以自然方式编写公式，但有些人仍然希望使用TA-LIB。因为，指标X在TA-LIB库中存在，但在backtrader中不存在（作者很乐意接受请求），还有，TA-LIB的行为是众所周知的，人们信赖传统的事物。\n为了满足每个人的需求，提供了TA-LIB集成。\n需求# TA-LIB的Python封装 任何需要的依赖项（例如numpy） 安装详情在GitHub仓库中 使用TA-LIB# 与使用backtrader内置指标一样简单。以下是一个简单移动平均线的示例。首先是backtrader的示例：\nimport backtrader as bt class MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.sma = bt.indicators.SMA(self.data, period=self.p.period) ...接下来是TA-LIB的示例：\nimport backtrader as bt class MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.sma = bt.talib.SMA(self.data, timeperiod=self.p.period) ...注意，TA-LIB指标的参数由库本身定义，而不是backtrader。在这种情况下，TA-LIB中的SMA使用名为timeperiod的参数来定义操作窗口的大小。\n对于需要多个输入的指标，例如随机指标：\nimport backtrader as bt class MyStrategy(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 20),) def __init__(self): self.stoc = bt.talib.STOCH(self.data.high, self.data.low, self.data.close, fastk_period=14, slowk_period=3, slowd_period=3) ...注意，high、low和close分别传递。可以尝试传递open而不是low（或其他任何数据系列）进行实验。\nTA-LIB指标文档会自动解析并添加到backtrader文档中。你也可以查看TA-LIB的源代码/文档，或者执行以下操作：\nprint(bt.talib.SMA.__doc__)输出如下：\nSMA([input_arrays], [timeperiod=30]) Simple Moving Average (Overlap Studies) Inputs: price: (any ndarray) Parameters: timeperiod: 30 Outputs: real这提供了一些信息：\n期望的输入（忽略ndarray的注释，因为backtrader在后台进行转换） 哪些参数及其默认值 指标实际提供的输出线 移动平均线和MA_Type# 要选择特定的移动平均线，如bt.talib.STOCH，标准的TA-LIB MA_Type可以通过backtrader.talib.MA_Type访问。例如：\nimport backtrader as bt print(\u0026#39;SMA:\u0026#39;, bt.talib.MA_Type.SMA) print(\u0026#39;T3:\u0026#39;, bt.talib.MA_Type.T3)绘制TA-LIB指标# 与常规用法一样，绘制TA-LIB指标无需特殊操作。\n注意：\n输出蜡烛图的指标（所有寻找蜡烛图模式的指标）会生成二进制输出：0或100。为了避免在图表上添加子图，存在自动绘图转换，以在识别模式时将其绘制在数据上。\n示例和比较# 以下是一些比较TA-LIB指标输出与backtrader内置指标的示例。注意：\nTA-LIB指标在图上有一个TA_前缀。这是样例特意这样做以帮助用户区分。 如果两者结果相同，移动平均线会叠加在现有移动平均线上，无法单独查看，这样的测试是通过的。 所有样例包括CDLDOJI指标作为参考。\nKAMA（考夫曼移动平均线）# 这是第一个示例，因为这是样本直接比较的所有指标中唯一存在差异的：\n样本的初始值不同 在某个时间点，值会趋同，两个KAMA实现具有相同的行为。 分析TA-LIB源码后发现：\nTA-LIB的实现为KAMA的初始值做了一个非行业标准的选择。 源代码引用：这里使用昨天的价格作为前一个KAMA。 backtrader采用了通常的选择，例如Stockcharts：\nStockCharts上的KAMA 由于需要一个初始值来开始计算，第一个KAMA只是一个简单移动平均线。因此存在差异。此外：\nTA-LIB的KAMA实现不允许指定用于调整Kaufman定义的可缩放常数的快慢周期。 样本执行：\n$ ./talibtest.py --plot --ind kama 输出图像\nSMA# $ ./talibtest.py --plot --ind sma 输出图像\nEMA# $ ./talibtest.py --plot --ind ema 输出图像\n随机指标# $ ./talibtest.py --plot --ind stoc 输出图像\nRSI# $ ./talibtest.py --plot --ind rsi 输出图像\nMACD# $ ./talibtest.py --plot --ind macd 输出图像\n布林带# $ ./talibtest.py --plot --ind bollinger 输出图像\nAROON# 注意，TA-LIB选择先绘制下降线，并且颜色与backtrader内置指标相反。\n$ ./talibtest.py --plot --ind aroon 输出图像\nUltimate Oscillator# $ ./talibtest.py --plot --ind ultimate 输出图像\nTrix# $ ./talibtest.py --plot --ind trix 输出图像\nADXR# backtrader同时提供ADX和ADXR线。\n$ ./talibtest.py --plot --ind adxr 输出图像\nDEMA# $ ./talibtest.py --plot --ind dema 输出图像\nTEMA# $ ./talibtest.py --plot --ind tema 输出图像\nPPO# backtrader不仅提供PPO线，还提供更传统的MACD方法。\n$ ./talibtest.py --plot --ind ppo 输出图像\nWilliamsR# $ ./talibtest.py --plot --ind williamsr 输出图像\nROC# 所有指标应具有相同的形状，但跟踪动量或变化率有多种定义。\n$ ./talibtest.py --plot --ind roc 输出图像\n样本用法# $ ./talibtest.py --help usage: talibtest.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--ind {sma,ema,stoc,rsi,macd,bollinger,aroon,ultimate,trix,kama,adxr,dema,tema,ppo,williamsr,roc}] [--no-doji] [--use-next] [--plot [kwargs]] Sample for ta-lib optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to be read in (default: ../../datas/yhoo-1996-2015.txt) --fromdate FROMDATE Starting date in YYYY-MM-DD format (default: 2005-01-01) --todate TODATE Ending date in YYYY-MM-DD format (default: 2006-12-31) --ind {sma,ema,stoc,rsi,macd,bollinger,aroon,ultimate,trix,kama,adxr,dema,tema,ppo,williamsr,roc} Which indicator pair to show together (default: sma) --no-doji Remove Doji CandleStick pattern checker (default: False) --use-next Use next (step by step) instead of once (batch) (default: False) --plot [kwargs], -p [kwargs] Plot the read data applying any kwargs passed For example (escape the quotes if needed): --plot style=\u0026#34;candle\u0026#34; (to plot candles) (default: None)样本代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class TALibStrategy(bt.Strategy): params = ((\u0026#39;ind\u0026#39;, \u0026#39;sma\u0026#39;), (\u0026#39;doji\u0026#39;, True),) INDS = [\u0026#39;sma\u0026#39;, \u0026#39;ema\u0026#39;, \u0026#39;stoc\u0026#39;, \u0026#39;rsi\u0026#39;, \u0026#39;mac d\u0026#39;, \u0026#39;bollinger\u0026#39;, \u0026#39;aroon\u0026#39;, \u0026#39;ultimate\u0026#39;, \u0026#39;trix\u0026#39;, \u0026#39;kama\u0026#39;, \u0026#39;adxr\u0026#39;, \u0026#39;dema\u0026#39;, \u0026#39;ppo\u0026#39;, \u0026#39;tema\u0026#39;, \u0026#39;roc\u0026#39;, \u0026#39;williamsr\u0026#39;] def __init__(self): if self.p.doji: bt.talib.CDLDOJI(self.data.open, self.data.high, self.data.low, self.data.close) if self.p.ind == \u0026#39;sma\u0026#39;: bt.talib.SMA(self.data.close, timeperiod=25, plotname=\u0026#39;TA_SMA\u0026#39;) bt.indicators.SMA(self.data, period=25) elif self.p.ind == \u0026#39;ema\u0026#39;: bt.talib.EMA(timeperiod=25, plotname=\u0026#39;TA_SMA\u0026#39;) bt.indicators.EMA(period=25) elif self.p.ind == \u0026#39;stoc\u0026#39;: bt.talib.STOCH(self.data.high, self.data.low, self.data.close, fastk_period=14, slowk_period=3, slowd_period=3, plotname=\u0026#39;TA_STOCH\u0026#39;) bt.indicators.Stochastic(self.data) elif self.p.ind == \u0026#39;macd\u0026#39;: bt.talib.MACD(self.data, plotname=\u0026#39;TA_MACD\u0026#39;) bt.indicators.MACD(self.data) bt.indicators.MACDHisto(self.data) elif self.p.ind == \u0026#39;bollinger\u0026#39;: bt.talib.BBANDS(self.data, timeperiod=25, plotname=\u0026#39;TA_BBANDS\u0026#39;) bt.indicators.BollingerBands(self.data, period=25) elif self.p.ind == \u0026#39;rsi\u0026#39;: bt.talib.RSI(self.data, plotname=\u0026#39;TA_RSI\u0026#39;) bt.indicators.RSI(self.data) elif self.p.ind == \u0026#39;aroon\u0026#39;: bt.talib.AROON(self.data.high, self.data.low, plotname=\u0026#39;TA_AROON\u0026#39;) bt.indicators.AroonIndicator(self.data) elif self.p.ind == \u0026#39;ultimate\u0026#39;: bt.talib.ULTOSC(self.data.high, self.data.low, self.data.close, plotname=\u0026#39;TA_ULTOSC\u0026#39;) bt.indicators.UltimateOscillator(self.data) elif self.p.ind == \u0026#39;trix\u0026#39;: bt.talib.TRIX(self.data, timeperiod=25, plotname=\u0026#39;TA_TRIX\u0026#39;) bt.indicators.Trix(self.data, period=25) elif self.p.ind == \u0026#39;adxr\u0026#39;: bt.talib.ADXR(self.data.high, self.data.low, self.data.close, plotname=\u0026#39;TA_ADXR\u0026#39;) bt.indicators.ADXR(self.data) elif self.p.ind == \u0026#39;kama\u0026#39;: bt.talib.KAMA(self.data, timeperiod=25, plotname=\u0026#39;TA_KAMA\u0026#39;) bt.indicators.KAMA(self.data, period=25) elif self.p.ind == \u0026#39;dema\u0026#39;: bt.talib.DEMA(self.data, timeperiod=25, plotname=\u0026#39;TA_DEMA\u0026#39;) bt.indicators.DEMA(self.data, period=25) elif self.p.ind == \u0026#39;ppo\u0026#39;: bt.talib.PPO(self.data, plotname=\u0026#39;TA_PPO\u0026#39;) bt.indicators.PPO(self.data, _movav=bt.indicators.SMA) elif self.p.ind == \u0026#39;tema\u0026#39;: bt.talib.TEMA(self.data, timeperiod=25, plotname=\u0026#39;TA_TEMA\u0026#39;) bt.indicators.TEMA(self.data, period=25) elif self.p.ind == \u0026#39;roc\u0026#39;: bt.talib.ROC(self.data, timeperiod=12, plotname=\u0026#39;TA_ROC\u0026#39;) bt.talib.ROCP(self.data, timeperiod=12, plotname=\u0026#39;TA_ROCP\u0026#39;) bt.talib.ROCR(self.data, timeperiod=12, plotname=\u0026#39;TA_ROCR\u0026#39;) bt.talib.ROCR100(self.data, timeperiod=12, plotname=\u0026#39;TA_ROCR100\u0026#39;) bt.indicators.ROC(self.data, period=12) bt.indicators.Momentum(self.data, period=12) bt.indicators.MomentumOscillator(self.data, period=12) elif self.p.ind == \u0026#39;williamsr\u0026#39;: bt.talib.WILLR(self.data.high, self.data.low, self.data.close, plotname=\u0026#39;TA_WILLR\u0026#39;) bt.indicators.WilliamsR(self.data) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() dkwargs = dict() if args.fromdate: fromdate = datetime.datetime.strptime(args.fromdate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;fromdate\u0026#39;] = fromdate if args.todate: todate = datetime.datetime.strptime(args.todate, \u0026#39;%Y-%m-%d\u0026#39;) dkwargs[\u0026#39;todate\u0026#39;] = todate data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **dkwargs) cerebro.adddata(data0) cerebro.addstrategy(TALibStrategy, ind=args.ind, doji=not args.no_doji) cerebro.run(runcone=not args.use_next, stdstats=False) if args.plot: pkwargs = dict(style=\u0026#39;candle\u0026#39;) if args.plot is not True: # evals to True but is not True npkwargs = eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;) # args were passed pkwargs.update(npkwargs) cerebro.plot(**pkwargs) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample for sizer\u0026#39;) parser.add_argument(\u0026#39;--data0\u0026#39;, required=False, default=\u0026#39;../../datas/yhoo-1996-2015.txt\u0026#39;, help=\u0026#39;Data to be read in\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;2005-01-01\u0026#39;, help=\u0026#39;Starting date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;2006-12-31\u0026#39;, help=\u0026#39;Ending date in YYYY-MM-DD format\u0026#39;) parser.add_argument(\u0026#39;--ind\u0026#39;, required=False, action=\u0026#39;store\u0026#39;, default=TALibStrategy.INDS[0], choices=TALibStrategy.INDS, help=(\u0026#39;Which indicator pair to show together\u0026#39;)) parser.add_argument(\u0026#39;--no-doji\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Remove Doji CandleStick pattern checker\u0026#39;)) parser.add_argument(\u0026#39;--use-next\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=(\u0026#39;Use next (step by step) \u0026#39; \u0026#39;instead of once (batch)\u0026#39;)) # Plot options parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, nargs=\u0026#39;?\u0026#39;, required=False, metavar=\u0026#39;kwargs\u0026#39;, const=True, help=(\u0026#39;Plot the read data applying any kwargs passed\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39;For example (escape the quotes if needed):\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39; --plot style=\u0026#34;candle\u0026#34; (to plot candles)\\n\u0026#39;)) if pargs is not None: return parser.parse_args(pargs) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()这样，您就可以在backtrader中使用TA-LIB的指标，并根据需要进行绘图和比较。\n"},{"id":59,"href":"/backtrader/docs/05-cerebro/04-optimization-improvements/","title":"优化改进","section":"Cerebro","content":"优化改进# Backtrader 通过引入两个新的 Cerebro 参数，优化了在多进程环境下管理数据源和结果的方式。\n参数说明：\n参数名 默认值 描述 optdatas True 如果为True并进行优化（系统可以预加载并使用runonce），则数据预加载将仅在主进程中进行一次，以节省时间和资源。 optreturn True 如果为True，优化结果将不是完整的策略对象（包括所有数据、指标、观察者等），而是带有以下属性的对象（与策略中相同）：- params（或p）：策略执行时的参数- analyzers：策略执行的分析器 通常，我们只需要查看策略使用的参数的最终表现（如收益率）。如想查看运行过程中的详细数据（如每个时间点的指标值），请关闭此选项。\n数据源管理# 在优化场景中，Cerebro 参数可能的组合是：\npreload=True（默认），数据源将在运行任何回测代码前完成预加载： runonce=True（默认），指标将在紧密的for循环中批量计算，而不是逐步计算。 如果两个条件都为True且optdatas=True，则数据源将在生成新子进程之前在主进程中预加载（这些子进程负责执行回测）\n结果管理# 在优化场景中，当评估每个策略运行的不同参数时，最重要的两个因素是：\nstrategy.params（或strategy.p）\n回测使用的实际参数集\nstrategy.analyzers\n提供策略实际表现评估的对象。例如：SharpeRatio_A（年化夏普比率）\n当optreturn=True时，不会返回完整的策略实例，而是创建占位符对象，这些对象携带上述两个属性以进行评估。\n这避免了传回大量生成的数据，例如回测期间指标生成的值。\n如果希望返回完整的策略对象，只需在Cerebro实例化或进行cerebro.run时设置optreturn=False。\n一些测试运行# backtrader源代码中的优化示例已扩展，添加了对optdatas和optreturn的控制（实际上是禁用它们）。\n单核心运行# 作为参考，当将CPU数量限制为1且不使用多进程模块时会发生什么：\n$ ./optimization.py --maxcpus 1 ================================================== ************************************************** -------------------------------------------------- OrderedDict([(u\u0026#39;smaperiod\u0026#39;, 10), (u\u0026#39;macdperiod1\u0026#39;, 12), (u\u0026#39;macdperiod2\u0026#39;, 26), (u\u0026#39;macdperiod3\u0026#39;, 9)]) ************************************************** -------------------------------------------------- OrderedDict([(u\u0026#39;smaperiod\u0026#39;, 10), (u\u0026#39;macdperiod1\u0026#39;, 13), (u\u0026#39;macdperiod2\u0026#39;, 26), (u\u0026#39;macdperiod3\u0026#39;, 9)]) ... ... OrderedDict([(u\u0026#39;smaperiod\u0026#39;, 29), (u\u0026#39;macdperiod1\u0026#39;, 19), (u\u0026#39;macdperiod2\u0026#39;, 29), (u\u0026#39;macdperiod3\u0026#39;, 14)]) ================================================== Time used: 184.922727833多核心运行# 在不限制CPU数量的情况下，Python多进程模块将尝试使用所有CPU。禁用optdatas和optreturn\noptdatas和optreturn都启用\n默认行为：\n$ ./optimization.py ... ... ... ================================================== Time used: 56.5889185394通过多核和数据源及结果改进，总时间从184.92秒减少到56.58秒。\n请注意，示例使用了252条数据，并且指标仅生成长度为252点的值。这只是一个例子。\n真正的问题是这种改进有多少是由于新行为。\noptreturn禁用：将完整的策略对象传回调用者：\n$ ./optimization.py --no-optreturn ... ... ... ================================================== Time used: 67.056914007执行时间增加了18.50%（或15.62%的速度提升）。\noptdatas禁用：每个子进程被迫加载其自己的数据源值：\n$ ./optimization.py --no-optdatas ... ... ... ================================================== Time used: 72.7238112637执行时间增加了28.52%（或22.19%的速度提升）。\n两者都禁用：仍然使用多核，但使用旧的未改进行为：\n$ ./optimization.py --no-optdatas --no-optreturn ... ... ... ================================================== Time used: 83.6246643786执行时间增加了47.79%（或32.34%的速度提升）。\n这表明使用多个核心是时间改进的主要贡献因素。\n注意：这些执行是在配备i7-4710HQ（4核/8逻辑）和16 GB RAM的笔记本电脑上进行的，操作系统为Windows 10 64位。在其他条件下可能会有所不同。\n总结# 在优化过程中时间减少的最大因素是使用多个核心。\n使用optdatas和optreturn的示例运行显示了大约22.19%和15.62%的速度提升（在测试中两者一起提高了32.34%）。\n示例使用# $ ./optimization.py --help usage: optimization.py [-h] [--data DATA] [--fromdate FROMDATE] [--todate TODATE] [--maxcpus MAXCPUS] [--no-runonce] [--exactbars EXACTBARS] [--no-optdatas] [--no-optreturn] [--ma_low MA_LOW] [--ma_high MA_HIGH] [--m1_low M1_LOW] [--m1_high M1_HIGH] [--m2_low M2_LOW] [--m2_high M2_HIGH] [--m3_low M3_LOW] [--m3_high M3_HIGH] Optimization optional arguments: -h, --help show this help message and exit --data DATA, -d DATA data to add to the system --fromdate FROMDATE, -f FROMDATE Starting date in YYYY-MM-DD format --todate TODATE, -t TODATE Starting date in YYYY-MM-DD format --maxcpus MAXCPUS, -m MAXCPUS Number of CPUs to use in the optimization - 0 (default): use all available CPUs - 1 -\u0026gt; n: use as many as specified --no-runonce Run in next mode --exactbars EXACTBARS Use the specified exactbars still compatible with preload 0 No memory savings -1 Moderate memory savings -2 Less moderate memory savings --no-optdatas Do not optimize data preloading in optimization --no-optreturn Do not optimize the returned values to save time --ma_low MA_LOW SMA range low to optimize --ma_high MA_HIGH SMA range high to optimize --m1_low M1_LOW MACD Fast MA range low to optimize --m1_high M1_HIGH MACD Fast MA range high to optimize --m2_low M2_LOW MACD Slow MA range low to optimize --m2_high M2_HIGH MACD Slow MA range high to optimize --m3_low M3_LOW MACD Signal range low to optimize --m3_high M3_HIGH MACD Signal range high to optimize (C) 2015-2024 Daniel Rodriguez"},{"id":60,"href":"/backtrader/docs/11-commission-schemes/04-credit-interests/","title":"利息","section":"Commission","content":"利息# 在某些情况下，由于资产操作包含利率，实际经纪商的现金金额可能会减少。例如：\n股票的卖空 ETF 的多头和空头操作 该费用直接从经纪账户的现金余额中扣除。但它仍然可以看作是佣金方案的一部分。因此，它已在 backtrader 中进行了建模。\nCommInfoBase 类（以及主要的 CommissionInfo 接口对象）已扩展了：\n两个新参数，用于设置利率并确定是否仅应用于空头还是同时应用于多头和空头 参数# interest（默认值：0.0）\n如果非零，这是持有卖空头寸时收取的年度利息。这主要用于股票卖空。\n应用的默认公式：days * price * size * (interest / 365)\n必须以绝对值指定：0.05 -\u0026gt; 5%\n注意：可以通过重写方法 get_credit_interest 来更改行为\ninterest_long（默认值：False）\n一些产品如 ETF，在多头和空头头寸上都收取利息。如果为 True 并且 interest 非零，则多头和空头方向都将收取利息。\n公式# 默认实现将使用以下公式：\ndays * abs(size) * price * (interest / 365)其中：\ndays：自头寸开立或上次利息计算以来经过的天数 重写公式# 要更改公式，需要子类化 CommissionInfo。需要重写的方法是：\ndef _get_credit_interest(self, size, price, days, dt0, dt1): \u0026#39;\u0026#39;\u0026#39; 此方法返回经纪商收取的利息成本。 对于 ``size \u0026gt; 0`` 的情况，仅在类参数 ``interest_long`` 为 ``True`` 时调用此方法。 计算利率的公式为： 公式：``days * price * abs(size) * (interest / 365)`` 参数： - ``data``：收取利息的数据源 - ``size``：当前头寸大小。\u0026gt; 0 表示多头头寸，\u0026lt; 0 表示空头头寸（此参数不会为 ``0``） - ``price``：当前头寸价格 - ``days``：自上次利息计算以来经过的天数（这是（dt0 - dt1）.days） - ``dt0``：当前日期时间（datetime.datetime） - ``dt1``：上次计算日期时间（datetime.datetime） ``dt0`` 和 ``dt1`` 在默认实现中未使用，并作为重写方法的额外输入提供 \u0026#39;\u0026#39;\u0026#39;可能经纪商在计算利率时不考虑周末或银行假日。在这种情况下，子类如下：\nimport backtrader as bt class MyCommissionInfo(bt.CommInfo): def _get_credit_interest(self, size, price, days, dt0, dt1): return 1.0 * abs(size) * price * (self.p.interest / 365.0)在这种情况下，公式中：\ndays 被替换为 1.0 因为如果周末/银行假日不算数，则下一次计算总是在上一次计算后的一个交易日进行。 "},{"id":61,"href":"/backtrader/docs/10-broker/04-volume-filling-filler/","title":"填充器","section":"Broker","content":"填充器# Backtrader 的经纪模拟在订单执行时有一个默认策略：忽略交易量。这是基于两个前提：\n交易在流动性足够高的市场中，可以一次性完全吸收买/卖订单 实际的交易量匹配需要真实的市场环境 一个简单的例子是“立即成交或取消”（Fill or Kill）订单。即使细化到每一笔交易，并且有足够的交易量来完成订单，Backtrader的经纪模拟也无法知道市场中有多少其他参与者来判断这样的订单是否会被匹配以遵循“立即成交”部分，或者订单是否应该被取消。\n但是经纪模拟可以接受交易量填充器（Volume Fillers），它们决定在给定时间点应该使用多少交易量来匹配订单。\n填充器签名# 在Backtrader生态系统中，填充器可以是任何符合以下签名的可调用对象：\ncallable(order, price, ago)其中：\norder 是即将执行的订单，该对象提供对目标数据对象的访问，创建的大小/价格、执行的价格/大小/剩余大小和其他详细信息 price 是订单执行的价格 ago 是数据在订单中的索引，用于查找交易量和价格元素 在几乎所有情况下，这将是0（当前时间点），但在某些特殊情况下（例如Close订单），这可能是-1。\n例如，访问bar交易量可以这样做：\nbarvolume = order.data.volume[ago]可调用对象可以是一个函数，或例如支持__call__方法的类的实例，例如：\nclass MyFiller(object): def __call__(self, order, price, ago): pass将填充器添加到经纪模拟\n最直接的方法是使用set_filler：\nimport backtrader as bt cerebro = Cerebro() cerebro.broker.set_filler(bt.broker.fillers.FixedSize())第二种选择是完全替换经纪模拟，这可能仅适用于重写了部分功能的BrokerBack子类：\nimport backtrader as bt cerebro = Cerebro() filler = bt.broker.fillers.FixedSize() newbroker = bt.broker.BrokerBack(filler=filler) cerebro.broker = newbroker示例# Backtrader的源代码中包含一个名为volumefilling的示例，它允许测试一些集成的填充器（最初是全部）。\n参考# class backtrader.fillers.FixedSize()使用条形图中某个百分比的交易量返回给定订单的执行大小。\n该百分比通过参数perc设置。\n参数：\nsize（默认：None）最大执行大小。如果执行时间的条形图实际交易量小于该大小，则条形图的实际交易量也是一个限制。\n如果该参数的值评估为False，则将使用条形图的全部交易量来匹配订单。\nclass backtrader.fillers.FixedBarPerc()使用条形图中某个百分比的交易量返回给定订单的执行大小。\n该百分比通过参数perc设置。\n参数：\nperc（默认：100.0）（有效值：0.0 - 100.0）\n用于执行订单的条形图交易量百分比\nclass backtrader.fillers.BarPointPerc()返回给定订单的执行大小。交易量将在高-低范围内均匀分布，使用minmov进行分区。\n对于给定价格分配的交易量，将使用perc百分比。\n参数：\nminmov（默认：0.01）\n最小价格变动。用于分区高-低范围，以按比例分配可能价格之间的交易量\nperc（默认：100.0）（有效值：0.0 - 100.0）\n用于订单执行价格匹配的分配交易量百分比\n"},{"id":62,"href":"/backtrader/docs/06-datafeed/04-datafeed-development-general/","title":"开发 Binary 数据源","section":"DataFeed","content":"开发 Binary 据源# 注意：示例中使用的 Binary 文件 goog.fd 属于 VisualChart，不能与 backtrader 一起分发。\n对于那些有兴趣直接使用 Binary 文件的人，可以免费下载 VisualChart。\nCSV 数据源开发展示了如何添加新的基于 CSV 的数据源。现有的基类 CSVDataBase 提供了框架，减轻了子类的大部分工作，在大多数情况下，它们可以简单地执行：\ndef _loadline(self, linetokens): # 在这里解析 linetokens 并将它们放入 self.lines.close, self.lines.high 等中 return True # 如果数据已解析，否则返回 False基类负责参数、初始化、打开文件、读取行、将行拆分为标记以及其他事项，例如跳过不符合日期范围（fromdate，todate）的行，这些行可能由最终用户定义。\n开发非 CSV 数据源遵循相同的模式，而无需深入到已拆分的行标记。\n需要做的事情：# 从 backtrader.feed.DataBase 派生 添加任何需要的参数 如果需要初始化，重写 __init__(self) 和/或 start(self) 如果需要清理代码，重写 stop(self) 工作发生在必须始终重写的方法 _load(self) 内 让我们看看 backtrader.feed.DataBase 已经提供的参数：\nfrom backtrader.utils.py3 import with_metaclass ... ... class DataBase(with_metaclass(MetaDataBase, dataseries.OHLCDateTime)): params = ((\u0026#39;dataname\u0026#39;, None), (\u0026#39;fromdate\u0026#39;, datetime.datetime.min), (\u0026#39;todate\u0026#39;, datetime.datetime.max), (\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;), (\u0026#39;compression\u0026#39;, 1), (\u0026#39;timeframe\u0026#39;, TimeFrame.Days), (\u0026#39;sessionend\u0026#39;, None))这些参数具有以下含义：\ndataname：允许数据源识别如何获取数据。在 CSVDataBase 的情况下，此参数表示文件路径或已存在的类似文件的对象。 fromdate 和 todate：定义传递给策略的日期范围。数据源提供的任何超出此范围的值都将被忽略。 name：用于绘图目的的装饰名称。 timeframe：表示时间工作参考。潜在值：Ticks, Seconds, Minutes, Days, Weeks, Months 和 Years。 compression（默认值：1）：每条实际条的条数。信息性。仅在数据重采样/重放中有效。 sessionend：如果传递（datetime.time 对象），将添加到数据源日期时间行，允许识别会话结束。 示例二进制数据源# backtrader 已经定义了一个 CSV 数据源（VChartCSVData）用于 VisualChart 的导出数据，但也可以直接读取二进制数据文件。\n让我们来实现（完整的数据源代码可以在文末找到）。\n初始化# 二进制 VisualChart 数据文件可以包含每日数据（.fd 扩展名）或日内数据（.min 扩展名）。这里使用参数 timeframe 来区分读取的文件类型。\n在 __init__ 中，设置每种类型不同的常量。\ndef __init__(self): super(VChartData, self).__init__() # 使用 informative \u0026#34;timeframe\u0026#34; 参数来理解传递的 \u0026#34;dataname\u0026#34; # 是指日内还是每日数据源 if self.p.timeframe \u0026gt;= TimeFrame.Days: self.barsize = 28 self.dtsize = 1 self.barfmt = \u0026#39;IffffII\u0026#39; else: self.dtsize = 2 self.barsize = 32 self.barfmt = \u0026#39;IIffffII\u0026#39;开始# 数据源将在回测开始时启动（在优化期间实际上可以启动多次）。\n在 start 方法中，除非传递了类似文件的对象，否则二进制文件会被打开。\ndef start(self): # 数据源必须启动...打开文件（或查看是否已打开） self.f = None if hasattr(self.p.dataname, \u0026#39;read\u0026#39;): # 传入了文件（例如：来自 GUI） self.f = self.p.dataname else: # 让异常传播 self.f = open(self.p.dataname, \u0026#39;rb\u0026#39;)停止# 回测结束时调用。\n如果文件已打开，则将其关闭。\ndef stop(self): # 如果有文件，关闭它 if self.f is not None: self.f.close() self.f = None实际加载# 实际工作在 _load 中完成。调用以加载下一组数据，在这种情况下是下一个：datetime、open、high、low、close、volume、openinterest。在 backtrader 中，“实际”时刻对应于索引 0。\n将从打开的文件中读取一些字节（由 __init__ 中设置的常量确定），使用 struct 模块解析，如果需要进一步处理（如日期和时间的 divmod 操作），并存储在数据源的行中：datetime、open、high、low、close、volume、openinterest。\n如果无法从文件中读取数据，则假定已达到文件末尾（EOF）\n返回 False 以指示没有更多数据可用\n如果数据已加载并解析：\n返回 True 以指示数据集加载成功\ndef _load(self): if self.f is None: # 如果没有文件...无法解析 return False # 读取所需数量的二进制数据 bardata = self.f.read(self.barsize) if not bardata: # 如果没有读取数据...游戏结束返回 \u0026#34;False\u0026#34; return False # 使用 struct 解析数据 bdata = struct.unpack(self.barfmt, bardata) # 年份存储为每年 500 天 y, md = divmod(bdata[0], 500) # 月份存储为每月 32 天 m, d = divmod(md, 32) # 将 y, m, d 放入 datetime dt = datetime.datetime(y, m, d) if self.dtsize \u0026gt; 1: # 分钟条 # 每日时间以秒为单位存储 hhmm, ss = divmod(bdata[1], 60) hh, mm = divmod(hhmm, 60) # 将时间添加到现有的 datetime dt = dt.replace(hour=hh, minute=mm, second=ss) self.lines.datetime[0] = date2num(dt) # 获取解析的数据的其余部分 o, h, l, c, v, oi = bdata[self.dtsize:] self.lines.open[0] = o self.lines.high[0] = h self.lines.low[0] = l self.lines.close[0] = c self.lines.volume[0] = v self.lines.openinterest[0] = oi # 返回成功 return True其他二进制格式# 同样的模型可以应用于任何其他二进制源：\n数据库 分层数据存储 在线来源 步骤再次说明：\n__init__ -\u0026gt; 实例的任何初始化代码，仅一次 start -\u0026gt; 回测开始时（如果将进行优化则会多次运行） stop -\u0026gt; 清理，例如关闭数据库连接或打开的套接字 _load -\u0026gt; 查询数据库或在线源以获取下一组数据并将其加载到对象的行中。标准字段为：datetime、open、high、low、close、volume、openinterest VChartData 测试# VChartData 从本地 .fd 文件加载 2006 年 Google 的数据。\n仅涉及加载数据，因此不需要策略的子类。\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import datetime import backtrader as bt from vchart import VChartData if __name__ == \u0026#39;__main__\u0026#39;: # 创建 cerebro 实体 cerebro = bt.Cerebro(stdstats=False) # 添加策略 cerebro.addstrategy(bt.Strategy) ########################################################################### # 注意： # goog.fd 文件属于 VisualChart，不能与 backtrader 一起分发 # # VisualChart 可从 www.visualchart.com 下载 ########################################################################### # 创建数据源 datapath = \u0026#39;../../datas/goog.fd\u0026#39; data = VChartData( dataname=datapath, fromdate=datetime.datetime(2006, 1, 1), todate=datetime.datetime(2006, 12, 31), timeframe=bt.TimeFrame.Days ) # 将数据源添加到 Cerebro cerebro.adddata(data) # 运行所有内容 cerebro.run() # 绘制结果 cerebro.plot(style=\u0026#39;bar\u0026#39;)VChartData 完整代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import datetime import struct from backtrader.feed import DataBase from backtrader import date2num from backtrader import TimeFrame class VChartData(DataBase): def __init__(self): super(VChartData, self).__init__() # 使用 informative \u0026#34;timeframe\u0026#34; 参数来理解传递的 \u0026#34;dataname\u0026#34; # 是指日内还是每日数据源 if self.p.timeframe \u0026gt;= TimeFrame.Days: self.barsize = 28 self.dtsize = 1 self.barfmt = \u0026#39;IffffII\u0026#39; else: self.dtsize = 2 self.barsize = 32 self.barfmt = \u0026#39;IIffffII\u0026#39; def start(self): # 数据源必须启动...打开文件（或查看是否已打开） self.f = None if hasattr(self.p.dataname, \u0026#39;read\u0026#39;): # 传入了文件（例如：来自 GUI） self.f = self.p.dataname else: # 让异常传播 self.f = open(self.p.dataname, \u0026#39;rb\u0026#39;) def stop(self): # 如果有文件，关闭它 if self.f is not None: self.f.close() self.f = None def _load(self): if self.f is None: # 如果没有文件...无法解析 return False # 读取所需数量的二进制数据 bardata = self.f.read(self.barsize) if not bardata: # 如果没有读取数据...游戏结束返回 \u0026#34;False\u0026#34; return False # 使用 struct 解析数据 bdata = struct.unpack(self.barfmt, bardata) # 年份存储为每年 500 天 y, md = divmod(bdata[0], 500) # 月份存储为每月 32 天 m, d = divmod(md, 32) # 将 y, m, d 放入 datetime dt = datetime.datetime(y, m, d) if self.dtsize \u0026gt; 1: # 分钟条 # 每日时间以秒为单位存储 hhmm, ss = divmod(bdata[1], 60) hh, mm = divmod(hhmm, 60) # 将时间添加到现有的 datetime dt = dt.replace(hour=hh, minute=mm, second=ss) self.lines.datetime[0] = date2num(dt) # 获取解析的数据的其余部分 o, h, l, c, v, oi = bdata[self.dtsize:] self.lines.open[0] = o self.lines.high[0] = h self.lines.low[0] = l self.lines.close[0] = c self.lines.volume[0] = v self.lines.openinterest[0] = oi # 返回成功 return True"},{"id":63,"href":"/backtrader/docs/19-articles/04-beating-the-random-entry/","title":"打败随机入场","section":"官方文章","content":"打败随机入场\n最近，reddit/r/algotrading 上有一些讨论，关于是否能够成功复制已发布的算法交易策略。首先，我复现了130多篇关于“预测股市”的研究论文，从头开始编写了代码，并记录了结果。以下是我学到的一些东西：\n因为之前的帖子已被删除，下面是快速总结：\n策略无效\n如果作者声称某个策略因阿尔法衰退而失效，那么这些测试都是在过去的数据上运行的，但它们仍然无效。 结论：这些策略要么是过拟合，要么是 p-hacking，或者只是微小的阿尔法，但这些阿尔法由于交易佣金的存在，已经被摧毁。 Artem Kaznatcheev 在《算法交易中的复现危机寓言》中写了对复现问题的描述，接着写了关于过拟合的文章。\n前两篇文章主要是理论性的（即使第一篇提到实现了130个策略），而《过拟合》则提供了实际的代码。\n在这么多讨论中，如何尝试复现一些已发布的策略而不是论文，采用像《过拟合》那样的实际方法呢？例如，出版在一本知名书籍中的策略。\n目标：“打败随机入场”。这是这本书第三部分第八章中的一节：\n《Amazon - 交易你的财务自由之路》\nVan Tharp Institute - 《交易你的财务自由之路》\n该书提供了一个结构化的算法交易方法，特别强调了：仓位大小和仓位管理（即：何时退出交易）。这些要远比大多数人认为最重要的入场设置更为关键。\n在第八章中，Van K. Tharp 与 Tom Basso 交谈时提到：“从你说的来看，听起来只要你有好的退出方式，并且聪明地调整仓位大小，似乎你可以通过随机入场来持续赚钱。” Tom Basso 回应说，他可能确实可以做到。\n规则：\n基于硬币投掷的入场 始终在市场中——多头或空头 一旦退出信号给出，立即重新进入 市场波动性由10天的平均真实波幅指数（EMA ATR）决定 跟踪止损，距离收盘价3倍波动性 止损只能朝着交易方向移动 固定仓位（1个合约）或1%风险模型（见书第12章） 结果：\n测试10个市场 固定仓位：80%的时间获利 1%风险模型：100%的时间获利 可靠性：38%（获胜交易的百分比） 缺失部分：\n测试的市场 测试的时间段 如果“始终在市场中”意味着“今天”关闭交易并在“明天”重新进入，或者意味着同时发出关闭/重新开仓的订单，这一点实际上最容易克服。\n对于最后两项，书中提到谈话发生在1991年，并且使用的是期货。为了公平起见，将使用1991年前的期货数据。也假设使用1天的价格条形图，考虑到提到的10天指数平滑移动平均（EMA）。\n最明显的问题似乎是如何正确实现算法，但在这种情况下，书籍很好地描述了简单算法及其结果。接下来，我们总结一下第12章中的“百分比风险模型”（书中称为“模型3”）。\n最大亏损：限制为账户总值的x%（即：百分比风险）\n每合约风险：根据给定的算法，风险为初始止损距离（波动性的3倍）乘以期货的乘数\n合约数量：最大亏损 / 每合约风险\n复现细节# 数据\n将使用1985至1990年的CL（原油）期货数据（即：6年完整数据）。该合约的规格如下：\n每点的最小变动：0.01（即：每点100个tick） 每个tick的费用：10美元 因此，乘数为1000美元/点（100 ticks/点 x 10美元/tick = 1000美元） 佣金\n每个合约每次交易收取2.00货币单位（类似IB的收费方式）\n一些实现细节\n硬币投掷被建模为一个指示器，以便清晰地可视化投掷的发生地点（以及如果多个入场方向相同，这符合随机性预期）\n为了更好地可视化止损以及它如何移动，止损价格计算和逻辑也嵌入到一个指示器中。请注意，止损计算逻辑有两个不同的阶段：\n当交易开始时，止损价格必须设置在与收盘价的给定距离，并与之前的止损价格无关 当交易进行时，止损价格会在可能的情况下调整，以跟随趋势。 图表显示\n代码会生成两种类型的图表：\n单次测试运行图表（\u0026ndash;plot选项）。通常在运行单次迭代（\u0026ndash;iterations 1）时使用它最为合适。 散点图，显示运行的盈亏情况。 样本#1\n测试运行图表：\n**** Iteration: 1 -- PNL: 10482.00 -- Trades 49 - Won 22 - %_Won: 0.45 **** Summary of Runs -- Total : 1 -- Won : 1 -- % Won : 1.00 **** Summary of Trades -- Total : 49 -- Total Won : 22 -- % Total Won : 0.45样本#2： 100次使用1%风险模型的测试运行，10次迭代和散点图\n**** Iteration: 1 -- PNL: -18218.00 -- Trades 60 - Won 24 - %_Won: 0.40 **** Iteration: 2 ... **** Iteration: 100 -- PNL: 111366.00 -- Trades 50 - Won 26 - %_Won: 0.52 **** Summary of Runs -- Total : 100 -- Won : 50 -- % Won : 0.50 **** Summary of Trades -- Total : 5504 -- Total Won : 2284 -- % Total Won : 0.41测试运行混合\n对10次测试运行进行了100次迭代，混合了以下变量：\n固定仓位为1，或使用1%的百分比风险模型 在同一根K线内执行入场/退出，或在连续K线内执行 结果总结\n平均而言，49%的测试运行是盈利的。固定仓位的盈利率接近50%，而百分比风险模型的盈利率波动较大，某些测试运行的盈利率最低为39%，最高为65%。 平均来说，39%的交易是盈利的（波动较小）。 回顾书中的内容：\n固定仓位模型，80%的盈利运行 1%风险模型，100%的盈利运行 38%的盈利交易 因此，似乎只有最后一个项目得到了复现。\n结论\n正如 Artem Kaznatcheev 所指出的，复现危机可能是由于以下原因：\n使用了错误的数据集 没有正确实现算法 或者原始实现可能没有遵循自己的规则，或者并非所有细节都已经公开。 注意\n无论如何，我个人仍然推荐阅读这本书。未能成功复现特定案例并不意味着这本书不好，书中展示了算法交易的实际方法。\n完整脚本\n享受吧！\n代码也可以在以下链接找到：GitHub Gist\n"},{"id":64,"href":"/backtrader/docs/04-concepts/","title":"核心概念","section":"介绍","content":"概念# 本节将介绍 backtrader 的一些核心概念，以求助我们更轻松地使用 backtrader。\n"},{"id":65,"href":"/backtrader/docs/03-quickstart/04-first-strategy/","title":"第一个策略","section":"快速开始","content":"第一个策略# 本节我们将学习如何开发策略。\n第一个策略不涉及交易，我们将通过它打印每一天（bar）的 \u0026ldquo;收盘价（Close）\u0026rdquo; 。\n策略类（Strategy）继承自 bt.Strategy。\nclass TestStrategy(bt.Strategy): def __init__(self): pass def next(self): pass它最重要的两个方法是 __init__（策略初始化）和 next（每个 OHLC，即bar，执行一次该方法）。\nclass TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0])如上代码中的 self.datas[0].close 访问的就是 cerebro.broker.adddata 方法添加的第一个数据源 DataFeed。\n数据列表（self.datas）是一个标准的Python列表，如添加多个数据源，数据按插入顺序存储。列表中的第一个数据项self.datas[0]是默认交易数据，用于同步所有策略元素（它作为系统时钟）。\nself.datas 的列表元素 data 底层类是 DataSeries，它有别名访问众所周知的 OHLC（开盘、高、低、收盘）每日值。\nopen = data.open low = data.low high = data.high close = data.close为了便于使用，我们将其赋值到 self.dataclose，这将简化打印逻辑的创建。\nself.dataclose = self.datas[0].close接着，在 next 方法中打印 self.dataclose[0] 最新收盘价即可。策略的 next 方法会在每个新的bar上调用，使用系统时钟（即self.datas[0]）作为参考。\ndef next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0])我们有了策略类 TestStrategy，还要通过 cerebro.addstrategy 将其添加交易系统中。\ncerebro.addstrategy(TestStrategy)完整示例# import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;./orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(100000.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出：\nStarting Portfolio Value: 100000.00 2000-01-03, Close, 27.85 2000-01-04, Close, 25.39 2000-01-05, Close, 24.05 ... ... ... 2000-12-26, Close, 29.17 2000-12-27, Close, 28.94 2000-12-28, Close, 29.29 2000-12-29, Close, 27.41 Final Portfolio Value: 100000.00"},{"id":66,"href":"/backtrader/docs/04-concepts/01-platform-concepts/04-index/","title":"索引和切片","section":"平台概念","content":"索引和切片# 索引：0 和 -1# 在 Backtrader 中，Line 代表着一组按时间顺序排列的点。这些点在策略执行期间动态生成，可以通过索引来访问。\n使用索引访问 Line# 访问当前值： 使用 0 索引访问当前的线值，如 self.data.close[0] 获取当前收盘价。\nclass MyStrategy(bt.Strategy): def next(self): print(self.data.close[0]) # 当前的收盘价访问前值： 使用负数索引访问之前的值，如 self.data.close[-1] 获取上一条数据的收盘价。\nclass MyStrategy(bt.Strategy): def next(self): if self.data.close[0] \u0026gt; self.data.close[-1]: print(\u0026#34;今天的收盘价高于昨日的收盘价\u0026#34;)索引的意义：\n0 索引指向当前时刻的值，-1 指向上一个时刻的值，以此类推。 负数索引指向历史数据点，这对于时间序列分析和策略中的数据回溯非常有用。 简单示例：\nclass MyStrategy(bt.Strategy): def next(self): # 比较今天的收盘价和昨天的收盘价 if self.data.close[0] \u0026gt; self.data.close[-1]: print(\u0026#34;今天的收盘价更高\u0026#34;) else: print(\u0026#34;今天的收盘价更低\u0026#34;)在这个示例中，self.data.close[0] 是今天的收盘价，self.data.close[-1] 是昨天的收盘价。\n切片# Backtrader 不支持对 Line 对象的切片操作，这是为了保持设计的一致性。切片适用于普通的 Python 数组，但在 Backtrader 中，Line 对象是动态增长的，因此切片的使用存在一定的限制。\n为什么不支持切片# 首先是 Line 的设计上要保持一致性。\nLine 对象上的数据是通过索引（如 0 和 -1）动态访问，基于时间序列进行数据处理。切片在此情况下并不适用，因为线的数据是按时间顺序排列的。\n而常规可索引对象的切片是什么样的？\n对于普通的 Python 对象，切片操作如下：\nmy_list = [1, 2, 3, 4, 5] sliced_list = my_list[1:3] # 返回 [2, 3]Backtrader 中的 Line 对象更像一个流式数据源，不能直接进行切片。\n如何获取线的某些点# 虽然 Line 不支持切片，但你仍然可以使用 get() 方法来获取线的一部分数据。例如：\n# 获取最后 10 个数据点 myslice = self.my_sma.get(size=10) # 获取最近的 10 个值这允许我们拿到指定数量的历史数据，且是按时间顺序拿到最近的数据。\n延迟索引# 在 Backtrader 中，延迟索引允许你在 __init__ 阶段访问历史数据，而无需手动使用负索引。通常情况下，[] 操作符用于在 next 阶段提取数据值，而通过延迟索引，可以在初始化阶段引用历史数据，并生成可以在 next 方法中直接使用的 Lines 对象。\n举个例子，如果你想比较前一日的收盘价与当前的简单移动平均线（SMA），你不需要在每次迭代中手动进行比较，而可以通过预先生成的 Lines 对象来实现：\n初始化时使用延迟索引# 在 __init__ 方法中，你可以通过延迟索引定义需要的历史数据。例如，比较前一天的收盘价和当前的移动平均值：\nclass MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): self.movav = btind.SimpleMovingAverage(self.data, period=self.p.period) self.cmpval = self.data.close(-1) \u0026gt; self.movav # 比较前一日收盘价与当前20日均线这里，self.data.close(-1) 通过延迟索引获取前一天的收盘价，self.movav 是当前的20日简单移动平均线。self.cmpval 是一个新的 Lines 对象，保存了每次比较的结果。\n在 next 方法中使用延迟数据# 在 next 方法中，你可以直接使用 Lines 对象的值进行逻辑判断。self.cmpval[0] 会返回当前条件是否成立：\nclass MyStrategy(bt.Strategy): def next(self): if self.cmpval[0]: # 如果前一日收盘价高于当前移动平均线 print(\u0026#34;前一日收盘价高于当前简单移动平均线\u0026#34;)延迟索引的工作原理# self.data.close(-1) 使用延迟索引从历史数据中提取前一天的收盘价。这个语法会返回一个 Line 对象，但它是延迟的，即相对于当前时刻，它表示的是前一个时间点的 Line。\n语句 self.data.close(-1) \u0026gt; self.movav 会生成一个新的 Line 对象，该对象在 next 方法中返回 1（条件为真）或 0（条件为假），使你在 next 方法可直接使用比较结果。\n通过这种方式，Backtrader 提供了更简洁和灵活的方式来引用和比较历史数据，而不需要手动管理索引，从而简化了策略的编写和逻辑实现。\n"},{"id":67,"href":"/backtrader/docs/09-orders/05-bracket-orders/","title":"Bracket Orders","section":"Order","content":"Bracket Orders# 1.9.37.116版本增加了Bracket订单，为回测经纪商提供了广泛的订单支持（Market、Limit、Close、Stop、StopLimit、StopTrail、StopTrailLimit、OCO）。\n注意，这是为回测和 Interactive Brokers 实现的。\nBracket订单不是单个订单，而是由3个订单组成。\n以做多为例：\n一个主要的买单，通常设置为 Limit 或 StopLimit 订单。 一个低价卖单，通常设置为 Stop 订单以限制损失。 一个高价卖单，通常设置为 Limit 订单以获取利润。 做空也有对应的卖单和 2 个买单。\n低价/高价卖单实际上形成了一个围绕主要订单的 Bracket。\n为了使其合理，以下规则适用：\n3个订单一起提交，以避免其中任何一个独立触发。 低价/高价卖单被标记为主要订单的子订单。 子订单在主要订单执行之前不活跃。 取消主要订单会取消低价和高价卖单。 执行主要订单会激活低价和高价卖单。 一旦活跃，低价/高价卖单的执行或取消会自动取消另一个订单。 使用模式# 有两种方式创建 Bracket 订单组：\n单次发布3个订单。 手动发布3个订单。 单次发布Bracket# backtrader在Strategy中提供了两个新方法来控制Bracket订单：buy_bracket和sell_bracket。\n注意\n签名和信息见下文或Strategy参考部分。\n通过单个语句完成3个订单的设置。示例如下：\nbrackets = self.buy_bracket(limitprice=14.00, price=13.50, stopprice=13.00)注意，stopprice和limitprice围绕price设定。这应该足够了。\n实际的目标数据将是 data0，大小将由默认的sizer自动确定。当然，可以指定其他参数来精细控制执行。\n返回值是一个包含3个订单的列表：[主要订单，stop订单，limit订单]。\n因为在发布 sell_bracket 订单时，低价和高价将翻转，所以参数命名遵循约定：stop 用于止损（在做多操作中是低价，在做空操作中是高价），limit 用于获取利润（在做多操作中是高价，在做空操作中是低价）。\n手动发布Bracket# 这涉及生成3个订单，并处理transmit和parent参数。规则如下：\n必须首先创建主要订单并设置transmit=False。 低价/高价订单必须有parent=main_side_order。 第一个创建的低价/高价订单必须设置transmit=False。 最后一个创建的订单（无论是低价还是高价）设置transmit=True。 以下示例实现了与上述单次命令相同的效果：\nmainside = self.buy(price=13.50, exectype=bt.Order.Limit, transmit=False) lowside = self.sell(price=13.00, size=mainside.size, exectype=bt.Order.Stop, transmit=False, parent=mainside) highside = self.sell(price=14.00, size=mainside.size, exectype=bt.Order.Limit, transmit=True, parent=mainside)需要做更多的事情：\n跟踪主要订单，指示它是其他订单的父订单。 控制transmit以确保只有最后一个订单触发联合传输。 指定执行类型。 为低价和高价订单指定大小。 因为大小必须相同。如果未手动指定大小且用户引入了sizer，sizer可能会为订单指示不同的值。因此，需要在调用时手动添加大小。\n示例# 运行下面的示例生成如下输出（为简洁起见进行了截断）：\n$ ./bracket.py --plot 2005-01-28: Oref 1 / Buy at 2941.11055 2005-01-28: Oref 2 / Sell Stop at 2881.99275 2005-01-28: Oref 3 / Sell Limit at 3000.22835 2005-01-31: Order ref: 1 / Type Buy / Status Submitted 2005-01-31: Order ref: 2 / Type Sell / Status Submitted 2005-01-31: Order ref: 3 / Type Sell / Status Submitted 2005-01-31: Order ref: 1 / Type Buy / Status Accepted 2005-01-31: Order ref: 2 / Type Sell / Status Accepted 2005-01-31: Order ref: 3 / Type Sell / Status Accepted 2005-02-01: Order ref: 1 / Type Buy / Status Expired 2005-02-01: Order ref: 2 / Type Sell / Status Canceled 2005-02-01: Order ref: 3 / Type Sell / Status Canceled ... 2005-08-11: Oref 16 / Buy at 3337.3892 2005-08-11: Oref 17 / Sell Stop at 3270.306 2005-08-11: Oref 18 / Sell Limit at 3404.4724 2005-08-12: Order ref: 16 / Type Buy / Status Submitted 2005-08-12: Order ref: 17 / Type Sell / Status Submitted 2005-08-12: Order ref: 18 / Type Sell / Status Submitted 2005-08-12: Order ref: 16 / Type Buy / Status Accepted 2005-08-12: Order ref: 17 / Type Sell / Status Accepted 2005-08-12: Order ref: 18 / Type Sell / Status Accepted 2005-08-12: Order ref: 16 / Type Buy / Status Completed 2005-08-18: Order ref: 17 / Type Sell / Status Completed 2005-08-18: Order ref: 18 / Type Sell / Status Canceled ... 2005-09-26: Oref 22 / Buy at 3383.92535 2005-09-26: Oref 23 / Sell Stop at 3315.90675 2005-09-26: Oref 24 / Sell Limit at 3451.94395 2005-09-27: Order ref: 22 / Type Buy / Status Submitted 2005-09-27: Order ref: 23 / Type Sell / Status Submitted 2005-09-27: Order ref: 24 / Type Sell / Status Submitted 2005-09-27: Order ref: 22 / Type Buy / Status Accepted 2005-09-27: Order ref: 23 / Type Sell / Status Accepted 2005-09-27: Order ref: 24 / Type Sell / Status Accepted 2005-09-27: Order ref: 22 / Type Buy / Status Completed 2005-10-04: Order ref: 24 / Type Sell / Status Completed 2005-10-04: Order ref: 23 / Type Sell / Status Canceled ...显示了 3 种不同的结果：\n第一种情况下，主要订单过期，自动取消了其他两个订单。 第二种情况下，主要订单完成，低价订单（买入情况下的止损）执行，限制了损失。 第三种情况下，主要订单完成，高价订单（限价）执行。 可以注意到，已完成的订单id是22和24，高价订单最后发布，未执行的低价订单id是23。\n图示\n可以立即看到，亏损交易集中在相同的值附近，而盈利交易也是如此，这是 Bracket 的目的。控制两侧。\n运行的示例手动发布3个订单，但可以使用buy_bracket。输出如下：\n$ ./bracket.py --strat usebracket=True结果相同。\n参考# 请参阅新的buy_bracket和sell_bracket方法\ndef buy_bracket(self, data=None, size=None, price=None, plimit=None, exectype=bt.Order.Limit, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=bt.Order.Stop, stopargs={}, limitprice=None, limitexec=bt.Order.Limit, limitargs={}, **kwargs): \u0026#39;\u0026#39;\u0026#39; 创建一个Bracket订单组（低侧 - 买单 - 高侧）。默认行为如下： - 发出执行类型为“Limit”的**买单** - 发出执行类型为“Stop”的*低侧*Bracket**卖单** - 发出执行类型为“Limit”的*高侧*Bracket**卖单**。 参见下文以了解不同参数的含义 - ``data``（默认：``None``） 订单针对的数据。如果为``None``，则使用系统中的第一个数据，即``self.datas[0 ]或self.data0``（即``self.data``） - ``size``（默认：``None``） 订单的数据单位大小（正数）。 如果为``None``，则使用通过``getsizer``检索到的``sizer``实例来确定大小。 **注意**：相同的大小适用于Bracket的所有3个订单 - ``price``（默认：``None``） 使用的价格（实时经纪商可能会对实际格式施加限制，如果不符合最小价格单位要求） ``None``对于``Market``和``Close``订单是有效的（市场决定价格） 对于``Limit``、``Stop``和``StopLimit``订单，此值确定触发点（在``Limit``的情况下，触发点显然是订单应匹配的价格） - ``plimit``（默认：``None``） 仅适用于``StopLimit``订单。这是设置隐含限价订单的价格，一旦触发了``Stop``（使用``price``） - ``trailamount``（默认：``None``） 如果订单类型为StopTrail或StopTrailLimit，这是一个绝对金额，确定价格的距离（卖单下方和买单上方），以保持追踪止损 - ``trailpercent``（默认：``None``） 如果订单类型为StopTrail或StopTrailLimit，这是一个百分比金额，确定价格的距离（卖单下方和买单上方），以保持追踪止损（如果也指定了``trailamount``，将使用它） - ``exectype``（默认：``bt.Order.Limit``） 可能的值：（参见``buy``方法的文档） - ``valid``（默认：``None``） 可能的值：（参见``buy``方法的文档） - ``tradeid``（默认：``0``） 可能的值：（参见``buy``方法的文档） - ``oargs``（默认：``{}``） 要传递给主要订单的特定关键字参数（在``dict``中）。默认``**kwargs``中的参数将应用于此。 - ``**kwargs``：其他经纪商实现可能支持的额外参数。``backtrader``将*kwargs*传递给创建的订单对象 可能的值：（参见``buy``方法的文档） **注意**：此``kwargs``将应用于Bracket的所有3个订单。参见下文以了解低侧和高侧订单的特定关键字参数 - ``stopprice``（默认：``None``） *低侧*止损订单的特定价格 - ``stopexec``（默认：``bt.Order.Stop``） *低侧*订单的特定执行类型 - ``stopargs``（默认：``{}``） 要传递给低侧订单的特定关键字参数（在``dict``中）。默认``**kwargs``中的参数将应用于此。 - ``limitprice``（默认：``None``） *高侧*止损订单的特定价格 - ``stopexec``（默认：``bt.Order.Limit``） *高侧*订单的特定执行类型 - ``limitargs``（默认：``{}``） 要传递给高侧订单的特定关键字参数（在``dict``中）。默认``**kwargs``中的参数将应用于此。 返回： - 一个包含3个Bracket订单的列表[订单，低侧，高侧] \u0026#39;\u0026#39;\u0026#39; def sell_bracket(self, data=None, size=None, price=None, plimit=None, exectype=bt.Order.Limit, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=bt.Order.Stop, stopargs={}, limitprice=None, limitexec=bt.Order.Limit, limitargs={}, **kwargs): \u0026#39;\u0026#39;\u0026#39; 创建一个Bracket订单组（低侧 - 卖单 - 高侧）。默认行为如下： - 发出执行类型为“Limit”的**卖单** - 发出执行类型为“Stop”的*高侧*Bracket**买单** - 发出执行类型为“Limit”的*低侧*Bracket**买单**。 参见``bracket_buy``以了解参数的含义 返回： - 一个包含3个Bracket订单的列表[订单，低侧，限价侧] \u0026#39;\u0026#39;\u0026#39;示例用法# $ ./bracket.py --help usage: bracket.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Sample Skeleton optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( ma=bt.ind.SMA, p1=5, p2=15, limit=0.005, limdays=3, limdays2=1000, hold=10, usebracket=False, # use order_target_size switchp1p2=False, # switch prices of order1 and order2 ) def notify_order(self, order): print(\u0026#39;{}: Order ref: {} / Type {} / Status {}\u0026#39;.format( self.data.datetime.date(0), order.ref, \u0026#39;Buy\u0026#39; * order.isbuy() or \u0026#39;Sell\u0026#39;, order.getstatusname())) if order.status == order.Completed: self.holdstart = len(self) if not order.alive() and order.ref in self.orefs: self.orefs.remove(order.ref) def __init__(self): ma1, ma2 = self.p.ma(period=self.p.p1), self.p.ma(period=self.p.p2) self.cross = bt.ind.CrossOver(ma1, ma2) self.orefs = list() if self.p.usebracket: print(\u0026#39;-\u0026#39; * 5, \u0026#39;Using buy_bracket\u0026#39;) def next(self): if self.orefs: return # pending orders do nothing if not self.position: if self.cross \u0026gt; 0.0: # crossing up close = self.data.close[0] p1 = close * (1.0 - self.p.limit) p2 = p1 - 0.02 * close p3 = p1 + 0.02 * close valid1 = datetime.timedelta(self.p.limdays) valid2 = valid3 = datetime.timedelta(self.p.limdays2) if self.p.switchp1p2: p1, p2 = p2, p1 valid1, valid2 = valid2, valid1 if not self.p.usebracket: o1 = self.buy(exectype=bt.Order.Limit, price=p1, valid=valid1, transmit=False) print(\u0026#39;{}: Oref {} / Buy at {}\u0026#39;.format(self.datetime.date(), o1.ref, p1)) o2 = self.sell(exectype=bt.Order.Stop, price=p2, valid=valid2, parent=o1, transmit=False) print(\u0026#39;{}: Oref {} / Sell Stop at {}\u0026#39;.format(self.datetime.date(), o2.ref, p2)) o3 = self.sell(exectype=bt.Order.Limit, price=p3, valid=valid3, parent=o1, transmit=True) print(\u0026#39;{}: Oref {} / Sell Limit at {}\u0026#39;.format(self.datetime.date(), o3.ref, p3)) self.orefs = [o1.ref, o2.ref, o3.ref] else: os = self.buy_bracket(price=p1, valid=valid1, stopprice=p2, stopargs=dict(valid=valid2), limitprice=p3, limitargs=dict(valid=valid3),) self.orefs = [o.ref for o in os] else: # in the market if (len(self) - self.holdstart) \u0026gt;= self.p.hold: pass # do nothing in this case def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # Data feed kwargs kwargs = dict() dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) cerebro.run() if args.plot: cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample Skeleton\u0026#39; ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":68,"href":"/backtrader/docs/05-cerebro/","title":"Cerebro","section":"介绍","content":"Cerebro# 本节将介绍 Cerebro，它是 Backtrader 框架的核心类，或者也可以成为大脑。\n"},{"id":69,"href":"/backtrader/docs/10-broker/05-position/","title":"Position","section":"Broker","content":"Position# 通常在策略中要检查资产 Position，或成为仓位、头寸，通过 position 属性或 getposition(data=None, broker=None) 方法。这将返回策略在cerebro提供的默认经纪商中的datas[0]的头寸。\n头寸只是一个表示：\n持有的资产数量（size） 平均价格（price） 它用作状态指示，例如可以用于决定是否需要发出订单（例如：仅在没有持仓时进入多头头寸）。\n参考# class backtrader.position.Position(size=0, price=0.0)保存并更新头寸的数量和价格。该对象与任何资产没有关系。它只保存数量和价格。\n成员属性：\nsize（int）：当前头寸的数量 price（float）：当前头寸的价格 可以使用 len(position) 来测试头寸实例以查看数量是否不为零。\n"},{"id":70,"href":"/backtrader/docs/19-articles/05-rebalancing-conserative/","title":"保守型公式的再平衡","section":"官方文章","content":"保守型公式的再平衡# 本文提出了保守型公式的方法：Python中的保守型公式：简化的量化投资\n这只是众多可能的再平衡方法中的一种，但它相对易于理解。方法概要如下：\n从Y个股票（比如1000个中的100个）中选出x只股票 选股标准为： 低波动性 高净派息收益率（Net Payout Yield，NPY） 高动量 每月再平衡一次 了解了这些概念后，接下来我们将展示如何在Backtrader中实现这一策略。\n数据# 即使有一个获胜的策略，如果没有可用的数据，那么一切都不会成真。因此，需要考虑数据的格式和如何加载它。\n假设有一组CSV文件（“逗号分隔值”），每个文件包含以下特征：\n每月的OHLCV数据 额外的列包含净派息收益率（NPY），以形成一个ohlcvn数据集。 CSV数据格式如下：\ndate, open, high, low, close, volume, npy 2001-12-31, 1.0, 1.0, 1.0, 1.0, 0.5, 3.0 2002-01-31, 2.0, 2.5, 1.1, 1.2, 3.0, 5.0 ...即每行表示一个月的数据。接下来，可以通过Backtrader的CSV数据加载引擎创建一个简单的扩展类。\nclass NetPayOutData(bt.feeds.GenericCSVData): lines = (\u0026#39;npy\u0026#39;,) # 增加一行，用于存储净派息收益率 params = dict( npy=6, # npy字段位于第6列（基于0的索引） dtformat=\u0026#39;%Y-%m-%d\u0026#39;, # 设置日期格式为yyyy-mm-dd timeframe=bt.TimeFrame.Months, # 设置时间框架为按月 openinterest=-1, # -1表示没有openinterest字段 )这样就完成了对数据源的扩展。注意，通过lines=('npy',)，已经将净派息收益率（NPY）数据添加到了OHLCV数据流中。其他常见的字段（如open、high等）已经是GenericCSVData的一部分。通过在params中指定位置，我们能够告诉Backtrader净派息收益率所在的列。\n策略# 接下来，我们将逻辑封装到Backtrader的标准策略中。为了使其尽可能通用和可自定义，我们将采用与数据源相同的params方法。\n首先，我们来回顾一下快速总结中的一个要点：\n从一个Y个股票的宇宙中选择x个股票 策略本身不负责将股票添加到股票宇宙中，但它负责选择股票。假设宇宙中有1000只股票，但在代码中设置了x=100，那么即使只有50只股票被加入，策略也会选择100只。为了应对这种情况，我们会做如下处理：\n设置selperc参数，默认值为0.10（即10%），表示从宇宙中选择的股票数量。 例如，如果宇宙中有1000只股票，则选择100只；如果只有50只股票，则选择5只。\n股票的排名公式如下：\n(momentum * net payout) / volatility即，动量更大、派息收益率更高、波动性更低的股票会有更高的评分。\n动量使用“变动率”指标（ROC，Rate of Change），它衡量的是价格在一段时间内的变化比率。\n净派息收益率已经作为数据的一部分包含在内。\n波动性则使用股票的标准差（标准差基于n周期的回报率）来计算。\n有了这些信息后，策略可以初始化所需的参数，并设置将在每个月的迭代中使用的指标和计算方法。\n策略实现# class St(bt.Strategy): params = dict( selcperc=0.10, # 从宇宙中选择的股票比例 rperiod=1, # 回报率计算周期，默认为1个周期 vperiod=36, # 波动性回顾期，默认为36个周期 mperiod=12, # 动量回顾期，默认为12个周期 reserve=0.05 # 5%的预留资本 ) def log(self, arg): print(\u0026#39;{} {}\u0026#39;.format(self.datetime.date(), arg)) def __init__(self): # 计算选股数量 self.selnum = int(len(self.datas) * self.p.selcperc) # 每只股票的资本分配比例 self.perctarget = (1.0 - self.p.reserve) / self.selnum # 计算回报率、波动性和动量 rs = [bt.ind.PctChange(d, period=self.p.rperiod) for d in self.datas] vs = [bt.ind.StdDev(ret, period=self.p.vperiod) for ret in rs] ms = [bt.ind.ROC(d, period=self.p.mperiod) for d in self.datas] # 排名公式： (动量 * 净派息收益率) / 波动性 self.ranks = {d: d.npy * m / v for d, v, m in zip(self.datas, vs, ms)} def next(self): # 按排名排序 ranks = sorted( self.ranks.items(), # 获取(d, rank)对 key=lambda x: x[1][0], # 使用排名（元素1）进行排序 reverse=True, # 按排名从高到低排序 ) # 获取排名前selnum的股票 rtop = dict(ranks[:self.selnum]) # 获取排名低的股票 rbot = dict(ranks[self.selnum:]) # 获取当前持有的股票 posdata = [d for d, pos in self.getpositions().items() if pos] # 卖出那些不再是前排名的股票 for d in (d for d in posdata if d not in rtop): self.log(\u0026#39;Exit {} - Rank {:.2f}\u0026#39;.format(d._name, rbot[d][0])) self.order_target_percent(d, target=0.0) # 重新平衡已经排名前的股票 for d in (d for d in posdata if d in rtop): self.log(\u0026#39;Rebal {} - Rank {:.2f}\u0026#39;.format(d._name, rtop[d][0])) self.order_target_percent(d, target=self.perctarget) del rtop[d] # 删除已处理的股票 # 为新进入的排名前的股票设置目标订单 for d in rtop: self.log(\u0026#39;Enter {} - Rank {:.2f}\u0026#39;.format(d._name, rtop[d][0])) self.order_target_percent(d, target=self.perctarget)运行和评估# 我们需要一些额外的代码来实现数据加载和运行策略的框架。\ndef run(args=None): args = parse_args(args) cerebro = bt.Cerebro() # 加载数据文件 for fname in glob.glob(os.path.join(args.datadir, \u0026#39;*\u0026#39;)): data = NetPayOutData(dataname=fname, **dkwargs) cerebro.adddata(data) # 添加策略 cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # 设置初始现金 cerebro.broker.setcash(args.cash) cerebro.run() # 执行策略 # 基本的性能评估 pnl = cerebro.broker.get_value() - args.cash print(\u0026#39;Profit ... or Loss: {:.2f}\u0026#39;.format(pnl))性能评估# 一种简单的评估方法是计算最终资产值减去初始现金的差额。\nBacktrader还提供了内置的性能分析器，如Sharpe比率、加权回报率、SQN等，具体可参考文档进行进一步的性能分析。\n完整脚本# import argparse import datetime import glob import os.path import backtrader as bt class NetPayOutData(bt.feeds.GenericCSVData): lines = (\u0026#39;npy\u0026#39;,) # add a line containing the net payout yield params = dict( npy=6, # npy field is in the 6th column (0 based index) dtformat=\u0026#39;%Y-%m-%d\u0026#39;, # fix date format a yyyy-mm-dd timeframe=bt.TimeFrame.Months, # fixed the timeframe openinterest=-1, # -1 indicates there is no openinterest field ) class St(bt.Strategy): params = dict( selcperc=0.10, # percentage of stocks to select from the universe rperiod=1, # period for the returns calculation, default 1 period vperiod=36, # lookback period for volatility - default 36 periods mperiod=12, # lookback period for momentum - default 12 periods reserve=0.05 # 5% reserve capital ) def log(self, arg): print(\u0026#39;{} {}\u0026#39;.format(self.datetime.date(), arg)) def __init__(self): # calculate 1st the amount of stocks that will be selected self.selnum = int(len(self.datas) * self.p.selcperc) # allocation perc per stock # reserve kept to make sure orders are not rejected due to # margin. Prices are calculated when known (close), but orders can only # be executed next day (opening price). Price can gap upwards self.perctarget = (1.0 - self.p.reserve) / self.selnum # returns, volatilities and momentums rs = [bt.ind.PctChange(d, period=self.p.rperiod) for d in self.datas] vs = [bt.ind.StdDev(ret, period=self.p.vperiod) for ret in rs] ms = [bt.ind.ROC(d, period=self.p.mperiod) for d in self.datas] # simple rank formula: (momentum * net payout) / volatility # the highest ranked: low vol, large momentum, large payout self.ranks = {d: d.npy * m / v for d, v, m in zip(self.datas, vs, ms)} def next(self): # sort data and current rank ranks = sorted( self.ranks.items(), # get the (d, rank), pair key=lambda x: x[1][0], # use rank (elem 1) and current time \u0026#34;0\u0026#34; reverse=True, # highest ranked 1st ... please ) # put top ranked in dict with data as key to test for presence rtop = dict(ranks[:self.selnum]) # For logging purposes of stocks leaving the portfolio rbot = dict(ranks[self.selnum:]) # prepare quick lookup list of stocks currently holding a position posdata = [d for d, pos in self.getpositions().items() if pos] # remove those no longer top ranked # do this first to issue sell orders and free cash for d in (d for d in posdata if d not in rtop): self.log(\u0026#39;Leave {} - Rank {:.2f}\u0026#39;.format(d._name, rbot[d][0])) self.order_target_percent(d, target=0.0) # rebalance those already top ranked and still there for d in (d for d in posdata if d in rtop): self.log(\u0026#39;Rebal {} - Rank {:.2f}\u0026#39;.format(d._name, rtop[d][0])) self.order_target_percent(d, target=self.perctarget) del rtop[d] # remove it, to simplify next iteration # issue a target order for the newly top ranked stocks # do this last, as this will generate buy orders consuming cash for d in rtop: self.log(\u0026#39;Enter {} - Rank {:.2f}\u0026#39;.format(d._name, rtop[d][0])) self.order_target_percent(d, target=self.perctarget) def run(args=None): args = parse_args(args) cerebro = bt.Cerebro() # Data feed kwargs dkwargs = dict(**eval(\u0026#39;dict(\u0026#39; + args.dargs + \u0026#39;)\u0026#39;)) # Parse from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; if args.fromdate: fmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in args.fromdate) dkwargs[\u0026#39;fromdate\u0026#39;] = datetime.datetime.strptime(args.fromdate, fmt) if args.todate: fmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in args.todate) dkwargs[\u0026#39;todate\u0026#39;] = datetime.datetime.strptime(args.todate, fmt) # add all the data files available in the directory datadir for fname in glob.glob(os.path.join(args.datadir, \u0026#39;*\u0026#39;)): data = NetPayOutData(dataname=fname, **dkwargs) cerebro.adddata(data) # add strategy cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # set the cash cerebro.broker.setcash(args.cash) cerebro.run() # execute it all # Basic performance evaluation ... final value ... minus starting cash pnl = cerebro.broker.get_value() - args.cash print(\u0026#39;Profit ... or Loss: {:.2f}\u0026#39;.format(pnl)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=(\u0026#39;Rebalancing with the Conservative Formula\u0026#39;), ) parser.add_argument(\u0026#39;--datadir\u0026#39;, required=True, help=\u0026#39;Directory with data files\u0026#39;) parser.add_argument(\u0026#39;--dargs\u0026#39;, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in k1=v1,k2=v2 format\u0026#39;) # Defaults for dates parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in k1=v1,k2=v2 format\u0026#39;) parser.add_argument(\u0026#39;--cash\u0026#39;, default=1000000.0, type=float, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in k1=v1,k2=v2 format\u0026#39;) parser.add_argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in k1=v1,k2=v2 format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: run()这个完整的脚本展示了如何在Backtrader中实现基于保守型公式的股票选择和再平衡策略。\n"},{"id":71,"href":"/backtrader/docs/06-datafeed/05-datafeed-multiple-timeframes/","title":"多时间框架","section":"DataFeed","content":"多时间框架策略# 在实际的交易中，我们常需要结合多个时间框架来制定投资决策，如在周级别评估趋势，而在日级别执行入场，或是基于 5 分钟与 60 分钟数据的对比执行交易。在 Backtrader 中要实现这个目标，需要将不同时间框架的数据组合在一起。\n本节将介绍如何在 Backtrader 实现多周期交易策略。\n基本规则# Backtrader 原生支持多时间框架的数据组合，只需遵循几个简单的规则。\n第一步，最小时间框架的数据必须首先加载。较小时间框架（条数最多的数据）应当首先加载到Cerebro实例中。\n第二步，数据必须按日期时间对齐。为了让平台能够正确解析数据并执行策略，必须保证各时间框架的数据时间对齐。\n第三步，使用 resampledata 实现较大时间框架的重采样。cerebro.resample 函数能轻松地将较大的时间框架数据添加到策略中。\n在这个基础上，就可以在较短和较长时间框架上使用不同的技术指标。要注意，应用于大时间框架的指标产生的信号较少，还有，Backtrader 会考虑大时间框架的最小周期，以确保数据的准确性。\n示例：如何使用多个时间框架# 如何在 Backtrader 实现多时间周期呢？大概演示这个步骤吧。\n加载数据# 首先，加载较小时间框架的数据。\ndata = btfeeds.BacktraderCSVData(dataname=datapath)将数据添加到Cerebro# 将较小时间框架数据都添加到 Cerebro 实例中。\ncerebro.adddata(data)重采样数据# 使用 cerebro.resampledata 将数据重采样到较大的时间框架。\ncerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression)运行策略# 执行策略并生成结果。\ncerebro.run()示例# 首先，演示每日和每周时间框架。假设我们希望在一个策略中同时使用每日和每周的时间框架。通过命令行指定时间框架为每周，并进行数据重采样：\n$ ./multitimeframe-example.py --timeframe weekly --compression 1此时，程序会加载每日数据，并将其重采样为每周数据。最终输出将包括每周和每日数据的合成图表。\n继续用每日时间框架压缩。如果我们希望将每日数据压缩为每两天一条数据，可以使用以下命令：\n$ ./multitimeframe-example.py --timeframe daily --compression 2此时，Backtrader会将每日数据压缩为每两天一条数据，并生成合成图表。\n还可以带简单移动平均（SMA）指标。为了展示不同时间框架对策略的影响，可以在策略中使用简单的移动平均线（SMA）指标。SMA将在较小和较大时间框架上应用，并根据它们产生不同的信号。\n在较小的时间框架（如每日）上，SMA将在第10个数据点后首次计算出值。 在较大的时间框架（如每周）上，SMA的计算会延迟，可能需要10个周期的时间来产生有效信号。 由于Backtrader的多时间框架支持，较大时间框架会消耗多个较小时间框架的数据条目来计算指标。\n在策略中使用 SMA 时，如果数据点来自较大时间框架，nextstart 方法的调用可能会有所延迟。例如，在每周时间框架下，SMA的计算需要10周的数据，而在每个周期内，我们将看到多个“nextstart”调用，因为Backtrader会等待所有数据都齐全时才开始执行策略逻辑。\n代码示例# # 导入必要的库 from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind # 创建SMA策略 class SMAStrategy(bt.Strategy): params = ( (\u0026#39;period\u0026#39;, 10), # SMA的周期 (\u0026#39;onlydaily\u0026#39;, False), # 是否只在每日时间框架上应用 ) def __init__(self): # 为较小时间框架添加SMA self.sma_small_tf = btind.SMA(self.data, period=self.p.period) # 如果选择不只应用于每日时间框架 if not self.p.onlydaily: # 为较大时间框架（如每周）添加SMA self.sma_large_tf = btind.SMA(self.data1, period=self.p.period) # nextstart方法，用于输出调试信息 def nextstart(self): print(\u0026#39;--------------------------------------------------\u0026#39;) print(\u0026#39;nextstart called with len\u0026#39;, len(self)) print(\u0026#39;--------------------------------------------------\u0026#39;) super(SMAStrategy, self).nextstart() # 运行策略 def runstrat(): args = parse_args() # 创建Cerebro实例 cerebro = bt.Cerebro(stdstats=False) # 根据用户选择的策略参数加载相应策略 if not args.indicators: cerebro.addstrategy(bt.Strategy) else: cerebro.addstrategy(SMAStrategy, period=args.period, onlydaily=args.onlydaily) # 加载数据文件 datapath = args.dataname or \u0026#39;../../datas/2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=datapath) cerebro.adddata(data) # 添加较小时间框架的数据 tframes = dict(daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 根据需要重采样数据到较大时间框架 if args.noresample: datapath = args.dataname2 or \u0026#39;../../datas/2006-week-001.txt\u0026#39; data2 = btfeeds.BacktraderCSVData(dataname=datapath) cerebro.adddata(data2) else: cerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression) # 执行策略并生成结果 cerebro.run() # 绘制结果 cerebro.plot(style=\u0026#39;bar\u0026#39;) # 解析命令行参数 def parse_args(): parser = argparse.ArgumentParser(description=\u0026#39;Multitimeframe test\u0026#39;) parser.add_argument(\u0026#39;--dataname\u0026#39;, default=\u0026#39;\u0026#39;, required=False, help=\u0026#39;数据文件路径\u0026#39;) parser.add_argument(\u0026#39;--dataname2\u0026#39;, default=\u0026#39;\u0026#39;, required=False, help=\u0026#39;第二个数据文件路径\u0026#39;) parser.add_argument(\u0026#39;--noresample\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;不进行数据重采样\u0026#39;) parser.add_argument(\u0026#39;--timeframe\u0026#39;, default=\u0026#39;weekly\u0026#39;, choices=[\u0026#39;daily\u0026#39;, \u0026#39;weekly\u0026#39;, \u0026#39;monthly\u0026#39;], help=\u0026#39;重采样时间框架\u0026#39;) parser.add_argument(\u0026#39;--compression\u0026#39;, default=1, type=int, help=\u0026#39;压缩数据条数\u0026#39;) parser.add_argument(\u0026#39;--indicators\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;是否使用带指标的策略\u0026#39;) parser.add_argument(\u0026#39;--onlydaily\u0026#39;, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;仅在每日时间框架上应用指标\u0026#39;) parser.add_argument(\u0026#39;--period\u0026#39;, default=10, type=int, help=\u0026#39;指标周期\u0026#39;) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()结论# 通过Backtrader的多时间框架支持，您可以轻松地将不同时间框架的数据结合在一起，从而实现更加灵活的交易策略。只需遵循上述规则，就能在多个时间框架中应用不同的指标，并根据数据的不同粒度调整策略的执行逻辑。\n此外，Backtrader也允许通过nextstart方法来精确控制每个周期的数据处理逻辑，这使得您可以清晰地跟踪每个时间框架的计算过程，方便调试和优化。\n"},{"id":72,"href":"/backtrader/docs/03-quickstart/05-strategy-logic/","title":"开始交易","section":"快速开始","content":"开始交易# 本节，我们将演示一个简单的策略，让策略执行交易操作，如果出现连续两个交易日下跌即 - 买入！买入！买入！\n我们将基于上节的策略类 TestStrategy 继续开发，策略逻辑部分要在 next 方法中实现。\nclass TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0])首先是买入条件，如何判断两日连续下跌呢？\n简单而言，就是 close[0] \u0026lt; close[-1] 和 close[-1] \u0026lt; close[-2]，即当前收盘价小于昨日收盘价，昨日收盘价小于大前日收盘价。\nself.dataclose[0] \u0026lt; self.dataclose[-1] and self.dataclose[-1] \u0026lt; self.dataclose[-2]而买入操作使用 self.buy 皆可。\nself.buy()默认情况下，如果存在多个数据源，self.buy 买入的是第一个数据资产。\n完整示例# import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if self.dataclose[0] \u0026lt; self.dataclose[-1]: if self.dataclose[-1] \u0026lt; self.dataclose[-2]: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.dataclose[0]) self.buy() if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;./orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(100000.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出：\nStarting Portfolio Value: 100000.00 2000-01-03, Close, 27.85 2000-01-04, Close, 25.39 2000-01-05, Close, 24.05 2000-01-05, BUY CREATE, 24.05 2000-01-06, Close, 22.63 2000-01-06, BUY CREATE, 22.63 2000-01-07, Close, 24.37 ... ... ... 2000-12-20, BUY CREATE, 26.88 2000-12-21, Close, 27.82 2000-12-22, Close, 30.06 2000-12-26, Close, 29.17 2000-12-27, Close, 28.94 2000-12-27, BUY CREATE, 28.94 2000-12-28, Close, 29.29 2000-12-29, Close, 27.41 Final Portfolio Value: 99725.08多个“买入”创建订单被发出，我们的组合价值减少了。显然缺少了一些重要的内容，订单已创建，但尚未确定其执行时间和价格。\n下个示例将监听订单状态通知来完善这个过程。\n"},{"id":73,"href":"/backtrader/docs/05-cerebro/05-exceptions/","title":"异常 Exceptions","section":"Cerebro","content":"异常# 设计目标之一是尽早退出并让用户完全透明地了解错误发生的情况。目的是强制自己编写在异常情况下会中断的代码，并强制重新审视受影响的部分。\n但现在是时候了，某些异常可能会慢慢添加到平台中。\n继承层次结构# 所有异常的基类是 BacktraderError（直接继承自 Exception）。\n位置# 在 errors 模块内，可以通过以下方式访问：\nimport backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.errors.StrategySkipError或者直接从 backtrader 访问：\nimport backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.StrategySkipError异常# StrategySkipError，请求平台跳过该策略的回测。应在实例的初始化（__init__）阶段引发。\n"},{"id":74,"href":"/backtrader/docs/04-concepts/01-platform-concepts/05-operator/","title":"运算符","section":"平台概念","content":"运算符# 在 Backtrader 中，运算符不仅用于常规的数学运算，还能构建复杂的策略逻辑。Backtrader 的自定义运算符让策略的数学和逻辑运算更自然和简洁。\n如何使用运算符# backtrader 支持基于运算符创建新的对象，如在 __init__ 中通过运算符计算多个指标，得到一个新的操作对象。\nclass MyStrategy(bt.Strategy): def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=20) # 使用运算符创建新的逻辑对象 close_over_sma = self.data.close \u0026gt; sma sma_dist_to_high = self.data.high - sma sma_dist_small = sma_dist_to_high \u0026lt; 3.5 # 创建卖出信号 self.sell_sig = bt.And(close_over_sma, sma_dist_small)我们在 Line 对象上使用了常规的运算符，如加减乘除、大小比较等。这简化了策略代码，增强了策略逻辑的可读性和可维护性。\n注：backtrader 的指标计算是自有的体系，不是基于 numpy 和 pandas，所以要单独实现这些运算符。\n一些未覆盖的运算符/函数# 某些 Python 中的运算符没有被覆盖，backtrader 提供了专门的函数来模拟逻辑运算，如 bt.And 和 bt.Or 来实现逻辑 \u0026ldquo;与\u0026rdquo; 和 \u0026ldquo;或\u0026rdquo;。\n下面把这些单独实现的运算符列出来看看吧。\n逻辑运算符# Python 中的 and 和 or 运算符无法在 Backtrader 中覆盖，backtradr 提供了 bt.And 和 bt.Or 来模拟这两个逻辑操作。\nself.buy_sig = bt.And(self.data.close \u0026gt; self.sma, self.data.high \u0026lt; 50.0) self.sell_sig = bt.Or(self.data.close \u0026lt; self.sma, self.data.low \u0026gt; 30.0)数学函数# Backtrader 也提供了替代 Python 标准库函数的方式，如 max 和 min 被替代为 bt.Max 和 bt.Min。这些函数可用于处理 Line 对象：\nhighest = bt.Max(self.data.high, period=20) # 获取过去20个周期的最高价 lowest = bt.Min(self.data.low, period=20) # 获取过去20个周期的最低价使用 bt.If 模拟条件分支# 如果要按条件选择值，Backtrader 提供了 bt.If 来模拟条件分支。bt.If 的功能类似于 Python 中的三元运算符 x if condition else y，或者说是 numpy 中 where 函数。\nclass MyStrategy(bt.Strategy): def __init__(self): sma1 = btind.SMA(self.data.close, period=15) # 使用 bt.If 来根据条件选择价格 high_or_low = bt.If(sma1 \u0026gt; self.data.close, self.data.low, self.data.high) sma2 = btind.SMA(high_or_low, period=15) # 使用选中的值计算新的简单移动平均线其他函数# 类似的，any 被替换为 bt.Any，all 被替换为 bt.All， sum 被替换为 bt.Sum，cmp 被替换为 bt.Cmp，还有 reduce 被替换为 bt.Reduce。\n这些函数都可用于处理可迭代对象，与 Line 对象兼容。\nsum_values = bt.Sum(self.data.close, period=10) # 计算过去10个周期的收盘价总和"},{"id":75,"href":"/backtrader/docs/19-articles/06-mfi-generic/","title":"MFI 通用版","section":"官方文章","content":"MFI 通用版# 在之前的《Canonical 与 Non-Canonical》一文中，介绍了 MFI（即 Money Flow Indicator，资金流动指标）的实现。\n虽然这个实现是按照传统的方式开发的，但它依然有改进的空间，并且可以做得更通用。\n让我们关注一下实现的前几行代码，即计算典型价格的部分。\nCanonical MFI - 典型价格和原始资金流# class MFI_Canonical(bt.Indicator): lines = (\u0026#39;mfi\u0026#39;,) params = dict(period=14) def __init__(self): tprice = (self.data.close + self.data.low + self.data.high) / 3.0 mfraw = tprice * self.data.volume ...典型的实例化方式如下所示：\nMFI 典型实例化# class MyMFIStrategy(bt.Strategy): def __init__(self): mfi = bt.MFI_Canonical(self.data)这里的问题应该很明显： “需要为指标提供包含收盘价、最低价、最高价和成交量的输入（即在 backtrader 生态系统中的lines）”。\n当然，也可能有人希望使用来自不同数据源的组件来创建资金流动指标（例如来自数据源或其他指标的线）。例如，想要给收盘价赋予更多权重，而不需要开发一个特定的指标。考虑到行业标准的 OHLCV 数据字段顺序，支持多个输入并给收盘价加权的实例化可以是这样的：\nMFI 多输入实例化# class MyMFIStrategy2(bt.Strategy): def __init__(self): wclose = self.data.close * 5.0 mfi = bt.MFI_Canonical(self.data.high, self.data.low, wclose, self.data.volume)或者因为用户之前使用过 ta-lib 并喜欢多个输入的方式。\n支持多个输入# backtrader 尽量做到符合 Python 风格，并且系统中的 self.datas 数组（自动提供给策略的所有数据源）可以查询其长度。我们可以利用这一点来区分调用者的需求，并正确地计算 tprice 和 mfraw。\nMFI - 使用 len 的多个输入# class MFI_MultipleInputs(bt.Indicator): lines = (\u0026#39;mfi\u0026#39;,) params = dict(period=14) def __init__(self): if len(self.datas) == 1: # 传入一个数据源，必须包含各个组件 tprice = (self.data.close + self.data.low + self.data.high) / 3.0 mfraw = tprice * self.data.volume else: # 如果有多个数据源，按照 OHLCV 顺序传入每个组件 tprice = (self.data0 + self.data1 + self.data2) / 3.0 mfraw = tprice * self.data3 # 与之前的实现无变化 flowpos = bt.ind.SumN(mfraw * (tprice \u0026gt; tprice(-1)), period=self.p.period) flowneg = bt.ind.SumN(mfraw * (tprice \u0026lt; tprice(-1)), period=self.p.period) mfiratio = bt.ind.DivByZero(flowpos, flowneg, zero=100.0) self.l.mfi = 100.0 - 100.0 / (1.0 + mfiratio)注意# 注意如何引用各个组件，如 self.dataX（如 self.data0、self.data1）。\n这与使用 self.datas[x]（如 self.datas[0]）是一样的。\n接下来，让我们通过图形化展示该指标与传统实现的结果是否一致，尤其是在多个输入与数据源的原始组件相对应时。为此，我们将在策略中运行如下代码：\nMFI - 结果检查# class MyMFIStrategy2(bt.Strategy): def __init__(self): MFI_Canonical(self.data) MFI_MultipleInputs(self.data, plotname=\u0026#39;MFI 单输入\u0026#39;) MFI_MultipleInputs(self.data.high, self.data.low, self.data.close, self.data.volume, plotname=\u0026#39;MFI 多输入\u0026#39;)MFI 结果检查# 通过图示来看，三者的结果应该是相同的，而无需逐一检查每个值。\n最后，让我们看看如果加大收盘价的权重，会发生什么。我们这样运行：\nMFI - 5 倍收盘价# class MyMFIStrategy2(bt.Strategy): def __init__(self): MFI_MultipleInputs(self.data) MFI_MultipleInputs(self.data.high, self.data.low, self.data.close * 5.0, self.data.volume, plotname=\u0026#39;MFI 收盘价 * 5.0\u0026#39;)MFI 收盘价 * 5.0# 是否合理留给读者自行判断，但可以清楚地看到，通过增加收盘价的权重，图形模式发生了变化。\n结论# 通过简单地使用 Pythonic 风格的 len，我们可以将一个使用固定组件名称的数据源的指标转换为一个接受多个通用输入的指标。\n"},{"id":76,"href":"/backtrader/docs/10-broker/06-trade/","title":"Trade","section":"Broker","content":"Trade# 交易的定义：当一个工具的头寸从 0 变为一个大小X（多头/空头头寸分别为正/负）时，交易被认为是开启的。或是当一个头寸从X变为0时，交易被认为是关闭的。\n以下两种操作：\n从正变负 从负变正 实际上被视为：一个交易被关闭了（头寸从X变为0），一个新的交易被开启了（头寸从0变为Y）\n交易仅用于信息展示，用户无法调用其方法。\n参考# class backtrader.trade.Trade(data=None, tradeid=0, historyon=False, size=0, price=0.0, value=0.0, commission=0.0)追踪交易的生命周期：数量、价格、佣金（和价值？）。一个交易从0开始，可以增加和减少，如果回到0可以被认为是关闭的。交易可以是多头（正数）或空头（负数）。交易不支持反转（逻辑中不支持）\n成员属性 描述 ref 唯一的交易标识符 status Created, Open, Closed之一 tradeid 在创建订单时传递给订单的分组交易ID，订单的默认值为0 size 当前交易的数量 price 当前交易的价格 value 当前交易的价值 commission 当前累计的佣金 pnl 当前交易的盈亏（毛利） pnlcomm 当前交易的净盈亏（扣除佣金后的净利润） isclosed 记录最后一次更新是否关闭了交易（将交易数量设为零） isopen 记录任何更新是否开启了交易 justopened 如果交易刚刚开启 baropen 交易开启的bar dtopen 交易开启的浮点编码日期时间，使用 open_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barclose 交易关闭的bar dtclose 交易关闭的浮点编码日期时间，使用 close_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barlen 交易开启的bar数量 historyon 是否记录历史 history 包含每次“更新”事件更新后的状态和使用的参数的列表，历史记录的第一个条目是开启事件，最后一个条目是关闭事件 "},{"id":77,"href":"/backtrader/docs/03-quickstart/06-sell/","title":"卖出操作","section":"快速开始","content":"卖出操作# 了解如何进入市场（多头，self.buy）后，还要一个“退出概念”，以及了解策略是否在市场中。\n本节将演示入场后如何退出市场。\n退出逻辑很简单，入场持有 5 根 bar 后（在第 6 根 bar 上）退出，无论是盈利还是亏损。另外，为了简化逻辑，仅在未入场时允许买入订单，即如果有持仓或者进行中的订单都不可买入。\n逻辑逻辑# 要完成这个逻辑，要能确认订单成交时间、成交所在位置、当前是否有进行中的订单以及是否有持仓。\n订单状态# 订单确认状态通过 Strategy 的订单状态变化 notify_order 方法监听。\ndef notify_order(self, order): print(order.status)订单状态有 Accepted（已接受）、Submitted（已提交）、Completed（已成交）、Margin（保证金不足）、Rejected（已拒绝）。\n订单类中除了状态，还包括订单的其他信息，如执行价格 - order.executed.price，已执行价值 - order.executed.value，订单手续费 - order.executed.comm。\n更多订单的信息，可查看 订单- Orders。\n成交位置# 策略对象提供了对默认数据源位置的访问，通过 len(self) 即可获得。\nlen(self)next 方法没有提供 \u0026ldquo;bar索引\u0026rdquo;，因此很难理解何时经过了 5 根bar，但调用对象的 len 方法，它会告诉你线的长度。\n我们只需记下订单完成时的长度，并查看当前长度是否距离其5根bar。\ndef notify_order(self, order): if order.status in [order.Completed]: self.bar_executed = len(self) def next(self): # 其他代码 if len(self) \u0026gt;= (self.bar_executed + 5): # 卖出退场此处无 \u0026ldquo;时间\u0026rdquo; 或 \u0026ldquo;时间框架\u0026rdquo; 含义，仅仅是 bar 的数量。bar可以代表1分钟、1小时、1天、1周或任何其他时间周期。尽管我们知道数据源是每日的，但策略不对其做任何假设。\n进行中的订单# 是否有进行中的订单如何判断？\n我们调用买入和卖出方法会返回创建的（尚未执行的）订单。我们可记录创建后的订单，待最终确认后（即非提交中 Submitted 和订单被接受 Accepted）将其清空。而我们只要在每次交易前，检查是否有进行中的订单即可。\ndef notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return self.order = None def next(self): # 是否有进行中的订单 if self.order: return # 如果满足买入 self.order = self.buy() # 如果满足退出 self.order = self.sell()是否有持仓# 是否有持仓的判断比较简单，通过 self.position 即可判断。\nif not self.position: # 入场逻辑 else: # 出场逻辑完整示例# from __future__ import (absolute_import, division, print_function, unicode_literals) import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.log(\u0026#39;BUY EXECUTED, %.2f\u0026#39; % order.executed.price) elif order.issell(): self.log(\u0026#39;SELL EXECUTED, %.2f\u0026#39; % order.executed.price) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(\u0026#39;Order Canceled/Margin/Rejected\u0026#39;) self.order = None def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if self.order: return if not self.position: if self.dataclose[0] \u0026lt; self.dataclose[-1]: if self.dataclose[-1] \u0026lt; self.dataclose[-2]: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.buy() else: if len(self) \u0026gt;= (self.bar_executed + 5): self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.sell() if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(100000.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出：\nStarting Portfolio Value: 100000.00 2000-01-03, Close, 27.85 2000-01-04, Close, 25.39 2000-01-05, Close, 24.05 2000-01-05, BUY CREATE, 24.05 2000-01-06, BUY EXECUTED, 23.61 2000-01-06, Close, 22.63 2000-01-07, Close, 24.37 2000-01-10, Close, 27.29 2000-01-11, Close, 26.49 2000-01-12, Close, 24.90 2000-01-13, Close, 24.77 2000-01-13, SELL CREATE, 24.77 2000-01-14, SELL EXECUTED, 25.70 ... ... ... 2000-12-15, SELL CREATE, 26.93 2000-12-18, SELL EXECUTED, 28.29 2000-12-18, Close, 30.18 2000-12-19, Close, 28.88 2000-12-20, Close, 26.88 2000-12-20, BUY CREATE, 26.88 2000-12-21, BUY EXECUTED, 26.23 2000-12-21, Close, 27.82 2000-12-22, Close, 30.06 2000-12-26, Close, 29.17 2000-12-27, Close, 28.94 2000-12-28, Close, 29.29 2000-12-29, Close, 27.41 Final Portfolio Value: 100018.53现在，系统确实赚到了钱，恭喜我们又进了一步。\n"},{"id":78,"href":"/backtrader/docs/05-cerebro/06-logging-writer/","title":"日志 Logging - Writter","section":"Cerebro","content":"Writer# Writer类负责将以下内容写入流：\n数据源、策略、指标和观察者的CSV流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。\n属性摘要：\n数据源 策略（线条和参数） 指标/观察者（线条和参数） 分析器（参数和分析结果） 系统中定义了一个名为WriterFile的Writer，可以通过以下方式添加：\n设置Cerebro的writer参数为True，将实例化一个标准的WriterFile 调用Cerebro.addwriter(writerclass, **kwargs)，在回测执行期间，使用给定的kwargs实例化writerclass 由于标准的WriterFile默认不输出CSV，以下调用可以处理这一点：\ncerebro.addwriter(bt.WriterFile, csv=True)参考# class backtrader.WriterFile()# 系统范围内的Writer类。\n可以通过以下参数进行参数化：\n参数名 默认 说明 out sys.stdout 写入的输出流，如果传递的是字符串，将使用参数内容作为文件名。 close_out False 如果 out 是一个流，是否需要由Writer显式关闭。 csv False 在执行过程中，是否将数据源、策略、观察者和指标的CSV流写入输出流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。 csv_filternan True CSV流中清除nan值（用空字段替换）。 csv_counter True 是否应保持并输出实际输出行的计数器。 indent 2 每个级别的缩进空格数。 separators \u0026lsquo;=\u0026rsquo;, \u0026lsquo;-\u0026rsquo;, \u0026lsquo;+\u0026rsquo;, \u0026lsquo;*\u0026rsquo;, \u0026lsquo;.\u0026rsquo;, \u0026lsquo;~\u0026rsquo;, \u0026lsquo;\u0026quot;\u0026rsquo;, \u0026lsquo;^\u0026rsquo;, \u0026lsquo;#\u0026rsquo; 用于分隔部分/子部分的行分隔符字符。 seplen 79 包括缩进在内的行分隔符的总长度。 rounding None 将浮点数舍入到的小数位数。如果为None，则不执行舍入。 "},{"id":79,"href":"/backtrader/docs/09-orders/06-future-spot-compensation/","title":"期货和现货补偿","section":"Order","content":"期货和现货补偿# 版本 1.9.32.116 增加了对社区提出的一个有趣用例的支持：\n用期货启动交易，包括实物交割； 使用指标进行分析； 如有必要，通过操作现货价格来平仓，从而有效地取消实物交割，无论是收货还是交货（希望能获利） 期货在操作现货价格的当天到期 这意味着：\n平台接收来自两个不同资产的数据点 平台必须以某种方式理解这些资产是相关的，并且现货价格的操作将关闭在期货上开启的头寸 实际上，期货并未平仓，只是实物交割被补偿了 利用这种补偿概念，backtrader 增加了一种方式，让用户告知平台一个数据流上的操作将对另一个数据流产生补偿效果。使用模式如下：\nimport backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFavouriteDataFeed(dataname=\u0026#39;futurename\u0026#39;) cerebro.adddata(data0) data1 = bt.feeds.MyFavouriteDataFeed(dataname=\u0026#39;spotname\u0026#39;) data1.compensate(data0) # 告诉系统 data1 的操作会影响 data0 cerebro.adddata(data1) ... cerebro.run()综合示例# 一个示例胜过千言万语，所以让我们把所有的部分结合起来。\n使用 backtrader 源代码中的一个标准示例数据源。这将是期货数据 通过重新使用相同的数据源并添加一个随机移动价格的过滤器来模拟一个类似但不同的价格，从而创建价差。如下简单地实现： # 更改收盘价的过滤器 def close_changer(data, *args, **kwargs): data.close[0] += 50.0 * random.randint(-1, 1) return False # 数据流长度未变在同一轴上绘图会混淆默认包含的 BuyObserver 标记，因此将禁用标准观察者并手动重新添加以使用不同的数据标记。\n头寸将随机进入并在 10 天后退出。\n这并不匹配期货到期期限，但这只是为了实现功能，而不是检查交易日历。\n注意：\n如果要在期货到期日模拟现货价格的执行，需要激活“cheat-on-close”以确保订单在期货到期时执行。这在本示例中不需要，因为到期是随机选择的。 注意策略：\n买操作在 data0 上执行 卖操作在 data1 上执行 class St(bt.Strategy): def __init__(self): bt.obs.BuySell(self.data0, barplot=True) # 为不同数据添加不同标记 BuySellArrows(self.data1, barplot=True) # 为不同数据添加不同标记 def next(self): if not self.position: if random.randint(0, 1): self.buy(data=self.data0) self.entered = len(self) else: # 在市场中 if (len(self) - self.entered) \u0026gt;= 10: self.sell(data=self.data1)执行：# $ ./future-spot.py --no-comp得到如下图形输出。\n可以看到：\n买操作用向上的绿色三角形标记，图例显示它们属于 data0 卖操作用向下箭头标记，图例显示它们属于 data1 即使在 data0 上打开头寸并在 data1 上平仓，也能实现交易的闭合，达到了避免实物交割的效果。\n我们可以想象，如果不进行补偿，同样的逻辑会发生什么。让我们试试：\n$ ./future-spot.py --no-comp这会惨败：\n逻辑期望 data0 上的头寸通过 data1 的操作平仓，并且只有在市场不在时才在 data0 上开仓 但是补偿被禁用，data0 上的初始操作（绿色三角形）从未平仓，因此无法发起其他操作，data1 上的空头头寸开始累积。 示例用法：# $ ./future-spot.py --help usage: future-spot.py [-h] [--no-comp] Compensation example optional arguments: -h, --help show this help message and exit --no-comp示例代码：# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import random import backtrader as bt # 更改收盘价的过滤器 def close_changer(data, *args, **kwargs): data.close[0] += 50.0 * random.randint(-1, 1) return False # 数据流长度未变 # 重写标准标记 class BuySellArrows(bt.observers.BuySell): plotlines = dict(buy=dict(marker=\u0026#39;$\\u21E7$\u0026#39;, markersize=12.0), sell=dict(marker=\u0026#39;$\\u21E9$\u0026#39;, markersize=12.0)) class St(bt.Strategy): def __init__(self): bt.obs.BuySell(self.data0, barplot=True) # 为不同数据添加不同标记 BuySellArrows(self.data1, barplot=True) # 为不同数据添加不同标记 def next(self): if not self.position: if random.randint(0, 1): self.buy(data=self.data0) self.entered = len(self) else: # 在市场中 if (len(self) - self.entered) \u0026gt;= 10: self.sell(data=self.data1) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() dataname = \u0026#39;../../datas/2006-day-001.txt\u0026#39; # 数据源 data0 = bt.feeds.BacktraderCSVData(dataname=dataname, name=\u0026#39;data0\u0026#39;) cerebro.adddata(data0) data1 = bt.feeds.BacktraderCSVData(dataname=dataname, name=\u0026#39;data1\u0026#39;) data1.addfilter(close_changer) if not args.no_comp: data1.compensate(data0) data1.plotinfo.plotmaster = data0 cerebro.adddata(data1) cerebro.addstrategy(St) # 示例策略 cerebro.addobserver(bt.obs.Broker) # 以下两行在 stdstats=False 时被移除 cerebro.addobserver(bt.obs.Trades) cerebro.broker.set_coc(True) cerebro.run(stdstats=False) # 执行 cerebro.plot(volume=False) # 绘图 def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=(\u0026#39;Compensation example\u0026#39;)) parser.add_argument(\u0026#39;--no-comp\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":80,"href":"/backtrader/docs/06-datafeed/06-datafeed-resampling/","title":"重采样","section":"DataFeed","content":"重采样# 当数据只有单一时间框架可用，而分析要在不同时间框架上进行，就需要进行数据重采样。\u0026ldquo;重采样\u0026rdquo; 实际应称为 \u0026ldquo;上采样\u0026rdquo;，因为它是从源时间框架到更大的时间框架（如：从天到周）。\nBacktrader 内置了通过过滤器对象进行重采样的支持。有几种方法可以实现这一点，但有一个简单的接口可以实现，它代替通过 cerebro.adddata(data) 将数据放入系统中，使用 resampledata。\ncerebro.resampledata(data, **kwargs)有两个主要选项可以控制：\n更改时间框架 压缩条数 要实现这些功能，请在调用resampledata时使用以下参数：\ntimeframe（默认值：bt.TimeFrame.Days）：目标时间框架，必须等于或大于源时间框架。 compression（默认值：1）：将选定的值“n”压缩为1个条。 让我们来看一个从每日到每周的示例，通过手工编写的脚本：\n$ ./resampling-example.py --timeframe weekly --compression 1我们可以将其与原始每日数据进行比较：\n$ ./resampling-example.py --timeframe daily --compression 1实现这些功能的步骤有：\n先用 cerebro.adddata 加载原始数据； 使用带参数的resampledata 传递数据给cerebro：timeframe 和 compression； 示例代码：\n# 加载数据 datapath = args.dataname or \u0026#39;../../datas/2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=datapath) # 方便的字典用于时间框架参数转换 tframes = dict( daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 添加重采样数据而不是原始数据 cerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression)假设，将时间框架从每日更改为每周，然后将 3 条压缩为 1 条。\n$ ./resampling-example.py --timeframe weekly --compression 3从原始的 256 个每日 Bar 中，最终得到 18 个 3 周的 Bar。因为一年是 52 周，而 52 / 3 = 17.33，因此有18个 Bar。\n重采样过滤器支持其他参数，在大多数情况下不需要更改：\n参数名 默认值 描述 bar2edge True 使用时间边界作为目标。例如，对于“ticks -\u0026gt; 5 seconds”，生成的5秒条将对齐到xx:00、xx:05、xx:10…… adjbartime True 使用边界的时间调整重采样条的时间，而不是最后看到的时间戳。例如，对于重采样到“5 seconds”，条的时间将调整为hh:MM:05，即使最后看到的时间戳是hh:MM:04.33。注意： 只有当 bar2edge 为True时，才会调整时间。如果条没有对齐到边界，调整时间没有意义。 rightedge True 使用时间边界的右边缘设置时间。- 如果为False，并且压缩到5秒，重采样条的时间将在hh:MM:00和hh:MM:04之间。 -如果为True，使用的时间边界为hh:MM:05。 boundoff 0 将重采样/重放边界前移一个单位。例如，从1分钟重采样到15分钟，默认行为是从00:01:00到00:15:00生成一个15分钟重放/重采样条。如果boundoff设置为1，则边界向前推1个单位。在这种情况下，原始单位是1分钟条。因此，重采样/重放将使用00:00:00到00:14:00的条生成15分钟条。 重采样测试脚本示例代码：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import backtrader as bt import backtrader.feeds as btfeeds def runstrat(): args = parse_args() # 创建 cerebro 实体 cerebro = bt.Cerebro(stdstats=False) # 添加策略 cerebro.addstrategy(bt.Strategy) # 加载数据 datapath = args.dataname or \u0026#39;../../datas/2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=datapath) # 方便的字典用于时间框架参数转换 tframes = dict( daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 添加重采样数据而不是原始数据 cerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression) # 运行所有内容 cerebro.run() # 绘制结果 cerebro.plot(style=\u0026#39;bar\u0026#39;) def parse_args(): parser = argparse.ArgumentParser( description=\u0026#39;Pandas test script\u0026#39;) parser.add_argument(\u0026#39;--dataname\u0026#39;, default=\u0026#39;\u0026#39;, required=False, help=\u0026#39;要加载的文件数据\u0026#39;) parser.add_argument(\u0026#39;--timeframe\u0026#39;, default=\u0026#39;weekly\u0026#39;, required=False, choices=[\u0026#39;daily\u0026#39;, \u0026#39;weekly\u0026#39;, \u0026#39;monthly\u0026#39;], help=\u0026#39;要重采样到的时间框架\u0026#39;) parser.add_argument(\u0026#39;--compression\u0026#39;, default=1, required=False, type=int, help=\u0026#39;将n个条压缩为1个\u0026#39;) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":81,"href":"/backtrader/docs/03-quickstart/07-commission/","title":"交易监控","section":"快速开始","content":"交易监控# 我们已经知道如何使用 backtrader 买卖交易了。本节将介绍 backtrader 如何监控它每笔交易，如成本、利润和佣金。由于佣金的存在，利润还分为毛利润和净利润\n设置佣金# 让我们先设置一个合理佣金率 - 0.1% （买入和卖出都要收取的），一行代码即可。\n# 0.1% ... 除以 100 以去掉百分号 cerebro.broker.setcommission(commission=0.001)订单的成本和佣金# 订单的成本和佣金可从订单回调 notify_order 中获取，它的 Order 参数 order.executed.comm 即为订单的已执行佣金，order.executed.value 即投入的成本。\nclass TestStrategy(bt.Strategy): def notify_order(self, order): if order.status in [order.Completed]: if order.isbuy(): self.log( \u0026#39;买入执行，价格：%.2f，成本：%.2f，佣金 %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: self.log(\u0026#39;卖出执行，价格：%.2f，成本：%.2f，佣金 %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm))交易记录计算利润# 对于利润的计算，使用交易记录会更简单，所谓成交记录，即成交撮合一笔记录一次。与订单类似，我们可通过 notify_trade 获取成交记录。它的回调参数是 Trade 类对象，利润相关属性有 trade.pnl（毛利润）和 trade.pnlcomm（净利润）。\nclass TestStrategy(bt.Strategy): def notify_trade(self, trade): if not trade.isclosed: return self.log(\u0026#39;利润记录，毛利润 %.2f，净利润 %.2f\u0026#39; % (trade.pnl, trade.pnlcomm))因为只有是平仓交易，才有利润的说法，故通过 trade.isclosed 判断在平仓交易的情况才输出利润信息。\n完整示例# import datetime import os.path import sys import backtrader as bt class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None self.buyprice = None self.buycomm = None def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.log( \u0026#39;买入执行，价格：%.2f，成本：%.2f，佣金 %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: self.log(\u0026#39;卖出执行，价格：%.2f，成本：%.2f，佣金 %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(\u0026#39;订单取消/保证金不足/拒绝\u0026#39;) self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(\u0026#39;利润记录，毛利润 %.2f，净利润 %.2f\u0026#39; % (trade.pnl, trade.pnlcomm)) def next(self): self.log(\u0026#39;收盘价，%.2f\u0026#39; % self.dataclose[0]) if self.order: return if not self.position: if self.dataclose[0] \u0026lt; self.dataclose[-1]: if self.dataclose[-1] \u0026lt; self.dataclose[-2]: self.log(\u0026#39;创建买入订单，%.2f\u0026#39; % self.dataclose[0]) self.order = self.buy() else: if len(self) \u0026gt;= (self.bar_executed + 5): self.log(\u0026#39;创建卖出订单，%.2f\u0026#39; % self.dataclose[0]) self.order = self.sell() if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;./datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(100000.0) cerebro.broker.setcommission(commission=0.001) print(\u0026#39;初始投资组合价值：%.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;最终投资组合价值：%.2f\u0026#39; % cerebro.broker.getvalue())执行后的输出是：\n初始投资组合价值：100000.00 2000-01-03T00:00:00, 收盘价，27.85 2000-01-04T00:00:00, 收盘价，25.39 2000-01-05T00:00:00, 收盘价，24.05 2000-01-05T00:00:00, 创建买入订单，24.05 2000-01-06T00:00:00, 买入执行，价格：23.61，成本：23.61，佣金 0.02 2000-01-06T00:00:00, 收盘价，22.63 2000-01-07T00:00:00, 收盘价，24.37 2000-01-10T00:00:00, 收盘价，27.29 2000-01-11T00:00:00, 收盘价，26.49 2000-01-12T00:00:00, 收盘价，24.90 2000-01-13T00:00:00, 收盘价，24.77 2000-01-13T00:00:00, 创建卖出订单，24.77 2000-01-14T00:00:00, 卖出执行，价格：25.70，成本：25.70，佣金 0.03 2000-01-14T00:00:00, 利润记录，毛利润 2.09，净利润 2.04 2000-01-14T00:00:00, 收盘价，25.18 ... ... ... 2000-12-15T00:00:00, 创建卖出订单，26.93 2000-12-18T00:00:00, 卖出执行，价格：28.29，成本：28.29，佣金 0.03 2000-12-18T00:00:00, 利润记录，毛利润 -0.06，净利润 -0.12 2000-12-18T00:00:00, 收盘价，30.18 2000-12-19T00:00:00, 收盘价，28.88 2000-12-20T00:00:00, 收盘价，26.88 2000-12-20T00:00:00, 创建买入订单，26.88 2000-12-21T00:00:00, 买入执行，价格：26.23，成本：26.23，佣金 0.03 2000-12-21T00:00:00, 收盘价，27.82 2000-12-22T00:00:00, 收盘价，30.06 2000-12-26T00:00:00, 收盘价，29.17 2000-12-27T00:00:00, 收盘价，28.94 2000-12-28T00:00:00, 收盘价，29.29 2000-12-29T00:00:00, 收盘价，27.41 2000-12-29T00:00:00, 创建卖出订单，27.41 最终投资组合价值：100016.98让我们将其中的 \u0026ldquo;利润记录\u0026rdquo; 的日志提取出来。\n2000-01-14T00:00:00, 利润记录，毛利润 2.09，净利润 2.04 2000-02-07T00:00:00, 利润记录，毛利润 3.68，净利润 3.63 2000-02-28T00:00:00, 利润记录，毛利润 4.48，净利润 4.42 2000-03-13T00:00:00, 利润记录，毛利润 3.48，净利润 3.41 2000-03-22T00:00:00, 利润记录，毛利润 -0.41，净利润 -0.49 2000-04-07T00:00:00, 利润记录，毛利润 2.45，净利润 2.37 2000-04-20T00:00:00, 利润记录，毛利润 -1.95，净利润 -2.02 2000-05-02T00:00:00, 利润记录，毛利润 5.46，净利润 5.39 2000-05-11T00:00:00, 利润记录，毛利润 -3.74，净利润 -3.81 2000-05-30T00:00:00, 利润记录，毛利润 -1.46，净利润 -1.53 2000-07-05T00:00:00, 利润记录，毛利润 -1.62，净利润 -1.69 2000-07-14T00:00:00, 利润记录，毛利润 2.08，净利润 2.01 2000-07-28T00:00:00, 利润记录，毛利润 0.14，净利润 0.07 2000-08-08T00:00:00, 利润记录，毛利润 4.36，净利润 4.29 2000-08-21T00:00:00, 利润记录，毛利润 1.03，净利润 0.95 2000-09-15T00:00:00, 利润记录，毛利润 -4.26，净利润 -4.34 2000-09-27T00:00:00, 利润记录，毛利润 1.29，净利润 1.22 2000-10-13T00:00:00, 利润记录，毛利润 -2.98，净利润 -3.04 2000-10-26T00:00:00, 利润记录，毛利润 3.01，净利润 2.95 2000-11-06T00:00:00, 利润记录，毛利润 -3.59，净利润 -3.65 2000-11-16T00:00:00, 利润记录，毛利润 1.28，净利润 1.23 2000-12-01T00:00:00, 利润记录，毛利润 2.59，净利润 2.54 2000-12-18T00:00:00, 利润记录，毛利润 -0.06，净利润 -0.12将这些 \u0026ldquo;净利润\u0026rdquo; 相加，最终的数字是 15.83。但系统告诉我们最终投资组合价值是 100016.98。显然，15.83 并不等于 16.98。\n这其实并没有任何错误，净利润 15.83 是已平仓的交易利润。而最后一天实际还有一个未平仓头寸。虽然已发送了卖出操作，还要等待下个 bar 才能成交。最终投资组合价值止于 2000-12-29 的收盘价。这个订单的成交价格将会在下一个交易日（即 2001-01-02）被设定。\n假设，我们将数据源提供到下一个交易日。\n2001-01-02T00:00:00, 卖出执行，价格：27.87，成本：27.87，佣金 0.03 2001-01-02T00:00:00, 利润记录，毛利润 1.64，净利润 1.59 2001-01-02T00:00:00, 收盘价，24.87 2001-01-02T00:00:00, 创建买入订单，24.87 最终投资组合价值：100017.41现在将先前的净利润与已完成操作的净利润相加：\n15.83 + 1.59 = 17.42忽略四舍五入的误差，现在一切就对上了。\n"},{"id":82,"href":"/backtrader/docs/06-datafeed/07-datafeed-replay/","title":"数据回放","section":"DataFeed","content":"数据回放# 随着时间的推移，单纯对已经完成关闭的 Bar 进行策略测试已不再足够，数据回放应运而生。假设，策略在时间框架X上操作（例如：每日），数据在更小的时间框架Y（例如：1分钟）可用。\n数据回放的作用正如其名，使用1分钟数据回放每日条。虽然，这并不能完全再现市场发展，但比单独观察每日完成关闭的 Bar 要好得多。如果策略在每日 Bar 形成期间实时操作，那么近似 Bar 形成过程模拟策略在实际条件下的表现。\n要实现数据回放，只按常规使用 backtrader 即可。\n加载数据源； 使用 replaydata 将数据传递给cerebro； 添加策略； 注意： 数据回放不支持预加载，因为每个 Bar 实际上是实时构建的，任何 Cerebro 实例中都会自动禁用预加载。\n可传递给replaydata的参数：\n参数 默认值 描述 timeframe bt.TimeFrame.Days 目标时间框架，必须等于或大于源时间框架 compression 1 将选定值“n”压缩为1条 扩展参数（若无特别需要请勿修改）：\n参数 默认值 描述 bar2edge True 使用时间边界作为闭合条的目标。例如，使用“ticks -\u0026gt; 5 seconds”时，生成的5秒条将对齐到xx:00、xx:05、xx:10…… adjbartime False 使用边界的时间调整传递的重采样条的时间，而不是最后看到的时间戳。 rightedge True 使用时间边界的右边缘设置时间。 举例说明，标准的 2006 年每日数据在每周基础上进行回放。\n最终会有 52 个 Bar，即每周一个； Cerebro 将调用 prenext 和 next 共计255次，这是原始数量每日 Bar； 诀窍在于：\n在每周 Bar 形成时，策略的长度（len(self)）保持不变。 每过一周，长度增加1。 以下是示例，但首先是测试脚本的主要部分，其中加载数据并将其传递给cerebro进行回放，然后运行。\n# 加载数据 datapath = args.dataname or \u0026#39;../../datas/2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=datapath) # 方便的字典用于时间框架参数转换 tframes = dict( daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 首先添加原始数据 - 较小的时间框架 cerebro.replaydata(data, timeframe=tframes[args.timeframe], compression=args.compression)示例 - 每日回放至每周# 脚本调用：\n$ ./replay-example.py --timeframe weekly --compression 1图表无法显示后台实际发生的情况，因此我们来看一下控制台输出：\nprenext len 1 - counter 1 prenext len 1 - counter 2 prenext len 1 - counter 3 prenext len 1 - counter 4 prenext len 1 - counter 5 prenext len 2 - counter 6 ... prenext len 9 - counter 44 prenext len 9 - counter 45 ---next len 10 - counter 46 ---next len 10 - counter 47 ---next len 10 - counter 48 ---next len 10 - counter 49 ---next len 10 - counter 50 ---next len 11 - counter 51 ---next len 11 - counter 52 ---next len 11 - counter 53 ... ---next len 51 - counter 248 ---next len 51 - counter 249 ---next len 51 - counter 250 ---next len 51 - counter 251 ---next len 51 - counter 252 ---next len 52 - counter 253 ---next len 52 - counter 254 ---next len 52 - counter 255我们看到内部的 self.counter 变量跟踪每次调用 prenext 或 next。前者在应用的简单移动平均线（SMA）产生值之前调用。后者在SMA产生值时调用。\n策略的长度（len(self)）每5条（每周5个交易日）变化一次。 策略实际上看到的是每周条在5次更新中的发展。 这并不能完全再现市场的实际逐秒（甚至分钟、小时）的发展，但比实际观察一个条要好。\n视觉输出是每周图表，这是系统测试的最终结果。\n示例2 - 每日到每日带压缩# 当然，“回放”也可以应用于相同时间框架，但带有压缩。\n控制台：\n$ ./replay-example.py --timeframe daily --compression 2 prenext len 1 - counter 1 prenext len 1 - counter 2 prenext len 2 - counter 3 prenext len 2 - counter 4 prenext len 3 - counter 5 prenext len 3 - counter 6 prenext len 4 - counter 7 ... ---next len 125 - counter 250 ---next len 126 - counter 251 ---next len 126 - counter 252 ---next len 127 - counter 253 ---next len 127 - counter 254 ---next len 128 - counter 255这次我们得到了预期的一半条数，因为请求了2倍压缩。\n结论# 可以重建市场发展。通常有可用的更小时间框架数据，可以用于离散地回放系统操作的时间框架。\n测试脚本如下：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import backtrader as bt import backtrader.feeds as btfeeds import backtrader.indicators as btind class SMAStrategy(bt.Strategy): params = ( (\u0026#39;period\u0026#39;, 10), (\u0026#39;onlydaily\u0026#39;, False), ) def __init__(self): self.sma = btind.SMA(self.data, period=self.p.period) def start(self): self.counter = 0 def prenext(self): self.counter += 1 print(\u0026#39;prenext len %d - counter %d\u0026#39; % (len(self), self.counter)) def next(self): self.counter += 1 print(\u0026#39;---next len %d - counter %d\u0026#39; % (len(self), self.counter)) def runstrat(): args = parse_args() # 创建 cerebro 实体 cerebro = bt.Cerebro(stdstats=False) cerebro.addstrategy( SMAStrategy, # 策略参数 period=args.period, ) # 加载数据 datapath = args.dataname or \u0026#39;../../datas/2006-day-001.txt\u0026#39; data = btfeeds.BacktraderCSVData(dataname=datapath) # 方便的字典用于时间框架参数转换 tframes = dict( daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 首先添加原始数据 - 较小的时间框架 cerebro.replaydata(data, timeframe=tframes[args.timeframe], compression=args.compression) # 运行所有内容 cerebro.run() # 绘制结果 cerebro.plot(style=\u0026#39;bar\u0026#39;) def parse_args(): parser = argparse.ArgumentParser( description=\u0026#39;Pandas test script\u0026#39;) parser.add_argument(\u0026#39;--dataname\u0026#39;, default=\u0026#39;\u0026#39;, required=False, help=\u0026#39;要加载的文件数据\u0026#39;) parser.add_argument(\u0026#39;--timeframe\u0026#39;, default=\u0026#39;weekly\u0026#39;, required=False, choices=[\u0026#39;daily\u0026#39;, \u0026#39;weekly\u0026#39;, \u0026#39;monthly\u0026#39;], help=\u0026#39;要重采样到的时间框架\u0026#39;) parser.add_argument(\u0026#39;--compression\u0026#39;, default=1, required=False, type=int, help=\u0026#39;将n个条压缩为1个\u0026#39;) parser.add_argument(\u0026#39;--period\u0026#39;, default=10, required=False, type=int, help=\u0026#39;应用于指标的周期\u0026#39;) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":83,"href":"/backtrader/docs/09-orders/07-stop-trails/","title":"跟踪止损（限价）","section":"Order","content":"跟踪止损（限价）# 版本 1.9.35.116 增加了跟踪止损和跟踪止损限价订单执行类型到回测工具中。\n注意，这只在回测中实现，尚未在实时经纪商中实现\n注意，更新至版本 1.9.36.116。Interactive Brokers 支持跟踪止损、跟踪止损限价和 OCO。\nOCO 始终将组中的第一个订单指定为参数 oco\n跟踪止损限价：经纪商模拟和 IB 经纪商具有相同的行为。指定：price 作为初始止损触发价格（也指定 trailamount），然后 plimit 作为初始限价。两者之间的差值将决定 limitoffset（限价与止损触发价格之间的距离）\n使用模式完全集成到策略实例的标准买、卖和平仓市场操作方法中。需要注意：\n指明所需的执行类型，如 exectype=bt.Order.StopTrail\n以及跟踪价格是否需要用固定距离或百分比距离计算\n固定距离：trailamount=10\n百分比距离：trailpercent=0.02（即：2%）\n如果通过发出买单进入市场多头，那么带有 StopTrail 和 trailamount 的卖单会这样做：\n如果未指定价格，则使用最新的收盘价\n从价格中减去 trailamount 以找到止损（或触发）价格\n经纪商的下一次迭代检查是否触及触发价格\n如果是：订单将以市场执行类型的方式执行\n如果否，使用最新的收盘价重新计算止损价格，并减去 trailamount 距离\n如果新价格上涨，则更新\n如果新价格下跌（或不变），则忽略\n也就是说：跟踪止损价格随着价格上涨而跟随，但如果价格开始下跌则保持不变，以潜在地确保利润。\n如果进入市场时发出的是卖单，那么发出带 StopTrail 的买单会执行相反的操作，即：价格会向下跟随。\n一些使用模式\n# 对于向下的跟踪止损 # 将使用最后价格作为参考 self.buy(size=1, exectype=bt.Order.StopTrail, trailamount=0.25) # 或 self.buy(size=1, exectype=bt.Order.StopTrail, price=10.50, trailamount=0.25) # 对于向上的跟踪止损 # 将使用最后价格作为参考 self.sell(size=1, exectype=bt.Order.StopTrail, trailamount=0.25) # 或 self.sell(size=1, exectype=bt.Order.StopTrail, price=10.50, trailamount=0.25)也可以指定 trailpercent 而不是 trailamount，并将距离价格的距离计算为价格的百分比\n# 对于 2% 距离的向下跟踪止损 # 将使用最后价格作为参考 self.buy(size=1, exectype=bt.Order.StopTrail, trailpercent=0.02) # 或 self.buy(size=1, exectype=bt.Order.StopTrail, price=10.50, trailpercent=0.02) # 对于 2% 距离的向上跟踪止损 # 将使用最后价格作为参考 self.sell(size=1, exectype=bt.Order.StopTrail, trailpercent=0.02) # 或 self.sell(size=1, exectype=bt.Order.StopTrail, price=10.50, trailpercent=0.02)对于跟踪止损限价\n唯一的区别在于触发跟踪止损价格时发生的事情。\n在这种情况下，订单作为限价订单执行（与 StopLimit 订单具有相同的行为，但此时触发价格是动态的）\n注意：必须指定 plimit=x.x 来买入或卖出，这将是限价\n注意：限价不会像止损/触发价格那样动态变化\n示例总是胜过千言万语，因此这里有一个 backtrader 的常规示例，它\n使用均线向上交叉进入市场多头 使用跟踪止损退出市场 执行时固定价格距离为 50 点\n$ ./trail.py --plot --strat trailamount=50.0以及以下输出：\n************************************************** 2005-02-14,3075.76,3025.76,3025.76 ---------- 2005-02-15,3086.95,3036.95,3036.95 2005-02-16,3068.55,3036.95,3018.55 2005-02-17,3067.34,3036.95,3017.34 2005-02-18,3072.04,3036.95,3022.04 2005-02-21,3063.64,3036.95,3013.64 ... ... ************************************************** 2005-05-19,3051.79,3001.79,3001.79 ---------- 2005-05-20,3050.45,3001.79,3000.45 2005-05-23,3070.98,3020.98,3020.98 2005-05-24,3066.55,3020.98,3016.55 2005-05-25,3059.84,3020.98,3009.84 2005-05-26,3086.08,3036.08,3036.08 2005-05-27,3084.0,3036.08,3034.0 2005-05-30,3096.54,3046.54,3046.54 2005-05-31,3076.75,3046.54,3026.75 2005-06-01,3125.88,3075.88,3075.88 2005-06-02,3131.03,3081.03,3081.03 2005-06-03,3114.27,3081.03,3064.27 2005-06-06,3099.2,3081.03,3049.2 2005-06-07,3134.82,3084.82,3084.82 2005-06-08,3125.59,3084.82,3075.59 2005-06-09,3122.93,3084.82,3072.93 2005-06-10,3143.85,3093.85,3093.85 2005-06-13,3159.83,3109.83,3109.83 2005-06-14,3162.86,3112.86,3112.86 2005-06-15,3147.55,3112.86,3097.55 2005-06-16,3160.09,3112.86,3110.09 2005-06-17,3178.48,3128.48,3128.48 2005-06-20,3162.14,3128.48,3112.14 2005-06-21,3179.62,3129.62,3129.62 2005-06-22,3182.08,3132.08,3132.08 2005-06-23,3190.8,3140.8,3140.8 2005-06-24,3161.0,3140.8,3111.0 ... ... ... ************************************************** 2006-12-19,4100.48,4050.48,4050.48 ---------- 2006-12-20,4118.54,4068.54,4068.54 2006-12-21,4112.1,4068.54,4062.1 2006-12-22,4073.5,4068.54,4023.5 2006-12-27,4134.86,4084.86,4084.86 2006-12-28,4130.66,4084.86,4080.66 2006-12-29,4119.94,4084.86,4069.94而不是等待通常的向下交叉模式，系统使用跟踪止损退出市场。让我们看看第一个操作，例如：\n进入多头时的收盘价：3075.76 系统计算的跟踪止损价格：3025.76（距离为 50 个单位） 示例计算的跟踪止损价格：3025.76（每行显示的最后一个价格） 在第一次计算之后：\n收盘价上涨到 3086.95，止损价格调整为 3036.95 随后的收盘价没有超过 3086.95，触发价格不变 其他两个操作\n中可以看到相同的模式。\n为了比较，执行时固定距离为 30 点（仅图表）\n$ ./trail.py --plot --strat trailamount=30.0图表如下：\n最后一次执行 trailpercent=0.02\n$ ./trail.py --plot --strat trailpercent=0.02示例用法# $ ./trail.py --help usage: trail.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] StopTrail Sample optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: ../../datas/2005-2006-day-001.txt) --fromdate FROMDATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --todate TODATE Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: ) --cerebro kwargs kwargs in key=value format (default: ) --broker kwargs kwargs in key=value format (default: ) --sizer kwargs kwargs in key=value format (default: ) --strat kwargs kwargs in key=value format (default: ) --plot [kwargs] kwargs in key=value format (default: )示例代码# from __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import datetime import backtrader as bt class St(bt.Strategy): params = dict( ma=bt.ind.SMA, p1=10, p2=30, stoptype=bt.Order.StopTrail, trailamount=0.0, trailpercent=0.0, ) def __init__(self): ma1, ma2 = self.p.ma(period=self.p.p1), self.p.ma(period=self.p.p2) self.crup = bt.ind.CrossUp(ma1, ma2) self.order = None def next(self): if not self.position: if self.crup: o = self.buy() self.order = None print(\u0026#39;*\u0026#39; * 50) elif self.order is None: self.order = self.sell(exectype=self.p.stoptype, trailamount=self.p.trailamount, trailpercent=self.p.trailpercent) if self.p.trailamount: tcheck = self.data.close - self.p.trailamount else: tcheck = self.data.close * (1.0 - self.p.trailpercent) print(\u0026#39;,\u0026#39;.join( map(str, [self.datetime.date(), self.data.close[0], self.order.created.price, tcheck]) ) ) print(\u0026#39;-\u0026#39; * 10) else: if self.p.trailamount: tcheck = self.data.close - self.p.trailamount else: tcheck = self.data.close * (1.0 - self.p.trailpercent) print(\u0026#39;,\u0026#39;.join( map(str, [self.datetime.date(), self.data.close[0], self.order.created.price, tcheck]) ) ) def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() # Data feed kwargs kwargs = dict() # Parse from/to-date dtfmt, tmfmt = \u0026#39;%Y-%m-%d\u0026#39;, \u0026#39;T%H:%M:%S\u0026#39; for a, d in ((getattr(args, x), x) for x in [\u0026#39;fromdate\u0026#39;, \u0026#39;todate\u0026#39;]): if a: strpfmt = dtfmt + tmfmt * (\u0026#39;T\u0026#39; in a) kwargs[d] = datetime.datetime.strptime(a, strpfmt) # Data feed data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs) cerebro.adddata(data0) # Broker cerebro.broker = bt.brokers.BackBroker(**eval(\u0026#39;dict(\u0026#39; + args.broker + \u0026#39;)\u0026#39;)) # Sizer cerebro.addsizer(bt.sizers.FixedSize, **eval(\u0026#39;dict(\u0026#39; + args.sizer + \u0026#39;)\u0026#39;)) # Strategy cerebro.addstrategy(St, **eval(\u0026#39;dict(\u0026#39; + args.strat + \u0026#39;)\u0026#39;)) # Execute cerebro.run(**eval(\u0026#39;dict(\u0026#39; + args.cerebro + \u0026#39;)\u0026#39;)) if args.plot: # Plot if requested to cerebro.plot(**eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;)) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=( \u0026#39;StopTrail Sample\u0026#39; ) ) parser.add_argument(\u0026#39;--data0\u0026#39;, default=\u0026#39;../../datas/2005-2006-day-001.txt\u0026#39;, required=False, help=\u0026#39;Data to read in\u0026#39;) # Defaults for dates parser.add_argument(\u0026#39;--fromdate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--todate\u0026#39;, required=False, default=\u0026#39;\u0026#39;, help=\u0026#39;Date[time] in YYYY-MM-DD[THH:MM:SS] format\u0026#39;) parser.add_argument(\u0026#39;--cerebro\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add_argument(\u0026#39;--broker\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add.argument(\u0026#39;--sizer\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add.argument(\u0026#39;--strat\u0026#39;, required=False, default=\u0026#39;\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) parser.add.argument(\u0026#39;--plot\u0026#39;, required=False, default=\u0026#39;\u0026#39;, nargs=\u0026#39;?\u0026#39;, const=\u0026#39;{}\u0026#39;, metavar=\u0026#39;kwargs\u0026#39;, help=\u0026#39;kwargs in key=value format\u0026#39;) return parser.parse_args(pargs) if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":84,"href":"/backtrader/docs/03-quickstart/08-parameters/","title":"参数定义","section":"快速开始","content":"参数定义# 前面的案例中，参数都是硬编码在策略中。本节将介绍如何在 backtrader 自定义参数。\n定义参数# 策略参数的定义非常简单，如在策略中定义两个参数：myparam 和 exitbars。\nclass TestStrategy: params = ((\u0026#39;myparam\u0026#39;, 27), (\u0026#39;exitbars\u0026#39;, 5),)参数 myparam 的默认值是 27，exitbars 的默认值是 5。\n配置参数# 我们可以在添加策略时修改参数默认值。\n# Add a strategy cerebro.addstrategy(TestStrategy, myparam=20, exitbars=7)使用参数# 策略代码中直接通过 self.params.param_name 即可调用参数。\n如下代码，通过参数 exitbars 修改退出逻辑：\nif len(self) \u0026gt;= (self.bar_executed + self.params.exitbars):完整示例# import backtrader as bt class TestStrategy(bt.Strategy): params = ( (\u0026#39;exitbars\u0026#39;, 5), ) def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None self.buyprice = None self.buycomm = None def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.log(\u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(\u0026#39;Order Canceled/Margin/Rejected\u0026#39;) self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(\u0026#39;OPERATION PROFIT, GROSS %.2f, NET %.2f\u0026#39; % (trade.pnl, trade.pnlcomm)) def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if self.order: return if not self.position: if self.dataclose[0] \u0026lt; self.dataclose[-1]: if self.dataclose[-1] \u0026lt; self.dataclose[-2]: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.buy() else: if len(self) \u0026gt;= (self.bar_executed + self.params.exitbars): self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.sell()"},{"id":85,"href":"/backtrader/docs/06-datafeed/08-datafeed-rollover/","title":"数据滚动","section":"DataFeed","content":"滚动# 并非所有提供商都提供连续期货合约数据。有时提供的数据是仍在交易的到期合约的有效数据。这种情况下，进行回测会变得很不方便，因为数据分散在多个不同的合约上，并且这些合约还会在时间上重叠。\n如果能够正确地将这些过去的合约数据连接成一个连续的数据流，可以缓解这种痛苦。问题在于：\n没有一种最佳方法将不同到期日期的数据连接成一个连续的期货数据 有些文献，如 SierraChart的文章 滚动数据源# 从backtrader 1.8.10.99开始，增加了将不同到期日期的期货数据连接成连续期货的功能：\nimport backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFeed(dataname=\u0026#39;Expiry0\u0026#39;) data1 = bt.feeds.MyFeed(dataname=\u0026#39;Expiry1\u0026#39;) ... dataN = bt.feeds.MyFeed(dataname=\u0026#39;ExpiryN\u0026#39;) drollover = cerebro.rolloverdata(data0, data1, ..., dataN, name=\u0026#39;MyRoll\u0026#39;, **kwargs) cerebro.run() 注意：\n**kwargs将在下文解释 也可以直接访问RollOver数据源（如果需要子类化，这是很有帮助的）： import backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFeed(dataname=\u0026#39;Expiry0\u0026#39;) data1 = bt.feeds.MyFeed(dataname=\u0026#39;Expiry1\u0026#39;) ... dataN = bt.feeds.MyFeed(dataname=\u0026#39;ExpiryN\u0026#39;) drollover = bt.feeds.RollOver(data0, data1, ..., dataN, dataname=\u0026#39;MyRoll\u0026#39;, **kwargs) cerebro.adddata(drollover) cerebro.run() 注意：\n使用RollOver时，使用dataname参数分配名称，这是所有数据源用于传递名称/代码的标准参数。在这种情况下，它被重用以给整个滚动的期货集分配一个通用名称。 对于cerebro.rolloverdata，使用name参数为数据源分配名称，这是该方法的一个命名参数。 Rollover 的使用可概括为：\n按通常方式创建数据源，但不要将它们添加到cerebro 将这些数据源作为输入传递给bt.feeds.RollOver 也传递一个dataname，主要用于识别目的 然后将这个滚动的数据源添加到cerebro 滚动的选项# 提供两个参数来控制滚动过程：\n参数名 默认值 描述 checkdate None 必须是一个可调用对象，签名：checkdate(dt, d)- dt 一个datetime.datetime对象 - d，当前活跃期货的数据源 预期返回值- True：只要可调用对象返回此值，就可以切换到下一个期货 - False：不能进行到期转换例如，如果某商品在3月的第三个星期五到期，checkdate可以在到期所在的一整周内返回True。 checkcondition None 仅当checkdate返回True时才会调用此参数。如果为None，则内部评估为True（执行滚动）。否则，它必须是一个可调用对象，签名是 checkcondition(d0, d1) - d0是当前活跃期货的数据源- d1是下一个到期的数据源预期返回值：- True：滚动到下一个期货- False：不能进行到期转换例如，可以通过checkcondition判断，如果d0的交易量小于d1，则进行到期转换。 子类化RollOver# 如果指定的可调用对象还不够用，可以子类化RollOver。需要子类化的方法有：\ndef _checkdate(self, dt, d)它与上文同名参数的签名相匹配。预期返回值也相同。\ndef _checkcondition(self, d0, d1)它与上文同名参数的签名相匹配。预期返回值也相同。\n示例用法# 注意： 示例中的默认行为是使用cerebro.rolloverdata。可以通过传递-no-cerebro标志来更改。在这种情况下，示例使用RollOver和cerebro.adddata。\n实现包括一个可在backtrader源代码中找到的示例。\n期货拼接\n首先让我们通过运行不带参数的示例来看一个纯粹的拼接示例：\n$ ./rollover.py输出结果如下：\nLen, Name, RollName, Datetime, WeekDay, Open, High, Low, Close, Volume, OpenInterest 0001, FESX, 199FESXM4, 2013-09-26, Thu, 2829.0, 2843.0, 2829.0, 2843.0, 3.0, 1000.0 0002, FESX, 199FESXM4, 2013-09-27, Fri, 2842.0, 2842.0, 2832.0, 2841.0, 16.0, 1101.0 ... 0176, FESX, 199FESXM4, 2014-06-20, Fri, 3315.0, 3324.0, 3307.0, 3322.0, 134777.0, 520978.0 0177, FESX, 199FESXU4, 2014-06-23, Mon, 3301.0, 3305.0, 3265.0, 3285.0, 730211.0, 3003692.0 ... 0241, FESX, 199FESXU4, 2014-09-19, Fri, 3287.0, 3308.0, 3286.0, 3294.0, 144692.0, 566249.0 0242, FESX, 199FESXZ4, 2014-09-22, Mon, 3248.0, 3263.0, 3231.0, 3240.0, 582077.0, 2976624.0 ... 0306, FESX, 199FESXZ4, 2014-12-19, Fri, 3196.0, 3202.0, 3131.0, 3132.0, 226415.0, 677924.0 0307, FESX, 199FESXH5, 2014-12-22, Mon, 3151.0, 3177.0, 3139.0, 3168.0, 547095.0, 2952769.0 ... 0366, FESX, 199FESXH5, 2015-03-20, Fri, 3680.0, 3698.0, 3672.0, 3695.0, 147632.0, 887205.0 0367, FESX, 199FESXM5, 2015-03-23, Mon, 3654.0, 3655.0, 3608.0, 3618.0, 802344.0, 3521988.0 ... 0426, FESX, 199FESXM5, 2015-06-18, Thu, 3398.0, 3540.0, 3373.0, 3465.0, 1173246.0, 811805.0 0427, FESX, 199FESXM5, 2015-06-19, Fri, 3443.0, 3499.0, 3440.0, 3488.0, 104096.0, 516792.0可以看到，当数据源结束时，下一个数据源接管。\n这总是在一个星期五和下一个星期一之间发生：示例中的期货合约总是在星期五到期。\n期货滚动无检查\n运行带有--rollover参数的示例：\n$ ./rollover.py --rollover --plot输出结果类似：\nLen, Name, RollName, Datetime, WeekDay, Open, High, Low, Close, Volume, OpenInterest 0001, FESX, 199FESXM4, 2013-09-26, Thu , 2829.0, 2843.0, 2829.0, 2843.0, 3.0, 1000.0 0002, FESX, 199FESXM4, 2013-09-27, Fri, 2842.0, 2842.0, 2832.0, 2841.0, 16.0, 1101.0 ... 0176, FESX, 199FESXM4, 2014-06-20, Fri, 3315.0, 3324.0, 3307.0, 3322.0, 134777.0, 520978.0 0177, FESX, 199FESXU4, 2014-06-23, Mon, 3301.0, 3305.0, 3265.0, 3285.0, 730211.0, 3003692.0 ... 0241, FESX, 199FESXU4, 2014-09-19, Fri, 3287.0, 3308.0, 3286.0, 3294.0, 144692.0, 566249.0 0242, FESX, 199FESXZ4, 2014-09-22, Mon, 3248.0, 3263.0, 3231.0, 3240.0, 582077.0, 2976624.0 ... 0306, FESX, 199FESXZ4, 2014-12-19, Fri, 3196.0, 3202.0, 3131.0, 3132.0, 226415.0, 677924.0 0307, FESX, 199FESXH5, 2014-12-22, Mon, 3151.0, 3177.0, 3139.0, 3168.0, 547095.0, 2952769.0 ... 0366, FESX, 199FESXH5, 2015-03-20, Fri, 3680.0, 3698.0, 3672.0, 3695.0, 147632.0, 887205.0 0367, FESX, 199FESXM5, 2015-03-23, Mon, 3654.0, 3655.0, 3608.0, 3618.0, 802344.0, 3521988.0 ... 0426, FESX, 199FESXM5, 2015-06-18, Thu, 3398.0, 3540.0, 3373.0, 3465.0, 1173246.0, 811805.0 0427, FESX, 199FESXM5, 2015-06-19, Fri, 3443.0, 3499.0, 3440.0, 3488.0, 104096.0, 516792.0可以清楚地看到，合约的更换是在3月、6月、9月和12月的第三个星期五。\n这大部分是错误的。虽然backtrader无法知道，但作者知道EuroStoxx 50期货在到期月的第三个星期五中午12:00 CET停止交易。因此，即使在到期月的第三个星期五有一个每日条，更换也是太晚了。\n在周内更换# 在示例中实现了一个checkdate可调用对象，它计算当前活跃合约的到期日期。\ncheckdate会在到期周一旦到达时允许进行滚动（如果例如星期一是银行假日，可能会是星期二）。\n运行带有--rollover和--checkdate参数的示例：\n$ ./rollover.py --rollover --checkdate --plot输出结果类似：\nLen, Name, RollName, Datetime, WeekDay, Open, High, Low, Close, Volume, OpenInterest 0001, FESX, 199FESXM4, 2013-09-26, Thu, 2829.0, 2843.0, 2829.0, 2843.0, 3.0, 1000.0 0002, FESX, 199FESXM4, 2013-09-27, Fri, 2842.0, 2842.0, 2832.0, 2841.0, 16.0, 1101.0 ... 0171, FESX, 199FESXM4, 2014-06-13, Fri, 3283.0, 3292.0, 3253.0, 3276.0, 734907.0, 2715357.0 0172, FESX, 199FESXU4, 2014-06-16, Mon, 3261.0, 3275.0, 3252.0, 3262.0, 180608.0, 844486.0 ... 0236, FESX, 199FESXU4, 2014-09-12, Fri, 3245.0, 3247.0, 3220.0, 3232.0, 650314.0, 2726874.0 0237, FESX, 199FESXZ4, 2014-09-15, Mon, 3209.0, 3224.0, 3203.0, 3221.0, 153448.0, 983793.0 ... 0301, FESX, 199FESXZ4, 2014-12-12, Fri, 3127.0, 3143.0, 3038.0, 3042.0, 1409834.0, 2934179.0 0302, FESX, 199FESXH5, 2014-12-15, Mon, 3041.0, 3089.0, 2963.0, 2980.0, 329896.0, 904053.0 ... 0361, FESX, 199FESXH5, 2015-03-13, Fri, 3657.0, 3680.0, 3627.0, 3670.0, 867678.0, 3499116.0 0362, FESX, 199FESXM5, 2015-03-16, Mon, 3594.0, 3641.0, 3588.0, 3629.0, 250445.0, 1056099.0 ... 0426, FESX, 199FESXM5, 2015-06-18, Thu, 3398.0, 3540.0, 3373.0, 3465.0, 1173246.0, 811805.0 0427, FESX, 199FESXM5, 2015-06-19, Fri, 3443.0, 3499.0, 3440.0, 3488.0, 104096.0, 516792.0效果要好得多。滚动现在发生在到期月的第三个星期五之前的星期一。\n添加交易量条件# 即使有了改进，还可以进一步改善，通过考虑日期和交易量来决定是否滚动。仅在新合约的交易量超过当前活跃合约时进行切换。\n运行带有--rollover、--checkdate和--checkcondition参数的示例：\n$ ./rollover.py --rollover --checkdate --checkcondition --plot输出结果类似：\nLen, Name, RollName, Datetime, WeekDay, Open, High, Low, Close, Volume, OpenInterest 0001, FESX, 199FESXM4, 2013-09-26, Thu, 2829.0, 2843.0, 2829.0, 2843.0, 3.0, 1000.0 0002, FESX, 199FESXM4, 2013-09-27, Fri, 2842.0, 2842.0, 2832.0, 2841.0, 16.0, 1101.0 ... 0175, FESX, 199FESXM4, 2014-06-19, Thu, 3307.0, 3330.0, 3300.0, 3321.0, 717979.0, 759122.0 0176, FESX, 199FESXU4, 2014-06-20, Fri, 3309.0, 3318.0, 3290 .0, 3298.0, 711627.0, 2957641.0 ... 0240, FESX, 199FESXU4, 2014-09-18, Thu, 3249.0, 3275.0, 3243.0, 3270.0, 846600.0, 803202.0 0241, FESX, 199FESXZ4, 2014-09-19, Fri, 3273.0, 3293.0, 3250.0, 3252.0, 1042294.0, 3021305.0 ... 0305, FESX, 199FESXZ4, 2014-12-18, Thu, 3095.0, 3175.0, 3085.0, 3172.0, 1309574.0, 889112.0 0306, FESX, 199FESXH5, 2014-12-19, Fri, 3195.0, 3200.0, 3106.0, 3147.0, 1329040.0, 2964538.0 ... 0365, FESX, 199FESXH5, 2015-03-19, Thu, 3661.0, 3691.0, 3646.0, 3668.0, 1271122.0, 1054639.0 0366, FESX, 199FESXM5, 2015-03-20, Fri, 3607.0, 3664.0, 3595.0, 3646.0, 1182235.0, 3407004.0 ... 0426, FESX, 199FESXM5, 2015-06-18, Thu, 3398.0, 3540.0, 3373.0, 3465.0, 1173246.0, 811805.0 0427, FESX, 199FESXM5, 2015-06-19, Fri, 3443.0, 3499.0, 3440.0, 3488.0, 104096.0, 516792.0效果更好。我们已将切换日期移至到期月第三个星期五之前的星期四。\n结论# backtrader 现在包含一个灵活的机制，用于创建连续期货数据流。\n示例用法# $ ./rollover.py --help输出：\nusage: rollover.py [-h] [--no-cerebro] [--rollover] [--checkdate] [--checkcondition] [--plot [kwargs]] Sample for Roll Over of Futures optional arguments: -h, --help show this help message and exit --no-cerebro Use RollOver Directly (default: False) --rollover --checkdate Change during expiration week (default: False) --checkcondition Change when a given condition is met (default: False) --plot [kwargs], -p [kwargs] Plot the read data applying any kwargs passed For example: --plot style=\u0026#34;candle\u0026#34; (to plot candles) (default: None)示例代码：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import bisect import calendar import datetime import backtrader as bt class TheStrategy(bt.Strategy): def start(self): header = [\u0026#39;Len\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;RollName\u0026#39;, \u0026#39;Datetime\u0026#39;, \u0026#39;WeekDay\u0026#39;, \u0026#39;Open\u0026#39;, \u0026#39;High\u0026#39;, \u0026#39;Low\u0026#39;, \u0026#39;Close\u0026#39;, \u0026#39;Volume\u0026#39;, \u0026#39;OpenInterest\u0026#39;] print(\u0026#39;, \u0026#39;.join(header)) def next(self): txt = list() txt.append(\u0026#39;%04d\u0026#39; % len(self.data0)) txt.append(\u0026#39;{}\u0026#39;.format(self.data0._dataname)) # Internal knowledge ... current expiration in use is in _d txt.append(\u0026#39;{}\u0026#39;.format(self.data0._d._dataname)) txt.append(\u0026#39;{}\u0026#39;.format(self.data.datetime.date())) txt.append(\u0026#39;{}\u0026#39;.format(self.data.datetime.date().strftime(\u0026#39;%a\u0026#39;))) txt.append(\u0026#39;{}\u0026#39;.format(self.data.open[0])) txt.append(\u0026#39;{}\u0026#39;.format(self.data.high[0])) txt.append(\u0026#39;{}\u0026#39;.format(self.data.low[0])) txt.append(\u0026#39;{}\u0026#39;.format(self.data.close[0])) txt.append(\u0026#39;{}\u0026#39;.format(self.data.volume[0])) txt.append(\u0026#39;{}\u0026#39;.format(self.data.openinterest[0])) print(\u0026#39;, \u0026#39;.join(txt)) def checkdate(dt, d): # Check if the date is in the week where the 3rd friday of Mar/Jun/Sep/Dec # EuroStoxx50 expiry codes: MY # M -\u0026gt; H, M, U, Z (Mar, Jun, Sep, Dec) # Y -\u0026gt; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -\u0026gt; year code. 5 -\u0026gt; 2015 MONTHS = dict(H=3, M=6, U=9, Z=12) M = MONTHS[d._dataname[-2]] centuria, year = divmod(dt.year, 10) decade = centuria * 10 YCode = int(d._dataname[-1]) Y = decade + YCode if Y \u0026lt; dt.year: # Example: year 2019 ... YCode is 0 for 2020 Y += 10 exp_day = 21 - (calendar.weekday(Y, M, 1) + 2) % 7 exp_dt = datetime.datetime(Y, M, exp_day) # Get the year, week numbers exp_year, exp_week, _ = exp_dt.isocalendar() dt_year, dt_week, _ = dt.isocalendar() # print(\u0026#39;dt {} vs {} exp_dt\u0026#39;.format(dt, exp_dt)) # print(\u0026#39;dt_week {} vs {} exp_week\u0026#39;.format(dt_week, exp_week)) # can switch if in same week return (dt_year, dt_week) == (exp_year, exp_week) def checkvolume(d0, d1): return d0.volume[0] \u0026lt; d1.volume[0] # Switch if volume from d0 \u0026lt; d1 def runstrat(args=None): args = parse_args(args) cerebro = bt.Cerebro() fcodes = [\u0026#39;199FESXM4\u0026#39;, \u0026#39;199FESXU4\u0026#39;, \u0026#39;199FESXZ4\u0026#39;, \u0026#39;199FESXH5\u0026#39;, \u0026#39;199FESXM5\u0026#39;] store = bt.stores.VChartFile() ffeeds = [store.getdata(dataname=x) for x in fcodes] rollkwargs = dict() if args.checkdate: rollkwargs[\u0026#39;checkdate\u0026#39;] = checkdate if args.checkcondition: rollkwargs[\u0026#39;checkcondition\u0026#39;] = checkvolume if not args.no_cerebro: if args.rollover: cerebro.rolloverdata(name=\u0026#39;FESX\u0026#39;, *ffeeds, **rollkwargs) else: cerebro.chaindata(name=\u0026#39;FESX\u0026#39;, *ffeeds) else: drollover = bt.feeds.RollOver(*ffeeds, dataname=\u0026#39;FESX\u0026#39;, **rollkwargs) cerebro.adddata(drollover) cerebro.addstrategy(TheStrategy) cerebro.run(stdstats=False) if args.plot: pkwargs = dict(style=\u0026#39;bar\u0026#39;) if args.plot is not True: # evals to True but is not True npkwargs = eval(\u0026#39;dict(\u0026#39; + args.plot + \u0026#39;)\u0026#39;) # args were passed pkwargs.update(npkwargs) cerebro.plot(**pkwargs) def parse_args(pargs=None): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter, description=\u0026#39;Sample for Roll Over of Futures\u0026#39;) parser.add_argument(\u0026#39;--no-cerebro\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Use RollOver Directly\u0026#39;) parser.add_argument(\u0026#39;--rollover\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;) parser.add_argument(\u0026#39;--checkdate\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Change during expiration week\u0026#39;) parser.add_argument(\u0026#39;--checkcondition\u0026#39;, required=False, action=\u0026#39;store_true\u0026#39;, help=\u0026#39;Change when a given condition is met\u0026#39;) # Plot options parser.add_argument(\u0026#39;--plot\u0026#39;, \u0026#39;-p\u0026#39;, nargs=\u0026#39;?\u0026#39;, required=False, metavar=\u0026#39;kwargs\u0026#39;, const=True, help=(\u0026#39;Plot the read data applying any kwargs passed\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39;For example:\\n\u0026#39; \u0026#39;\\n\u0026#39; \u0026#39; --plot style=\u0026#34;candle\u0026#34; (to plot candles)\\n\u0026#39;)) if pargs is not None: return parser.parse_args(pargs) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":86,"href":"/backtrader/docs/03-quickstart/09-indicators/","title":"技术指标","section":"快速开始","content":"技术指标（Indicators）# 本节将介绍如何使用技术指标，将技术指标作为入场和出场信号。我们将用简单移动平均线（Simple Moving Average），或称 SMA，作为演示指标。SMA 是一个非常简单的技术指标，计算一定周期的价格均值。\n交易规则# 基于 SMA 交易规则，定义如下所示：\n入场条件： 当收盘价大于最新的 SMA，则入场买入。 出场条件： 当持有头寸，当收盘价小于 SMA，则出场卖出。 前面章节的策略代码大部分可复用，现在重点关注如何计算技术指标。\n指标计算# backtrader 下的 indicators 模块内置了大量技术指标的计算方法，如 SMA 简单移动均线的计算。\nself.sma = bt.indicators.MovingAverageSimple(self.datas[0], period=self.params.maperiod)如上代码中参数 self.params.maperiod 就是 SMA 的均线周期。\n注：如果安装了 talib，backtrader 也集成了 talib 的支持，详情文档 指标-TALib。\n条件判断# 现在基于 self.sma 判断进出场条件。\n为了简化代码，这里只考虑 SMA 的判断逻辑，在完整实例中会包含所有情况。\n入场判断：\nself.dataclose[0] \u0026gt; self.sma[0]出场判断：\nself.dataclose[0] \u0026lt; self.sma[0]策略代码# 起始现金 1000 货币单位。\nimport datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt策略部分：\nclass TestStrategy(bt.Strategy): params = ( (\u0026#39;maperiod\u0026#39;, 15), ) def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None self.buyprice = None self.buycomm = None self.sma = bt.indicators.SimpleMovingAverage( self.datas[0], period=self.params.maperiod) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.log(\u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(\u0026#39;Order Canceled/Margin/Rejected\u0026#39;) self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(\u0026#39;OPERATION PROFIT, GROSS %.2f, NET %.2f\u0026#39; % (trade.pnl, trade.pnlcomm)) def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if self.order: return if not self.position: if self.dataclose[0] \u0026gt; self.sma[0]: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.buy() else: if self.dataclose[0] \u0026lt; self.sma[0]: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.sell() if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(1000.0) cerebro.addsizer(bt.sizers.FixedSize, stake=10) cerebro.broker.setcommission(commission=0.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue())输出：\nStarting Portfolio Value: 1000.00 2000-01-24, Close, 25.55 2000-01-25, Close, 26.61 2000-01-25, BUY CREATE, 26.61 2000-01-26, BUY EXECUTED, Size 10, Price: 26.76, Cost: 267.60, Commission 0.00 2000-01-26, Close, 25.96 2000-01-27, Close, 24.43 2000-01-27, SELL CREATE, 24.43 2000-01-28, SELL EXECUTED, Size 10, Price: 24.28, Cost: 242.80, Commission 0.00 2000-01-28, OPERATION PROFIT, GROSS -24.80, NET -24.80 ... ... ... 2000-12-20, SELL CREATE, 26.88 2000-12-21, SELL EXECUTED, Size 10, Price: 26.23, Cost: 262.30, Commission 0.00 2000-12-21, OPERATION PROFIT, GROSS -20.60, NET -20.60 2000-12-21, Close, 27.82 2000-12-21, BUY CREATE, 27.82 2000-12-22, BUY EXECUTED, Size 10, Price: 28.65, Cost: 286.50, Commission 0.00 2000-12-22, Close, 30.06 2000-12-26, Close, 29.17 2000-12-27, Close, 28.94 2000-12-28, Close, 29.29 2000-12-29, Close, 27.41 2000-12-29, SELL CREATE, 27.41 Final Portfolio Value: 973.90现在，投资组合变得亏损了。\n"},{"id":87,"href":"/backtrader/docs/06-datafeed/10-datafeed-yahoo/","title":"Yahoo 数据源说明","section":"DataFeed","content":"Yahoo 数据源说明# 在 2017 年 5 月，Yahoo 停用了现有的 CSV 格式的历史数据下载 API。\n很快，新 API（这里称为 v7）被标准化并已实现。\n这也带来了实际 CSV 下载格式的变化。\n使用 v7 API/格式# 从版本 1.9.49.116 开始，这是默认行为。可以简单地选择：\nYahooFinanceData 用于在线下载 YahooFinanceCSVData 用于离线下载的文件 使用旧的 API/格式# 要使用旧的 API/格式，可以：\n在线 Yahoo 数据源实例化如下：\ndata = bt.feeds.YahooFinanceData( ... version=\u0026#39;\u0026#39;, ... )离线 Yahoo 数据源实例化如下：\ndata = bt.feeds.YahooFinanceCSVData( ... version=\u0026#39;\u0026#39;, ... )可能在线服务会恢复（服务在没有任何公告的情况下被停用……它也可能会恢复）\n或者\n仅用于在变更前下载的离线文件，也可以这样做：\ndata = bt.feeds.YahooLegacyCSV( ... ... )新的 YahooLegacyCSV 简化了使用 version='' 的操作。\n"},{"id":88,"href":"/backtrader/docs/03-quickstart/10-plotting/","title":"可视化","section":"快速开始","content":"可视化# 通过 print 输出每个 bar 的信息不利于我们阅读，我们还是更倾向于图表的视觉效果。backtrader 内置了图表绘制的能力，一行代码即可绘图。\ncerebro.plot()请确保在调用cerebro.run()之后执行，还有，backtrader 的绘图能力依赖 matplotlib。\n演示# 为了展示出基本的价格和收益外，我们将执行以下操作以展示绘图的功能和配置。\n添加一个 EMA（指数移动平均线），默认情况下，它会与数据一起绘制。 添加一个 WMA（移动平均线加权），配置在子图绘制（即使没有意义）。 添加一个 StochasticSlow（慢速随机指标），不更改默认设置。 添加一个 MACD，不更改默认设置。 添加一个ATR，更改默认设置以避免绘图。 添加一个 RSI，不更改默认设置。 在 RSI 上添加一个 SMA 指标，不更改默认设置，且与RSI一起绘制。 在策略的 __init__ 方法中添加的所有内容：\n# Indicators for the plotting show bt.indicators.ExponentialMovingAverage(self.datas[0], period=25) bt.indicators.WeightedMovingAverage(self.datas[0], period=25).subplot = True bt.indicators.StochasticSlow(self.datas[0]) bt.indicators.MACDHisto(self.datas[0]) rsi = bt.indicators.RSI(self.datas[0]) bt.indicators.SmoothedMovingAverage(rsi, period=10) bt.indicators.ATR(self.datas[0]).plot = False即使将指标没有赋值到策略成员变量（如self.sma = MovingAverageSimple…），它们也会被注册到策略中，成为图表的一部分。\n示例中，只有RSI被添加到临时变量rsi中，其目的是要在其上创建一个 SmoothedMovingAverage。\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): params = ( (\u0026#39;maperiod\u0026#39;, 15), ) def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None self.buyprice = None self.buycomm = None self.sma = bt.indicators.SimpleMovingAverage( self.datas[0], period=self.params.maperiod) # Indicators for the plotting show bt.indicators.ExponentialMovingAverage(self.datas[0], period=25) bt.indicators.WeightedMovingAverage(self.datas[0], period=25, subplot=True) bt.indicators.StochasticSlow(self.datas[0]) bt.indicators.MACDHisto(self.datas[0]) rsi = bt.indicators.RSI(self.datas[0]) bt.indicators.SmoothedMovingAverage(rsi, period=10) bt.indicators.ATR(self.datas[0], plot=False) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.log(\u0026#39;BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.buyprice = order.executed.price self.buycomm = order.executed.comm else: self.log(\u0026#39;SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f\u0026#39; % (order.executed.price, order.executed.value, order.executed.comm)) self.bar_executed = len(self) elif order.status in [order.Canceled, order.Margin, order.Rejected]: self.log(\u0026#39;Order Canceled/Margin/Rejected\u0026#39;) self.order = None def notify_trade(self, trade): if not trade.isclosed: return self.log(\u0026#39;OPERATION PROFIT, GROSS %.2f, NET %.2f\u0026#39; % (trade.pnl, trade.pnlcomm)) def next(self): self.log(\u0026#39;Close, %.2f\u0026#39; % self.dataclose[0]) if self.order: return if not self.position: if self.dataclose[0] \u0026gt; self.sma[0]: self.log(\u0026#39;BUY CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.buy() else: if self.dataclose[0] \u0026lt; self.sma[0]: self.log(\u0026#39;SELL CREATE, %.2f\u0026#39; % self.dataclose[0]) self.order = self.sell() if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(1000.0) cerebro.addsizer(bt.sizers.FixedSize, stake=10) cerebro.broker.setcommission(commission=0.0) print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) # Plot the result cerebro.plot()执行后的输出：\nStarting Portfolio Value: 1000.00 2000-02-18, Close, 27.61 2000-02-22, Close, 27.97 2000-02-22, BUY CREATE, 27.97 2000-02-23, BUY EXECUTED, Size 10, Price: 28.38, Cost: 283.80, Commission 0.00 2000-02-23, Close, 29.73 ... ... ... 2000-12-21, BUY CREATE, 27.82 2000-12-22, BUY EXECUTED, Size 10, Price: 28.65, Cost: 286.50, Commission 0.00 2000-12-22, Close, 30.06 2000-12-26, Close, 29.17 2000-12-27, Close, 28.94 2000-12-28, Close, 29.29 2000-12-29, Close, 27.41 2000-12-29, SELL CREATE, 27.41 Final Portfolio Value: 981.00因为交易逻辑没有修改，故而结果和上节一样，图表如下：\n"},{"id":89,"href":"/backtrader/docs/06-datafeed/11-datafeed-pandas/","title":"Pandas 数据源示例","section":"DataFeed","content":"Pandas 数据源示例# 注意，需要安装 pandas 及其依赖项。支持 Pandas Dataframe 对很多人来说很重要，他们依赖于 Pandas 提供的不同数据源（包括 CSV）的解析代码及其他功能。\n数据源的重要声明# 注意\n这些只是声明。不要盲目复制此代码。请参见下面的实际用法示例：\nclass PandasData(feed.DataBase): \u0026#39;\u0026#39;\u0026#39; ``dataname`` 参数继承自 ``feed.DataBase`` 是 pandas DataFrame \u0026#39;\u0026#39;\u0026#39; params = ( # datetime 的可能值（必须始终存在） # None : datetime 是 Pandas Dataframe 中的 \u0026#34;index\u0026#34; # -1 : 自动检测位置或大小写相同的名称 # \u0026gt;= 0 : pandas dataframe 中列的数值索引 # string : pandas dataframe 中的列名（作为索引） (\u0026#39;datetime\u0026#39;, None), # 下面是可能的值： # None : 列不存在 # -1 : 自动检测位置或大小写相同的名称 # \u0026gt;= 0 : pandas dataframe 中列的数值索引 # string : pandas dataframe 中的列名（作为索引） (\u0026#39;open\u0026#39;, -1), (\u0026#39;high\u0026#39;, -1), (\u0026#39;low\u0026#39;, -1), (\u0026#39;close\u0026#39;, -1), (\u0026#39;volume\u0026#39;, -1), (\u0026#39;openinterest\u0026#39;, -1), )上述 PandasData 类的片段展示了关键点：\n在实例化时，类的 dataname 参数包含 Pandas Dataframe\n该参数继承自基类 feed.DataBase\n新参数具有 DataSeries 中常规字段的名称，并遵循以下约定：\ndatetime (默认: None)\nNone: datetime 是 Pandas Dataframe 中的“索引” -1: 自动检测位置或大小写相同的名称 = 0: pandas dataframe 中列的数值索引\nstring: pandas dataframe 中的列名（作为索引） open、high、low、close、volume、openinterest (默认: -1)\nNone: 列不存在 -1: 自动检测位置或大小写相同的名称 = 0: pandas dataframe 中列的数值索引\nstring: pandas dataframe 中的列名（作为索引） 一个小示例应能够加载经过 Pandas 解析的标准 2006 示例数据，而不是直接由 backtrader 解析。\n运行示例代码以使用 CSV 数据中的现有“头”：\n$ ./panda-test.py -------------------------------------------------- Open High Low Close Volume OpenInterest Date 2006-01-02 3578.73 3605.95 3578.73 3604.33 0 0 2006-01-03 3604.08 3638.42 3601.84 3614.34 0 0 2006-01-04 3615.23 3652.46 3615.23 3652.46 0 0相同的代码，但告诉脚本跳过头：\n$ ./panda-test.py --noheaders -------------------------------------------------- 1 2 3 4 5 6 0 2006-01-02 3578.73 3605.95 3578.73 3604.33 0 0 2006-01-03 3604.08 3638.42 3601.84 3614.34 0 0 2006-01-04 3615.23 3652.46 3615.23 3652.46 0 0第二次运行时，使用 pandas.read_csv：\n跳过第一行输入（skiprows 参数设置为 1） 不查找头行（header 参数设置为 None） backtrader 对 Pandas 的支持尝试自动检测列名是否已被使用，否则使用数值索引，并相应地进行操作，尽量提供最佳匹配。\n以下图表展示了成功的结果。Pandas Dataframe 已正确加载（在两种情况下均如此）。\n示例代码：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import argparse import backtrader as bt import backtrader.feeds as btfeeds import pandas def runstrat(): args = parse_args() # 创建 cerebro 实体 cerebro = bt.Cerebro(stdstats=False) # 添加策略 cerebro.addstrategy(bt.Strategy) # 获取 pandas dataframe datapath = (\u0026#39;../../datas/2006-day-001.txt\u0026#39;) # 模拟在请求 noheaders 时不存在头行 skiprows = 1 if args.noheaders else 0 header = None if args.noheaders else 0 dataframe = pandas.read_csv(datapath, skiprows=skiprows, header=header, parse_dates=True, index_col=0) if not args.noprint: print(\u0026#39;--------------------------------------------------\u0026#39;) print(dataframe) print(\u0026#39;--------------------------------------------------\u0026#39;) # 将其传递给 backtrader 数据源并添加到 cerebro data = bt.feeds.PandasData(dataname=dataframe) cerebro.adddata(data) # 运行所有内容 cerebro.run() # 绘制结果 cerebro.plot(style=\u0026#39;bar\u0026#39;) def parse_args(): parser = argparse.ArgumentParser( description=\u0026#39;Pandas 测试脚本\u0026#39;) parser.add_argument(\u0026#39;--noheaders\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, required=False, help=\u0026#39;不使用头行\u0026#39;) parser.add_argument(\u0026#39;--noprint\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, help=\u0026#39;打印 dataframe\u0026#39;) return parser.parse_args() if __name__ == \u0026#39;__main__\u0026#39;: runstrat()"},{"id":90,"href":"/backtrader/docs/03-quickstart/11-optimization/","title":"策略优化","section":"快速开始","content":"策略优化# 许多交易书籍中提到，每个市场和每个交易的股票（或商品等）都有不同的节奏，没有一种适合所有的策略。\n在绘图示例前，当策略开始使用一个指标，周期默认值为 15 个 bar。这是一个策略参数，可以用于优化，改变参数值以找出哪个更适合你的市场。\n注意：关于优化及其优缺点的文献很多。但建议基本是：不要过度优化。如果交易思路不健全，优化可能会产生一个仅对回测数据集有效的正面结果。\n示例修改为优化简单移动平均线的周期。为了清晰起见，已删除与买卖订单相关的任何输出。\n示例如下：\nimport datetime #For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): params = ( (\u0026#39;maperiod\u0026#39;, 15), (\u0026#39;printlog\u0026#39;, False), ) def log(self, txt, dt=None, doprint=False): if self.params.printlog or doprint: dt = dt or self.datas[0].datetime.date(0) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close self.order = None self.buyprice = None self.buycomm = None self.sma = bt.indicators.SimpleMovingAverage( self.datas[0], period=self.params.maperiod) def notify_order(self, order): if order.status in [order.Submitted, order.Accepted]: return if order.status in [order.Completed]: if order.isbuy(): self.buyprice = order.executed.price self.buycomm = order.executed.comm else: self.bar_executed = len(self) self.order = None def notify_trade(self, trade): if not trade.isclosed: return def next(self): if self.order: return if not self.position: if self.dataclose[0] \u0026gt; self.sma[0]: self.order = self.buy() else: if self.dataclose[0] \u0026lt; self.sma[0]: self.order = self.sell() def stop(self): self.log(\u0026#39;(MA Period %2d) Ending Value %.2f\u0026#39; % (self.params.maperiod, self.broker.getvalue()), doprint=True) if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() strats = cerebro.optstrategy( TestStrategy, maperiod=range(10, 31)) modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;) data = bt.feeds.YahooFinanceCSVData( dataname=datapath, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False) cerebro.adddata(data) cerebro.broker.setcash(1000.0) cerebro.addsizer(bt.sizers.FixedSize, stake=10) cerebro.broker.setcommission(commission=0.0) cerebro.run(maxcpus=1)策略优化调用不再是 addstrategy，而是 optstrategy，且传递的是值的范围，而非单一值。\n代码中添加了一个 stop 方法，当回测结束时会调用它。我们用它打印最终净值。\n运行程序，系统将为每个范围值执行策略。\n输出如下：\n2000-12-29, (MA Period 10) Ending Value 880.30 2000-12-29, (MA Period 11) Ending Value 880.00 2000-12-29, (MA Period 12) Ending Value 830.30 2000-12-29, (MA Period 13) Ending Value 893.90 2000-12-29, (MA Period 14) Ending Value 896.90 2000-12-29, (MA Period 15) Ending Value 973.90 2000-12-29, (MA Period 16) Ending Value 959.40 2000-12-29, (MA Period 17) Ending Value 949.80 2000-12-29, (MA Period 18) Ending Value 1011.90 2000-12-29, (MA Period 19) Ending Value 1041.90 2000-12-29, (MA Period 20) Ending Value 1078.00 2000-12-29, (MA Period 21) Ending Value 1058.80 2000-12-29, (MA Period 22) Ending Value 1061.50 2000-12-29, (MA Period 23) Ending Value 1023.00 2000-12-29, (MA Period 24) Ending Value 1020.10 2000-12-29, (MA Period 25) Ending Value 1013.30 2000-12-29, (MA Period 26) Ending Value 998.30 2000-12-29, (MA Period 27) Ending Value 982.20 2000-12-29, (MA Period 28) Ending Value 975.70 2000-12-29, (MA Period 29) Ending Value 983.30 2000-12-29, (MA Period 30) Ending Value 979.80结果# 对于小于18的周期，策略亏损。 对于18到26（包括）的周期，策略盈利。 超过26的周期，策略再次亏损。 对于这个策略和数据集，得到最优参数是均线周期为 20 时，盈利78.00单位货币（即7.8%）。\n"},{"id":91,"href":"/backtrader/docs/06-datafeed/12-datafeed-reference/","title":"数据源参考","section":"DataFeed","content":"数据源参考# AbstractDataBase# 数据行（Lines）:\nclose low high open volume openinterest datetime 参数（Params）:\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) BacktraderCSVData# 解析用于测试的自定义 CSV 数据。\n特定参数：\ndataname: 要解析的文件名或类文件对象 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) CSVDataBase# 用于实现 CSV 数据源的基类。\n该类负责打开文件、读取行并将其标记化。子类只需重写 _loadline(tokens) 方法。\n数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) Chainer# 用于链式连接数据的类。\n数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) DataClone# 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) DataFiller# 该类将使用基础数据源的信息填充数据中的空隙。\n参数：\nfill_price (def: None): 如果为 None，将使用上一条数据的收盘价；否则使用传递的值（例如 ‘NaN’） fill_vol (def: NaN): 用于填充缺失数据的交易量 fill_oi (def: NaN): 用于填充缺失数据的未平仓合约量 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) fill_price (None) fill_vol (nan) fill_oi (nan) DataFilter# 此类过滤给定数据源中的数据行。除了 DataBase 的标准参数外，它还接受 funcfilter 参数，该参数可以是任何可调用对象。\n逻辑：\nfuncfilter 将与基础数据源一起调用 它可以是任何可调用对象 返回值 True：当前数据源的数据行值将被使用 返回值 False：当前数据源的数据行值将被丢弃 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) funcfilter (None) GenericCSVData# 根据定义的参数解析 CSV 文件。\n特定参数（或特定含义）：\ndataname: 要解析的文件名或类文件对象 lines 参数（datetime, open, high …）取数值 值为 -1 表示 CSV 源中不存在该字段 如果 time 存在（参数 time \u0026gt;=0），源包含分开的日期和时间字段，将合并 参数：\nnullvalue: 如果缺少值（CSV 字段为空），将使用的值 dtformat: 用于解析 datetime CSV 字段的格式。请参阅 python strptime/strftime 文档以了解格式。 如果指定了数值，它将按以下方式解释： 1: 值为代表自 1970 年 1 月 1 日以来的秒数的 Unix 时间戳（int 型） 2: 值为代表自 1970 年 1 月 1 日以来的秒数的 Unix 时间戳（float 型） 如果传递了一个可调用对象，它将接受一个字符串并返回一个 datetime.datetime 实例 tmformat: 用于解析 time CSV 字段的格式（如果存在）（time 字段默认不存在） 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) nullvalue (nan) dtformat (%Y-%m-%d %H:%M:%S) tmformat (%H:%M:%S) datetime (0) time (-1) open (1) high (2) low (3) close (4) volume (5) openinterest (6) IBData# 交互式经纪商数据源（Interactive Brokers Data Feed）\n支持参数 dataname 中的合约规格：\nTICKER # 股票类型和 SMART 交易所 TICKER-STK # 股票和 SMART 交易所 TICKER-STK-EXCHANGE # 股票 TICKER-STK-EXCHANGE-CURRENCY # 股票 TICKER-CFD # CFD 和 SMART 交易所 TICKER-CFD-EXCHANGE # CFD TICKER-CDF-EXCHANGE-CURRENCY # 股票 TICKER-IND-EXCHANGE # 指数 TICKER-IND-EXCHANGE-CURRENCY # 指数 TICKER-YYYYMM-EXCHANGE # 期货 TICKER-YYYYMM-EXCHANGE-CURRENCY # 期货 TICKER-YYYYMM-EXCHANGE-CURRENCY-MULT # 期货 TICKER-FUT-EXCHANGE-CURRENCY-YYYYMM-MULT # 期货 TICKER-YYYYMM-EXCHANGE-CURRENCY-STRIKE-RIGHT # 期权 TICKER-YYYYMM-EXCHANGE-CURRENCY-STRIKE-RIGHT-MULT # 期权 TICKER-FOP-EXCHANGE-CURRENCY-YYYYMM-STRIKE-RIGHT # 期权 TICKER-FOP-EXCHANGE-CURRENCY-YYYYMM-STRIKE-RIGHT-MULT # 期权 CUR1.CUR2-CASH-IDEALPRO # 外汇 TICKER-YYYYMMDD-EXCHANGE-CURRENCY-STRIKE-RIGHT # 期权 TICKER-YYYYMMDD-EXCHANGE-CURRENCY-STRIKE-RIGHT-MULT # 期权 TICKER-OPT-EXCHANGE-CURRENCY-YYYYMMDD-STRIKE-RIGHT # 期权 TICKER-OPT-EXCHANGE-CURRENCY-YYYYMMDD-STRIKE-RIGHT-MULT # 期权参数：\nsectype (默认: STK) exchange (默认: SMART) currency (默认: \u0026lsquo;\u0026rsquo;) historical (默认: False) what (默认: None) rtbar (默认: False) qcheck (默认: 0.5) backfill_start (默认: True) backfill (默认: True) backfill_from (默认: None)\nlatethrough (默认: False) tradename (默认: None) 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.5) calendar (None) sectype (STK) exchange (SMART) currency () rtbar (False) historical (False) what (None) useRTH (False) backfill_start (True) backfill (True) backfill_from (None) latethrough (False) tradename (None) InfluxDB# 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) host (127.0.0.1) port (8086) username (None) password (None) database (None) startdate (None) high (high_p) low (low_p) open (open_p) close (close_p) volume (volume) ointerest (oi) MT4CSVData# 解析 Metatrader4 历史中心导出的 CSV 文件。\n特定参数（或特定含义）：\ndataname: 要解析的文件名或类文件对象 使用 GenericCSVData 并简单修改参数 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) nullvalue (nan) dtformat (%Y.%m.%d) tmformat (%H:%M) datetime (0) time (1) open (2) high (3) low (4) close (5) volume (6) openinterest (-1) OandaData# 参数：\nqcheck (默认: 0.5) historical (默认: False) backfill_start (默认: True) backfill (默认: True) backfill_from (默认: None) bidask (默认: True) useask (默认: False) includeFirst (默认: True) reconnect (默认: True) reconnections (默认: -1) reconntimeout (默认: 5.0) 支持的时间框架和压缩映射符合 OANDA API 开发者指南中的定义：\n(TimeFrame.Seconds, 5): \u0026#39;S5\u0026#39;, (TimeFrame.Seconds, 10): \u0026#39;S10\u0026#39;, (TimeFrame.Seconds, 15): \u0026#39;S15\u0026#39;, (TimeFrame.Seconds, 30): \u0026#39;S30\u0026#39;, (TimeFrame.Minutes, 1): \u0026#39;M1\u0026#39;, (TimeFrame.Minutes, 2): \u0026#39;M3\u0026#39;, (TimeFrame.Minutes, 3): \u0026#39;M3\u0026#39;, (TimeFrame.Minutes, 4): \u0026#39;M4\u0026#39;, (TimeFrame.Minutes, 5): \u0026#39;M5\u0026#39;, (TimeFrame.Minutes, 10): \u0026#39;M10\u0026#39;, (TimeFrame.Minutes, 15): \u0026#39;M15\u0026#39;, (TimeFrame.Minutes, 30): \u0026#39;M30\u0026#39;, (TimeFrame.Minutes, 60): \u0026#39;H1\u0026#39;, (TimeFrame.Minutes, 120): \u0026#39;H2\u0026#39;, (TimeFrame.Minutes, 180): \u0026#39;H3\u0026#39;, (TimeFrame.Minutes, 240): \u0026#39;H4\u0026#39;, (TimeFrame.Minutes, 360): \u0026#39;H6\u0026#39;, (TimeFrame.Minutes, 480): \u0026#39;H8\u0026#39;, (TimeFrame.Days, 1): \u0026#39;D\u0026#39;, (TimeFrame.Weeks, 1): \u0026#39;W\u0026#39;, (TimeFrame.Months, 1): \u0026#39;M\u0026#39;,数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.5) calendar (None) historical (False) backfill_start (True) backfill (True) backfill_from (None) bidask (True) useask (False) includeFirst (True) reconnect (True) reconnections (-1) reconntimeout (5.0) PandasData# 使用 Pandas DataFrame 作为数据源。\n参数：\nnocase (默认: True) 列名匹配不区分大小写 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) nocase (True) datetime (None) open (-1) high (-1) low (-1) close (-1) volume (-1) openinterest (-1) PandasDirectData# 使用 Pandas DataFrame 作为数据源，直接迭代由 itertuples 返回的元组。\n数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) datetime (0) open (1) high (2) low (3) close (4) volume (5) openinterest (6) Quandl# 直接从 Quandl 服务器下载数据。\n特定参数（或特定含义）：\ndataname: 要下载的代码（例如 \u0026lsquo;YHOO\u0026rsquo;） baseurl: 服务器 URL proxies: 指示下载时使用的代理的字典，例如 {‘http’: ‘http://myproxy.com’} buffered: 如果为 True，整个 socket 连接将在解析前缓存在本地 reverse: Quandl 返回的值按降序排列（最新的在前）。如果为 True，请求将告诉 Quandl 以升序（最旧的在前）格式返回 adjclose: 是否使用股息/拆股调整后的收盘价，并根据它调整所有值 apikey: 如果需要，使用的 API 密钥 dataset: 标识要查询的数据集的字符串。默认为 WIKI 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) reverse (True) adjclose (True) round (False) decimals (2) baseurl (https://www.quandl.com/api/v3/datasets) proxies ({}) buffered (True) apikey (None) dataset (WIKI) QuandlCSV# 解析预先下载的 Quandl CSV 数据源（或如果符合 Quandl 格式，本地生成的 CSV 文件）。\n特定参数：\ndataname: 要解析的文件名或类文件对象 reverse (默认: False): 假设本地存储的文件在下载过程中已被反向 adjclose (默认: True): 是否使用股息/拆股调整后的收盘价，并根据它调整所有值 round (默认: False): 是否在调整收盘价后将值四舍五入到特定的小数位数 decimals (默认: 2): 要四舍五入的小数位数 数据行：# close\nlow high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) reverse (False) adjclose (True) round (False) decimals (2) RollOver# 在满足条件时切换到下一个期货合约。\n参数：\ncheckdate (默认: None): 必须是具有以下签名的可调用对象： checkdate(dt, d): dt: datetime.datetime 对象 d: 当前活动期货的数据源 返回值：\nTrue: 只要返回 True，就可以切换到下一个期货\nFalse: 不能进行切换\ncheckcondition (默认: None): 注意：只有当 checkdate 返回 True 时才会调用此方法。如果为 None，将在内部评估为 True（执行切换）。否则，必须是具有以下签名的可调用对象：\ncheckcondition(d0, d1): d0: 当前活动期货的数据源 d1: 下一个到期的数据源 返回值：\nTrue: 切换到下一个期货 False: 不能进行切换 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) checkdate (None) checkcondition (None) SierraChartCSVData# 解析 SierraChart 导出的 CSV 文件。\n特定参数（或特定含义）：\ndataname: 要解析的文件名或类文件对象 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) nullvalue (nan) dtformat (%Y/%m/%d) tmformat (%H:%M:%S) datetime (0) time (-1) open (1) high (2) low (3) close (4) volume (5) openinterest (6) VCData# VisualChart 数据源。\n参数：\nqcheck (默认: 0.5): 唤醒的默认超时，以让重新采样器/重放器知道当前条形图可以检查是否应交付 historical (默认: False): 如果未提供 todate 参数（在基类中定义），如果设置为 True，将强制仅进行历史下载。如果提供了 todate 参数，则效果相同。 milliseconds (默认: True): Visual Chart 构建的条形图具有以下方面：HH:MM:59.999000。如果此参数为 True，将添加一毫秒以使其看起来像：HH:MM + 1:00.000000 tradename (默认: None): 连续期货不能交易，但非常适合数据跟踪。如果提供此参数，它将是当前期货的名称，即交易资产。例如： 001ES -\u0026gt; ES-Mini 连续期货作为 dataname 提供 ESU16 -\u0026gt; ES-Mini 2016-09。如果在 tradename 中提供，它将是交易资产。 usetimezones (默认: True): 对于大多数市场，Visual Chart 提供的时区信息允许将日期时间转换为市场时间（backtrader 选择的表示方法）。某些市场（096）需要特殊的内部覆盖和时区支持以显示为用户期望的市场时间。如果设置为 True，将尝试使用 pytz 进行时区转换（默认）。禁用它将删除时区使用（可能有助于减少负载）。 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.5) calendar (None) historical (False) millisecond (True) tradename (None) usetimezones (True) VChartCSVData# 解析 VisualChart 导出的 CSV 文件。\n特定参数（或特定含义）：\ndataname: 要解析的文件名或类文件对象 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) VChartData# 支持 Visual Chart 二进制磁盘文件的每日和日内格式。\n注：\ndataname: 文件名或打开的类文件对象 如果传递了一个类文件对象，将使用 timeframe 参数来确定实际的时间框架。否则将使用文件扩展名（.fd 表示每日，.min 表示日内）。\n数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) VChartFile# 支持 Visual Chart 二进制磁盘文件的每日和日内格式。\n注：\ndataname: Visual Chart 显示的市场代码。例如：015ES 表示 EuroStoxx 50 连续期货 数据行：\nclose low high open volume openinterest datetime 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) YahooFinanceCSVData# 解析预先下载的 Yahoo CSV 数据源（或符合 Yahoo 格式的本地生成的 CSV 文件）。\n特定参数：\ndataname: 要解析的文件名或类文件对象 reverse (默认: False): 假设本地存储的文件在下载过程中已被反向 adjclose (默认: True): 是否使用股息/拆股调整后的收盘价，并根据它调整所有值 adjvolume (默认: True): 如果 adjclose 也为 True，则也调整交易量 round (默认: True): 是否在调整收盘价后将值四舍五入到特定的小数位数 roundvolume (默认: 0): 在调整后将交易量四舍五入到给定的小数位数 decimals (默认: 2): 要四舍五入的小数位数 swapcloses (默认: False): [2018-11-16] 看起来关闭和调整后的关闭的顺序现在是固定的。保留该参数，以防需要再次交换列的顺序。 数据行：\nclose low high open volume openinterest datetime adjclose 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) reverse (False) adjclose (True) adjvolume (True) round (True) decimals (2) roundvolume (False) swapcloses (False )\nYahooFinanceData# 直接从 Yahoo 服务器下载数据。\n特定参数（或特定含义）：\ndataname: 要下载的代码（例如 \u0026lsquo;YHOO\u0026rsquo; 表示 Yahoo 自己的股票报价） proxies: 指示下载时使用的代理的字典，例如 {‘http’: ‘http://myproxy.com’} 或 {‘http’: ‘http://127.0.0.1:8080’} period: 要下载数据的时间框架。传递 \u0026lsquo;w\u0026rsquo; 表示每周，\u0026rsquo;m\u0026rsquo; 表示每月。 reverse: [2018-11-16] Yahoo 在线下载的最新版本返回的数据顺序正确。因此，在线下载的默认值为 False。 adjclose: 是否使用股息/拆股调整后的收盘价，并根据它调整所有值 urlhist: Yahoo Finance 中的历史报价 URL，用于获取下载的面包授权 cookie urldown: 实际下载服务器的 URL retries: 获取面包 cookie 和下载数据的次数 数据行：\nclose low high open volume openinterest datetime adjclose 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) reverse (False) adjclose (True) adjvolume (True) round (True) decimals (2) roundvolume (False) swapcloses (False) proxies ({}) period (d) urlhist (https://finance.yahoo.com/quote/{}/history) urldown (https://query1.finance.yahoo.com/v7/finance/download) retries (3) YahooLegacyCSV# 此类旨在加载 Yahoo 在 2017 年 5 月停止提供原始服务之前下载的文件。\n数据行：\nclose low high open volume openinterest datetime adjclose 参数：\ndataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) headers (True) separator (,) reverse (False) adjclose (True) adjvolume (True) round (True) decimals (2) roundvolume (False) swapcloses (False) version () "},{"id":92,"href":"/backtrader/docs/15-livetrading/","title":"实盘","section":"介绍","content":"从 1.5.0 版本开始，backtrader 支持实时数据和实时交易。\n支持的实时数据和交易平台有：\nInteractive Brokers Visual Chart Oanda "},{"id":93,"href":"/backtrader/docs/18-automated-running/","title":"自动运行","section":"介绍","content":"自动运行# 到目前为止，所有 backtrader 示例和工作样本都从头开始创建一个主 Python 模块，该模块加载数据、策略、观察器，并准备现金和佣金方案。\n算法交易的目标之一是自动化交易，而 backtrader 作为一个回测平台，旨在检查交易算法（因此是一个算法交易平台），自动化使用 backtrader 是一个显而易见的目标。\n安装 backtrader 后，它提供了两个脚本/可执行文件形式的入口点，自动化大多数任务：\nbt-run-py：一个使用下一个条目中的代码库的脚本。 btrun（可执行文件）：由 setuptools 在打包时创建的入口点。该可执行文件在 Windows 下具有优势，理论上不会出现“找不到路径/文件”的错误。 下面的描述适用于这两个工具。\nbtrun 允许最终用户：\n指定要加载的数据源 设置加载数据的格式 指定数据的日期范围 传递参数给 Cerebro 禁用标准观察器 这是一个原始的额外开关，在实现“Cerebro”参数之前。因此，如果传递了与标准观察器相关的参数给 Cerebro，将忽略此参数（参数 stdstats 给 Cerebro） 从内置或 Python 模块加载一个或多个观察器（例如：DrawDown） 设置经纪商的现金和佣金方案参数（佣金、保证金、倍数） 启用绘图，控制图表的数量和样式 向系统添加一个参数化的 writer 最后是核心功能：加载一个策略（内置或来自 Python 模块） 传递参数给加载的策略 请参阅下面的脚本用法。\n应用用户定义策略# 考虑以下策略，它：\n简单加载一个简单移动平均线（默认周期为 15） 打印输出 存在于名为 mymod.py 的文件中 from __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt import backtrader.indicators as btind class MyTest(bt.Strategy): params = ((\u0026#39;period\u0026#39;, 15),) def log(self, txt, dt=None): \u0026#39;\u0026#39;\u0026#39;策略的日志记录函数\u0026#39;\u0026#39;\u0026#39; dt = dt或self.data.datetime[0] if isinstance(dt, float): dt = bt.num2date(dt) print(\u0026#39;%s, %s\u0026#39; % (dt.isoformat(), txt)) def __init__(self): sma = btind.SMA(period=self.p.period) def next(self): ltxt = \u0026#39;%d, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f\u0026#39; self.log(ltxt % (len(self), self.data.open[0], self.data.high[0], self.data.low[0], self.data.close[0], self.data.volume[0], self.data.openinterest[0]))使用常规测试示例执行策略非常简单：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --strategy mymod.py图表输出：\n控制台输出：\n2006-01-20T23:59:59+00:00, 15, 3593.16, 3612.37, 3550.80, 3550.80, 0.00, 0.00 2006-01-23T23:59:59+00:00, 16, 3550.24, 3550.24, 3515.07, 3544.31, 0.00, 0.00 2006-01-24T23:59:59+00:00, 17, 3544.78, 3553.16, 3526.37, 3532.68, 0.00, 0.00 2006-01-25T23:59:59+00:00, 18, 3532.72, 3578.00, 3532.72, 3578.00, 0.00, 0.00 ... 2006-12-22T23:59:59+00:00, 252, 4109.86, 4109.86, 4072.62, 4073.50, 0.00, 0.00 2006-12-27T23:59:59+00:00, 253, 4079.70, 4134.86, 4079.70, 4134.86, 0.00, 0.00 2006-12-28T23:59:59+00:00, 254, 4137.44, 4142.06, 4125.14, 4130.66, 0.00, 0.00 2006-12-29T23:59:59+00:00, 255, 4130.12, 4142.01, 4119.94, 4119.94, 0.00, 0.00相同策略，但将参数 period 设置为 50 的命令行：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --plot \\ --strategy mymod.py:period=50图表输出：\n注意：如果没有提供 .py 扩展名，bt-run 会自动添加它。\n使用内置策略# backtrader 将逐步包括一些示例（教科书）策略。与 bt-run.py 脚本一起，包含了一个标准的简单移动平均交叉策略。名称为 SMA_CrossOver。\n参数# fast（默认 10）：快速移动平均线的周期 slow（默认 30）：慢速移动平均线的周期 该策略在快速移动平均线上穿慢速移动平均线时买入，并在快速移动平均线下穿慢速移动平均线时卖出（仅在之前已买入的情况下）。\n代码如下：\nfrom __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt import backtrader.indicators as btind class SMA_CrossOver(bt.Strategy): params = ((\u0026#39;fast\u0026#39;, 10), (\u0026#39;slow\u0026#39;, 30)) def __init__(self): sma_fast = btind.SMA(period=self.p.fast) sma_slow = btind.SMA(period=self.p.slow) self.buysig = btind.CrossOver(sma_fast, sma_slow) def next(self): if self.position.size: if self.buysig \u0026lt; 0: self.sell() elif self.buysig \u0026gt; 0: self.buy()标准执行：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --plot \\ --strategy :SMA_CrossOver注意 :。标准的加载策略表示法为：module:strategy:kwargs。规则如下：\n如果指定了 module 和 strategy，则使用该策略。 如果指定了 module 但未指定 strategy，则使用模块中找到的第一个策略。 如果未指定 module，则“strategy”被视为 backtrader 包中的策略。 如果指定了 module 和/或 strategy，如果存在 kwargs，它们将传递给相应的策略。 注意：相同的表示法和规则适用于 --observer、--analyzer 和 --indicator 选项，显然适用于相应的对象类型。\n输出结果：\n最后一个示例，添加佣金方案、现金并更改参数：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --plot \\ --cash 20000 \\ --commission 2.0 \\ --mult 10 \\ --margin 2000 \\ --strategy :SMA_CrossOver:fast=5,slow=20输出结果：\n我们已经回测了策略：\n更改移动平均线周期 设置新的起始现金 为类似期货的工具设置佣金方案 观察每个条的现金持续变化，因为现金根据类似期货工具的每日变化进行调整。\n使用无策略# 这是一个夸张的说法。会应用一个策略，但您可以省略任何类型的策略，会自动添加一个默认的 backtrader.Strategy。\n分析器、观察器和指标将自动注入策略中。\n例如：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --cash 20000 \\ --commission 2.0 \\ --mult 10 \\ --margin 2000 \\ --nost dstats \\ --observer :Broker这不会做很多事情，但可以实现以下目的：\n在后台添加一个默认的 backtrader.Strategy Cerebro 不会实例化常规的 stdstats 观察器（Broker、BuySell、Trades） 手动添加一个 Broker 观察器 如上所述，nostdstats 是一个遗留参数。更新版本的 btrun 可以将参数直接传递给 Cerebro。等效调用如下：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --cash 20000 \\ --commission 2.0 \\ --mult 10 \\ --margin 2000 \\ --cerebro stdstats=False \\ --observer :Broker添加分析器# btrun 还支持使用与选择内部/外部分析器相同的语法添加分析器。\n例如，对 2005-2006 年进行夏普比率分析：\nbtrun --csvformat btcsv \\ --data ../../datas/2005-2006-day-001.txt \\ --strategy :SMA_CrossOver \\ --analyzer :SharpeRatio控制台输出为空。\n如果希望打印分析器结果，必须指定：\n--pranalyzer，默认调用下一个（除非分析器覆盖了适当的方法） --ppranalyzer，使用 pprint 模块打印结果 注意：这两个打印选项在 writers 成为 backtrader 的一部分之前实现。添加一个 writer 而不输出 CSV 将实现相同的效果（并且输出得到了改进）。\n扩展上述示例：\nbtrun --csvformat btcsv \\ --data ../../datas/2005-2006-day-001.txt \\ --strategy :SMA_CrossOver \\ --analyzer :SharpeRatio \\ --plot \\ --pranalyzer ==================== == Analyzers ==================== ########## sharperatio ########## {\u0026#39;sharperatio\u0026#39;: 11.647332609673256}好策略！（实际上纯属运气，示例中没有考虑佣金）\n图表（仅显示分析器未在图表中绘制，因为分析器无法绘制，它们不是线条对象）：\n使用 writer 参数的相同示例：\nbtrun --csvformat btcsv \\ --data ../../datas/2005-2006-day-001.txt \\ --strategy :SMA_CrossOver \\ --analyzer :SharpeRatio \\ --plot \\ --writer =============================================================================== Cerebro: ----------------------------------------------------------------------------- - Datas: +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ - Data0: - Name: 2005-2006-day-001 - Timeframe: Days - Compression: 1 ----------------------------------------------------------------------------- - Strategies: +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ - SMA_CrossOver: ************************************************************************* - Params: - fast: 10 - slow: 30 - _movav: SMA ************************************************************************* - Indicators: ....................................................................... - SMA: - Lines: sma ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ - Params: - period: 30 ....................................................................... - CrossOver: - Lines: crossover - Params: None ************************************************************************* - Observers: ....................................................................... - Broker: - Lines: cash, value - Params: None ....................................................................... - BuySell: - Lines: buy, sell - Params: None ....................................................................... - Trades: - Lines: pnlplus, pnlminus - Params: None ************************************************************************* - Analyzers: ....................................................................... - Value: - Begin: 10000.0 - End: 10496.68 ....................................................................... - SharpeRatio: - Params: None ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ - Analysis: - sharperatio: 11.6473326097添加指标和观察器# 与策略和分析器相同，btrun 还可以添加：\n指标 观察器 语法与上面添加 Broker 观察器时所见完全相同。\n让我们重复示例，添加一个随机指标、Broker 并查看图表（我们将更改一些参数）：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --nostdstats \\ --observer :Broker \\ --indicator :Stochastic:period_dslow=5 \\ --plot图表：\n绘图控制# 上面大多数示例都使用了以下选项：\n--plot：激活创建默认图表 更多控制可以通过向 --plot 选项添加 kwargs 实现\n--plot style=\u0026quot;candle\u0026quot; 例如，使用蜡烛图而不是 LineOnClose 样式（这是绘图默认值） 调用如下：\nbtrun --csvformat btcsv \\ --data ../../datas/2006-day-001.txt \\ --nostdstats \\ --observer :Broker \\ --indicator :Stochastic:period_dslow=5 \\ --plot style=\\\u0026#34;candle\\\u0026#34;注意：示例在 bash shell 中运行，传递参数给脚本之前会去除引号，因此需要使用反斜杠转义 \\\u0026quot; 确保 candle 作为字符串传递。\n图表：\n脚本用法# 直接从脚本：\n$ btrun --help usage: btrun-script.py [-h] --data DATA [--cerebro [kwargs]] [--nostdstats] [--format {yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracsv,yahoocsv,btcsv,vcdata}] [--fromdate FROMDATE] [--todate TODATE] [--timeframe {microseconds,seconds,weeks,months,minutes,days,years}] [--compression COMPRESSION] [--resample RESAMPLE | --replay REPLAY] [--strategy module:name:kwargs] [--signal module:signaltype:name:kwargs] [--observer module:name:kwargs] [--analyzer module:name:kwargs] [--pranalyzer | --ppranalyzer] [--indicator module:name:kwargs] [--writer [kwargs]] [--cash CASH] [--commission COMMISSION] [--margin MARGIN] [--mult MULT] [--interest INTEREST] [--interest_long] [--slip_perc SLIP_PERC] [--slip_fixed SLIP_FIXED] [--slip_open] [--no-slip_match] [--slip_out] [--flush] [--plot [kwargs]] Backtrader Run Script optional arguments: -h, --help show this help message and exit --resample RESAMPLE, -rs RESAMPLE resample with timeframe:compression values --replay REPLAY, -rp REPLAY replay with timeframe:compression values --pranalyzer, -pralyzer Automatically print analyzers --ppranalyzer, -ppralyzer Automatically PRETTY print analyzers --plot [kwargs], -p [kwargs] Plot the read data applying any kwargs passed For example: --plot style=\u0026#34;candle\u0026#34; (to plot candlesticks) Data options: --data DATA, -d DATA Data files to be added to the system Cerebro options: --cerebro [kwargs], -cer [kwargs] The argument can be specified with the following form: - kwargs Example: \u0026#34;preload=True\u0026#34; which set its to True The passed kwargs will be passed directly to the cerebro instance created for the execution The available kwargs to cerebro are: - preload (default: True) - runonce (default: True) - maxcpus (default: None) - stdstats (default: True) - live (default: False) - exactbars (default: False) - preload (default: True) - writer (default False) - oldbuysell (default False) - tradehistory (default False) --nostdstats Disable the standard statistics observers --format {yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracsv,yahoocsv,btcsv,vcdata}, --csvformat {yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracsv,yahoocsv,btcsv,vcdata}, -c {yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracsv,yahoocsv,btcsv,vcdata} CSV Format --fromdate FROMDATE, -f FROMDATE Starting date in YYYY-MM-DD[THH:MM:SS] format --todate TODATE, -t TODATE Ending date in YYYY-MM-DD[THH:MM:SS] format --timeframe {microseconds,seconds,weeks,months,minutes,days,years}, -tf {microseconds,seconds,weeks,months,minutes,days,years} Ending date in YYYY-MM-DD[THH:MM:SS] format --compression COMPRESSION, -cp COMPRESSION Ending date in YYYY-MM-DD[THH:MM:SS] format Strategy options: --strategy module:name:kwargs, -st module:name:kwargs This option can be specified multiple times. The argument can be specified with the following form: - module:classname:kwargs Example: mymod:myclass:a=1,b=2 kwargs is optional If module is omitted then class name will be sought in the built-in strategies module. Such as in: - :name:kwargs or :name If name is omitted, then the 1st strategy found in the mod will be used. Such as in: - module or module::kwargs Signals: --signal module:signaltype:name:kwargs, -sig module:signaltype:name:kwargs This option can be specified multiple times. The argument can be specified with the following form: - signaltype:module:signaltype:classname:kwargs Example: longshort+mymod:myclass:a=1,b=2 signaltype may be ommited: longshort will be used Example: mymod:myclass:a=1,b=2 kwargs is optional signaltype will be uppercased to match the defintions fromt the backtrader.signal module If module is omitted then class name will be sought in the built-in signals module. Such as in: - LONGSHORT::name:kwargs or :name If name is omitted, then the 1st signal found in the mod will be used. Such as in: - module or module:::kwargs Observers and statistics: --observer module:name:kwargs, -ob module:name:kwargs This option can be specified multiple times. The argument can be specified with the following form: - module:classname:kwargs Example: mymod:myclass:a=1,b=2 kwargs is optional If module is omitted then class name will be sought in the built-in observers module. Such as in: - :name:kwargs or :name If name is omitted, then the 1st observer found in the will be used. Such as in: - module or module::kwargs Analyzers: --analyzer module:name:kwargs, -an module:name:kwargs This option can be specified multiple times. The argument can be specified with the following form: - module:classname:kwargs Example: mymod:myclass:a=1,b=2 kwargs is optional If module is omitted then class name will be sought in the built-in analyzers module. Such as in: - :name:kwargs or :name If name is omitted, then the 1st analyzer found in the will be used. Such as in: - module or module::kwargs Indicators: --indicator module:name:kwargs, -ind module:name:kwargs This option can be specified multiple times. The argument can be specified with the following form: - module:classname:kwargs Example: mymod:myclass:a=1,b=2 kwargs is optional If module is omitted then class name will be sought in the built-in analyzers module. Such as in: - :name:kwargs or :name If name is omitted, then the 1st analyzer found in the will be used. Such as in: - module or module::kwargs Writers: --writer [kwargs], -wr [kwargs] This option can be specified multiple times. The argument can be specified with the following form: - kwargs Example: a=1,b=2 kwargs is optional It creates a system wide writer which outputs run data Please see the documentation for the available kwargs Cash and Commission Scheme Args: --cash CASH, -cash CASH Cash to set to the broker --commission COMMISSION, -comm COMMISSION Commission value to set --margin MARGIN, -marg MARGIN Margin type to set --mult MULT, -mul MULT Multiplier to use --interest INTEREST Credit Interest rate to apply (0.0x) --interest_long Apply credit interest to long positions --slip_perc SLIP_PERC Enable slippage with a percentage value --slip_fixed SLIP_FIXED Enable slippage with a fixed point value --slip_open enable slippage for when matching opening prices --no-slip_match Disable slip_match, ie: matching capped at high-low if slippage goes over those limits --slip_out with slip_match enabled, match outside high-low --flush flush the output - useful under win32 systems"},{"id":94,"href":"/backtrader/readme/","title":"Readme","section":"首页","content":"Fyne 中文文档# Backtrader 是一款 Python 实现量化回测框架，本文档是基于 Backtrader4的官方文档中文翻译版。英文原版，请异步 backtrader.com。\n"}]