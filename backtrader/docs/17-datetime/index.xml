<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>日期时间 on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/</link><description>Recent content in 日期时间 on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/17-datetime/index.xml" rel="self" type="application/rss+xml"/><item><title>管理</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/01-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/01-management/</guid><description>管理 # 在发布 1.5.0 版本之前，backtrader 对时间管理采用的是直接方式，即直接使用数据源计算出的任何日期时间。用户输入的参数，如 fromdate（或 sessionstart），也可以传递给任何数据源。
这种方法在对冻结数据源进行回测时效果很好。可以假设输入的日期时间在进入系统之前已经经过处理。
但在 1.5.0 版本之后，backtrader 开始支持实时数据源，这就需要考虑日期时间管理。如果以下情况总是成立，那么就不需要进行这种管理：
纽约的交易者交易 ES-Mini。这两个的时区都是 US/Eastern（或其别名）。 柏林的交易者交易 DAX 期货。在这种情况下，两个的时区都是 CET（或 Europe/Berlin）。 上面的直接输入-输出日期时间方法可以工作，因为柏林的交易者可以始终这样做：
class Strategy(bt.Strategy): def next(self): # DAX 期货在 CET 时间早上 08:00 开盘 if self.data.datetime.time() &amp;lt; datetime.time(8, 30): # 市场运行 30 分钟之前不操作 return # 当同一个柏林交易者决定交易 ES-Mini 时，直接方法的问题就会显现出来。因为 DST（夏令时）的变化发生在一年中的不同时间，这会导致时间差异在一年中的某些周内不同步。
以下代码并不总是有效：
class Strategy(bt.Strategy): def next(self): # SPX 在 US/Eastern 全年早上 09:30 开盘 # 大部分时间是 15:30 CET # 但有时是 16:30 CET 或 14:30 CET，取决于美国和欧洲的 DST 切换时间 # 因此以下代码是不可靠的 if self.</description></item><item><title>定时器</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/02-timer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/02-timer/</guid><description>定时器 # 在版本 1.9.44.116 中，backtrader 添加了定时器功能。这使得在特定时间点调用 notify_timer（在 Cerebro 和 Strategy 中可用）成为可能，用户可以进行精细控制。
选项 # 基于绝对时间输入或相对于会话开始/结束时间的定时器。 时间规范的时区指定，可以直接通过 pytz 兼容对象或通过数据源会话结束时间进行指定。 相对于指定时间的起始偏移。 重复间隔。 工作日过滤器（带有结转选项）。 月份天数过滤器（带有结转选项）。 自定义回调过滤器。 使用模式 # 在 Cerebro 和 Strategy 子类中，定时器回调将在以下方法中接收：
def notify_timer(self, timer, when, *args, **kwargs): &amp;#39;&amp;#39;&amp;#39;接收定时器通知，其中 `timer` 是通过 `add_timer` 返回的定时器，`when` 是调用时间。 `args` 和 `kwargs` 是传递给 `add_timer` 的额外参数。 实际的 `when` 时间可能稍后，但系统可能无法在之前调用定时器。 此值是定时器值，而不是系统时间。 &amp;#39;&amp;#39;&amp;#39; 添加定时器 - 通过 Strategy # 使用以下方法完成：
def add_timer(self, when, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, *args, **kwargs): &amp;#39;&amp;#39;&amp;#39; 它返回创建的 Timer 实例。下面是参数的解释。</description></item><item><title>交易日历</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/03-trading-calendars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/03-trading-calendars/</guid><description>交易日历 # 版本 1.9.42.116 增加了对交易日历的支持。这在以下场景中的重采样时非常有用：
从每日到每周的重采样现在可以将每周的K线与本周的最后一根K线一起交付。 这是因为交易日历可以识别下一个交易日，并且可以提前识别出本周的最后一个交易日。 当交易会话的结束时间不是常规时间（可以通过数据源来指定）时，从子日内到每日的重采样。 交易日历接口 # 有一个基类 TradingCalendarBase 用作任何交易日历的基类。它定义了两个必须被重写的方法：
class TradingCalendarBase(with_metaclass(MetaParams, object)): def _nextday(self, day): &amp;#39;&amp;#39;&amp;#39; 返回在 `day`（datetime/date 实例）之后的下一个交易日（datetime/date 实例）以及 isocalendar 组件。 返回值是一个包含两个组件的元组：(nextday, (y, w, d))，其中 (y, w, d)。 &amp;#39;&amp;#39;&amp;#39; raise NotImplementedError def schedule(self, day): &amp;#39;&amp;#39;&amp;#39; 返回给定日期（datetime/date 实例）的开盘和收盘时间（`datetime.time`）。 &amp;#39;&amp;#39;&amp;#39; raise NotImplementedError 实现 # PandasMarketCalendar # 这个实现基于一个不错的包，这是从 Quantopian 的初始功能衍生出来的。包位于 pandas_market_calendars，可以很容易地安装：
pip install pandas_market_calendars 实现的接口如下：
class PandasMarketCalendar(TradingCalendarBase): &amp;#39;&amp;#39;&amp;#39; `pandas_market_calendars` 的交易日历包装器。必须安装 `pandas_market_calendar` 包。 参数： - `calendar` (默认 `None`) 参数 `calendar` 接受以下内容： - 字符串：支持的日历名称，例如 `NYSE`。包装器会尝试获取一个日历实例。 - 日历实例：由 `get_calendar(&amp;#39;NYSE&amp;#39;)` 返回。 - `cachesize` (默认 `365`) 缓存查找提前天数。 参见： - https://github.</description></item></channel></rss>