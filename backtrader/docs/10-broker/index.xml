<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Broker on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/10-broker/</link><description>Recent content in Broker on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/10-broker/index.xml" rel="self" type="application/rss+xml"/><item><title>Broker</title><link>https://www.poloxue.com/backtrader/docs/10-broker/01-broker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/01-broker/</guid><description>Broker # 类 backtrader.brokers.BackBroker() # Broker 经纪商模拟器，该模拟支持不同的订单类型，检查提交订单的现金需求与当前现金的对比，跟踪每次 Cerebro 迭代的现金和价值，并保持不同数据的当前头寸。
现金在每次迭代中调整，对于期货等工具来说，当价格变化时，会在实际经纪商中增加或减少现金。 支持的订单类型：
Market：将在下一个柱的第一个tick（即开盘价）执行 Close：用于日内交易，订单以会话最后一个柱的收盘价执行 Limit：如果在会话期间看到给定的限价则执行 Stop：如果看到给定的止损价，则执行市场订单 StopLimit：如果看到给定的止损价，则启动限价订单 因为经纪商由 Cerebro 实例化，用户通常不需要替换经纪商实例，因此参数不受用户控制。
要更改参数，有两种选择：
手动创建带所需参数的 Broker，用 cerebro.broker = instance 将该实例设置为这个经纪商； 使用 set_xxx 方法通过 cerebro.broker.set_xxx 设置参数，其中 xxx 代表设置参数名称； 注意，cerebro.broker 是一个由 Cerebro 的 getbroker 和 setbroker 方法支持的属性。
参数 # 参数名 默认值 描述 cash 10000 起始现金 commission CommInfoBase(percabs=True) 适用于所有资产的基础佣金方案 checksubmit True 在将订单接受到系统之前检查保证金/现金 eosbar False 对于日内 Bar，考虑与会话结束时间相同的柱为会话结束。通常不会这样，因为许多交易所会在会话结束后几分钟内为许多产品生成一些柱（最终拍卖） filler None 一个可调用对象，签名为 callable(order, price, ago)。参数说明：- order：显然是执行中的订单。这提供了对数据的访问（包括 ohlc 和成交量值）、执行类型、剩余大小（order.executed.remsize）等。- price：订单将在 ago 柱中执行的价格- ago：用于从 order.</description></item><item><title>滑点</title><link>https://www.poloxue.com/backtrader/docs/10-broker/02-slippage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/02-slippage/</guid><description>滑点 # 回测无法保证真实市场条件。无论市场模拟有多好，在真实市场条件下滑点可能发生。这意味着，请求的价格可能无法匹配。
集成的回测经纪商支持滑点，以下参数可以传递给经纪商：
参数名 默认值 描述 slip_perc 0.0 应用于买卖订单的价格上下滑动的绝对百分比（且为正值），注意：0.01 是 1%，0.001 是 0.1%； slip_fixed 0.0 应用于买卖订单的价格上下滑动的单位百分比（且为正值），注意：如果 slip_perc 非零，则优先于此。 slip_open False 是否为专门使用下一个柱的开盘价执行的订单滑动价格。例如，市场订单将在下一个可用tick执行，即柱的开盘价。这也适用于其他一些执行，因为逻辑尝试检测开盘价是否会匹配请求的价格/执行类型在移动到新柱时。 slip_match True - 如果为 True，经纪商将通过在高/低价位封顶滑点来提供匹配，以防它们超出。- 如果为 False，经纪商将不会使用当前价格匹配订单，并将在下一次迭代中尝试执行 slip_limit True - 限价订单，给定确切的匹配价格请求，即使 slip_match 为 False，也会被匹配。- 此选项控制该行为。- 如果为 True，那么限价订单将通过在限价/高低价位封顶价格进行匹配。- 如果为 False 且滑点超出上限，则不会有匹配 slip_out False 即使价格超出高-低范围，也提供滑点。 工作原理 # 为了决定何时应用滑点，考虑了订单执行类型：
Close - 不应用滑点
这种订单匹配收盘价，而这个价格是当天的最后一个。滑点无法发生，因为订单只能在会话的最后一个tick发生，而这是唯一的价格，没有容忍度。 Market - 应用滑点
请检查 slip_open 例外情况。因为市场订单将匹配下一个柱的开盘价。 Limit - 按以下逻辑应用滑点
如果匹配价格是开盘价，则根据参数 slip_open 应用滑点。如果应用，价格不会比请求的限价更差。 如果匹配价格不是限价，则应用滑点在高/低点封顶。在这种情况下，slip_limit 应用以决定在超过封顶时是否会发生匹配。 如果匹配价格是限价，则不应用滑点。 Stop - 一旦订单触发，应用与市场订单相同的逻辑</description></item><item><title>开盘作弊</title><link>https://www.poloxue.com/backtrader/docs/10-broker/03-cheat-on-open/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/03-cheat-on-open/</guid><description>Cheat On Open（开盘作弊） # 版本 1.9.44.116 添加了 Cheat-On-Open 支持。这似乎是对那些在计算完一个柱的收盘价后全仓操作的人们的需求，他们期望与开盘价匹配。
当开盘价跳空（向上或向下，取决于买入或卖出）且现金不足以进行全仓操作时，这种情况会失败。这迫使经纪商拒绝操作。
虽然人们可以尝试通过正 [1] 索引法查看未来，但这需要预加载数据，而这并不总是可行的。
模式 # cerebro = bt.Cerebro(cheat_on_open=True) 这会在系统中激活一个额外的循环，该循环调用策略中的 next_open、nextstart_open 和 prenext_open 方法。
为了清楚地分离常规方法（这些方法基于所检查的价格不再可用且未来未知）和作弊模式下的操作，决定增加一组额外的方法家族。
这也避免了对常规 next 方法的两次调用。
以下情况在 xxx_open 方法内部保持不变：
指标尚未重新计算，保持上一个循环中在等效的 xxx 常规方法中最后看到的值。 经纪商尚未评估新循环中的待处理订单，并且可以引入新订单，如果可能，将进行评估。 注意：
Cerebro 还有一个名为 broker_coo（默认值：True）参数，它告诉 cerebro 如果激活了 cheat-on-open，它也会尝试在经纪商中激活它（如果可能的话）。 模拟经纪商有一个名为 coo 的参数和一个名为 set_coo 的方法来设置它。 尝试 Cheat-on-open # 下面的示例有一个策略，具有两种不同的行为：
如果 cheat-on-open 为 True，它将仅从 next_open 操作。 如果 cheat-on-open 为 False，它将仅从 next 操作。 在这两种情况下，匹配价格必须相同：
如果不作弊，订单在前一天的收盘后发出，并将与下一个到来的价格（开盘价）匹配。 如果作弊，订单在同一天发出并执行。因为订单是在经纪商评估订单之前发出的，所以它也将与下一个到来的价格（开盘价）匹配。 第二种情况下，可以精确计算全仓策略的份额，因为可以直接访问当前的开盘价。
在这两种情况下，当前的开盘价和收盘价将从 next 中打印。</description></item><item><title>填充器</title><link>https://www.poloxue.com/backtrader/docs/10-broker/04-volume-filling-filler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/04-volume-filling-filler/</guid><description>填充器 # Backtrader 的经纪模拟在订单执行时有一个默认策略：忽略交易量。这是基于两个前提：
交易在流动性足够高的市场中，可以一次性完全吸收买/卖订单 实际的交易量匹配需要真实的市场环境 一个简单的例子是“立即成交或取消”（Fill or Kill）订单。即使细化到每一笔交易，并且有足够的交易量来完成订单，Backtrader的经纪模拟也无法知道市场中有多少其他参与者来判断这样的订单是否会被匹配以遵循“立即成交”部分，或者订单是否应该被取消。
但是经纪模拟可以接受交易量填充器（Volume Fillers），它们决定在给定时间点应该使用多少交易量来匹配订单。
填充器签名 # 在Backtrader生态系统中，填充器可以是任何符合以下签名的可调用对象：
callable(order, price, ago) 其中：
order 是即将执行的订单，该对象提供对目标数据对象的访问，创建的大小/价格、执行的价格/大小/剩余大小和其他详细信息 price 是订单执行的价格 ago 是数据在订单中的索引，用于查找交易量和价格元素 在几乎所有情况下，这将是0（当前时间点），但在某些特殊情况下（例如Close订单），这可能是-1。
例如，访问bar交易量可以这样做：
barvolume = order.data.volume[ago] 可调用对象可以是一个函数，或例如支持__call__方法的类的实例，例如：
class MyFiller(object): def __call__(self, order, price, ago): pass 将填充器添加到经纪模拟
最直接的方法是使用set_filler：
import backtrader as bt cerebro = Cerebro() cerebro.broker.set_filler(bt.broker.fillers.FixedSize()) 第二种选择是完全替换经纪模拟，这可能仅适用于重写了部分功能的BrokerBack子类：
import backtrader as bt cerebro = Cerebro() filler = bt.broker.fillers.FixedSize() newbroker = bt.broker.BrokerBack(filler=filler) cerebro.broker = newbroker 示例 # Backtrader的源代码中包含一个名为volumefilling的示例，它允许测试一些集成的填充器（最初是全部）。
参考 # class backtrader.</description></item><item><title>Position</title><link>https://www.poloxue.com/backtrader/docs/10-broker/05-position/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/05-position/</guid><description>Position # 通常在策略中要检查资产 Position，或成为仓位、头寸，通过 position 属性或 getposition(data=None, broker=None) 方法。这将返回策略在cerebro提供的默认经纪商中的datas[0]的头寸。
头寸只是一个表示：
持有的资产数量（size） 平均价格（price） 它用作状态指示，例如可以用于决定是否需要发出订单（例如：仅在没有持仓时进入多头头寸）。
参考 # class backtrader.position.Position(size=0, price=0.0) 保存并更新头寸的数量和价格。该对象与任何资产没有关系。它只保存数量和价格。
成员属性：
size（int）：当前头寸的数量 price（float）：当前头寸的价格 可以使用 len(position) 来测试头寸实例以查看数量是否不为零。</description></item><item><title>Trade</title><link>https://www.poloxue.com/backtrader/docs/10-broker/06-trade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/06-trade/</guid><description> Trade # 交易的定义：当一个工具的头寸从 0 变为一个大小X（多头/空头头寸分别为正/负）时，交易被认为是开启的。或是当一个头寸从X变为0时，交易被认为是关闭的。
以下两种操作：
从正变负 从负变正 实际上被视为：一个交易被关闭了（头寸从X变为0），一个新的交易被开启了（头寸从0变为Y）
交易仅用于信息展示，用户无法调用其方法。
参考 # class backtrader.trade.Trade(data=None, tradeid=0, historyon=False, size=0, price=0.0, value=0.0, commission=0.0) 追踪交易的生命周期：数量、价格、佣金（和价值？）。一个交易从0开始，可以增加和减少，如果回到0可以被认为是关闭的。交易可以是多头（正数）或空头（负数）。交易不支持反转（逻辑中不支持）
成员属性 描述 ref 唯一的交易标识符 status Created, Open, Closed之一 tradeid 在创建订单时传递给订单的分组交易ID，订单的默认值为0 size 当前交易的数量 price 当前交易的价格 value 当前交易的价值 commission 当前累计的佣金 pnl 当前交易的盈亏（毛利） pnlcomm 当前交易的净盈亏（扣除佣金后的净利润） isclosed 记录最后一次更新是否关闭了交易（将交易数量设为零） isopen 记录任何更新是否开启了交易 justopened 如果交易刚刚开启 baropen 交易开启的bar dtopen 交易开启的浮点编码日期时间，使用 open_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barclose 交易关闭的bar dtclose 交易关闭的浮点编码日期时间，使用 close_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barlen 交易开启的bar数量 historyon 是否记录历史 history 包含每次“更新”事件更新后的状态和使用的参数的列表，历史记录的第一个条目是开启事件，最后一个条目是关闭事件</description></item></channel></rss>