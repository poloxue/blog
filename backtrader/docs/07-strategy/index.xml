<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Strategy on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/</link><description>Recent content in Strategy on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/07-strategy/index.xml" rel="self" type="application/rss+xml"/><item><title>Strategy</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/01-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/01-strategy/</guid><description>Strategy # 在 backtrader 中，Cerebro 实例是整个系统的核心，而 Strategy 是用户的核心。
Strategy 的生命周期方法 # 注意, 策略可以在创建时通过抛出 StrategySkipError 异常来中断，该异常来自 backtrader.errors 模块。这将避免在回测期间处理该策略。请参阅“异常”部分。
构建：__init__ # 这是在实例化期间调用的：指标将在此处创建以及其他需要的属性。
示例代码：
def __init__(self): self.sma = btind.SimpleMovingAverage(period=15) 启动：start # Cerebro 实例通知策略是时候开始运行了。存在一个默认的空方法。
初期：prenext # 在创建期间声明的指标将对策略的成熟期施加限制：这称为最小周期。上面的 __init__ 创建了一个周期为 15 的简单移动平均线 (SMA)。
只要系统看到的 bar 少于 15 个，就会调用 prenext（默认实现为空操作）。
成熟：next # 一旦系统看到 15 个 bar 并且 SMA 有足够的缓冲区开始生成值，策略就足够成熟可以真正执行。
存在一个 nextstart 方法，会在从 prenext 切换到 next 时调用一次。nextstart 的默认实现是简单地调用 next。
繁衍：无 # 策略实际上不会繁衍，但从某种意义上来说，它们会，因为系统会在优化时实例化它们多次（使用不同的参数）。
结束：stop # 系统通知策略是时候重置并整理一切了。存在一个默认的空方法。
通常情况下和常规使用模式下，这看起来像这样：</description></item><item><title>信号策略</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/02-strategy-with-signals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/02-strategy-with-signals/</guid><description>信号策略 # 使用 backtrader 进行操作不一定非得编写一个策略类。虽然这是首选方式，但由于对象层次结构的原因，使用信号也是可行的。
快速总结： # 不需要编写策略类、实例化指标、编写买卖逻辑等。 添加信号（无论如何也是指标），其余部分在后台完成。 快速示例： # import backtrader as bt data = bt.feeds.OneOfTheFeeds(dataname=&amp;#39;mydataname&amp;#39;) cerebro.adddata(data) cerebro.add_signal(bt.SIGNAL_LONGSHORT, MySignal) cerebro.run() 这就完成了。当然，信号本身还没有定义。
让我们定义一个非常简单的信号：
如果收盘价高于简单移动平均线 (SMA)，则发出多头信号。 如果收盘价低于 SMA，则发出空头信号。 定义如下：
class MySignal(bt.Indicator): lines = (&amp;#39;signal&amp;#39;,) params = ((&amp;#39;period&amp;#39;, 30),) def __init__(self): self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period) 现在真的完成了。
当运行 run 时，Cerebro 会处理实例化一个特殊的策略实例，它知道如何处理这些信号。
常见问题 # 买卖操作的数量是如何确定的？
Cerebro 实例自动为策略添加一个固定大小 (FixedSize) 的定量器。最终用户可以通过 cerebro.addsizer 更改定量器以改变策略。
订单是如何执行的？
执行类型为市价单，订单的有效期为“直到取消” (Good Until Canceled)。
信号细节 # 从技术和理论角度来看，可以描述为：
一个可调用对象，当被调用时返回另一个对象（只调用一次）。 在大多数情况下，这是一个类的实例化，但不一定非得是。 支持 __getitem__ 接口。唯一请求的键/索引将是 0。 从实际角度来看，信号是：</description></item><item><title>策略参考</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/03-strategy-references/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/03-strategy-references/</guid><description>策略参考 # 内置策略参考 # MA_CrossOver # 别名：SMA_CrossOver，这是一个仅做多的策略，基于移动平均线交叉操作。
交易规则 # 买入逻辑： 如果无持仓，fast 移动平均线向上穿过 slow 移动平均线。
卖出逻辑： 有持仓时，fast 移动平均线向下穿过 slow 移动平均线。
订单类型： 市价单
参数：
fast (10)，_movav (&amp;lt;class ‘backtrader.indicators.sma.SMA’&amp;gt;) slow (30)，_movav (&amp;lt;class ‘backtrader.indicators.sma.SMA’&amp;gt;) SignalStrategy # 此策略的子类旨在使用信号自动操作。信号通常是指标，预期输出值为：
&amp;gt; 0 表示多头指示 &amp;lt; 0 表示空头指示 信号分为两组，共有 5 种类型。
主要组：
LONGSHORT：接受来自该信号的多头和空头指示。 LONG： 接受多头指示进行做多。 接受空头指示平仓多头。但： 如果系统中有 LONGEXIT 信号，将用它来平仓多头。 如果有 SHORT 信号且没有 LONGEXIT 信号，它将被用来平仓多头再开空头。 SHORT： 接受空头指示进行做空。 接受多头指示平仓空头。但： 如果系统中有 SHORTEXIT 信号，将用它来平仓空头。 如果有 LONG 信号且没有 SHORTEXIT 信号，它将被用来平仓空头再开多头。 退出组：
这两个信号旨在覆盖其他信号，并为平仓提供标准。
LONGEXIT：接受空头指示平仓多头。 SHORTEXIT：接受多头指示平仓空头。 订单发出：</description></item></channel></rss>