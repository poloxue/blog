<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>快速开始 on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/</link><description>Recent content in 快速开始 on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/03-quickstart/index.xml" rel="self" type="application/rss+xml"/><item><title>环境设置</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/01-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/01-setup/</guid><description>环境设置 # 在开始构建复杂的交易策略前，我们要先配置策略运行环境。Backtrader 的环境离不开一个核心类 Cerebro（大脑），后续会详细介绍它。
初始化配置 # 我们先看完整的环境初始化设置的代码：
import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.Cerebro() print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 在这个示例中，我们首先导入了 backtrader 模块并命名为 bt。
import backtrader as bt 并基于 bt.Cerebro 实例化了 Cerebro 引擎。
cerebro = bt.Cerebro() 我们通过 cerebro.broker.getvalue() 获取并打印了初始的持仓组合价值，即我们的初始资金。
print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 接着运行 cerebro.run() 以处理数据模拟交易，并再次打印最终的持仓组合价值
cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 输出如下：
Starting Portfolio Value: 10000.</description></item><item><title>账户资金</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/02-cash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/02-cash/</guid><description>设置初始账户资金 # 上节中，账户资金使是默认值 10,000 货币单位。当然，这个默认值是可以更改的，通过 cerebro.broker 的 setcash 方法即可。
cerebro.broker.setcash(100000.0) 完整示例 # import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.Cerebro() cerebro.broker.setcash(100000.0) print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 输出：
Starting Portfolio Value: 100000.00 Final Portfolio Value: 100000.00 让我们继续进入下一节，配置数据源（DataFeed）。</description></item><item><title>配置数据</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/03-datafeed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/03-datafeed/</guid><description>配置数据 DataFeed # 我们目标是通过策略实现资产增值，这就离不开价格数据，甚至是其他有用的数据。本小节，我们将学习如何系统配置数据源，即添加数据源 DataFeed。
配置 DataFeed 要用到的是 backtrader.feeds 中提供的数据工具。要用到的数据文件是 orcl-1995-2014（点击下载即可下载）。
假设，数据文件被下载到当前目录，通过 bt.feeds.YahooFinanceCSVDataFeed 即可创建 datafeed。
data = bt.feeds.YahooFinanceCSVData( dataname=&amp;#34;./orcl-1995-2014.txt&amp;#34;, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False ) Yahoo 在线下载的 CSV 数据按日期降序排列，YahooFinanceCSVData 也是按这个标准解析。但我们提供的数据是升序排列，故设置参数 reverse=True。
接下来，我们通过 cerebro.adddata 将数据添加系统即可。
cerebro.adddata(data) 将这部分实现补充到我们的系统中。
完整示例 # import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.</description></item><item><title>第一个策略</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/04-first-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/04-first-strategy/</guid><description>第一个策略 # 本节我们将学习如何开发策略。
第一个策略不涉及交易，我们将通过它打印每一天（bar）的 &amp;ldquo;收盘价（Close）&amp;rdquo; 。
策略类（Strategy）继承自 bt.Strategy。
class TestStrategy(bt.Strategy): def __init__(self): pass def next(self): pass 它最重要的两个方法是 __init__（策略初始化）和 next（每个 OHLC，即bar，执行一次该方法）。
class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(&amp;#39;Close, %.2f&amp;#39; % self.dataclose[0]) 如上代码中的 self.datas[0].close 访问的就是 cerebro.broker.adddata 方法添加的第一个数据源 DataFeed。
数据列表（self.datas）是一个标准的Python列表，如添加多个数据源，数据按插入顺序存储。列表中的第一个数据项self.datas[0]是默认交易数据，用于同步所有策略元素（它作为系统时钟）。
self.datas 的列表元素 data 底层类是 DataSeries，它有别名访问众所周知的 OHLC（开盘、高、低、收盘）每日值。
open = data.open low = data.low high = data.high close = data.</description></item><item><title>开始交易</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/05-strategy-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/05-strategy-logic/</guid><description>开始交易 # 本节，我们将演示一个简单的策略，让策略执行交易操作，如果出现连续两个交易日下跌即 - 买入！买入！买入！
我们将基于上节的策略类 TestStrategy 继续开发，策略逻辑部分要在 next 方法中实现。
class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(&amp;#39;Close, %.2f&amp;#39; % self.dataclose[0]) 首先是买入条件，如何判断两日连续下跌呢？
简单而言，就是 close[0] &amp;lt; close[-1] 和 close[-1] &amp;lt; close[-2]，即当前收盘价小于昨日收盘价，昨日收盘价小于大前日收盘价。
self.dataclose[0] &amp;lt; self.dataclose[-1] and self.dataclose[-1] &amp;lt; self.dataclose[-2] 而买入操作使用 self.buy 皆可。
self.buy() 默认情况下，如果存在多个数据源，self.buy 买入的是第一个数据资产。
完整示例 # import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.</description></item><item><title>卖出操作</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/06-sell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/06-sell/</guid><description>卖出操作 # 了解如何进入市场（多头，self.buy）后，还要一个“退出概念”，以及了解策略是否在市场中。
本节将演示入场后如何退出市场。
退出逻辑很简单，入场持有 5 根 bar 后（在第 6 根 bar 上）退出，无论是盈利还是亏损。另外，为了简化逻辑，仅在未入场时允许买入订单，即如果有持仓或者进行中的订单都不可买入。
逻辑逻辑 # 要完成这个逻辑，要能确认订单成交时间、成交所在位置、当前是否有进行中的订单以及是否有持仓。
订单状态 # 订单确认状态通过 Strategy 的订单状态变化 notify_order 方法监听。
def notify_order(self, order): print(order.status) 订单状态有 Accepted（已接受）、Submitted（已提交）、Completed（已成交）、Margin（保证金不足）、Rejected（已拒绝）。
订单类中除了状态，还包括订单的其他信息，如执行价格 - order.executed.price，已执行价值 - order.executed.value，订单手续费 - order.executed.comm。
更多订单的信息，可查看 订单- Orders。
成交位置 # 策略对象提供了对默认数据源位置的访问，通过 len(self) 即可获得。
len(self) next 方法没有提供 &amp;ldquo;bar索引&amp;rdquo;，因此很难理解何时经过了 5 根bar，但调用对象的 len 方法，它会告诉你线的长度。
我们只需记下订单完成时的长度，并查看当前长度是否距离其5根bar。
def notify_order(self, order): if order.status in [order.Completed]: self.bar_executed = len(self) def next(self): # 其他代码 if len(self) &amp;gt;= (self.</description></item><item><title>交易监控</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/07-commission/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/07-commission/</guid><description>交易监控 # 我们已经知道如何使用 backtrader 买卖交易了。本节将介绍 backtrader 如何监控它每笔交易，如成本、利润和佣金。由于佣金的存在，利润还分为毛利润和净利润
设置佣金 # 让我们先设置一个合理佣金率 - 0.1% （买入和卖出都要收取的），一行代码即可。
# 0.1% ... 除以 100 以去掉百分号 cerebro.broker.setcommission(commission=0.001) 订单的成本和佣金 # 订单的成本和佣金可从订单回调 notify_order 中获取，它的 Order 参数 order.executed.comm 即为订单的已执行佣金，order.executed.value 即投入的成本。
class TestStrategy(bt.Strategy): def notify_order(self, order): if order.status in [order.Completed]: if order.isbuy(): self.log( &amp;#39;买入执行，价格：%.2f，成本：%.2f，佣金 %.2f&amp;#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: self.log(&amp;#39;卖出执行，价格：%.2f，成本：%.2f，佣金 %.2f&amp;#39; % (order.executed.price, order.executed.value, order.executed.comm)) 交易记录计算利润 # 对于利润的计算，使用交易记录会更简单，所谓成交记录，即成交撮合一笔记录一次。与订单类似，我们可通过 notify_trade 获取成交记录。它的回调参数是 Trade 类对象，利润相关属性有 trade.pnl（毛利润）和 trade.pnlcomm（净利润）。
class TestStrategy(bt.Strategy): def notify_trade(self, trade): if not trade.</description></item><item><title>参数定义</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/08-parameters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/08-parameters/</guid><description>参数定义 # 前面的案例中，参数都是硬编码在策略中。本节将介绍如何在 backtrader 自定义参数。
定义参数 # 策略参数的定义非常简单，如在策略中定义两个参数：myparam 和 exitbars。
class TestStrategy: params = ((&amp;#39;myparam&amp;#39;, 27), (&amp;#39;exitbars&amp;#39;, 5),) 参数 myparam 的默认值是 27，exitbars 的默认值是 5。
配置参数 # 我们可以在添加策略时修改参数默认值。
# Add a strategy cerebro.addstrategy(TestStrategy, myparam=20, exitbars=7) 使用参数 # 策略代码中直接通过 self.params.param_name 即可调用参数。
如下代码，通过参数 exitbars 修改退出逻辑：
if len(self) &amp;gt;= (self.bar_executed + self.params.exitbars): 完整示例 # import backtrader as bt class TestStrategy(bt.Strategy): params = ( (&amp;#39;exitbars&amp;#39;, 5), ) def log(self, txt, dt=None): dt = dt or self.</description></item><item><title>技术指标</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/09-indicators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/09-indicators/</guid><description>技术指标（Indicators） # 本节将介绍如何使用技术指标，将技术指标作为入场和出场信号。我们将用简单移动平均线（Simple Moving Average），或称 SMA，作为演示指标。SMA 是一个非常简单的技术指标，计算一定周期的价格均值。
交易规则 # 基于 SMA 交易规则，定义如下所示：
入场条件： 当收盘价大于最新的 SMA，则入场买入。 出场条件： 当持有头寸，当收盘价小于 SMA，则出场卖出。 前面章节的策略代码大部分可复用，现在重点关注如何计算技术指标。
指标计算 # backtrader 下的 indicators 模块内置了大量技术指标的计算方法，如 SMA 简单移动均线的计算。
self.sma = bt.indicators.MovingAverageSimple(self.datas[0], period=self.params.maperiod) 如上代码中参数 self.params.maperiod 就是 SMA 的均线周期。
注：如果安装了 talib，backtrader 也集成了 talib 的支持，详情文档 指标-TALib。
条件判断 # 现在基于 self.sma 判断进出场条件。
为了简化代码，这里只考虑 SMA 的判断逻辑，在完整实例中会包含所有情况。
入场判断：
self.dataclose[0] &amp;gt; self.sma[0] 出场判断：
self.dataclose[0] &amp;lt; self.sma[0] 策略代码 # 起始现金 1000 货币单位。
import datetime # For datetime objects import os.</description></item><item><title>可视化</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/10-plotting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/10-plotting/</guid><description>可视化 # 通过 print 输出每个 bar 的信息不利于我们阅读，我们还是更倾向于图表的视觉效果。backtrader 内置了图表绘制的能力，一行代码即可绘图。
cerebro.plot() 请确保在调用cerebro.run()之后执行，还有，backtrader 的绘图能力依赖 matplotlib。
演示 # 为了展示出基本的价格和收益外，我们将执行以下操作以展示绘图的功能和配置。
添加一个 EMA（指数移动平均线），默认情况下，它会与数据一起绘制。 添加一个 WMA（移动平均线加权），配置在子图绘制（即使没有意义）。 添加一个 StochasticSlow（慢速随机指标），不更改默认设置。 添加一个 MACD，不更改默认设置。 添加一个ATR，更改默认设置以避免绘图。 添加一个 RSI，不更改默认设置。 在 RSI 上添加一个 SMA 指标，不更改默认设置，且与RSI一起绘制。 在策略的 __init__ 方法中添加的所有内容：
# Indicators for the plotting show bt.indicators.ExponentialMovingAverage(self.datas[0], period=25) bt.indicators.WeightedMovingAverage(self.datas[0], period=25).subplot = True bt.indicators.StochasticSlow(self.datas[0]) bt.indicators.MACDHisto(self.datas[0]) rsi = bt.indicators.RSI(self.datas[0]) bt.indicators.SmoothedMovingAverage(rsi, period=10) bt.indicators.ATR(self.datas[0]).plot = False 即使将指标没有赋值到策略成员变量（如self.sma = MovingAverageSimple…），它们也会被注册到策略中，成为图表的一部分。
示例中，只有RSI被添加到临时变量rsi中，其目的是要在其上创建一个 SmoothedMovingAverage。
from __future__ import (absolute_import, division, print_function, unicode_literals) import datetime # For datetime objects import os.</description></item><item><title>策略优化</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/11-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/11-optimization/</guid><description>策略优化 # 许多交易书籍中提到，每个市场和每个交易的股票（或商品等）都有不同的节奏，没有一种适合所有的策略。
在绘图示例前，当策略开始使用一个指标，周期默认值为 15 个 bar。这是一个策略参数，可以用于优化，改变参数值以找出哪个更适合你的市场。
注意：关于优化及其优缺点的文献很多。但建议基本是：不要过度优化。如果交易思路不健全，优化可能会产生一个仅对回测数据集有效的正面结果。
示例修改为优化简单移动平均线的周期。为了清晰起见，已删除与买卖订单相关的任何输出。
示例如下：
import datetime #For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): params = ( (&amp;#39;maperiod&amp;#39;, 15), (&amp;#39;printlog&amp;#39;, False), ) def log(self, txt, dt=None, doprint=False): if self.params.printlog or doprint: dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.</description></item></channel></rss>