<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Analyzer on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/</link><description>Recent content in Analyzer on Backtrader 中文</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/12-analyzers/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzers</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</guid><description>&lt;h1 id="分析器"&gt;分析器&lt;a class="anchor" href="#%e5%88%86%e6%9e%90%e5%99%a8"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;无论是回测还是交易，能够分析交易系统的表现对于理解是否不仅仅获得了利润，而且是否在实现利润的过程中承担了过多的风险，或者与参考资产（或无风险资产）相比是否真的值得付出努力，都是关键。&lt;/p&gt;
&lt;p&gt;这就是分析器对象的作用：提供对已发生情况或当前情况的分析。&lt;/p&gt;
&lt;p&gt;分析器的性质
接口的设计参照了线条对象，例如具有 next 方法，但有一个主要的区别：分析器不包含线条。&lt;/p&gt;
&lt;p&gt;这意味着它们在内存方面不是很消耗资源，因为即使在分析了成千上万个价格条之后，它们可能仍然只在内存中保存单个结果。&lt;/p&gt;
&lt;h2 id="在生态系统中的位置"&gt;在生态系统中的位置&lt;a class="anchor" href="#%e5%9c%a8%e7%94%9f%e6%80%81%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e4%bd%8d%e7%bd%ae"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;分析器对象（如同策略、观察者和数据）通过 cerebro 实例添加到系统中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;addanalyzer(ancls, &lt;span style="color:#f92672"&gt;*&lt;/span&gt;args, &lt;span style="color:#f92672"&gt;**&lt;/span&gt;kwargs)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但在 cerebro.run 操作期间，对于系统中存在的每个策略，将会发生以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ancls 在 cerebro.run 期间会用 *args 和 **kwargs 实例化&lt;/li&gt;
&lt;li&gt;ancls 实例将会附加到策略上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;p&gt;如果回测运行包含例如 3 个策略，那么将创建 3 个 ancls 实例，并且每个实例将附加到不同的策略上。&lt;/p&gt;
&lt;p&gt;结论：分析器分析单个策略的表现，而不是整个系统的表现。&lt;/p&gt;
&lt;h2 id="附加位置"&gt;附加位置&lt;a class="anchor" href="#%e9%99%84%e5%8a%a0%e4%bd%8d%e7%bd%ae"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;某些分析器对象可能实际上使用其他分析器来完成其工作。例如：SharpeRatio 使用 TimeReturn 的输出进行计算。&lt;/p&gt;
&lt;p&gt;这些子分析器或从属分析器也将插入到创建它们的同一策略中。但它们对用户是完全不可见的。&lt;/p&gt;
&lt;h2 id="属性"&gt;属性&lt;a class="anchor" href="#%e5%b1%9e%e6%80%a7"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了完成预期的工作，分析器对象提供了一些默认属性，这些属性会自动传递并在实例中设置，以便于使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;self.strategy&lt;/code&gt;：对分析器对象正在运行的策略子类的引用。策略可以访问的任何内容，分析器也可以访问。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.datas[x]&lt;/code&gt;：策略中存在的数据源数组。虽然可以通过策略引用访问，但快捷方式使工作更舒适。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.data&lt;/code&gt;：对 &lt;code&gt;self.datas[0]&lt;/code&gt; 的快捷方式，以增加舒适度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.dataX&lt;/code&gt;：对不同的 &lt;code&gt;self.datas[x]&lt;/code&gt; 的快捷方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一些其他别名可用，尽管它们可能有些多余：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;self.dataX_Y&lt;/code&gt;，其中 X 是对 &lt;code&gt;self.datas[X]&lt;/code&gt; 的引用，Y 指的是线条，最终指向 &lt;code&gt;self.datas[X].lines[Y]&lt;/code&gt;。
如果线条有名称，还可以使用以下命名：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;self.dataX_Name&lt;/code&gt;，解析为 &lt;code&gt;self.datas[X].Name&lt;/code&gt;，按名称而不是按索引返回线条。
对于第一个数据，最后两个快捷方式在没有初始 X 数字引用的情况下可用。例如：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;self.data_2&lt;/code&gt; 指 &lt;code&gt;self.datas[0].lines[2]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;self.data_close&lt;/code&gt; 指 &lt;code&gt;self.datas[0].close&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>Pyfolio</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</guid><description>&lt;h1 id="pyfolio"&gt;PyFolio&lt;a class="anchor" href="#pyfolio"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;注意，截至（至少）2017-07-25，pyfolio 的 API 已更改，&lt;code&gt;create_full_tear_sheet&lt;/code&gt; 不再有 &lt;code&gt;gross_lev&lt;/code&gt; 作为命名参数。因此，集成示例无法正常工作。&lt;/p&gt;
&lt;blockquote class='book-hint '&gt;
&lt;p&gt;引用 pyfolio 主页面 &lt;a href="http://quantopian.github.io/pyfolio/"&gt;http://quantopian.github.io/pyfolio/&lt;/a&gt; 的内容：
pyfolio 是一个由 Quantopian Inc. 开发的用于金融投资组合的表现和风险分析的 Python 库。它与开源回测库 Zipline 配合良好，现在它也可以很好地与 backtrader 配合。所需的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显然需要 pyfolio&lt;/li&gt;
&lt;li&gt;以及它的依赖项（如 pandas、seaborn 等）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;注意，在与 0.5.1 版本集成期间，需要更新依赖项的最新版本，例如将之前安装的 seaborn 从 0.7.0-dev 更新到 0.7.1，显然是由于缺少方法 &lt;code&gt;swarmplot&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="用法"&gt;用法&lt;a class="anchor" href="#%e7%94%a8%e6%b3%95"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将 PyFolio 分析器添加到 cerebro 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;addanalyzer(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;PyFolio)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行并检索第一个策略：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;strats &lt;span style="color:#f92672"&gt;=&lt;/span&gt; cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;run()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;strat0 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; strats[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用你给分析器命名的名称或默认名称（pyfolio）来检索分析器。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;pyfolio &lt;span style="color:#f92672"&gt;=&lt;/span&gt; strats&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;getbyname(&lt;span style="color:#e6db74"&gt;&amp;#39;pyfolio&amp;#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用分析器方法 &lt;code&gt;get_pf_items&lt;/code&gt; 检索 pyfolio 后续需要的四个组件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;returns, positions, transactions, gross_lev &lt;span style="color:#f92672"&gt;=&lt;/span&gt; pyfolio&lt;span style="color:#f92672"&gt;.&lt;/span&gt;get_pf_items()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意&lt;/p&gt;
&lt;p&gt;集成是通过查看 &lt;code&gt;pyfolio&lt;/code&gt; 的测试样本并复制相同的标题（或缺少的部分）来完成的。&lt;/p&gt;
&lt;p&gt;与 pyfolio 一起工作（这已经超出了 backtrader 生态系统的范围）&lt;/p&gt;
&lt;p&gt;一些与 backtrader 无关的使用注意事项：&lt;/p&gt;</description></item><item><title>Pyfolio 集成</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</guid><description>&lt;h1 id="pyfolio-集成"&gt;Pyfolio 集成&lt;a class="anchor" href="#pyfolio-%e9%9b%86%e6%88%90"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在 Ticket #108 中提出了一个投资组合工具，即 pyfolio 的集成。&lt;/p&gt;
&lt;p&gt;一开始看教程觉得很难，因为 zipline 和 pyfolio 之间的紧密集成，但 pyfolio 提供的一些其他用途的示例测试数据实际上非常有用，可以解码幕后运行的内容，从而实现集成。&lt;/p&gt;
&lt;p&gt;在 backtrader 中大多数部分已经就位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析器基础设施&lt;/li&gt;
&lt;li&gt;子分析器&lt;/li&gt;
&lt;li&gt;TimeReturn 分析器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要一个主 PyFolio 分析器和三个简单的子分析器。再加上依赖于 pyfolio 所需的依赖项之一，即 pandas 的方法。&lt;/p&gt;
&lt;p&gt;最具挑战的部分是…“正确获取所有依赖项”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新 pandas&lt;/li&gt;
&lt;li&gt;更新 numpy&lt;/li&gt;
&lt;li&gt;更新 scikit-lean&lt;/li&gt;
&lt;li&gt;更新 seaborn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在类似 Unix 的环境中，有一个 C 编译器，一切都是时间问题。在 Windows 上，即使安装了特定的 Microsoft 编译器（在这种情况下是 Python 2.7 的链），事情也失败了。但一个知名网站拥有最新的 Windows 软件包集合，提供了帮助。如果你需要它，可以访问：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/"&gt;http://www.lfd.uci.edu/~gohlke/pythonlibs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果没有测试集成，它就不会完成，这就是为什么通常的示例总是存在的原因。&lt;/p&gt;
&lt;h2 id="没有-pyfolio"&gt;没有 PyFolio&lt;a class="anchor" href="#%e6%b2%a1%e6%9c%89-pyfolio"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;示例使用 random.randint 来决定何时买卖，因此这只是检查事情是否正常运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ ./pyfoliotest.py --printout --no-pyfolio --plot&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Len,Datetime,Open,High,Low,Close,Volume,OpenInterest
0001,2005-01-03T23:59:59,38.36,38.90,37.65,38.18,25482800.00,0.00
BUY 1000 @%23.58
0002,2005-01-04T23:59:59,38.45,38.54,36.46,36.58,26625300.00,0.00
BUY 1000 @%36.58
SELL 500 @%22.47
0003,2005-01-05T23:59:59,36.69,36.98,36.06,36.13,18469100.00,0.00
...
SELL 500 @%37.51
0502,2006-12-28T23:59:59,25.62,25.72,25.30,25.36,11908400.00,0.00
0503,2006-12-29T23:59:59,25.42,25.82,25.33,25.54,16297800.00,0.00
SELL 250 @%17.14
SELL 250 @%37.01&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有 3 个数据，多个买卖操作在测试运行的默认两年期间随机选择和分散。&lt;/p&gt;</description></item><item><title>Reference</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</guid><description>&lt;h1 id="参考"&gt;参考&lt;a class="anchor" href="#%e5%8f%82%e8%80%83"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="annualreturn"&gt;AnnualReturn&lt;a class="anchor" href="#annualreturn"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;backtrader&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;AnnualReturn()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该分析器通过查看年的起点和终点来计算年度回报率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;成员属性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rets&lt;/code&gt;：计算出的年度回报率列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ret&lt;/code&gt;：年度回报率字典（键：年份）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;get_analysis：&lt;/strong&gt;
返回包含年度回报率的字典（键：年份）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="calmar"&gt;Calmar&lt;a class="anchor" href="#calmar"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;backtrader&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Calmar()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该分析器计算 Calmar 比率，时间框架可以与基础数据使用的不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;timeframe&lt;/code&gt;（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compression&lt;/code&gt;（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.Minutes&amp;rdquo; 和 60 作为压缩在每小时时间框架上工作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fund&lt;/code&gt;（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 &lt;code&gt;set_fundmode&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;get_analysis：&lt;/strong&gt;
返回一个包含时间段键和对应滚动 Calmar 比率的 OrderedDict。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="drawdown"&gt;DrawDown&lt;a class="anchor" href="#drawdown"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;backtrader&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;DrawDown()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该分析器计算交易系统的回撤统计数据，如百分比和美元的回撤值、最大回撤值、回撤长度和最大回撤长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fund&lt;/code&gt;（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 &lt;code&gt;set_fundmode&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;get_analysis：&lt;/strong&gt;
返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;drawdown&lt;/code&gt;：回撤值（百分比）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;moneydown&lt;/code&gt;：回撤值（货币单位）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：回撤长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max.drawdown&lt;/code&gt;：最大回撤值（百分比）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max.moneydown&lt;/code&gt;：最大回撤值（货币单位）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max.len&lt;/code&gt;：最大回撤长度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="timedrawdown"&gt;TimeDrawDown&lt;a class="anchor" href="#timedrawdown"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;backtrader&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeDrawDown()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该分析器计算在选定时间框架上的交易系统回撤，可以与基础数据使用的时间框架不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;timeframe&lt;/code&gt;（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compression&lt;/code&gt;（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.Minutes&amp;rdquo; 和 60 作为压缩在每小时时间框架上工作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fund&lt;/code&gt;（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 &lt;code&gt;set_fundmode&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;get_analysis：&lt;/strong&gt;
返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;drawdown&lt;/code&gt;：回撤值（百分比）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxdrawdown&lt;/code&gt;：最大回撤值（货币单位）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxdrawdownperiod&lt;/code&gt;：回撤长度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="grossleverage"&gt;GrossLeverage&lt;a class="anchor" href="#grossleverage"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;backtrader&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;analyzers&lt;span style="color:#f92672"&gt;.&lt;/span&gt;GrossLeverage()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该分析器计算当前策略的总杠杆。&lt;/p&gt;</description></item></channel></rss>