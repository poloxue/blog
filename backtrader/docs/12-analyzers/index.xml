<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Analyzer on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/</link><description>Recent content in Analyzer on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/12-analyzers/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzers</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</guid><description>分析器 # 无论是回测还是交易，能够分析交易系统的表现对于理解是否不仅仅获得了利润，而且是否在实现利润的过程中承担了过多的风险，或者与参考资产（或无风险资产）相比是否真的值得付出努力，都是关键。
这就是分析器对象的作用：提供对已发生情况或当前情况的分析。
分析器的性质 接口的设计参照了线条对象，例如具有 next 方法，但有一个主要的区别：分析器不包含线条。
这意味着它们在内存方面不是很消耗资源，因为即使在分析了成千上万个价格条之后，它们可能仍然只在内存中保存单个结果。
在生态系统中的位置 # 分析器对象（如同策略、观察者和数据）通过 cerebro 实例添加到系统中：
addanalyzer(ancls, *args, **kwargs) 但在 cerebro.run 操作期间，对于系统中存在的每个策略，将会发生以下情况：
ancls 在 cerebro.run 期间会用 *args 和 **kwargs 实例化 ancls 实例将会附加到策略上 这意味着：
如果回测运行包含例如 3 个策略，那么将创建 3 个 ancls 实例，并且每个实例将附加到不同的策略上。
结论：分析器分析单个策略的表现，而不是整个系统的表现。
附加位置 # 某些分析器对象可能实际上使用其他分析器来完成其工作。例如：SharpeRatio 使用 TimeReturn 的输出进行计算。
这些子分析器或从属分析器也将插入到创建它们的同一策略中。但它们对用户是完全不可见的。
属性 # 为了完成预期的工作，分析器对象提供了一些默认属性，这些属性会自动传递并在实例中设置，以便于使用：
self.strategy：对分析器对象正在运行的策略子类的引用。策略可以访问的任何内容，分析器也可以访问。 self.datas[x]：策略中存在的数据源数组。虽然可以通过策略引用访问，但快捷方式使工作更舒适。 self.data：对 self.datas[0] 的快捷方式，以增加舒适度。 self.dataX：对不同的 self.datas[x] 的快捷方式。 还有一些其他别名可用，尽管它们可能有些多余：
self.dataX_Y，其中 X 是对 self.datas[X] 的引用，Y 指的是线条，最终指向 self.datas[X].lines[Y]。 如果线条有名称，还可以使用以下命名：
self.dataX_Name，解析为 self.datas[X].Name，按名称而不是按索引返回线条。 对于第一个数据，最后两个快捷方式在没有初始 X 数字引用的情况下可用。例如：</description></item><item><title>Pyfolio</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</guid><description>PyFolio # 注意，截至（至少）2017-07-25，pyfolio 的 API 已更改，create_full_tear_sheet 不再有 gross_lev 作为命名参数。因此，集成示例无法正常工作。
引用 pyfolio 主页面 http://quantopian.github.io/pyfolio/ 的内容： pyfolio 是一个由 Quantopian Inc. 开发的用于金融投资组合的表现和风险分析的 Python 库。它与开源回测库 Zipline 配合良好，现在它也可以很好地与 backtrader 配合。所需的内容包括：
显然需要 pyfolio 以及它的依赖项（如 pandas、seaborn 等） 注意，在与 0.5.1 版本集成期间，需要更新依赖项的最新版本，例如将之前安装的 seaborn 从 0.7.0-dev 更新到 0.7.1，显然是由于缺少方法 swarmplot。
用法 # 将 PyFolio 分析器添加到 cerebro 中：
cerebro.addanalyzer(bt.analyzers.PyFolio) 运行并检索第一个策略：
strats = cerebro.run() strat0 = strats[0] 使用你给分析器命名的名称或默认名称（pyfolio）来检索分析器。例如：
pyfolio = strats.analyzers.getbyname(&amp;#39;pyfolio&amp;#39;) 使用分析器方法 get_pf_items 检索 pyfolio 后续需要的四个组件：
returns, positions, transactions, gross_lev = pyfolio.get_pf_items() 注意</description></item><item><title>Pyfolio 集成</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</guid><description>Pyfolio 集成 # 在 Ticket #108 中提出了一个投资组合工具，即 pyfolio 的集成。
一开始看教程觉得很难，因为 zipline 和 pyfolio 之间的紧密集成，但 pyfolio 提供的一些其他用途的示例测试数据实际上非常有用，可以解码幕后运行的内容，从而实现集成。
在 backtrader 中大多数部分已经就位：
分析器基础设施 子分析器 TimeReturn 分析器 只需要一个主 PyFolio 分析器和三个简单的子分析器。再加上依赖于 pyfolio 所需的依赖项之一，即 pandas 的方法。
最具挑战的部分是…“正确获取所有依赖项”。
更新 pandas 更新 numpy 更新 scikit-lean 更新 seaborn 在类似 Unix 的环境中，有一个 C 编译器，一切都是时间问题。在 Windows 上，即使安装了特定的 Microsoft 编译器（在这种情况下是 Python 2.7 的链），事情也失败了。但一个知名网站拥有最新的 Windows 软件包集合，提供了帮助。如果你需要它，可以访问：
http://www.lfd.uci.edu/~gohlke/pythonlibs/
如果没有测试集成，它就不会完成，这就是为什么通常的示例总是存在的原因。
没有 PyFolio # 示例使用 random.randint 来决定何时买卖，因此这只是检查事情是否正常运行：
$ ./pyfoliotest.py --printout --no-pyfolio --plot 输出：
Len,Datetime,Open,High,Low,Close,Volume,OpenInterest 0001,2005-01-03T23:59:59,38.36,38.90,37.65,38.18,25482800.00,0.00 BUY 1000 @%23.</description></item><item><title>Reference</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</guid><description>参考 # AnnualReturn # class backtrader.analyzers.AnnualReturn() 该分析器通过查看年的起点和终点来计算年度回报率。
参数：
无 成员属性：
rets：计算出的年度回报率列表 ret：年度回报率字典（键：年份） get_analysis： 返回包含年度回报率的字典（键：年份）
Calmar # class backtrader.analyzers.Calmar() 该分析器计算 Calmar 比率，时间框架可以与基础数据使用的不同。
参数：
timeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.Minutes&amp;rdquo; 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含时间段键和对应滚动 Calmar 比率的 OrderedDict。
DrawDown # class backtrader.analyzers.DrawDown() 该分析器计算交易系统的回撤统计数据，如百分比和美元的回撤值、最大回撤值、回撤长度和最大回撤长度。
参数：
fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：
drawdown：回撤值（百分比） moneydown：回撤值（货币单位） len：回撤长度 max.drawdown：最大回撤值（百分比） max.moneydown：最大回撤值（货币单位） max.len：最大回撤长度 TimeDrawDown # class backtrader.analyzers.TimeDrawDown() 该分析器计算在选定时间框架上的交易系统回撤，可以与基础数据使用的时间框架不同。
参数：
timeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.</description></item></channel></rss>