<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="参数说明#
如下是 Cerebro 类的详细说明。
实例化参数#

  
      
          参数
          默认值
          说明
      
  
  
      
          preload
          True
          是否预加载传递给策略的不同数据源。
      
      
          runonce
          True
          以矢量化模式计算指标，从而提高整个系统的性能。注： 策略和观察者将始终基于事件运行。
      
      
          live
          False
          如果没有数据报告为实时（通过数据的islive方法，但用户仍希望以实时模式运行，可将此参数设为true。
      
      
          maxcpus
          None
          同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。
      
      
          stdstats
          True）
          如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。
      
      
          oldbuysell
          False
          如 stdstats 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。
      
      
          oldtrades
          False
          如果stdstats为True 且自动添加观察者，此开关控制交易观察者的主要行为。
      
      
          exactbars
          False
          - False：默认值，将存储在 Line 中的值都保存到内存。-True或1：所有Line对象的内存使用减少至计算最小周期。如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。此设置将停用preload和runonce。使用此设置还将停用绘图。 -1：策略级别的数据源和指标/操作将保留所有数据在内存中。如 RSI 通过指标UpDay计算，不会将它的所有数据保留内存。 这允许保持绘图和预加载活动。runonce将被停用。-2：作为策略属性的数据源和指标将保留所有点在内存中。例如：RSI内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。- 这允许保持绘图和预加载活动。runonce将被停用。
      
      
          objcache
          False
          实验选项，用于实现 Line 对象的缓存并减少它们的数量。示例来自UltimateOscillator：bp = self.data.close - TrueLow(self.data) # -> 创建另一个 TrueLow(self.data)tr = TrueRange(self.data) 如果为True，TrueRange内部的第二个TrueLow(self.data)将匹配bp计算中的签名，并将被重用。可能发生的极端情况是这会使线对象超出其最小周期并导致问题，因此被禁用。
      
      
          writer
          False
          如果设置为True，将创建一个默认的WriterFile，它将打印到标准输出。它将被添加到策略中（除了用户代码添加的任何其他编写器）。
      
      
          tradehistory
          False
          如果设置为True，它将激活所有策略中每个交易的更新事件日志记录。也可以通过策略方法set_tradehistory在每个策略基础上完成。
      
      
          optdatas
          True
          如果为 True 且在优化（并且系统可以预加载和使用runonce），则数据预加载将仅在主进程中完成，以节省时间和资源。测试显示，执行时间从83秒减少到66秒，约20%的速度提升。
      
      
          optreturn
          True
          如果为True，优化结果将不会是完整的策略对象（和所有数据、指标、观察者&mldr;），而是具有以下属性的对象（与策略相同）：
      
      
          params（或p）
          无
          执行策略时的参数。
      
      
          analyzers
          无
          策略已执行的分析器。大多数情况下，仅需要分析器和参数来评估策略的性能。如果需要详细分析生成的值（例如指标），请将其关闭。测试显示，执行时间提高了13% - 15%。结合optdatas，总收益增加到32%。
      
      
          oldsync
          False
          从版本1.9.0.99开始，多个数据（相同或不同时间框架）的同步已更改，以允许不同长度的数据。如果希望使用数据0作为系统主控的数据的旧行为，请将此参数设置为True。
      
      
          tz
          None
          为策略添加全局时区。参数tz可以是：None：在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。pytz实例。将用作将UTC时间转换为所选时区。字符串。将尝试实例化pytz实例。整数。对于策略，使用self.datas可迭代对象中相应数据的相同时区（0将使用data0的时区）。
      
      
          cheat_on_open
          False
          将调用策略的next_open方法。这发生在next之前，并且在经纪人有机会评估订单之前。指标尚未重新计算。这允许发布考虑前一天指标的订单，但使用开盘价进行股份计算。对于cheat_on_open订单执行，还要调用 cerebro.broker.set_coo(True)或实例化一个BackBroker(coo=True)（coo表示cheat-on-open）或将broker_coo参数设置为True。除非在下文中禁用，否则Cerebro会自动执行此操作。
      
      
          broker_coo
          True
          这将自动调用经纪人的set_coo方法，并将其设置为True以激活cheat_on_open执行。只有在cheat_on_open也为True时才会执行。
      
      
          quicknotify
          False
          在传递下一个价格之前立即传递经纪人通知。对于回测没有影响，但对于实时经纪人，通知可能在条传递之前很久就发生。当设置为True时，将尽快传递通知（请参阅实时数据源中的qcheck）。为了兼容性，设置为False。可能会更改为True。
      
  

成员方法#

addstorecb(callback)

添加一个回调以获取将由notify_store方法处理的消息。回调的签名必须支持以下内容："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/"><meta property="og:site_name" content="Backtrader 中文"><meta property="og:title" content="参数说明"><meta property="og:description" content="参数说明# 如下是 Cerebro 类的详细说明。
实例化参数# 参数 默认值 说明 preload True 是否预加载传递给策略的不同数据源。 runonce True 以矢量化模式计算指标，从而提高整个系统的性能。
注： 策略和观察者将始终基于事件运行。 live False 如果没有数据报告为实时（通过数据的islive方法，但用户仍希望以实时模式运行，可将此参数设为true。 maxcpus None 同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。 stdstats True） 如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。 oldbuysell False 如 stdstats 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。 oldtrades False 如果stdstats为True 且自动添加观察者，此开关控制交易观察者的主要行为。 exactbars False - False：默认值，将存储在 Line 中的值都保存到内存。-True或1：所有Line对象的内存使用减少至计算最小周期。如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。此设置将停用preload和runonce。使用此设置还将停用绘图。 -1：策略级别的数据源和指标/操作将保留所有数据在内存中。如 RSI 通过指标UpDay计算，不会将它的所有数据保留内存。 这允许保持绘图和预加载活动。runonce将被停用。-2：作为策略属性的数据源和指标将保留所有点在内存中。例如：RSI内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。- 这允许保持绘图和预加载活动。runonce将被停用。 objcache False 实验选项，用于实现 Line 对象的缓存并减少它们的数量。示例来自UltimateOscillator：bp = self.data.close - TrueLow(self.data) # -> 创建另一个 TrueLow(self.data)tr = TrueRange(self.data) 如果为True，TrueRange内部的第二个TrueLow(self.data)将匹配bp计算中的签名，并将被重用。可能发生的极端情况是这会使线对象超出其最小周期并导致问题，因此被禁用。 writer False 如果设置为True，将创建一个默认的WriterFile，它将打印到标准输出。它将被添加到策略中（除了用户代码添加的任何其他编写器）。 tradehistory False 如果设置为True，它将激活所有策略中每个交易的更新事件日志记录。也可以通过策略方法set_tradehistory在每个策略基础上完成。 optdatas True 如果为 True 且在优化（并且系统可以预加载和使用runonce），则数据预加载将仅在主进程中完成，以节省时间和资源。测试显示，执行时间从83秒减少到66秒，约20%的速度提升。 optreturn True 如果为True，优化结果将不会是完整的策略对象（和所有数据、指标、观察者…），而是具有以下属性的对象（与策略相同）： params（或p） 无 执行策略时的参数。 analyzers 无 策略已执行的分析器。大多数情况下，仅需要分析器和参数来评估策略的性能。如果需要详细分析生成的值（例如指标），请将其关闭。测试显示，执行时间提高了13% - 15%。结合optdatas，总收益增加到32%。 oldsync False 从版本1.9.0.99开始，多个数据（相同或不同时间框架）的同步已更改，以允许不同长度的数据。如果希望使用数据0作为系统主控的数据的旧行为，请将此参数设置为True。 tz None 为策略添加全局时区。参数tz可以是：None：在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。pytz实例。将用作将UTC时间转换为所选时区。字符串。将尝试实例化pytz实例。整数。对于策略，使用self.datas可迭代对象中相应数据的相同时区（0将使用data0的时区）。 cheat_on_open False 将调用策略的next_open方法。这发生在next之前，并且在经纪人有机会评估订单之前。指标尚未重新计算。这允许发布考虑前一天指标的订单，但使用开盘价进行股份计算。对于cheat_on_open订单执行，还要调用 cerebro.broker.set_coo(True)或实例化一个BackBroker(coo=True)（coo表示cheat-on-open）或将broker_coo参数设置为True。除非在下文中禁用，否则Cerebro会自动执行此操作。 broker_coo True 这将自动调用经纪人的set_coo方法，并将其设置为True以激活cheat_on_open执行。只有在cheat_on_open也为True时才会执行。 quicknotify False 在传递下一个价格之前立即传递经纪人通知。对于回测没有影响，但对于实时经纪人，通知可能在条传递之前很久就发生。当设置为True时，将尽快传递通知（请参阅实时数据源中的qcheck）。为了兼容性，设置为False。可能会更改为True。 成员方法# addstorecb(callback) 添加一个回调以获取将由notify_store方法处理的消息。回调的签名必须支持以下内容："><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-12-29T15:28:50+08:00"><title>参数说明 | Backtrader 中文</title><link rel=icon href=/backtrader/favicon.png><link rel=manifest href=/backtrader/manifest.json><link rel=canonical href=https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/><link rel=stylesheet href=/backtrader/book.min.f079ea268834b2e0459e63011be648e8a3cc0e4819a71206873f891528fbfdf6.css integrity="sha256-8HnqJog0suBFnmMBG+ZI6KPMDkgZpxIGhz+JFSj7/fY=" crossorigin=anonymous><script defer src=/backtrader/fuse.min.js></script><script defer src=/backtrader/en.search.min.28c0072bcb426eba2da739aceed7cf13edcc133474c849dae0ba197d767c4d54.js integrity="sha256-KMAHK8tCbrotpzms7tfPE+3MEzR0yEna4LoZfXZ8TVQ=" crossorigin=anonymous></script><script defer src=/backtrader/sw.min.6e7f3387f593f3527ac4d321c3f23a8d1e0c070c219a9f97642913dc39d4b5ff.js integrity="sha256-bn8zh/WT81J6xNMhw/I6jR4MBwwhmp+XZCkT3DnUtf8=" crossorigin=anonymous></script><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/backtrader/><img src=/backtrader/logo.png alt=Logo><span>Backtrader 中文</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/backtrader/docs/01-introduction/>介绍</a><ul></ul></li><li><a href=/backtrader/docs/02-installation/>安装指南</a><ul></ul></li><li><input type=checkbox id=section-ef1b0f3b48f1accf5a8e12976586a132 class=toggle>
<label for=section-ef1b0f3b48f1accf5a8e12976586a132 class=flex><a href=/backtrader/docs/03-quickstart/>快速开始</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/03-quickstart/01-setup/>环境设置</a></li><li><a href=/backtrader/docs/03-quickstart/02-cash/>账户资金</a></li><li><a href=/backtrader/docs/03-quickstart/03-datafeed/>配置数据</a></li><li><a href=/backtrader/docs/03-quickstart/04-first-strategy/>第一个策略</a></li><li><a href=/backtrader/docs/03-quickstart/05-strategy-logic/>开始交易</a></li><li><a href=/backtrader/docs/03-quickstart/06-sell/>卖出操作</a></li><li><a href=/backtrader/docs/03-quickstart/07-commission/>交易监控</a></li><li><a href=/backtrader/docs/03-quickstart/08-parameters/>参数定义</a></li><li><a href=/backtrader/docs/03-quickstart/09-indicators/>技术指标</a></li><li><a href=/backtrader/docs/03-quickstart/10-plotting/>可视化</a></li><li><a href=/backtrader/docs/03-quickstart/11-optimization/>策略优化</a></li></ul></li><li><input type=checkbox id=section-8b6cc0ccf66e33ea233e54e3e1c71bd0 class=toggle>
<label for=section-8b6cc0ccf66e33ea233e54e3e1c71bd0 class=flex><a href=/backtrader/docs/04-concepts/>核心概念</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/>平台概念</a><ul><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/>数据源 DataFeed</a></li><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/02-params/>策略参数</a></li><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/03-line/>线 Line 类</a></li><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/04-index/>索引和切片</a></li><li><a href=/backtrader/docs/04-concepts/01-platform-concepts/05-operator/>运算符</a></li></ul></li><li><a href=/backtrader/docs/04-concepts/02-operate-the-platform/>平台操作</a><ul><li><a href=/backtrader/docs/04-concepts/02-operate-the-platform/01-iteration/>Line 迭代器</a></li><li><a href=/backtrader/docs/04-concepts/02-operate-the-platform/02-startup/>启动运行</a></li></ul></li></ul></li><li><input type=checkbox id=section-1d25046da157a996ab4b83cedd86be47 class=toggle checked>
<label for=section-1d25046da157a996ab4b83cedd86be47 class=flex><a href=/backtrader/docs/05-cerebro/>Cerebro</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/05-cerebro/01-cerebro/>Cerebro</a></li><li><a href=/backtrader/docs/05-cerebro/02-reference/ class=active>参数说明</a></li><li><a href=/backtrader/docs/05-cerebro/03-saving-memory/>节省内存</a></li><li><a href=/backtrader/docs/05-cerebro/04-optimization-improvements/>优化改进</a></li><li><a href=/backtrader/docs/05-cerebro/05-exceptions/>异常 Exceptions</a></li><li><a href=/backtrader/docs/05-cerebro/06-logging-writer/>日志 Logging - Writter</a></li></ul></li><li><input type=checkbox id=section-b39bf4495a5a92ed51fcc77b0cf4545f class=toggle>
<label for=section-b39bf4495a5a92ed51fcc77b0cf4545f class=flex><a role=button>DataFeed</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/06-datafeed/01-datafeeds/>Data Feeds</a></li><li><a href=/backtrader/docs/06-datafeed/02-datafeed-extending/>扩展数据源</a></li><li><a href=/backtrader/docs/06-datafeed/03-datafeed-development-csv/>开发 CSV 数据源</a></li><li><a href=/backtrader/docs/06-datafeed/04-datafeed-development-general/>开发 Binary 数据源</a></li><li><a href=/backtrader/docs/06-datafeed/05-datafeed-multiple-timeframes/>多时间框架</a></li><li><a href=/backtrader/docs/06-datafeed/06-datafeed-resampling/>重采样</a></li><li><a href=/backtrader/docs/06-datafeed/07-datafeed-replay/>数据回放</a></li><li><a href=/backtrader/docs/06-datafeed/08-datafeed-rollover/>数据滚动</a></li><li><a>过滤器 Filters</a><ul><li><a href=/backtrader/docs/06-datafeed/09-datafeed-filters/01-datafeed-filters/>过滤器 Filters</a></li><li><a href=/backtrader/docs/06-datafeed/09-datafeed-filters/02-datafeed-filters-referrence/>参考文档</a></li></ul></li><li><a href=/backtrader/docs/06-datafeed/10-datafeed-yahoo/>Yahoo 数据源说明</a></li><li><a href=/backtrader/docs/06-datafeed/11-datafeed-pandas/>Pandas 数据源示例</a></li><li><a href=/backtrader/docs/06-datafeed/12-datafeed-reference/>数据源参考</a></li></ul></li><li><input type=checkbox id=section-e3fe58eaef3418b317102036dce25013 class=toggle>
<label for=section-e3fe58eaef3418b317102036dce25013 class=flex><a role=button>Strategy</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/07-strategy/01-strategy/>Strategy</a></li><li><a href=/backtrader/docs/07-strategy/02-strategy-with-signals/>信号策略</a></li><li><a href=/backtrader/docs/07-strategy/03-strategy-references/>策略参考</a></li></ul></li><li><input type=checkbox id=section-cad109a715fc3bbeef472f4f0cad4358 class=toggle>
<label for=section-cad109a715fc3bbeef472f4f0cad4358 class=flex><a role=button>Indicator</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/08-indicators/01-using-indicators/>使用指标</a></li><li><a href=/backtrader/docs/08-indicators/02-indicators-development/>指标开发</a></li><li><a href=/backtrader/docs/08-indicators/03-timeframe-mixing/>周期混合</a></li><li><a href=/backtrader/docs/08-indicators/04-talib/>TA-Lib</a></li></ul></li><li><input type=checkbox id=section-56aaa6caa9d538f335a48813aa684f48 class=toggle>
<label for=section-56aaa6caa9d538f335a48813aa684f48 class=flex><a role=button>Order</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/09-orders/01-general/>订单</a></li><li><a href=/backtrader/docs/09-orders/02-creation-execution/>创建/执行</a></li><li><a href=/backtrader/docs/09-orders/03-target-orders/>目标订单</a></li><li><a href=/backtrader/docs/09-orders/04-oco-orders/>OCO 订单</a></li><li><a href=/backtrader/docs/09-orders/05-bracket-orders/>Bracket Orders</a></li><li><a href=/backtrader/docs/09-orders/06-future-spot-compensation/>期货和现货补偿</a></li><li><a href=/backtrader/docs/09-orders/07-stop-trails/>跟踪止损（限价）</a></li></ul></li><li><input type=checkbox id=section-44410e36d2de519599cb0e5e09a3b2ed class=toggle>
<label for=section-44410e36d2de519599cb0e5e09a3b2ed class=flex><a role=button>Broker</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/10-broker/01-broker/>Broker</a></li><li><a href=/backtrader/docs/10-broker/02-slippage/>滑点</a></li><li><a href=/backtrader/docs/10-broker/03-cheat-on-open/>开盘作弊</a></li><li><a href=/backtrader/docs/10-broker/04-volume-filling-filler/>填充器</a></li><li><a href=/backtrader/docs/10-broker/05-position/>Position</a></li><li><a href=/backtrader/docs/10-broker/06-trade/>Trade</a></li></ul></li><li><input type=checkbox id=section-ae52187dba190ff9aaf14da3856b7cd3 class=toggle>
<label for=section-ae52187dba190ff9aaf14da3856b7cd3 class=flex><a role=button>Commission</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/11-commission-schemes/01-commission-schemes/>佣金</a></li><li><a href=/backtrader/docs/11-commission-schemes/02-commission-schemes-extending/>扩展</a></li><li><a href=/backtrader/docs/11-commission-schemes/03-customization/>自定义佣金</a></li><li><a href=/backtrader/docs/11-commission-schemes/04-credit-interests/>利息</a></li></ul></li><li><input type=checkbox id=section-c06d50c5f364fda6157cd2e0322dd59c class=toggle>
<label for=section-c06d50c5f364fda6157cd2e0322dd59c class=flex><a role=button>Analyzer</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/12-analyzers/01-analyzers/>Analyzers</a></li><li><a href=/backtrader/docs/12-analyzers/02-pyfolio/>Pyfolio</a></li><li><a href=/backtrader/docs/12-analyzers/03-pyfolio-integration/>Pyfolio 集成</a></li><li><a href=/backtrader/docs/12-analyzers/04-reference/>Reference</a></li></ul></li><li><input type=checkbox id=section-c8768af388a3e3ade998ccab1da7af20 class=toggle>
<label for=section-c8768af388a3e3ade998ccab1da7af20 class=flex><a role=button>Observer</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/13-observers/01-statistics/>统计</a></li><li><a href=/backtrader/docs/13-observers/02-benchmarking/>基准测试</a></li><li><a href=/backtrader/docs/13-observers/03-reference/>参考</a></li></ul></li><li><input type=checkbox id=section-71aa242f05842258d04bb7390059ae0c class=toggle>
<label for=section-71aa242f05842258d04bb7390059ae0c class=flex><a role=button>Sizer</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/14-sizers/01-sizers/>sizers</a></li><li><a href=/backtrader/docs/14-sizers/02-reference/>参考</a></li></ul></li><li><input type=checkbox id=section-5787874ab2a916d11389152b4141fa73 class=toggle>
<label for=section-5787874ab2a916d11389152b4141fa73 class=flex><a href=/backtrader/docs/15-livetrading/>实盘</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/15-livetrading/01-interactive-brokers/>Interactive Brokers</a></li><li><a href=/backtrader/docs/15-livetrading/02-qanda-v1-0/>Qanda</a></li><li><a href=/backtrader/docs/15-livetrading/03-visual-chart/>Visual Chart</a></li></ul></li><li><input type=checkbox id=section-3dcf1c9f08afe4d22a0a825dccbf62c9 class=toggle>
<label for=section-3dcf1c9f08afe4d22a0a825dccbf62c9 class=flex><a role=button>绘图</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/16-plotting/01-plotting/>Plotting</a></li><li><a href=/backtrader/docs/16-plotting/02-ploting-date-ranges/>绘制日期范围</a></li><li><a href=/backtrader/docs/16-plotting/03-plotting-same-axis/>同轴绘图</a></li></ul></li><li><input type=checkbox id=section-b6e31488b3e951ce956583dfc7ccd8a2 class=toggle>
<label for=section-b6e31488b3e951ce956583dfc7ccd8a2 class=flex><a role=button>日期时间</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/17-datetime/01-management/>管理</a></li><li><a href=/backtrader/docs/17-datetime/02-timer/>定时器</a></li><li><a href=/backtrader/docs/17-datetime/03-trading-calendars/>交易日历</a></li></ul></li><li><a href=/backtrader/docs/18-automated-running/>自动运行</a><ul></ul></li><li><input type=checkbox id=section-1c57bab4ff24bdea61d636c257658085 class=toggle>
<label for=section-1c57bab4ff24bdea61d636c257658085 class=flex><a role=button>官方文章</a>
<img src=/backtrader/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/backtrader/docs/19-articles/01-out-of-memory/>超大内存</a></li><li><a href=/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/>跨平台回测的陷进</a></li><li><a href=/backtrader/docs/19-articles/03-fractional-sizes/>加密货币中的分位仓位</a></li><li><a href=/backtrader/docs/19-articles/04-beating-the-random-entry/>打败随机入场</a></li><li><a href=/backtrader/docs/19-articles/05-rebalancing-conserative/>保守型公式的再平衡</a></li><li><a href=/backtrader/docs/19-articles/06-mfi-generic/>MFI 通用版</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/backtrader/icons/menu.svg class=book-icon alt=Menu></label><h3>参数说明</h3><label for=toc-control><img src=/backtrader/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#实例化参数>实例化参数</a></li><li><a href=#成员方法>成员方法</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=参数说明>参数说明<a class=anchor href=#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e>#</a></h1><p>如下是 <code>Cerebro</code> 类的详细说明。</p><h2 id=实例化参数>实例化参数<a class=anchor href=#%e5%ae%9e%e4%be%8b%e5%8c%96%e5%8f%82%e6%95%b0>#</a></h2><table><thead><tr><th>参数</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>preload</code></td><td>True</td><td>是否预加载传递给策略的不同数据源。</td></tr><tr><td><code>runonce</code></td><td>True</td><td>以矢量化模式计算指标，从而提高整个系统的性能。<br><strong>注：</strong> 策略和观察者将始终基于事件运行。</td></tr><tr><td><code>live</code></td><td>False</td><td>如果没有数据报告为实时（通过数据的<code>islive</code>方法，但用户仍希望以实时模式运行，可将此参数设为true。</td></tr><tr><td><code>maxcpus</code></td><td>None</td><td>同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。</td></tr><tr><td><code>stdstats</code></td><td>True）</td><td>如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。</td></tr><tr><td><code>oldbuysell</code></td><td>False</td><td>如 <code>stdstats</code> 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。</td></tr><tr><td><code>oldtrades</code></td><td>False</td><td>如果<code>stdstats</code>为True 且自动添加观察者，此开关控制交易观察者的主要行为。</td></tr><tr><td><code>exactbars</code></td><td>False</td><td><ul style=list-style-type:none;padding-left:0;margin-left:0><li>- <code>False</code>：默认值，将存储在 <code>Line</code> 中的值都保存到内存。</li><li>-<code>True</code>或<code>1</code>：所有<code>Line</code>对象的内存使用减少至计算最小周期。<ul><li>如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。</li><li>此设置将停用<code>preload</code>和<code>runonce</code>。</li><li>使用此设置还将停用绘图。</li></ul></li><li><code>-1</code>：策略级别的数据源和指标/操作将保留所有数据在内存中。<ul><li>如 <code>RSI</code> 通过指标<code>UpDay</code>计算，不会将它的所有数据保留内存。</li><li>这允许保持绘图和预加载活动。</li><li><code>runonce</code>将被停用。</li></ul><li><code>-2</code>：作为策略属性的数据源和指标将保留所有点在内存中。<ul><li>例如：<code>RSI</code>内部使用指标<code>UpDay</code>进行计算。此子指标将不保留所有数据在内存中。</li><li>如果在<code>__init__</code>中定义了<code>a = self.data.close - self.data.high</code>，那么<code>a</code>将不保留所有数据在内存中。</li><li>- 这允许保持绘图和预加载活动。</li><li><code>runonce</code>将被停用。</li></ul></li></ul></td></tr><tr><td><code>objcache</code></td><td>False</td><td>实验选项，用于实现 <code>Line</code> 对象的缓存并减少它们的数量。示例来自<code>UltimateOscillator</code>：<div><pre><code class=language-python data-lang=python>bp = self.data.close - TrueLow(self.data) <br># -&gt; 创建另一个 TrueLow(self.data)<br><span>tr = TrueRange(self.data)</span> </code></pre></div>如果为True，<code>TrueRange</code>内部的第二个<code>TrueLow(self.data)</code>将匹配bp计算中的签名，并将被重用。可能发生的极端情况是这会使线对象超出其最小周期并导致问题，因此被禁用。</td></tr><tr><td><code>writer</code></td><td>False</td><td>如果设置为True，将创建一个默认的<code>WriterFile</code>，它将打印到标准输出。它将被添加到策略中（除了用户代码添加的任何其他编写器）。</td></tr><tr><td><code>tradehistory</code></td><td>False</td><td>如果设置为True，它将激活所有策略中每个交易的更新事件日志记录。也可以通过策略方法<code>set_tradehistory</code>在每个策略基础上完成。</td></tr><tr><td><code>optdatas</code></td><td>True</td><td>如果为 True 且在优化（并且系统可以预加载和使用runonce），则数据预加载将仅在主进程中完成，以节省时间和资源。测试显示，执行时间从83秒减少到66秒，约20%的速度提升。</td></tr><tr><td><code>optreturn</code></td><td>True</td><td>如果为True，优化结果将不会是完整的策略对象（和所有数据、指标、观察者&mldr;），而是具有以下属性的对象（与策略相同）：</td></tr><tr><td><code>params</code>（或<code>p</code>）</td><td>无</td><td>执行策略时的参数。</td></tr><tr><td><code>analyzers</code></td><td>无</td><td>策略已执行的分析器。大多数情况下，仅需要分析器和参数来评估策略的性能。如果需要详细分析生成的值（例如指标），请将其关闭。测试显示，执行时间提高了13% - 15%。结合<code>optdatas</code>，总收益增加到32%。</td></tr><tr><td><code>oldsync</code></td><td>False</td><td>从版本1.9.0.99开始，多个数据（相同或不同时间框架）的同步已更改，以允许不同长度的数据。如果希望使用数据0作为系统主控的数据的旧行为，请将此参数设置为True。</td></tr><tr><td><code>tz</code></td><td>None</td><td>为策略添加全局时区。参数tz可以是：<ul><li><code>None</code>：在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。</li><li><code>pytz</code>实例。将用作将UTC时间转换为所选时区。</li><li><code>字符串</code>。将尝试实例化<code>pytz</code>实例。</li><li><code>整数</code>。对于策略，使用<code>self.datas</code>可迭代对象中相应数据的相同时区（0将使用<code>data0</code>的时区）。</li></ul></td></tr><tr><td><code>cheat_on_open</code></td><td>False</td><td>将调用策略的<code>next_open</code>方法。<br><br>这发生在<code>next</code>之前，并且在经纪人有机会评估订单之前。指标尚未重新计算。这允许发布考虑前一天指标的订单，但使用开盘价进行股份计算。<br><br>对于<code>cheat_on_open</code>订单执行，还要调用 <code>cerebro.broker.set_coo(True)</code>或实例化一个<code>BackBroker(coo=True)</code>（coo表示<code>cheat-on-open</code>）或将<code>broker_coo</code>参数设置为True。除非在下文中禁用，否则Cerebro会自动执行此操作。</td></tr><tr><td><code>broker_coo</code></td><td>True</td><td>这将自动调用经纪人的<code>set_coo</code>方法，并将其设置为True以激活<code>cheat_on_open</code>执行。只有在<code>cheat_on_open</code>也为True时才会执行。</td></tr><tr><td><code>quicknotify</code></td><td>False</td><td>在传递下一个价格之前立即传递经纪人通知。对于回测没有影响，但对于实时经纪人，通知可能在条传递之前很久就发生。当设置为True时，将尽快传递通知（请参阅实时数据源中的<code>qcheck</code>）。为了兼容性，设置为False。可能会更改为True。</td></tr></tbody></table><h2 id=成员方法>成员方法<a class=anchor href=#%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95>#</a></h2><ul><li><code>addstorecb(callback)</code></li></ul><p>添加一个回调以获取将由<code>notify_store</code>方法处理的消息。回调的签名必须支持以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>callback(msg, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)</span></span></code></pre></div><p>实际接收的<code>msg</code>、<code>*args</code>和<code>**kwargs</code>是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。</p><ul><li><code>notify_store(msg, *args, **kwargs)</code></li></ul><p>在cerebro中接收存储通知。此方法可以在Cerebro子类中覆盖。实际接收的<code>msg</code>、<code>*args</code>和<code>**kwargs</code>是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。</p><ul><li><code>adddatacb(callback)</code></li></ul><p>添加一个回调以获取将由<code>notify_data</code>方法处理的消息。回调的签名必须支持以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>callback(data, status, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)</span></span></code></pre></div><p>实际接收的<code>*args</code>和<code>**kwargs</code>是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。</p><ul><li><code>notify_data(data, status, *args, **kwargs)</code></li></ul><p>在cerebro中接收数据通知。此方法可以在Cerebro子类中覆盖。实际接收的<code>*args</code>和<code>**kwargs</code>是实现定义的（完全依赖于数据/经纪人/存储），但通常应该期望它们是可打印的，以便接收和实验。</p><ul><li><code>adddata(data, name=None)</code></li></ul><p>将数据源实例添加到混合中。如果<code>name</code>不为None，将放入<code>data._name</code>，用于装饰/绘图目的。</p><ul><li><code>resampledata(dataname, name=None, **kwargs)</code></li></ul><p>添加数据源以供系统重新采样。如果<code>name</code>不为None，将放入<code>data._name</code>，用于装饰/绘图目的。任何其他如<code>timeframe</code>、<code>compression</code>、<code>todate</code>等支持的参数将透明地传递。</p><ul><li><code>replaydata(dataname, name=None, **kwargs)</code></li></ul><p>添加数据源以供系统重放。如果<code>name</code>不为None，将放入<code>data._name</code>，用于装饰/绘图目的。任何其他如<code>timeframe</code>、<code>compression</code>、<code>todate</code>等支持的参数将透明地传递。</p><ul><li><code>chaindata(*args, **kwargs)</code></li></ul><p>将多个数据源链接为一个。如果作为命名参数传递并且<code>name</code>不为None，将放入<code>data._name</code>，用于装饰/绘图目的。如果为None，则使用第一个数据的名称。</p><ul><li><code>rolloverdata(*args, **kwargs)</code></li></ul><p>将多个数据源链接为一个。如果作为命名参数传递并且<code>name</code>不为None，将放入<code>data._name</code>，用于装饰/绘图目的。如果为None，则使用第一个数据的名称。任何其他kwargs将传递给<code>RollOver</code>类。</p><ul><li><code>addstrategy(strategy, *args, **kwargs)</code></li></ul><p>为单次运行添加策略类。在运行时进行实例化。<code>args</code>和<code>kwargs</code>将在实例化期间按原样传递给策略。返回的索引可以与添加其他对象（如<code>Sizer</code>）引用兼容。</p><ul><li><code>optstrategy(strategy, *args, **kwargs)</code></li></ul><p>为优化添加策略类。在运行时进行实例化。<code>args</code>和<code>kwargs</code>必须是包含要检查值的可迭代对象。例如：如果策略接受参数<code>period</code>，为了优化目的，调用<code>optstrategy</code>如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cerebro<span style=color:#f92672>.</span>optstrategy(MyStrategy, period<span style=color:#f92672>=</span>(<span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>25</span>))</span></span></code></pre></div><p>这将执行值为15和25的优化。而：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cerebro<span style=color:#f92672>.</span>optstrategy(MyStrategy, period<span style=color:#f92672>=</span>range(<span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>25</span>))</span></span></code></pre></div><p>将以<code>period</code>值15 -> 25（25不包含，因为Python中的范围是半开的）执行<code>MyStrategy</code>。如果传递了一个参数但不应优化，调用如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cerebro<span style=color:#f92672>.</span>optstrategy(MyStrategy, period<span style=color:#f92672>=</span>(<span style=color:#ae81ff>15</span>,))</span></span></code></pre></div><p>注意<code>period</code>仍然作为一个可迭代对象传递……只有一个元素。backtrader无论如何都会尝试识别如下情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cerebro<span style=color:#f92672>.</span>optstrategy(MyStrategy, period<span style=color:#f92672>=</span><span style=color:#ae81ff>15</span>)</span></span></code></pre></div><p>如果可能，将创建一个内部伪可迭代对象。</p><ul><li><code>optcallback(cb)</code></li></ul><p>将回调添加到回调列表中，当每个策略运行时将与优化一起调用。签名：<code>cb(strategy)</code>。</p><ul><li><code>addindicator(indcls, *args, **kwargs)</code></li></ul><p>添加指标类到混合中。在传递策略中进行实例化。</p><ul><li><code>addobserver(obscls, *args, **kwargs)</code></li></ul><p>添加观察者类到混合中。在运行时进行实例化。</p><ul><li><code>addobservermulti(obscls, *args, **kwargs)</code></li></ul><p>添加观察者类到混合中。在运行时进行实例化。将为系统中的每个数据添加一次。一个用例是观察单个数据的买入/卖出观察者。一个反例是观察系统范围值的<code>CashValue</code>。</p><ul><li><code>addanalyzer(ancls, *args, **kwargs)</code></li></ul><p>添加分析器类到混合中。在运行时进行实例化。</p><ul><li><code>addwriter(wrtcls, *args, **kwargs)</code></li></ul><p>添加编写器类到混合中。在cerebro中进行实例化。</p><ul><li><code>run(**kwargs)</code></li></ul><p>执行回测的核心方法。传递给它的任何kwargs将影响实例化时Cerebro的标准参数值。如果cerebro没有数据，该方法将立即退出。返回值不同：</p><p><strong>无优化：</strong> 包含使用<code>addstrategy</code>添加的策略类实例的列表。<br><strong>优化：</strong> 包含使用<code>addstrategy</code>添加的策略类实例的列表的列表。</p><ul><li><code>runstop()</code></li></ul><p>如果从策略内部或其他地方（包括其他线程）调用，将尽快停止执行。</p><ul><li><code>setbroker(broker)</code></li></ul><p>为此策略设置特定的经纪人实例，替换从cerebro继承的经纪人。</p><ul><li><code>getbroker()</code></li></ul><p>返回经纪人实例。也可以通过<code>broker</code>属性访问。</p><ul><li><code>plot(plotter=None, numfigs=1, iplot=True, start=None, end=None, width=16, height=9, dpi=300, tight=True, use=None, **kwargs)</code></li></ul><p>绘制cerebro中的策略。如果<code>plotter</code>为None，将创建一个默认的<code>Plot</code>实例，并在实例化期间将kwargs传递给它。<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>`</span>numfigs<span style=color:#e6db74>`</span>将图表分成所指示的数量，以减少图表密度。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>iplot<span style=color:#e6db74>`</span>：如果为True且在笔记本中运行，图表将内联显示。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>use<span style=color:#e6db74>`</span>：将其设置为所需matplotlib后端的名称。它将优先于<span style=color:#e6db74>`</span>iplot<span style=color:#e6db74>`</span>。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>start<span style=color:#e6db74>`</span>：策略日期时间线数组的索引或表示绘图开始的<span style=color:#e6db74>`</span>datetime.date<span style=color:#e6db74>`</span>、<span style=color:#e6db74>`</span>datetime.datetime<span style=color:#e6db74>`</span>实例。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>end<span style=color:#e6db74>`</span>：策略日期时间线数组的索引或表示绘图结束的<span style=color:#e6db74>`</span>datetime.date<span style=color:#e6db74>`</span>、<span style=color:#e6db74>`</span>datetime.datetime<span style=color:#e6db74>`</span>实例。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>width<span style=color:#e6db74>`</span>：保存图形的宽度（以英寸为单位）。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>height<span style=color:#e6db74>`</span>：保存图形的高度（以英寸为单位）。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>dpi<span style=color:#e6db74>`</span>：保存图形的质量（以每英寸点数为单位）。&lt;br/&gt;
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>tight<span style=color:#e6db74>`</span>：仅保存实际内容而不保存图形框架。</span></span></code></pre></div><ul><li><code>addsizer(sizercls, *args, **kwargs)</code></li></ul><p>添加一个<code>Sizer</code>类（和args），作为添加到cerebro的任何策略的默认定量器。</p><ul><li><code>addsizer_byidx(idx, sizercls, *args, **kwargs)</code></li></ul><p>按<code>idx</code>添加一个<code>Sizer</code>类。此<code>idx</code>是与<code>addstrategy</code>返回的索引兼容的引用。只有由<code>idx</code>引用的策略将收到此大小。</p><ul><li><code>add_signal(sigtype, sigcls, *sigargs, **sigkwargs)</code></li></ul><p>向系统添加一个信号，稍后将添加到<code>SignalStrategy</code>中。</p><ul><li><code>signal_concurrent(onoff)</code></li></ul><p>如果将信号添加到系统并且<code>concurrent</code>值设置为True，将允许并发订单。</p><ul><li><code>signal_accumulate(onoff)</code></li></ul><p>如果将信号添加到系统并且<code>accumulate</code>值设置为True，当已在市场中时进入市场，将允许增加头寸。</p><ul><li><code>signal_strategy(stratcls, *args, **kwargs)</code></li></ul><p>添加可以接受信号的<code>SignalStrategy</code>子类。</p><ul><li><code>addcalendar(cal)</code></li></ul><p>向系统添加一个全局交易日历。单个数据源可能有单独的日历覆盖全局日历。<code>cal</code>可以是<code>TradingCalendar</code>的实例、字符串或<code>pandas_market_calendars</code>的实例。字符串将实例化为<code>PandasMarketCalendar</code>（需要系统中安装模块<code>pandas_market_calendar</code>）。如果传递的是<code>TradingCalendarBase</code>的子类（而不是实例），它将被实例化。</p><ul><li><code>addtz(tz)</code></li></ul><p>也可以使用参数<code>tz</code>完成。为策略添加全局时区。参数<code>tz</code>可以是：</p><table><thead><tr><th>可选项</th><th>描述</th></tr></thead><tbody><tr><td>None</td><td>在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。</td></tr><tr><td>pytz 实例</td><td>将用作将UTC时间转换为所选时区。</td></tr><tr><td>字符串</td><td>将尝试实例化<code>pytz</code>实例。</td></tr><tr><td>整数</td><td>对于策略，使用<code>self.datas</code>中相应数据的时区（0就用<code>data0</code>的时区）。</td></tr></tbody></table><ul><li><code>add_timer(when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, strats=False, cheat=False, *args, **kwargs)</code></li></ul><p>安排一个计时器以调用<code>notify_timer</code>。参数：</p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td><code>when</code></td><td>可以是<code>datetime.time</code>实例（见下文的<code>tzdata</code>），<code>bt.timer.SESSION_START</code>以参考会话开始，<code>bt.timer.SESSION_END</code>以参考会话结束。</td></tr><tr><td><code>offset</code></td><td>必须是<code>datetime.timedelta</code>实例，用于偏移值<code>when</code>。在与<code>SESSION_START</code>和<code>SESSION_END</code>组合使用时具有有意义的用途，以指示例如在会话开始后15分钟调用计时器。</td></tr><tr><td><code>repeat</code></td><td>必须是<code>datetime.timedelta</code>实例，表示在第一次调用后，是否在同一会话内按计划的重复增量安排进一步的调用。</td></tr><tr><td><code>weekdays</code></td><td>一个排序的可迭代对象，包含表示计时器可以实际调用的天数（iso代码，周一是1，周日是7）。如果未指定，计时器将在所有天都有效。</td></tr><tr><td><code>weekcarry</code></td><td>默认：False，如果为True并且未看到工作日（例如：交易假期），计时器将在第二天执行（即使在新的一周内）。</td></tr><tr><td><code>monthdays</code></td><td>一个排序的可迭代对象，包含表示每月应执行计时器的天数。例如总是在每月的15日。如果未指定，计时器将在所有天都有效。</td></tr><tr><td><code>monthcarry</code></td><td>默认：True，如果未看到该天（周末、交易假期），计时器将在下一个可用日执行。</td></tr><tr><td><code>allow</code></td><td>默认：None，一个回调，接收一个<code>datetime.date</code>实例，如果日期被允许用于计时器则返回True，否则返回False。</td></tr><tr><td><code>tzdata</code></td><td>可以是None（默认）、一个<code>pytz</code>实例或一个数据源实例。<ul><li><code>None</code>：按面值解释<code>when</code>（这意味着将其处理为UTC，即使不是）。</li><li>- <code>pytz</code>实例：<code>when</code>将被解释为在所选时区本地时间指定。</li><li>数据源实例：<code>when</code>将被解释为在数据源实例的<code>tz</code>参数指定的本地时间。</li></ul><strong>注意</strong>，如果<code>when</code>是<code>SESSION_START</code>或<code>SESSION_END</code>并且<code>tzdata</code>为None，将使用系统中的第一个数据源（即<code>self.data0</code>）作为参考，以找出会话时间。</td></tr><tr><td><code>strats</code></td><td>默认：False，也调用策略的<code>notify_timer</code>。</td></tr><tr><td><code>cheat</code></td><td>默认：False）如果为True，将在经纪人有机会评估订单之前调用计时器。这打开了发布基于开盘价的订单的机会，例如在会话开始前。</td></tr><tr><td><code>*args</code></td><td>将传递给<code>notify_timer</code>的任何额外args。</td></tr><tr><td><code>**kwargs</code></td><td>将传递给<code>notify_timer</code>的任何额外kwargs。返回值：创建的计时器。</td></tr></tbody></table><ul><li><code>notify_timer(timer, when, *args, **kwargs)</code></li></ul><p>接收计时器通知，其中<code>timer</code>是由 <code>add_timer</code> 返回的计时器，<code>when</code>是调用时间。<code>args</code>和<code>kwargs</code>是传递给<code>add_timer</code>的任何附加参数。实际的<code>when</code>时间可能稍后，但系统可能无法提前调用计时器。此值是计时器值，而不是系统时间。</p><ul><li><code>add_order_history(orders, notify=True)</code></li></ul><p>将订单历史直接添加到经纪人以进行性能评估。</p><p><code>orders</code>：是一个可迭代对象（例如：列表、元组、迭代器、生成器），其中每个元素也是一个具有以下子元素（2种格式可能）的可迭代对象（具有长度）：<code>[datetime, size, price]</code>或<code>[datetime, size, price, data]</code>，<strong>注意</strong>，必须按日期时间升序排序（或生成排序的元素）。</p><p>具体说明如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>datetime</code></td><td>是Python的日期/日期时间实例或格式为<code>YYYY-MM-DD[THH:MM:SS[.us]]</code>的字符串，其中括号内的元素是可选的。</td></tr><tr><td><code>size</code></td><td>是一个整数（正数表示买入，负数表示卖出）。</td></tr><tr><td><code>price</code></td><td>是一个浮点数/整数。</td></tr><tr><td><code>data</code></td><td>如果存在，可以取以下任何值：<ul><li><code>None</code> - 将使用第一个数据源作为目标。</li><li><code>integer</code> - 将使用该索引（在Cerebro中插入顺序）的数据。</li><li><code>string</code> - 将使用具有该名称的数据，例如使用<code>cerebro.adddata(data, name=value)</code>分配的名称。</li></ul></td></tr></tbody></table><p><code>notify</code>（默认：True）：如果为True，系统中插入的第一个策略将收到根据每个订单的信息创建的人工订单通知。</p><p><strong>注意</strong></p><p>描述中隐含的是添加作为订单目标的数据源。例如，这是分析器（如跟踪回报）的必要条件。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/backtrader/docs/05-cerebro/01-cerebro/ class="flex align-center"><img src=/backtrader/icons/backward.svg class=book-icon alt=Previous title=Cerebro>
<span>Cerebro</span>
</a></span><span><a href=/backtrader/docs/05-cerebro/03-saving-memory/ class="flex align-center"><span>节省内存</span>
<img src=/backtrader/icons/forward.svg class=book-icon alt=Next title=节省内存></a></span></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class=book-comments><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#实例化参数>实例化参数</a></li><li><a href=#成员方法>成员方法</a></li></ul></nav></div></aside></main></body></html>