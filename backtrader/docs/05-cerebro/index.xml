<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cerebro on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/</link><description>Recent content in Cerebro on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/05-cerebro/index.xml" rel="self" type="application/rss+xml"/><item><title>Cerebro</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</guid><description>Cerebro # Cerebro 是 Backtrader 的核心类，负责整个系统的运行。
它的功能包括：
收集输入（数据源）、执行者（策略）、观察者、评论者（分析器）和记录者（编写器），确保系统的正常运行。 执行回测或实时数据供给和交易。 返回回测结果。 提供策略绘图功能。 创建 Cerebro 实例 # 创建 Cerebro 实例时，可以通过传递一些控制参数：
cerebro = bt.Cerebro(**kwargs) 这些参数会影响系统的执行，具体的参数说明可以参考文档（也可以应用于后续的 run 方法）。
添加数据源 # 最常见的方式是使用 cerebro.adddata(data) 添加数据源，data 是已实例化的数据源。例如：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.days&amp;#39;, timeframe=bt.TimeFrame.Days) cerebro.adddata(data) 数据的重采样与重放 # Cerebro 也支持对数据进行重采样或重放：
重采样：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.min&amp;#39;, timeframe=bt.TimeFrame.Minutes) cerebro.resampledata(data, timeframe=bt.TimeFrame.Days) 重放数据：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.min&amp;#39;, timeframe=bt.TimeFrame.Minutes) cerebro.replaydata(data, timeframe=bt.TimeFrame.Days) 你可以同时使用多种类型的数据源，包括常规数据、重采样数据和重放数据。但需要确保它们的时间对齐。详见文档中的 多时间框架 和 数据重采样 部分。
添加策略 # Cerebro 接受策略类并传递相关参数，即使没有优化，也可以使用以下方式添加策略：
cerebro.addstrategy(MyStrategy, myparam1=value1, myparam2=value2) 策略优化 # 在优化时，参数需要作为可迭代对象传递。例如：
cerebro.optstrategy(MyStrategy, myparam1=range(10, 20)) 这会运行 MyStrategy 10次，myparam1 的值从 10 到 19。</description></item><item><title>参数说明</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</guid><description>参数说明 # 如下是 Cerebro 类的详细说明。
实例化参数 # 参数 默认值 说明 preload True 是否预加载传递给策略的不同数据源。 runonce True 以矢量化模式计算指标，从而提高整个系统的性能。
注： 策略和观察者将始终基于事件运行。 live False 如果没有数据报告为实时（通过数据的islive方法，但用户仍希望以实时模式运行，可将此参数设为true。 maxcpus None 同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。 stdstats True） 如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。 oldbuysell False 如 stdstats 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。 oldtrades False 如果stdstats为True 且自动添加观察者，此开关控制交易观察者的主要行为。 exactbars False - False：默认值，将存储在 Line 中的值都保存到内存。-True或1：所有Line对象的内存使用减少至计算最小周期。如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。此设置将停用preload和runonce。使用此设置还将停用绘图。 -1：策略级别的数据源和指标/操作将保留所有数据在内存中。如 RSI 通过指标UpDay计算，不会将它的所有数据保留内存。 这允许保持绘图和预加载活动。runonce将被停用。-2：作为策略属性的数据源和指标将保留所有点在内存中。例如：RSI内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。- 这允许保持绘图和预加载活动。runonce将被停用。 objcache False 实验选项，用于实现 Line 对象的缓存并减少它们的数量。示例来自UltimateOscillator：bp = self.data.close - TrueLow(self.data) # -&amp;gt; 创建另一个 TrueLow(self.data)tr = TrueRange(self.</description></item><item><title>节省内存</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</guid><description>内存优化 # Backtrader 的开发是在拥有大量RAM的机器上进行的，加上绘图的可视化反馈非常有用，几乎是必需品，这使得设计决策变得容易：将所有内容保存在内存中。但这一决定有一些缺点：
使用array.array进行数据存储时，当某些边界被超出时，需要分配和移动数据。 内存较少的机器可能会受到影响。 连接到一个可能在线数周/数月、提供数千秒/分钟分辨率tick的实时数据源。 后者比前者更重要，因为backtrader做出了另一个设计决策：
保持纯Python以便在需要时能够在嵌入式系统中运行。 未来的一个场景可能是backtrader连接到第二台提供实时数据的机器，而backtrader本身运行在Raspberry Pi甚至更有限的设备上，如ADSL路由器（带有Freetz映像的AVM Frit!Box 7490）。
因此，需要backtrader支持动态内存方案。现在可以使用以下语义实例化或运行Cerebro：
exactbars 默认值为 False，每个存储在线中的值都保存在内存中。可能的值：
True或1：所有“线”对象将内存使用减少到自动计算的最小周期。
如果 SMA 的周期为30，则底层将始终有一个30条的运行缓冲区，以允许计算 SMA。 此设置将停用预加载和runonce。 使用此设置还将停用绘图。 -1：在策略级别的数据源和指标/操作将保留所有数据在内存中。
如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 -2：作为策略属性的数据源和指标将保留所有点在内存中。
如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 正如往常，示例胜过千言万语。一个示例脚本展示了差异。它针对1996年至2015年的雅虎每日数据运行，共计4965天。
注意：这是一个小样本。交易14小时的EuroStoxx50期货在一个月内将生成约18000个1分钟条。
首先执行脚本，查看在不请求内存节省时使用了多少内存位置：
$ ./memory-savings.py --save 0 Total memory cells used: 506430 对于级别1（完全节省）：
$ ./memory-savings.py --save 1 Total memory cells used: 2041 从 50 万降到 2041。确实如此。
系统中的每个“线”对象使用collections.deque作为缓冲区（而不是array.array），并且长度限制为所需操作的绝对最小值。
假设，使用周期为30的简单移动平均线的策略。在这种情况下，将进行以下调整：</description></item><item><title>优化改进</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</guid><description>优化改进 # Backtrader 通过引入两个新的 Cerebro 参数，优化了在多进程环境下管理数据源和结果的方式。
参数说明：
参数名 默认值 描述 optdatas True 如果为True并进行优化（系统可以预加载并使用runonce），则数据预加载将仅在主进程中进行一次，以节省时间和资源。 optreturn True 如果为True，优化结果将不是完整的策略对象（包括所有数据、指标、观察者等），而是带有以下属性的对象（与策略中相同）：- params（或p）：策略执行时的参数- analyzers：策略执行的分析器 通常，我们只需要查看策略使用的参数的最终表现（如收益率）。如想查看运行过程中的详细数据（如每个时间点的指标值），请关闭此选项。
数据源管理 # 在优化场景中，Cerebro 参数可能的组合是：
preload=True（默认），数据源将在运行任何回测代码前完成预加载： runonce=True（默认），指标将在紧密的for循环中批量计算，而不是逐步计算。 如果两个条件都为True且optdatas=True，则数据源将在生成新子进程之前在主进程中预加载（这些子进程负责执行回测）
结果管理 # 在优化场景中，当评估每个策略运行的不同参数时，最重要的两个因素是：
strategy.params（或strategy.p）
回测使用的实际参数集
strategy.analyzers
提供策略实际表现评估的对象。例如：SharpeRatio_A（年化夏普比率）
当optreturn=True时，不会返回完整的策略实例，而是创建占位符对象，这些对象携带上述两个属性以进行评估。
这避免了传回大量生成的数据，例如回测期间指标生成的值。
如果希望返回完整的策略对象，只需在Cerebro实例化或进行cerebro.run时设置optreturn=False。
一些测试运行 # backtrader源代码中的优化示例已扩展，添加了对optdatas和optreturn的控制（实际上是禁用它们）。
单核心运行 # 作为参考，当将CPU数量限制为1且不使用多进程模块时会发生什么：
$ ./optimization.py --maxcpus 1 ================================================== ************************************************** -------------------------------------------------- OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 10), (u&amp;#39;macdperiod1&amp;#39;, 12), (u&amp;#39;macdperiod2&amp;#39;, 26), (u&amp;#39;macdperiod3&amp;#39;, 9)]) ************************************************** -------------------------------------------------- OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 10), (u&amp;#39;macdperiod1&amp;#39;, 13), (u&amp;#39;macdperiod2&amp;#39;, 26), (u&amp;#39;macdperiod3&amp;#39;, 9)]) ... ... OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 29), (u&amp;#39;macdperiod1&amp;#39;, 19), (u&amp;#39;macdperiod2&amp;#39;, 29), (u&amp;#39;macdperiod3&amp;#39;, 14)]) ================================================== Time used: 184.</description></item><item><title>异常 Exceptions</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</guid><description>异常 # 设计目标之一是尽早退出并让用户完全透明地了解错误发生的情况。目的是强制自己编写在异常情况下会中断的代码，并强制重新审视受影响的部分。
但现在是时候了，某些异常可能会慢慢添加到平台中。
继承层次结构 # 所有异常的基类是 BacktraderError（直接继承自 Exception）。
位置 # 在 errors 模块内，可以通过以下方式访问：
import backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.errors.StrategySkipError 或者直接从 backtrader 访问：
import backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.StrategySkipError 异常 # StrategySkipError，请求平台跳过该策略的回测。应在实例的初始化（__init__）阶段引发。</description></item><item><title>日志 Logging - Writter</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</guid><description> Writer # Writer类负责将以下内容写入流：
数据源、策略、指标和观察者的CSV流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。
属性摘要：
数据源 策略（线条和参数） 指标/观察者（线条和参数） 分析器（参数和分析结果） 系统中定义了一个名为WriterFile的Writer，可以通过以下方式添加：
设置Cerebro的writer参数为True，将实例化一个标准的WriterFile 调用Cerebro.addwriter(writerclass, **kwargs)，在回测执行期间，使用给定的kwargs实例化writerclass 由于标准的WriterFile默认不输出CSV，以下调用可以处理这一点：
cerebro.addwriter(bt.WriterFile, csv=True) 参考 # class backtrader.WriterFile() # 系统范围内的Writer类。
可以通过以下参数进行参数化：
参数名 默认 说明 out sys.stdout 写入的输出流，如果传递的是字符串，将使用参数内容作为文件名。 close_out False 如果 out 是一个流，是否需要由Writer显式关闭。 csv False 在执行过程中，是否将数据源、策略、观察者和指标的CSV流写入输出流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。 csv_filternan True CSV流中清除nan值（用空字段替换）。 csv_counter True 是否应保持并输出实际输出行的计数器。 indent 2 每个级别的缩进空格数。 separators &amp;lsquo;=&amp;rsquo;, &amp;lsquo;-&amp;rsquo;, &amp;lsquo;+&amp;rsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;.&amp;rsquo;, &amp;lsquo;~&amp;rsquo;, &amp;lsquo;&amp;quot;&amp;rsquo;, &amp;lsquo;^&amp;rsquo;, &amp;lsquo;#&amp;rsquo; 用于分隔部分/子部分的行分隔符字符。 seplen 79 包括缩进在内的行分隔符的总长度。 rounding None 将浮点数舍入到的小数位数。如果为None，则不执行舍入。</description></item></channel></rss>