<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cerebro on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/</link><description>Recent content in Cerebro on Backtrader 中文</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/05-cerebro/index.xml" rel="self" type="application/rss+xml"/><item><title>Cerebro</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</guid><description>&lt;h1 id="cerebro"&gt;Cerebro&lt;a class="anchor" href="#cerebro"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Cerebro&lt;/code&gt; 是 Backtrader 的核心类，负责整个系统的运行。&lt;/p&gt;
&lt;p&gt;它的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集输入（数据源）、执行者（策略）、观察者、评论者（分析器）和记录者（编写器），确保系统的正常运行。&lt;/li&gt;
&lt;li&gt;执行回测或实时数据供给和交易。&lt;/li&gt;
&lt;li&gt;返回回测结果。&lt;/li&gt;
&lt;li&gt;提供策略绘图功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="创建-cerebro-实例"&gt;创建 &lt;code&gt;Cerebro&lt;/code&gt; 实例&lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba-cerebro-%e5%ae%9e%e4%be%8b"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;创建 &lt;code&gt;Cerebro&lt;/code&gt; 实例时，可以通过传递一些控制参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Cerebro(&lt;span style="color:#f92672"&gt;**&lt;/span&gt;kwargs)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这些参数会影响系统的执行，具体的参数说明可以参考文档（也可以应用于后续的 &lt;code&gt;run&lt;/code&gt; 方法）。&lt;/p&gt;
&lt;h2 id="添加数据源"&gt;添加数据源&lt;a class="anchor" href="#%e6%b7%bb%e5%8a%a0%e6%95%b0%e6%8d%ae%e6%ba%90"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最常见的方式是使用 &lt;code&gt;cerebro.adddata(data)&lt;/code&gt; 添加数据源，&lt;code&gt;data&lt;/code&gt; 是已实例化的数据源。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;data &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;BacktraderCSVData(dataname&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;mypath.days&amp;#39;&lt;/span&gt;, timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Days)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;adddata(data)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="数据的重采样与重放"&gt;数据的重采样与重放&lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%9a%84%e9%87%8d%e9%87%87%e6%a0%b7%e4%b8%8e%e9%87%8d%e6%94%be"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cerebro&lt;/code&gt; 也支持对数据进行重采样或重放：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重采样&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;data &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;BacktraderCSVData(dataname&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;mypath.min&amp;#39;&lt;/span&gt;, timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Minutes)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;resampledata(data, timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Days)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;重放数据&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;data &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;BacktraderCSVData(dataname&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;mypath.min&amp;#39;&lt;/span&gt;, timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Minutes)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;replaydata(data, timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Days)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以同时使用多种类型的数据源，包括常规数据、重采样数据和重放数据。但需要确保它们的时间对齐。详见文档中的 &lt;strong&gt;多时间框架&lt;/strong&gt; 和 &lt;strong&gt;数据重采样&lt;/strong&gt; 部分。&lt;/p&gt;
&lt;h2 id="添加策略"&gt;添加策略&lt;a class="anchor" href="#%e6%b7%bb%e5%8a%a0%e7%ad%96%e7%95%a5"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Cerebro&lt;/code&gt; 接受策略类并传递相关参数，即使没有优化，也可以使用以下方式添加策略：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;addstrategy(MyStrategy, myparam1&lt;span style="color:#f92672"&gt;=&lt;/span&gt;value1, myparam2&lt;span style="color:#f92672"&gt;=&lt;/span&gt;value2)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="策略优化"&gt;策略优化&lt;a class="anchor" href="#%e7%ad%96%e7%95%a5%e4%bc%98%e5%8c%96"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在优化时，参数需要作为可迭代对象传递。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;optstrategy(MyStrategy, myparam1&lt;span style="color:#f92672"&gt;=&lt;/span&gt;range(&lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;20&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会运行 &lt;code&gt;MyStrategy&lt;/code&gt; 10次，&lt;code&gt;myparam1&lt;/code&gt; 的值从 10 到 19。&lt;/p&gt;
&lt;h2 id="添加其他组件"&gt;添加其他组件&lt;a class="anchor" href="#%e6%b7%bb%e5%8a%a0%e5%85%b6%e4%bb%96%e7%bb%84%e4%bb%b6"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;你可以通过以下方法为回测添加额外的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;addwriter&lt;/code&gt;&lt;/strong&gt;：记录回测数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;addanalyzer&lt;/code&gt;&lt;/strong&gt;：分析回测结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;addobserver&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;addobservermulti&lt;/code&gt;&lt;/strong&gt;：添加观察者，实时跟踪策略执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="自定义经纪人"&gt;自定义经纪人&lt;a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%8f%e7%ba%aa%e4%ba%ba"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Cerebro&lt;/code&gt; 默认使用 Backtrader 内建的经纪人，但你也可以自定义经纪人：&lt;/p&gt;</description></item><item><title>参数说明</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</guid><description>&lt;h1 id="参数说明"&gt;参数说明&lt;a class="anchor" href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;如下是 &lt;code&gt;Cerebro&lt;/code&gt; 类的详细说明。&lt;/p&gt;
&lt;h2 id="实例化参数"&gt;实例化参数&lt;a class="anchor" href="#%e5%ae%9e%e4%be%8b%e5%8c%96%e5%8f%82%e6%95%b0"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;参数&lt;/th&gt;
 &lt;th&gt;默认值&lt;/th&gt;
 &lt;th&gt;说明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;preload&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;是否预加载传递给策略的不同数据源。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;runonce&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;以矢量化模式计算指标，从而提高整个系统的性能。&lt;br&gt;&lt;strong&gt;注：&lt;/strong&gt; 策略和观察者将始终基于事件运行。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;live&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;如果没有数据报告为实时（通过数据的&lt;code&gt;islive&lt;/code&gt;方法，但用户仍希望以实时模式运行，可将此参数设为true。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;maxcpus&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;None&lt;/td&gt;
 &lt;td&gt;同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;stdstats&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True）&lt;/td&gt;
 &lt;td&gt;如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;oldbuysell&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;如 &lt;code&gt;stdstats&lt;/code&gt; 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;oldtrades&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;如果&lt;code&gt;stdstats&lt;/code&gt;为True 且自动添加观察者，此开关控制交易观察者的主要行为。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;exactbars&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;&lt;ul style="list-style-type: none;padding-left: 0; margin-left: 0;"&gt;&lt;li&gt;- &lt;code&gt;False&lt;/code&gt;：默认值，将存储在 &lt;code&gt;Line&lt;/code&gt; 中的值都保存到内存。&lt;/li&gt;&lt;li&gt;-&lt;code&gt;True&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;：所有&lt;code&gt;Line&lt;/code&gt;对象的内存使用减少至计算最小周期。&lt;ul&gt;&lt;li&gt;如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。&lt;/li&gt;&lt;li&gt;此设置将停用&lt;code&gt;preload&lt;/code&gt;和&lt;code&gt;runonce&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;使用此设置还将停用绘图。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;-1&lt;/code&gt;：策略级别的数据源和指标/操作将保留所有数据在内存中。&lt;ul&gt;&lt;li&gt;如 &lt;code&gt;RSI&lt;/code&gt; 通过指标&lt;code&gt;UpDay&lt;/code&gt;计算，不会将它的所有数据保留内存。&lt;/li&gt;&lt;li&gt; 这允许保持绘图和预加载活动。&lt;/li&gt;&lt;li&gt;&lt;code&gt;runonce&lt;/code&gt;将被停用。&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;code&gt;-2&lt;/code&gt;：作为策略属性的数据源和指标将保留所有点在内存中。&lt;ul&gt;&lt;li&gt;例如：&lt;code&gt;RSI&lt;/code&gt;内部使用指标&lt;code&gt;UpDay&lt;/code&gt;进行计算。此子指标将不保留所有数据在内存中。&lt;/li&gt;&lt;li&gt;如果在&lt;code&gt;__init__&lt;/code&gt;中定义了&lt;code&gt;a = self.data.close - self.data.high&lt;/code&gt;，那么&lt;code&gt;a&lt;/code&gt;将不保留所有数据在内存中。&lt;/li&gt;&lt;li&gt;- 这允许保持绘图和预加载活动。&lt;/li&gt;&lt;li&gt;&lt;code&gt;runonce&lt;/code&gt;将被停用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;objcache&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;实验选项，用于实现 &lt;code&gt;Line&lt;/code&gt; 对象的缓存并减少它们的数量。示例来自&lt;code&gt;UltimateOscillator&lt;/code&gt;：&lt;div&gt;&lt;pre&gt;&lt;code class="language-python" data-lang="python"&gt;bp = self.data.close - TrueLow(self.data) &lt;br/&gt;# -&amp;gt; 创建另一个 TrueLow(self.data)&lt;br/&gt;&lt;span&gt;tr = TrueRange(self.data)&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;如果为True，&lt;code&gt;TrueRange&lt;/code&gt;内部的第二个&lt;code&gt;TrueLow(self.data)&lt;/code&gt;将匹配bp计算中的签名，并将被重用。可能发生的极端情况是这会使线对象超出其最小周期并导致问题，因此被禁用。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;如果设置为True，将创建一个默认的&lt;code&gt;WriterFile&lt;/code&gt;，它将打印到标准输出。它将被添加到策略中（除了用户代码添加的任何其他编写器）。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;tradehistory&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;如果设置为True，它将激活所有策略中每个交易的更新事件日志记录。也可以通过策略方法&lt;code&gt;set_tradehistory&lt;/code&gt;在每个策略基础上完成。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;optdatas&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;如果为 True 且在优化（并且系统可以预加载和使用runonce），则数据预加载将仅在主进程中完成，以节省时间和资源。测试显示，执行时间从83秒减少到66秒，约20%的速度提升。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;optreturn&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;如果为True，优化结果将不会是完整的策略对象（和所有数据、指标、观察者&amp;hellip;），而是具有以下属性的对象（与策略相同）：&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;params&lt;/code&gt;（或&lt;code&gt;p&lt;/code&gt;）&lt;/td&gt;
 &lt;td&gt;无&lt;/td&gt;
 &lt;td&gt;执行策略时的参数。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;analyzers&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;无&lt;/td&gt;
 &lt;td&gt;策略已执行的分析器。大多数情况下，仅需要分析器和参数来评估策略的性能。如果需要详细分析生成的值（例如指标），请将其关闭。测试显示，执行时间提高了13% - 15%。结合&lt;code&gt;optdatas&lt;/code&gt;，总收益增加到32%。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;oldsync&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;从版本1.9.0.99开始，多个数据（相同或不同时间框架）的同步已更改，以允许不同长度的数据。如果希望使用数据0作为系统主控的数据的旧行为，请将此参数设置为True。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;tz&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;None&lt;/td&gt;
 &lt;td&gt;为策略添加全局时区。参数tz可以是：&lt;ul&gt;&lt;li&gt;&lt;code&gt;None&lt;/code&gt;：在这种情况下，策略显示的日期时间将是UTC，这一直是标准行为。&lt;/li&gt;&lt;li&gt;&lt;code&gt;pytz&lt;/code&gt;实例。将用作将UTC时间转换为所选时区。&lt;/li&gt;&lt;li&gt;&lt;code&gt;字符串&lt;/code&gt;。将尝试实例化&lt;code&gt;pytz&lt;/code&gt;实例。&lt;/li&gt;&lt;li&gt;&lt;code&gt;整数&lt;/code&gt;。对于策略，使用&lt;code&gt;self.datas&lt;/code&gt;可迭代对象中相应数据的相同时区（0将使用&lt;code&gt;data0&lt;/code&gt;的时区）。&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;cheat_on_open&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;将调用策略的&lt;code&gt;next_open&lt;/code&gt;方法。&lt;br/&gt;&lt;br/&gt;这发生在&lt;code&gt;next&lt;/code&gt;之前，并且在经纪人有机会评估订单之前。指标尚未重新计算。这允许发布考虑前一天指标的订单，但使用开盘价进行股份计算。&lt;br/&gt;&lt;br/&gt;对于&lt;code&gt;cheat_on_open&lt;/code&gt;订单执行，还要调用 &lt;code&gt;cerebro.broker.set_coo(True)&lt;/code&gt;或实例化一个&lt;code&gt;BackBroker(coo=True)&lt;/code&gt;（coo表示&lt;code&gt;cheat-on-open&lt;/code&gt;）或将&lt;code&gt;broker_coo&lt;/code&gt;参数设置为True。除非在下文中禁用，否则Cerebro会自动执行此操作。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;broker_coo&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;这将自动调用经纪人的&lt;code&gt;set_coo&lt;/code&gt;方法，并将其设置为True以激活&lt;code&gt;cheat_on_open&lt;/code&gt;执行。只有在&lt;code&gt;cheat_on_open&lt;/code&gt;也为True时才会执行。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;quicknotify&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;False&lt;/td&gt;
 &lt;td&gt;在传递下一个价格之前立即传递经纪人通知。对于回测没有影响，但对于实时经纪人，通知可能在条传递之前很久就发生。当设置为True时，将尽快传递通知（请参阅实时数据源中的&lt;code&gt;qcheck&lt;/code&gt;）。为了兼容性，设置为False。可能会更改为True。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="成员方法"&gt;成员方法&lt;a class="anchor" href="#%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addstorecb(callback)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;添加一个回调以获取将由&lt;code&gt;notify_store&lt;/code&gt;方法处理的消息。回调的签名必须支持以下内容：&lt;/p&gt;</description></item><item><title>节省内存</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</guid><description>&lt;h1 id="内存优化"&gt;内存优化&lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e4%bc%98%e5%8c%96"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Backtrader&lt;/strong&gt; 的开发是在拥有大量RAM的机器上进行的，加上绘图的可视化反馈非常有用，几乎是必需品，这使得设计决策变得容易：将所有内容保存在内存中。但这一决定有一些缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;array.array&lt;/code&gt;进行数据存储时，当某些边界被超出时，需要分配和移动数据。&lt;/li&gt;
&lt;li&gt;内存较少的机器可能会受到影响。&lt;/li&gt;
&lt;li&gt;连接到一个可能在线数周/数月、提供数千秒/分钟分辨率tick的实时数据源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后者比前者更重要，因为backtrader做出了另一个设计决策：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持纯Python以便在需要时能够在嵌入式系统中运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;未来的一个场景可能是backtrader连接到第二台提供实时数据的机器，而backtrader本身运行在Raspberry Pi甚至更有限的设备上，如ADSL路由器（带有Freetz映像的AVM Frit!Box 7490）。&lt;/p&gt;
&lt;p&gt;因此，需要backtrader支持动态内存方案。现在可以使用以下语义实例化或运行Cerebro：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exactbars&lt;/code&gt; 默认值为 &lt;code&gt;False&lt;/code&gt;，每个存储在线中的值都保存在内存中。可能的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;True&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;：所有“线”对象将内存使用减少到自动计算的最小周期。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 SMA 的周期为30，则底层将始终有一个30条的运行缓冲区，以允许计算 SMA。&lt;/li&gt;
&lt;li&gt;此设置将停用预加载和runonce。&lt;/li&gt;
&lt;li&gt;使用此设置还将停用绘图。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-1&lt;/code&gt;：在策略级别的数据源和指标/操作将保留所有数据在内存中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。&lt;/li&gt;
&lt;li&gt;这允许保持绘图和预加载活动。&lt;/li&gt;
&lt;li&gt;runonce将被停用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-2&lt;/code&gt;：作为策略属性的数据源和指标将保留所有点在内存中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。&lt;/li&gt;
&lt;li&gt;如果在&lt;code&gt;__init__&lt;/code&gt;中定义了&lt;code&gt;a = self.data.close - self.data.high&lt;/code&gt;，那么&lt;code&gt;a&lt;/code&gt;将不保留所有数据在内存中。&lt;/li&gt;
&lt;li&gt;这允许保持绘图和预加载活动。&lt;/li&gt;
&lt;li&gt;runonce将被停用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如往常，示例胜过千言万语。一个示例脚本展示了差异。它针对1996年至2015年的雅虎每日数据运行，共计4965天。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这是一个小样本。交易14小时的EuroStoxx50期货在一个月内将生成约18000个1分钟条。&lt;/p&gt;
&lt;p&gt;首先执行脚本，查看在不请求内存节省时使用了多少内存位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ ./memory-savings.py --save &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Total memory cells used: &lt;span style="color:#ae81ff"&gt;506430&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于级别1（完全节省）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ ./memory-savings.py --save &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Total memory cells used: &lt;span style="color:#ae81ff"&gt;2041&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从 50 万降到 2041。确实如此。&lt;/p&gt;
&lt;p&gt;系统中的每个“线”对象使用&lt;code&gt;collections.deque&lt;/code&gt;作为缓冲区（而不是&lt;code&gt;array.array&lt;/code&gt;），并且长度限制为所需操作的绝对最小值。&lt;/p&gt;
&lt;p&gt;假设，使用周期为30的简单移动平均线的策略。在这种情况下，将进行以下调整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据源将有一个30位置的缓冲区，这是 SMA 生成下一个值所需的数量。&lt;/li&gt;
&lt;li&gt;SMA 将有一个位置的缓冲区，因为除非其他指标需要（依赖于 SMA），否则没必要保留更大缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此模式最吸引人且可能最重要的特点是，整个脚本生命周期内使用的内存量保持不变。&lt;/p&gt;
&lt;p&gt;无论数据源的大小如何。如如果长时间连接实时数据源，这将非常有用。&lt;/p&gt;</description></item><item><title>优化改进</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</guid><description>&lt;h1 id="优化改进"&gt;优化改进&lt;a class="anchor" href="#%e4%bc%98%e5%8c%96%e6%94%b9%e8%bf%9b"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Backtrader&lt;/strong&gt; 通过引入两个新的 Cerebro 参数，优化了在多进程环境下管理数据源和结果的方式。&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;参数名&lt;/th&gt;
 &lt;th&gt;默认值&lt;/th&gt;
 &lt;th&gt;描述&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;optdatas&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;如果为True并进行优化（系统可以预加载并使用runonce），则数据预加载将仅在主进程中进行一次，以节省时间和资源。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;optreturn&lt;/td&gt;
 &lt;td&gt;True&lt;/td&gt;
 &lt;td&gt;如果为True，优化结果将不是完整的策略对象（包括所有数据、指标、观察者等），而是带有以下属性的对象（与策略中相同）：&lt;ul style="list-style-type: none; padding-left: 0;"&gt;&lt;li&gt;- params（或p）：策略执行时的参数&lt;/li&gt;&lt;li&gt;- analyzers：策略执行的分析器&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常，我们只需要查看策略使用的参数的最终表现（如收益率）。如想查看运行过程中的详细数据（如每个时间点的指标值），请关闭此选项。&lt;/p&gt;
&lt;h2 id="数据源管理"&gt;数据源管理&lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e6%ba%90%e7%ae%a1%e7%90%86"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在优化场景中，Cerebro 参数可能的组合是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;preload=True&lt;/code&gt;（默认），数据源将在运行任何回测代码前完成预加载：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runonce=True&lt;/code&gt;（默认），指标将在紧密的for循环中批量计算，而不是逐步计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果两个条件都为True且&lt;code&gt;optdatas=True&lt;/code&gt;，则数据源将在生成新子进程之前在主进程中预加载（这些子进程负责执行回测）&lt;/p&gt;
&lt;h2 id="结果管理"&gt;结果管理&lt;a class="anchor" href="#%e7%bb%93%e6%9e%9c%e7%ae%a1%e7%90%86"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在优化场景中，当评估每个策略运行的不同参数时，最重要的两个因素是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strategy.params&lt;/code&gt;（或&lt;code&gt;strategy.p&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;回测使用的实际参数集&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strategy.analyzers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;提供策略实际表现评估的对象。例如：&lt;code&gt;SharpeRatio_A&lt;/code&gt;（年化夏普比率）&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;optreturn=True&lt;/code&gt;时，不会返回完整的策略实例，而是创建占位符对象，这些对象携带上述两个属性以进行评估。&lt;/p&gt;
&lt;p&gt;这避免了传回大量生成的数据，例如回测期间指标生成的值。&lt;/p&gt;
&lt;p&gt;如果希望返回完整的策略对象，只需在Cerebro实例化或进行&lt;code&gt;cerebro.run&lt;/code&gt;时设置&lt;code&gt;optreturn=False&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="一些测试运行"&gt;一些测试运行&lt;a class="anchor" href="#%e4%b8%80%e4%ba%9b%e6%b5%8b%e8%af%95%e8%bf%90%e8%a1%8c"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;backtrader源代码中的优化示例已扩展，添加了对&lt;code&gt;optdatas&lt;/code&gt;和&lt;code&gt;optreturn&lt;/code&gt;的控制（实际上是禁用它们）。&lt;/p&gt;
&lt;h3 id="单核心运行"&gt;单核心运行&lt;a class="anchor" href="#%e5%8d%95%e6%a0%b8%e5%bf%83%e8%bf%90%e8%a1%8c"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;作为参考，当将CPU数量限制为1且不使用多进程模块时会发生什么：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ ./optimization.py --maxcpus 1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;**************************************************
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;OrderedDict&lt;span style="color:#f92672"&gt;([(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;smaperiod&amp;#39;&lt;/span&gt;, 10&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod1&amp;#39;&lt;/span&gt;, 12&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod2&amp;#39;&lt;/span&gt;, 26&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod3&amp;#39;&lt;/span&gt;, 9&lt;span style="color:#f92672"&gt;)])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;**************************************************
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;OrderedDict&lt;span style="color:#f92672"&gt;([(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;smaperiod&amp;#39;&lt;/span&gt;, 10&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod1&amp;#39;&lt;/span&gt;, 13&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod2&amp;#39;&lt;/span&gt;, 26&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod3&amp;#39;&lt;/span&gt;, 9&lt;span style="color:#f92672"&gt;)])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;OrderedDict&lt;span style="color:#f92672"&gt;([(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;smaperiod&amp;#39;&lt;/span&gt;, 29&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod1&amp;#39;&lt;/span&gt;, 19&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod2&amp;#39;&lt;/span&gt;, 29&lt;span style="color:#f92672"&gt;)&lt;/span&gt;, &lt;span style="color:#f92672"&gt;(&lt;/span&gt;u&lt;span style="color:#e6db74"&gt;&amp;#39;macdperiod3&amp;#39;&lt;/span&gt;, 14&lt;span style="color:#f92672"&gt;)])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;==================================================&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Time used: 184.922727833&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="多核心运行"&gt;多核心运行&lt;a class="anchor" href="#%e5%a4%9a%e6%a0%b8%e5%bf%83%e8%bf%90%e8%a1%8c"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在不限制CPU数量的情况下，Python多进程模块将尝试使用所有CPU。禁用&lt;code&gt;optdatas&lt;/code&gt;和&lt;code&gt;optreturn&lt;/code&gt;&lt;/p&gt;</description></item><item><title>异常 Exceptions</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</guid><description>&lt;h1 id="异常"&gt;异常&lt;a class="anchor" href="#%e5%bc%82%e5%b8%b8"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;设计目标之一是尽早退出并让用户完全透明地了解错误发生的情况。目的是强制自己编写在异常情况下会中断的代码，并强制重新审视受影响的部分。&lt;/p&gt;
&lt;p&gt;但现在是时候了，某些异常可能会慢慢添加到平台中。&lt;/p&gt;
&lt;h2 id="继承层次结构"&gt;继承层次结构&lt;a class="anchor" href="#%e7%bb%a7%e6%89%bf%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所有异常的基类是 &lt;code&gt;BacktraderError&lt;/code&gt;（直接继承自 &lt;code&gt;Exception&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id="位置"&gt;位置&lt;a class="anchor" href="#%e4%bd%8d%e7%bd%ae"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;errors&lt;/code&gt; 模块内，可以通过以下方式访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; backtrader &lt;span style="color:#66d9ef"&gt;as&lt;/span&gt; bt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Strategy&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Strategy):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; something_goes_wrong():
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;raise&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;errors&lt;span style="color:#f92672"&gt;.&lt;/span&gt;StrategySkipError&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者直接从 &lt;code&gt;backtrader&lt;/code&gt; 访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; backtrader &lt;span style="color:#66d9ef"&gt;as&lt;/span&gt; bt
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Strategy&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Strategy):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; something_goes_wrong():
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;raise&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;StrategySkipError&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="异常-1"&gt;异常&lt;a class="anchor" href="#%e5%bc%82%e5%b8%b8-1"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;StrategySkipError&lt;/code&gt;，请求平台跳过该策略的回测。应在实例的初始化（&lt;code&gt;__init__&lt;/code&gt;）阶段引发。&lt;/p&gt;</description></item><item><title>日志 Logging - Writter</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</guid><description>&lt;h1 id="writer"&gt;Writer&lt;a class="anchor" href="#writer"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Writer类负责将以下内容写入流：&lt;/p&gt;
&lt;p&gt;数据源、策略、指标和观察者的CSV流。可以通过每个对象的&lt;code&gt;csv&lt;/code&gt;属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。&lt;/p&gt;
&lt;p&gt;属性摘要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据源&lt;/li&gt;
&lt;li&gt;策略（线条和参数）&lt;/li&gt;
&lt;li&gt;指标/观察者（线条和参数）&lt;/li&gt;
&lt;li&gt;分析器（参数和分析结果）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统中定义了一个名为&lt;code&gt;WriterFile&lt;/code&gt;的Writer，可以通过以下方式添加：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置Cerebro的&lt;code&gt;writer&lt;/code&gt;参数为True，将实例化一个标准的&lt;code&gt;WriterFile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Cerebro.addwriter(writerclass, **kwargs)&lt;/code&gt;，在回测执行期间，使用给定的kwargs实例化&lt;code&gt;writerclass&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于标准的&lt;code&gt;WriterFile&lt;/code&gt;默认不输出CSV，以下调用可以处理这一点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;cerebro&lt;span style="color:#f92672"&gt;.&lt;/span&gt;addwriter(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;WriterFile, csv&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="参考"&gt;参考&lt;a class="anchor" href="#%e5%8f%82%e8%80%83"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="class-backtraderwriterfile"&gt;&lt;code&gt;class backtrader.WriterFile()&lt;/code&gt;&lt;a class="anchor" href="#class-backtraderwriterfile"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;系统范围内的Writer类。&lt;/p&gt;
&lt;p&gt;可以通过以下参数进行参数化：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;参数名&lt;/th&gt;
 &lt;th&gt;默认&lt;/th&gt;
 &lt;th&gt;说明&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;out&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;写入的输出流，如果传递的是字符串，将使用参数内容作为文件名。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;close_out&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;False&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;如果 &lt;code&gt;out&lt;/code&gt; 是一个流，是否需要由Writer显式关闭。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;False&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;在执行过程中，是否将数据源、策略、观察者和指标的CSV流写入输出流。可以通过每个对象的&lt;code&gt;csv&lt;/code&gt;属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;csv_filternan&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;True&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;CSV流中清除nan值（用空字段替换）。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;csv_counter&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&lt;code&gt;True&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;是否应保持并输出实际输出行的计数器。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;2&lt;/td&gt;
 &lt;td&gt;每个级别的缩进空格数。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;separators&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;&amp;lsquo;=&amp;rsquo;, &amp;lsquo;-&amp;rsquo;, &amp;lsquo;+&amp;rsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;.&amp;rsquo;, &amp;lsquo;~&amp;rsquo;, &amp;lsquo;&amp;quot;&amp;rsquo;, &amp;lsquo;^&amp;rsquo;, &amp;lsquo;#&amp;rsquo;&lt;/td&gt;
 &lt;td&gt;用于分隔部分/子部分的行分隔符字符。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;seplen&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;79&lt;/td&gt;
 &lt;td&gt;包括缩进在内的行分隔符的总长度。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/td&gt;
 &lt;td&gt;None&lt;/td&gt;
 &lt;td&gt;将浮点数舍入到的小数位数。如果为None，则不执行舍入。&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;</description></item></channel></rss>