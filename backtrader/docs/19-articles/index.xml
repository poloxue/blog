<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>官方文章 on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/19-articles/</link><description>Recent content in 官方文章 on Backtrader 中文</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/19-articles/index.xml" rel="self" type="application/rss+xml"/><item><title>超大内存</title><link>https://www.poloxue.com/backtrader/docs/19-articles/01-out-of-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/01-out-of-memory/</guid><description>&lt;h1 id="关于回测性能和超大内存执行"&gt;关于回测性能和超大内存执行&lt;a class="anchor" href="#%e5%85%b3%e4%ba%8e%e5%9b%9e%e6%b5%8b%e6%80%a7%e8%83%bd%e5%92%8c%e8%b6%85%e5%a4%a7%e5%86%85%e5%ad%98%e6%89%a7%e8%a1%8c"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;最近在 Reddit 上有两个相关的帖子，启发了本文的写作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个声称 backtrader 无法处理 160 万根 K线的帖子：reddit/r/algotrading - A performant backtesting system?&lt;/li&gt;
&lt;li&gt;另一个要求一个能回测 8000 支股票的工具：reddit/r/algotrading - Backtesting libs that supports 1000+ stocks?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中有一位作者询问如何使用一个可以回测“超大内存”的框架，“因为显然不能将所有这些数据加载到内存中。”&lt;/p&gt;
&lt;p&gt;我们将会在本文中讨论这些概念，结合 backtrader 来解决。&lt;/p&gt;
&lt;h3 id="2m-k线"&gt;2M K线&lt;a class="anchor" href="#2m-k%e7%ba%bf"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;为了验证这一点，首先需要生成这么多的 K线。考虑到第一个发帖者提到 77 支股票和 160 万根 K线，这意味着每支股票大约有 20,779 根 K线，因此我们将进行以下操作来使数据更加简洁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为 100 支股票生成 K线数据&lt;/li&gt;
&lt;li&gt;每支股票生成 20,000 根 K线&lt;/li&gt;
&lt;li&gt;即：生成 100 个文件，总共 200 万根 K线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成数据的脚本如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; numpy &lt;span style="color:#66d9ef"&gt;as&lt;/span&gt; np
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; pandas &lt;span style="color:#66d9ef"&gt;as&lt;/span&gt; pd
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;COLUMNS &lt;span style="color:#f92672"&gt;=&lt;/span&gt; [&lt;span style="color:#e6db74"&gt;&amp;#39;open&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;high&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;low&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;close&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;openinterest&amp;#39;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;CANDLES &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;20000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;STOCKS &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;dateindex &lt;span style="color:#f92672"&gt;=&lt;/span&gt; pd&lt;span style="color:#f92672"&gt;.&lt;/span&gt;date_range(start&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;2010-01-01&amp;#39;&lt;/span&gt;, periods&lt;span style="color:#f92672"&gt;=&lt;/span&gt;CANDLES, freq&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;15min&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; i &lt;span style="color:#f92672"&gt;in&lt;/span&gt; range(STOCKS):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; data &lt;span style="color:#f92672"&gt;=&lt;/span&gt; np&lt;span style="color:#f92672"&gt;.&lt;/span&gt;random&lt;span style="color:#f92672"&gt;.&lt;/span&gt;randint(&lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;20&lt;/span&gt;, size&lt;span style="color:#f92672"&gt;=&lt;/span&gt;(CANDLES, len(COLUMNS)))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; df &lt;span style="color:#f92672"&gt;=&lt;/span&gt; pd&lt;span style="color:#f92672"&gt;.&lt;/span&gt;DataFrame(data &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1.01&lt;/span&gt;, dateindex, columns&lt;span style="color:#f92672"&gt;=&lt;/span&gt;COLUMNS)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; df &lt;span style="color:#f92672"&gt;=&lt;/span&gt; df&lt;span style="color:#f92672"&gt;.&lt;/span&gt;rename_axis(&lt;span style="color:#e6db74"&gt;&amp;#39;datetime&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; df&lt;span style="color:#f92672"&gt;.&lt;/span&gt;to_csv(&lt;span style="color:#e6db74"&gt;&amp;#39;candles&lt;/span&gt;&lt;span style="color:#e6db74"&gt;{:02d}&lt;/span&gt;&lt;span style="color:#e6db74"&gt;.csv&amp;#39;&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;format(i))&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该脚本生成了 100 个文件，从 &lt;code&gt;candles00.csv&lt;/code&gt; 到 &lt;code&gt;candles99.csv&lt;/code&gt;。实际的数据值不重要，重要的是保持标准的日期时间格式、OHLCV 数据（包括未平仓合约）。&lt;/p&gt;</description></item><item><title>跨平台回测的陷进</title><link>https://www.poloxue.com/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/</guid><description>&lt;h3 id="跨平台回测的陷阱"&gt;跨平台回测的陷阱&lt;a class="anchor" href="#%e8%b7%a8%e5%b9%b3%e5%8f%b0%e5%9b%9e%e6%b5%8b%e7%9a%84%e9%99%b7%e9%98%b1"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 Backtrader 社区中，经常有用户希望将 TradingView 等流行的回测平台上的回测结果进行复制。TradingView 使用的脚本语言是 Pinescript，而用户往往并不了解该语言的具体实现，也未接触过回测引擎的内部机制。因此，即使用户有意复制回测结果，也必须明白跨平台编程有其局限性。&lt;/p&gt;
&lt;h4 id="指标并不总是忠实于原始定义"&gt;指标：并不总是忠实于原始定义&lt;a class="anchor" href="#%e6%8c%87%e6%a0%87%e5%b9%b6%e4%b8%8d%e6%80%bb%e6%98%af%e5%bf%a0%e5%ae%9e%e4%ba%8e%e5%8e%9f%e5%a7%8b%e5%ae%9a%e4%b9%89"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;当在 Backtrader 中实现新指标时，开发者会特别强调尊重指标的原始定义。例如，RSI 指标就是一个典型的例子。&lt;/p&gt;
&lt;p&gt;Welles Wilder 设计 RSI 时使用了修改过的移动平均（即平滑移动平均，参见 Wikipedia - Modified Moving Average）。然而，许多平台提供的 RSI 指标，实际上使用的是经典的指数移动平均（EMA），而非书中的定义。&lt;/p&gt;
&lt;p&gt;尽管两者的差别并不算巨大，但这并不是 Wilder 原始定义的 RSI。它可能仍然有用，甚至可能更好，但它并不等同于 Wilder 所定义的 RSI。而且，大多数文档（如果有的话）并未提到这一点。&lt;/p&gt;
&lt;p&gt;在 Backtrader 中，RSI 的默认配置使用 MMA，以保持忠实于原始定义。不过，开发者可以通过子类化或者在运行时实例化时，选择使用 EMA 或者简单移动平均（SMA）来替代。&lt;/p&gt;
&lt;h4 id="例子唐奇安通道"&gt;例子：唐奇安通道&lt;a class="anchor" href="#%e4%be%8b%e5%ad%90%e5%94%90%e5%a5%87%e5%ae%89%e9%80%9a%e9%81%93"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Wikipedia 中的定义是这样的：&lt;strong&gt;Wikipedia - Donchian Channel&lt;/strong&gt;。但是，它只是一些文字，未提到如何使用通道突破作为交易信号。&lt;/p&gt;
&lt;p&gt;另外，以下两个定义明确说明，计算通道时数据不包括当前的柱线，因为如果包括了，突破就无法被反映出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StockCharts - School - Price Channels&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IncredibleCharts - Donchian Channels&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些来源明确指出，计算通道时不包含当前的价格柱线，这样突破才会被正确显示。以下是来自 StockCharts 的示例图表：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StockCharts - Donchian Channels - Breakouts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后，我们看看 TradingView。首先是链接：
&lt;strong&gt;TradingView - Wiki - Donchian Channels&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>加密货币中的分位仓位</title><link>https://www.poloxue.com/backtrader/docs/19-articles/03-fractional-sizes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/03-fractional-sizes/</guid><description>&lt;p&gt;&lt;strong&gt;在 backtrader 中交易加密货币的分数仓位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，让我们用两句话总结一下 backtrader 的工作方式：&lt;/p&gt;
&lt;p&gt;它像一个构建工具包，包含一个基本构建模块（Cerebro），可以将许多不同的模块插入其中。&lt;/p&gt;
&lt;p&gt;基本分发版包含许多模块，如指标、分析器、观察者、仓位大小计算器、过滤器、数据源、经纪商、佣金/资产信息方案等&amp;hellip;&lt;/p&gt;
&lt;p&gt;可以轻松地从头开始构建新的模块，或者基于现有模块进行构建。&lt;/p&gt;
&lt;p&gt;基本模块（Cerebro）已经实现了一些自动“插拔”，使得用户可以更轻松地使用框架，而不需要关注所有细节。&lt;/p&gt;
&lt;p&gt;因此，该框架已预配置以提供默认行为，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用单一的主数据源&lt;/li&gt;
&lt;li&gt;1天的时间框架/压缩组合&lt;/li&gt;
&lt;li&gt;10,000 单位的货币&lt;/li&gt;
&lt;li&gt;股票交易&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些设置可能并不适合每个人，但重要的是：它可以根据每个交易者/程序员的需求进行定制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交易股票：整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上所述，默认配置是用于股票交易，当交易股票时，买入/卖出的是完整的股票份额（即：1、2、50、1000 等，而不是像 1.5 或 1001.7589 这样的数量）。&lt;/p&gt;
&lt;p&gt;这意味着，当用户在默认配置下执行以下代码时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;next&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;# 将投资组合的 50% 用于购买主资产&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;order_target_percent(target&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0.5&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发生的情况是：&lt;/p&gt;
&lt;p&gt;系统会计算出需要多少股票份额，以便该资产在投资组合中的价值尽可能接近 50%。&lt;/p&gt;
&lt;p&gt;但是，由于默认配置是与股票交易配合使用，结果股票的数量将是一个整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请注意，默认配置是使用单一的主数据源，因此在调用 &lt;code&gt;order_target_percent&lt;/code&gt; 时，实际的数据并未指定。当使用多个数据源时，必须指定获取/卖出哪个数据（除非是主数据源）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交易加密货币：分数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然，在交易加密货币时，即使是小数点后有 20 位数字，也可以购买“半个比特币”。&lt;/p&gt;
&lt;p&gt;好消息是，你可以更改与资产相关的信息。这是通过 &lt;code&gt;CommissionInfo&lt;/code&gt; 家族的可插拔模块实现的。&lt;/p&gt;
&lt;p&gt;一些文档：&lt;a href="https://www.backtrader.com/docu/commission-schemes/commission-schemes/"&gt;Docs - Commission Schemes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不得不承认，名字不太合适，因为这些方案不仅仅包含佣金信息，还包含其他内容。&lt;/p&gt;
&lt;p&gt;在分数方案中，关注的是该方案的 &lt;code&gt;getsize(price, cash)&lt;/code&gt; 方法，它有如下文档字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;返回在给定价格下执行现金操作所需的仓位大小&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这些方案与经纪商密切相关，并且可以通过经纪商 API 将这些方案添加到系统中。&lt;/p&gt;
&lt;p&gt;经纪商文档在这里：&lt;a href="https://www.backtrader.com/docu/broker/"&gt;Docs - Broker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关方法是：&lt;code&gt;addcommissioninfo(comminfo, name=None)&lt;/code&gt;。当 &lt;code&gt;name&lt;/code&gt; 为 None 时，方案会应用到所有资产；如果指定了名称，则方案仅应用于具有特定名称的资产。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现分数方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这可以通过扩展现有的基础方案（即 &lt;code&gt;CommissionInfo&lt;/code&gt;）轻松实现。&lt;/p&gt;</description></item><item><title>打败随机入场</title><link>https://www.poloxue.com/backtrader/docs/19-articles/04-beating-the-random-entry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/04-beating-the-random-entry/</guid><description>&lt;p&gt;&lt;strong&gt;打败随机入场&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近，reddit/r/algotrading 上有一些讨论，关于是否能够成功复制已发布的算法交易策略。首先，我复现了130多篇关于“预测股市”的研究论文，从头开始编写了代码，并记录了结果。以下是我学到的一些东西：&lt;/p&gt;
&lt;p&gt;因为之前的帖子已被删除，下面是快速总结：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略无效&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果作者声称某个策略因阿尔法衰退而失效，那么这些测试都是在过去的数据上运行的，但它们仍然无效。&lt;/li&gt;
&lt;li&gt;结论：这些策略要么是过拟合，要么是 p-hacking，或者只是微小的阿尔法，但这些阿尔法由于交易佣金的存在，已经被摧毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Artem Kaznatcheev 在《算法交易中的复现危机寓言》中写了对复现问题的描述，接着写了关于&lt;strong&gt;过拟合&lt;/strong&gt;的文章。&lt;/p&gt;
&lt;p&gt;前两篇文章主要是理论性的（即使第一篇提到实现了130个策略），而《过拟合》则提供了实际的代码。&lt;/p&gt;
&lt;p&gt;在这么多讨论中，如何尝试复现一些已发布的策略而不是论文，采用像《过拟合》那样的实际方法呢？例如，出版在一本知名书籍中的策略。&lt;/p&gt;
&lt;p&gt;目标：“打败随机入场”。这是这本书第三部分第八章中的一节：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《Amazon - 交易你的财务自由之路》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Van Tharp Institute - &lt;strong&gt;《交易你的财务自由之路》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该书提供了一个结构化的算法交易方法，特别强调了：仓位大小和仓位管理（即：何时退出交易）。这些要远比大多数人认为最重要的入场设置更为关键。&lt;/p&gt;
&lt;p&gt;在第八章中，Van K. Tharp 与 Tom Basso 交谈时提到：“从你说的来看，听起来只要你有好的退出方式，并且聪明地调整仓位大小，似乎你可以通过随机入场来持续赚钱。” Tom Basso 回应说，他可能确实可以做到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于硬币投掷的入场&lt;/li&gt;
&lt;li&gt;始终在市场中——多头或空头&lt;/li&gt;
&lt;li&gt;一旦退出信号给出，立即重新进入&lt;/li&gt;
&lt;li&gt;市场波动性由10天的平均真实波幅指数（EMA ATR）决定&lt;/li&gt;
&lt;li&gt;跟踪止损，距离收盘价3倍波动性&lt;/li&gt;
&lt;li&gt;止损只能朝着交易方向移动&lt;/li&gt;
&lt;li&gt;固定仓位（1个合约）或1%风险模型（见书第12章）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试10个市场&lt;/li&gt;
&lt;li&gt;固定仓位：80%的时间获利&lt;/li&gt;
&lt;li&gt;1%风险模型：100%的时间获利&lt;/li&gt;
&lt;li&gt;可靠性：38%（获胜交易的百分比）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺失部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试的市场&lt;/li&gt;
&lt;li&gt;测试的时间段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果“始终在市场中”意味着“今天”关闭交易并在“明天”重新进入，或者意味着同时发出关闭/重新开仓的订单，这一点实际上最容易克服。&lt;/p&gt;
&lt;p&gt;对于最后两项，书中提到谈话发生在1991年，并且使用的是期货。为了公平起见，将使用1991年前的期货数据。也假设使用1天的价格条形图，考虑到提到的10天指数平滑移动平均（EMA）。&lt;/p&gt;
&lt;p&gt;最明显的问题似乎是如何正确实现算法，但在这种情况下，书籍很好地描述了简单算法及其结果。接下来，我们总结一下第12章中的“百分比风险模型”（书中称为“模型3”）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大亏损&lt;/strong&gt;：限制为账户总值的x%（即：百分比风险）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每合约风险&lt;/strong&gt;：根据给定的算法，风险为初始止损距离（波动性的3倍）乘以期货的乘数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合约数量&lt;/strong&gt;：最大亏损 / 每合约风险&lt;/p&gt;
&lt;h3 id="复现细节"&gt;复现细节&lt;a class="anchor" href="#%e5%a4%8d%e7%8e%b0%e7%bb%86%e8%8a%82"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将使用1985至1990年的CL（原油）期货数据（即：6年完整数据）。该合约的规格如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每点的最小变动：0.01（即：每点100个tick）&lt;/li&gt;
&lt;li&gt;每个tick的费用：10美元&lt;/li&gt;
&lt;li&gt;因此，乘数为1000美元/点（100 ticks/点 x 10美元/tick = 1000美元）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;佣金&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>保守型公式的再平衡</title><link>https://www.poloxue.com/backtrader/docs/19-articles/05-rebalancing-conserative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/05-rebalancing-conserative/</guid><description>&lt;h1 id="保守型公式的再平衡"&gt;保守型公式的再平衡&lt;a class="anchor" href="#%e4%bf%9d%e5%ae%88%e5%9e%8b%e5%85%ac%e5%bc%8f%e7%9a%84%e5%86%8d%e5%b9%b3%e8%a1%a1"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;本文提出了保守型公式的方法：&lt;strong&gt;Python中的保守型公式：简化的量化投资&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这只是众多可能的再平衡方法中的一种，但它相对易于理解。方法概要如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从Y个股票（比如1000个中的100个）中选出x只股票&lt;/li&gt;
&lt;li&gt;选股标准为：
&lt;ul&gt;
&lt;li&gt;低波动性&lt;/li&gt;
&lt;li&gt;高净派息收益率（Net Payout Yield，NPY）&lt;/li&gt;
&lt;li&gt;高动量&lt;/li&gt;
&lt;li&gt;每月再平衡一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了这些概念后，接下来我们将展示如何在Backtrader中实现这一策略。&lt;/p&gt;
&lt;h3 id="数据"&gt;数据&lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;即使有一个获胜的策略，如果没有可用的数据，那么一切都不会成真。因此，需要考虑数据的格式和如何加载它。&lt;/p&gt;
&lt;p&gt;假设有一组CSV文件（“逗号分隔值”），每个文件包含以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每月的OHLCV数据&lt;/li&gt;
&lt;li&gt;额外的列包含净派息收益率（NPY），以形成一个ohlcvn数据集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSV数据格式如下：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;date, open, high, low, close, volume, npy
2001-12-31, 1.0, 1.0, 1.0, 1.0, 0.5, 3.0
2002-01-31, 2.0, 2.5, 1.1, 1.2, 3.0, 5.0
...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即每行表示一个月的数据。接下来，可以通过Backtrader的CSV数据加载引擎创建一个简单的扩展类。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;NetPayOutData&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;feeds&lt;span style="color:#f92672"&gt;.&lt;/span&gt;GenericCSVData):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; lines &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#e6db74"&gt;&amp;#39;npy&amp;#39;&lt;/span&gt;,) &lt;span style="color:#75715e"&gt;# 增加一行，用于存储净派息收益率&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; params &lt;span style="color:#f92672"&gt;=&lt;/span&gt; dict(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; npy&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;, &lt;span style="color:#75715e"&gt;# npy字段位于第6列（基于0的索引）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; dtformat&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;%Y-%m-&lt;/span&gt;&lt;span style="color:#e6db74"&gt;%d&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;&lt;/span&gt;, &lt;span style="color:#75715e"&gt;# 设置日期格式为yyyy-mm-dd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; timeframe&lt;span style="color:#f92672"&gt;=&lt;/span&gt;bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;TimeFrame&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Months, &lt;span style="color:#75715e"&gt;# 设置时间框架为按月&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; openinterest&lt;span style="color:#f92672"&gt;=-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, &lt;span style="color:#75715e"&gt;# -1表示没有openinterest字段&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; )&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就完成了对数据源的扩展。注意，通过&lt;code&gt;lines=('npy',)&lt;/code&gt;，已经将净派息收益率（NPY）数据添加到了OHLCV数据流中。其他常见的字段（如open、high等）已经是&lt;code&gt;GenericCSVData&lt;/code&gt;的一部分。通过在&lt;code&gt;params&lt;/code&gt;中指定位置，我们能够告诉Backtrader净派息收益率所在的列。&lt;/p&gt;
&lt;h3 id="策略"&gt;策略&lt;a class="anchor" href="#%e7%ad%96%e7%95%a5"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;接下来，我们将逻辑封装到Backtrader的标准策略中。为了使其尽可能通用和可自定义，我们将采用与数据源相同的&lt;code&gt;params&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;首先，我们来回顾一下快速总结中的一个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个Y个股票的宇宙中选择x个股票&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;策略本身不负责将股票添加到股票宇宙中，但它负责选择股票。假设宇宙中有1000只股票，但在代码中设置了x=100，那么即使只有50只股票被加入，策略也会选择100只。为了应对这种情况，我们会做如下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置&lt;code&gt;selperc&lt;/code&gt;参数，默认值为0.10（即10%），表示从宇宙中选择的股票数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，如果宇宙中有1000只股票，则选择100只；如果只有50只股票，则选择5只。&lt;/p&gt;
&lt;p&gt;股票的排名公式如下：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;(momentum * net payout) / volatility&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即，动量更大、派息收益率更高、波动性更低的股票会有更高的评分。&lt;/p&gt;</description></item><item><title>MFI 通用版</title><link>https://www.poloxue.com/backtrader/docs/19-articles/06-mfi-generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/06-mfi-generic/</guid><description>&lt;h3 id="mfi-通用版"&gt;MFI 通用版&lt;a class="anchor" href="#mfi-%e9%80%9a%e7%94%a8%e7%89%88"&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在之前的《Canonical 与 Non-Canonical》一文中，介绍了 MFI（即 Money Flow Indicator，资金流动指标）的实现。&lt;/p&gt;
&lt;p&gt;虽然这个实现是按照传统的方式开发的，但它依然有改进的空间，并且可以做得更通用。&lt;/p&gt;
&lt;p&gt;让我们关注一下实现的前几行代码，即计算典型价格的部分。&lt;/p&gt;
&lt;h4 id="canonical-mfi---典型价格和原始资金流"&gt;Canonical MFI - 典型价格和原始资金流&lt;a class="anchor" href="#canonical-mfi---%e5%85%b8%e5%9e%8b%e4%bb%b7%e6%a0%bc%e5%92%8c%e5%8e%9f%e5%a7%8b%e8%b5%84%e9%87%91%e6%b5%81"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;MFI_Canonical&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Indicator):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; lines &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#e6db74"&gt;&amp;#39;mfi&amp;#39;&lt;/span&gt;,)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; params &lt;span style="color:#f92672"&gt;=&lt;/span&gt; dict(period&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;14&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; tprice &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;close &lt;span style="color:#f92672"&gt;+&lt;/span&gt; self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;low &lt;span style="color:#f92672"&gt;+&lt;/span&gt; self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;high) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;3.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mfraw &lt;span style="color:#f92672"&gt;=&lt;/span&gt; tprice &lt;span style="color:#f92672"&gt;*&lt;/span&gt; self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;volume
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;典型的实例化方式如下所示：&lt;/p&gt;
&lt;h4 id="mfi-典型实例化"&gt;MFI 典型实例化&lt;a class="anchor" href="#mfi-%e5%85%b8%e5%9e%8b%e5%ae%9e%e4%be%8b%e5%8c%96"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;MyMFIStrategy&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Strategy):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mfi &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;MFI_Canonical(self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的问题应该很明显： “需要为指标提供包含收盘价、最低价、最高价和成交量的输入（即&lt;em&gt;在 backtrader 生态系统中的&lt;/em&gt;lines）”。&lt;/p&gt;
&lt;p&gt;当然，也可能有人希望使用来自不同数据源的组件来创建资金流动指标（例如来自数据源或其他指标的线）。例如，想要给收盘价赋予更多权重，而不需要开发一个特定的指标。考虑到行业标准的 OHLCV 数据字段顺序，支持多个输入并给收盘价加权的实例化可以是这样的：&lt;/p&gt;
&lt;h4 id="mfi-多输入实例化"&gt;MFI 多输入实例化&lt;a class="anchor" href="#mfi-%e5%a4%9a%e8%be%93%e5%85%a5%e5%ae%9e%e4%be%8b%e5%8c%96"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;MyMFIStrategy2&lt;/span&gt;(bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;Strategy):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;__init__&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wclose &lt;span style="color:#f92672"&gt;=&lt;/span&gt; self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;close &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;5.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; mfi &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bt&lt;span style="color:#f92672"&gt;.&lt;/span&gt;MFI_Canonical(self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;high, self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;low,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wclose, self&lt;span style="color:#f92672"&gt;.&lt;/span&gt;data&lt;span style="color:#f92672"&gt;.&lt;/span&gt;volume)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者因为用户之前使用过 ta-lib 并喜欢多个输入的方式。&lt;/p&gt;
&lt;h4 id="支持多个输入"&gt;支持多个输入&lt;a class="anchor" href="#%e6%94%af%e6%8c%81%e5%a4%9a%e4%b8%aa%e8%be%93%e5%85%a5"&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;backtrader 尽量做到符合 Python 风格，并且系统中的 &lt;code&gt;self.datas&lt;/code&gt; 数组（自动提供给策略的所有数据源）可以查询其长度。我们可以利用这一点来区分调用者的需求，并正确地计算 &lt;code&gt;tprice&lt;/code&gt; 和 &lt;code&gt;mfraw&lt;/code&gt;。&lt;/p&gt;</description></item></channel></rss>