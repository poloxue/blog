<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>平台概念 on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/</link><description>Recent content in 平台概念 on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>数据源 DataFeed</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/</guid><description>数据源 - 配置与使用 # 本节介绍 backtrader 中数据源的配置与使用，同时也包含了一些数据访问的技巧。
数据配置 # 在 Backtrader 中，数据源 DataFeed 通过 Celebro 配置。
配置代码：
cerebro = bt.Cerebro() data = btfeeds.MyFeed(...) cerebro.adddata(data) cerebro.addstrategy(MyStrategy, period=30) 通过 cerebro.adddata 将 DataFeed 添加到系统中。我们无需关心系统是如何接收 DataFeed 的。
使用方法 # 策略中，我们通过 self.datas 数组即可访问数据。我们看一个简单示例，如我们实现策略。
示例如下：
class MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): sma = btind.SimpleMovingAverage(self.datas[0], period=self.params.period) 通过 self.datas[0] 即可访问数据。
示例中有两个注意点：
策略的 __init__ 方法无需接收 *args 或 **kwargs； self.datas 是一个包含 DataFeed 的数组，至少包含一个数据源，否则会出现异常； 一旦数据源被添加到系统中，我们在策略实现就可以按它们添加的顺序访问到每个数据源。
cerebro.adddata(data0) cerebro.adddata(data1) 在策略类访问：
self.datas[0] # data0 self.</description></item><item><title>策略参数</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/02-params/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/02-params/</guid><description>策略参数 # 策略基本上都需要参数，而在 backtrader 中，这些参数可作为类属性进行声明。我们可以通过元组或字典的形式声明这些策略变量。
元组：
class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) 字典：
class MyStrategy(bt.Strategy): params = dict(period=20) 无论是元组还是字典，参数声明后，都可以通过 self.params 或 self.p 访问参数的值。
class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=self.p.period) 在这个例子中，self.p.period 就是获取 period 参数的值。
参数继承 # 如果你在一个类中定义了参数，子类会自动继承这些参数。你可以在子类中重写这些参数的默认值。
class BaseStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) class MyStrategy(BaseStrategy): params = ((&amp;#39;period&amp;#39;, 30),) # 重写父类的 period 参数 如果你使用多重继承，子类会继承所有父类的参数。如果多个父类定义了相同的参数，子类会使用继承列表中最后一个类的默认值。</description></item><item><title>线 Line 类</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/03-line/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/03-line/</guid><description>线 Line 类 # 在 Backtrader 中，许多对象都会生成 Line 对象，而每个 Line 代表的是一个时间序列数据，可以是价格、指标或其他数据。策略逻辑基本都离不开操作 Line 对象。
Line 的访问 # 数据源中的 Line # 数据源中包含了多个 Line，如 close、open、high、low ，通过 self.data.lines 访问它们。
class MyStrategy(bt.Strategy): def __init__(self): self.close_line = self.data.lines.close # 访问收盘价线 指标中的 Line # 指标同样会生成 Line，如 SimpleMovingAverage 的 sma，通过 self.movav.lines.sma 访问。
class MyStrategy(bt.Strategy): def __init__(self): self.movav = btind.SimpleMovingAverage(self.data, period=20) def next(self): if self.movav.lines.sma[0] &amp;gt; self.data.lines.close[0]: print(&amp;#39;移动平均大于收盘价&amp;#39;) 访问线的快捷方式 # 前面的语法和我们平时使用的不一样，因为我们平时都是通过简写访问，如 self.data.close 实际上是 self.data.lines.close 的快捷方式。
Backtrader 提供了多种简化访问 Line 的方式：</description></item><item><title>索引和切片</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/04-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/04-index/</guid><description>索引和切片 # 索引：0 和 -1 # 在 Backtrader 中，Line 代表着一组按时间顺序排列的点。这些点在策略执行期间动态生成，可以通过索引来访问。
使用索引访问 Line # 访问当前值： 使用 0 索引访问当前的线值，如 self.data.close[0] 获取当前收盘价。
class MyStrategy(bt.Strategy): def next(self): print(self.data.close[0]) # 当前的收盘价 访问前值： 使用负数索引访问之前的值，如 self.data.close[-1] 获取上一条数据的收盘价。
class MyStrategy(bt.Strategy): def next(self): if self.data.close[0] &amp;gt; self.data.close[-1]: print(&amp;#34;今天的收盘价高于昨日的收盘价&amp;#34;) 索引的意义：
0 索引指向当前时刻的值，-1 指向上一个时刻的值，以此类推。 负数索引指向历史数据点，这对于时间序列分析和策略中的数据回溯非常有用。 简单示例：
class MyStrategy(bt.Strategy): def next(self): # 比较今天的收盘价和昨天的收盘价 if self.data.close[0] &amp;gt; self.data.close[-1]: print(&amp;#34;今天的收盘价更高&amp;#34;) else: print(&amp;#34;今天的收盘价更低&amp;#34;) 在这个示例中，self.data.close[0] 是今天的收盘价，self.data.close[-1] 是昨天的收盘价。
切片 # Backtrader 不支持对 Line 对象的切片操作，这是为了保持设计的一致性。切片适用于普通的 Python 数组，但在 Backtrader 中，Line 对象是动态增长的，因此切片的使用存在一定的限制。</description></item><item><title>运算符</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/05-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/05-operator/</guid><description>运算符 # 在 Backtrader 中，运算符不仅用于常规的数学运算，还能构建复杂的策略逻辑。Backtrader 的自定义运算符让策略的数学和逻辑运算更自然和简洁。
如何使用运算符 # backtrader 支持基于运算符创建新的对象，如在 __init__ 中通过运算符计算多个指标，得到一个新的操作对象。
class MyStrategy(bt.Strategy): def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=20) # 使用运算符创建新的逻辑对象 close_over_sma = self.data.close &amp;gt; sma sma_dist_to_high = self.data.high - sma sma_dist_small = sma_dist_to_high &amp;lt; 3.5 # 创建卖出信号 self.sell_sig = bt.And(close_over_sma, sma_dist_small) 我们在 Line 对象上使用了常规的运算符，如加减乘除、大小比较等。这简化了策略代码，增强了策略逻辑的可读性和可维护性。
注：backtrader 的指标计算是自有的体系，不是基于 numpy 和 pandas，所以要单独实现这些运算符。
一些未覆盖的运算符/函数 # 某些 Python 中的运算符没有被覆盖，backtrader 提供了专门的函数来模拟逻辑运算，如 bt.And 和 bt.Or 来实现逻辑 &amp;ldquo;与&amp;rdquo; 和 &amp;ldquo;或&amp;rdquo;。
下面把这些单独实现的运算符列出来看看吧。
逻辑运算符 # Python 中的 and 和 or 运算符无法在 Backtrader 中覆盖，backtradr 提供了 bt.</description></item></channel></rss>