<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Indicator on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/</link><description>Recent content in Indicator on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/docs/08-indicators/index.xml" rel="self" type="application/rss+xml"/><item><title>使用指标</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/01-using-indicators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/01-using-indicators/</guid><description>使用指标 # 指标可以在平台中的两个地方使用：
策略内部 其他指标内部 指标在操作中的使用 # 在策略中，指标总是在 __init__ 中实例化。在 next 中使用/检查指标值（或派生值）。有一个重要的公理需要考虑：在 __init__ 中声明的任何指标（或派生值）将在调用 next 之前预先计算。
让我们了解操作模式的差异。
__init__ vs next # 在 __init__ 中涉及到线条对象的任何操作都会生成另一个线条对象。在 next 中涉及到线条对象的任何操作都会生成常规的 Python 类型，如浮点数和布尔值。
如 __init__ 中的一个操作：
hilo_diff = self.data.high - self.data.low 变量 hilo_diff 持有一个线条对象的引用，该对象在调用 next 之前预先计算，可以使用标准数组表示法 [] 访问。
它显然包含了数据源中每个条的高低差值。
这在混合简单线条（如 self.data 数据源中的线条）和复杂线条（如指标）时也有效：
sma = bt.SimpleMovingAverage(self.data.close) close_sma_diff = self.data.close - sma 现在 close_sma_diff 再次包含一个线条对象。
使用逻辑运算符：
close_over_sma = self.data.close &amp;gt; sma 现在生成的线条对象将包含一个布尔数组。
在 next 中，一个操作（逻辑运算符）：
close_over_sma = self.</description></item><item><title>指标开发</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/02-indicators-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/02-indicators-development/</guid><description>指标开发 # 如果需要开发任何内容（除了一个或多个获胜策略），这个内容就是自定义指标。在平台内开发此类内容很容易。
开发要点：
从 Indicator 类（直接或从现有子类）派生一个类； 定义它将包含的 Line； 一个指标至少要有一条线。如果从现有的类派生，线条可能已经定义好了 可选地定义可以改变行为的参数 可选地提供/自定义一些用于合理绘制指标的元素 在 __init__ 中提供一个完全定义的操作，并绑定（分配）到指标的线条，或者提供 next 方法和（可选的）once 方法 如果一个指标可以在初始化期间通过逻辑/算术操作完全定义，且结果分配给线条：完成。如果情况不是这样，至少要提供一个 next 方法，其中指标必须在索引 0 处分配一个值给线条。可以通过提供 once 方法来优化运行一次模式（批处理操作）的计算。
重要说明：幂等性 # 指标为每个接收到的条生成一个输出。不能假设同一个条会被发送多少次。操作必须是幂等的。
其背后的理由：
同一个条（索引-wise）可以多次发送，并且值会变化（即变化的值是收盘价） 这使得可以“重放”一个日内会话，但使用由 5 分钟条组成的日内数据。 这也允许平台从实时数据源获取值。
一个简单（但功能齐全）的指标 # 可以这样：
class DummyInd(bt.Indicator): lines = (&amp;#39;dummyline&amp;#39;,) params = ((&amp;#39;value&amp;#39;, 5),) def __init__(self): self.lines.dummyline = bt.Max(0.0, self.params.value) 完成！
该指标将始终输出相同的值：要么是 0.0，要么是 self.params.value（如果它恰好大于 0.0）。
使用 next 方法的相同指标：
class DummyInd(bt.Indicator): lines = (&amp;#39;dummyline&amp;#39;,) params = ((&amp;#39;value&amp;#39;, 5),) def next(self): self.</description></item><item><title>周期混合</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/03-timeframe-mixing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/03-timeframe-mixing/</guid><description>周期混合 # 如果提供值的数据源有不同的时间框架，在 Cerebro 引擎中有不同的长度，指标将会出错。
示例计算中，data0 有天的时间框架，data1 有月的时间框架：
pivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close &amp;lt; pivotpoint.s1 在这里，当收盘价低于 s1 线（第一个支撑）时，寻求卖出信号。
注意
PivotPoint 定义上在较大的时间框架中工作。
过去，这会导致以下错误：
return self.array[self.idx + ago] IndexError: array index out of range 原因很简单：self.data.close 从第一个时刻提供值，但 PivotPoint（以及 s1 线）只有在整个月过去后才会提供值，这大约相当于 22 个 self.data0.close 的值。在这 22 个收盘价期间，s1 还没有值，尝试从底层数组获取它会失败。
线条对象支持 (ago) 操作符（Python 中的 __call__ 特殊方法）以提供其延迟版本：
close1 = self.data.close(-1) 在这个例子中，对象 close1（通过 [0] 访问时）始终包含由 close 提供的前一个值（-1）。此语法已被重用以适应时间框架。让我们重写上述的 pivotpoint 代码片段：
pivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close &amp;lt; pivotpoint.</description></item><item><title>TA-Lib</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/04-talib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/04-talib/</guid><description>TA-Lib # 即使backtrader已经提供了大量内置指标，并且开发一个指标主要是定义输入、输出并以自然方式编写公式，但有些人仍然希望使用TA-LIB。因为，指标X在TA-LIB库中存在，但在backtrader中不存在（作者很乐意接受请求），还有，TA-LIB的行为是众所周知的，人们信赖传统的事物。
为了满足每个人的需求，提供了TA-LIB集成。
需求 # TA-LIB的Python封装 任何需要的依赖项（例如numpy） 安装详情在GitHub仓库中 使用TA-LIB # 与使用backtrader内置指标一样简单。以下是一个简单移动平均线的示例。首先是backtrader的示例：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.sma = bt.indicators.SMA(self.data, period=self.p.period) ... 接下来是TA-LIB的示例：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.sma = bt.talib.SMA(self.data, timeperiod=self.p.period) ... 注意，TA-LIB指标的参数由库本身定义，而不是backtrader。在这种情况下，TA-LIB中的SMA使用名为timeperiod的参数来定义操作窗口的大小。
对于需要多个输入的指标，例如随机指标：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.stoc = bt.talib.STOCH(self.data.high, self.data.low, self.data.close, fastk_period=14, slowk_period=3, slowd_period=3) .</description></item></channel></rss>