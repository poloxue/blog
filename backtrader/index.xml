<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on Backtrader 中文</title><link>https://www.poloxue.com/backtrader/</link><description>Recent content in 首页 on Backtrader 中文</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.poloxue.com/backtrader/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzers</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/01-analyzers/</guid><description>分析器 # 无论是回测还是交易，能够分析交易系统的表现对于理解是否不仅仅获得了利润，而且是否在实现利润的过程中承担了过多的风险，或者与参考资产（或无风险资产）相比是否真的值得付出努力，都是关键。
这就是分析器对象的作用：提供对已发生情况或当前情况的分析。
分析器的性质 接口的设计参照了线条对象，例如具有 next 方法，但有一个主要的区别：分析器不包含线条。
这意味着它们在内存方面不是很消耗资源，因为即使在分析了成千上万个价格条之后，它们可能仍然只在内存中保存单个结果。
在生态系统中的位置 # 分析器对象（如同策略、观察者和数据）通过 cerebro 实例添加到系统中：
addanalyzer(ancls, *args, **kwargs) 但在 cerebro.run 操作期间，对于系统中存在的每个策略，将会发生以下情况：
ancls 在 cerebro.run 期间会用 *args 和 **kwargs 实例化 ancls 实例将会附加到策略上 这意味着：
如果回测运行包含例如 3 个策略，那么将创建 3 个 ancls 实例，并且每个实例将附加到不同的策略上。
结论：分析器分析单个策略的表现，而不是整个系统的表现。
附加位置 # 某些分析器对象可能实际上使用其他分析器来完成其工作。例如：SharpeRatio 使用 TimeReturn 的输出进行计算。
这些子分析器或从属分析器也将插入到创建它们的同一策略中。但它们对用户是完全不可见的。
属性 # 为了完成预期的工作，分析器对象提供了一些默认属性，这些属性会自动传递并在实例中设置，以便于使用：
self.strategy：对分析器对象正在运行的策略子类的引用。策略可以访问的任何内容，分析器也可以访问。 self.datas[x]：策略中存在的数据源数组。虽然可以通过策略引用访问，但快捷方式使工作更舒适。 self.data：对 self.datas[0] 的快捷方式，以增加舒适度。 self.dataX：对不同的 self.datas[x] 的快捷方式。 还有一些其他别名可用，尽管它们可能有些多余：
self.dataX_Y，其中 X 是对 self.datas[X] 的引用，Y 指的是线条，最终指向 self.datas[X].lines[Y]。 如果线条有名称，还可以使用以下命名：
self.dataX_Name，解析为 self.datas[X].Name，按名称而不是按索引返回线条。 对于第一个数据，最后两个快捷方式在没有初始 X 数字引用的情况下可用。例如：</description></item><item><title>Broker</title><link>https://www.poloxue.com/backtrader/docs/10-broker/01-broker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/01-broker/</guid><description>Broker # 类 backtrader.brokers.BackBroker() # Broker 经纪商模拟器，该模拟支持不同的订单类型，检查提交订单的现金需求与当前现金的对比，跟踪每次 Cerebro 迭代的现金和价值，并保持不同数据的当前头寸。
现金在每次迭代中调整，对于期货等工具来说，当价格变化时，会在实际经纪商中增加或减少现金。 支持的订单类型：
Market：将在下一个柱的第一个tick（即开盘价）执行 Close：用于日内交易，订单以会话最后一个柱的收盘价执行 Limit：如果在会话期间看到给定的限价则执行 Stop：如果看到给定的止损价，则执行市场订单 StopLimit：如果看到给定的止损价，则启动限价订单 因为经纪商由 Cerebro 实例化，用户通常不需要替换经纪商实例，因此参数不受用户控制。
要更改参数，有两种选择：
手动创建带所需参数的 Broker，用 cerebro.broker = instance 将该实例设置为这个经纪商； 使用 set_xxx 方法通过 cerebro.broker.set_xxx 设置参数，其中 xxx 代表设置参数名称； 注意，cerebro.broker 是一个由 Cerebro 的 getbroker 和 setbroker 方法支持的属性。
参数 # 参数名 默认值 描述 cash 10000 起始现金 commission CommInfoBase(percabs=True) 适用于所有资产的基础佣金方案 checksubmit True 在将订单接受到系统之前检查保证金/现金 eosbar False 对于日内 Bar，考虑与会话结束时间相同的柱为会话结束。通常不会这样，因为许多交易所会在会话结束后几分钟内为许多产品生成一些柱（最终拍卖） filler None 一个可调用对象，签名为 callable(order, price, ago)。参数说明：- order：显然是执行中的订单。这提供了对数据的访问（包括 ohlc 和成交量值）、执行类型、剩余大小（order.executed.remsize）等。- price：订单将在 ago 柱中执行的价格- ago：用于从 order.</description></item><item><title>Cerebro</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/01-cerebro/</guid><description>Cerebro # Cerebro 是 Backtrader 的核心类，负责整个系统的运行。
它的功能包括：
收集输入（数据源）、执行者（策略）、观察者、评论者（分析器）和记录者（编写器），确保系统的正常运行。 执行回测或实时数据供给和交易。 返回回测结果。 提供策略绘图功能。 创建 Cerebro 实例 # 创建 Cerebro 实例时，可以通过传递一些控制参数：
cerebro = bt.Cerebro(**kwargs) 这些参数会影响系统的执行，具体的参数说明可以参考文档（也可以应用于后续的 run 方法）。
添加数据源 # 最常见的方式是使用 cerebro.adddata(data) 添加数据源，data 是已实例化的数据源。例如：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.days&amp;#39;, timeframe=bt.TimeFrame.Days) cerebro.adddata(data) 数据的重采样与重放 # Cerebro 也支持对数据进行重采样或重放：
重采样：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.min&amp;#39;, timeframe=bt.TimeFrame.Minutes) cerebro.resampledata(data, timeframe=bt.TimeFrame.Days) 重放数据：
data = bt.BacktraderCSVData(dataname=&amp;#39;mypath.min&amp;#39;, timeframe=bt.TimeFrame.Minutes) cerebro.replaydata(data, timeframe=bt.TimeFrame.Days) 你可以同时使用多种类型的数据源，包括常规数据、重采样数据和重放数据。但需要确保它们的时间对齐。详见文档中的 多时间框架 和 数据重采样 部分。
添加策略 # Cerebro 接受策略类并传递相关参数，即使没有优化，也可以使用以下方式添加策略：
cerebro.addstrategy(MyStrategy, myparam1=value1, myparam2=value2) 策略优化 # 在优化时，参数需要作为可迭代对象传递。例如：
cerebro.optstrategy(MyStrategy, myparam1=range(10, 20)) 这会运行 MyStrategy 10次，myparam1 的值从 10 到 19。</description></item><item><title>Data Feeds</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/01-datafeeds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/01-datafeeds/</guid><description>数据源 # Backtrader 提供了一组数据源解析器（在撰写本文时都是基于 CSV 的）以便从不同来源加载数据。
Yahoo（在线或已保存到文件） VisualChart（参见 www.visualchart.com） Backtrader CSV（自定义格式用于测试） 通用 CSV 支持 从快速入门指南中可以清楚地看到，您可以将数据源添加到 Cerebro 实例中。这些数据源稍后将在策略中可用：
self.datas 数组（按插入顺序） 数组对象的别名： self.data 和 self.data0 指向第一个元素 self.dataX 指向数组中索引为 X 的元素 以下是插入方式的快速提醒：
import backtrader as bt import backtrader.feeds as btfeeds data = btfeeds.YahooFinanceCSVData(dataname=&amp;#39;wheremydatacsvis.csv&amp;#39;) cerebro = bt.Cerebro() cerebro.adddata(data) # 可以传递一个 &amp;#39;name&amp;#39; 参数用于绘图 数据源通用参数 # 这个数据源可以直接从 Yahoo 下载数据并将其输入系统。
Backtrader 数据源常用参数：
参数名 默认值 描述 dataname None 必须提供。其含义因数据源类型而异，例如文件路径、股票代码等。 name '' 用于绘图时的装饰性名称。如果未指定，可能会从 dataname 派生（例如：文件路径的最后一部分）。 fromdate mindate Python datetime 对象，表示应忽略此日期之前的任何数据。 todate maxdate Python datetime 对象，表示应忽略此日期之后的任何数据。 timeframe TimeFrame.</description></item><item><title>Interactive Brokers</title><link>https://www.poloxue.com/backtrader/docs/15-livetrading/01-interactive-brokers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/15-livetrading/01-interactive-brokers/</guid><description>盈透（Interactive Brokers） # 与盈透（Interactive Brokers）的集成支持以下功能：
实时数据馈送 实时交易 注意：尽管已经尽力测试了尽可能多的错误条件和情况，但代码（像任何其他软件一样）可能包含错误。在进入生产环境之前，请使用纸面交易账户或 TWS 演示帐户彻底测试任何策略。
注意：与互动经纪商的交互是通过使用 IbPy 模块进行的，该模块在使用前必须安装。目前在 Pypi 中没有该模块的包（撰写本文时），但可以使用以下命令通过 pip 安装：
pip install git+https://github.com/blampe/IbPy.git 如果您的系统中没有 git（例如在 Windows 上安装），以下命令也可以正常工作：
pip install https://github.com/blampe/IbPy/archive/master.zip 示例代码 # 源码包含一个完整的示例，位于：
samples/ibtest/ibtest.py
该示例无法涵盖所有可能的用例，但它试图提供广泛的见解，并应强调在使用回测模块或实时数据模块时没有实际差异。
需要注意的一点是：
示例在任何交易活动开始之前，都会等待 data.LIVE 数据状态通知。这可能是任何实时策略中都需要考虑的事项。
存储模型与直接模型 # 与互动经纪商的交互支持两种模型：
存储模型（推荐） 直接与数据馈送类和经纪商类交互 存储模型提供了一种明确的分离模式，用于创建经纪商和数据。以下两个代码片段应更好地作为示例。
首先是存储模型：
import backtrader as bt ibstore = bt.stores.IBStore(host=&amp;#39;127.0.0.1&amp;#39;, port=7496, clientId=35) data = ibstore.getdata(dataname=&amp;#39;EUR.USD-CASH-IDEALPRO&amp;#39;) 这里的参数：
host，port 和 clientId 传递到 IBStore 中，用于打开连接。 然后使用 getdata 创建数据馈送，并使用 backtrader 中所有数据馈送中常见的参数 dataname 请求 EUR/USD 外汇对。 直接使用模型：</description></item><item><title>Line 迭代器</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/02-operate-the-platform/01-iteration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/02-operate-the-platform/01-iteration/</guid><description>Line 迭代器 # Backtrader 引入了一个独特的概念，叫做 Line 迭代器（Line Iterator）。它的核心思想是，通过迭代数据来驱动策略和指标的运作。这一点和 Python 的普通迭代器在表面上看有些相似，但实际上它们是为金融数据处理量身定制的。
在 Backtrader 中，策略 和 指标 都是基于 Line 迭代器构建的。下面，我们会逐步拆解这个概念，让它变得简单易懂。
什么是 Line 迭代器？ # Line 迭代器是一个控制 &amp;ldquo;数据处理节奏&amp;rdquo; 的工具，它的主要职责是：
驱动数据流动：Line 迭代器像是一个“指挥者”，它会触发从属 Line 迭代器（如指标或策略）依次处理数据。 逐步更新数据：Line 迭代器按照声明的规则迭代数据，并在每一步设置对应的结果。 Line 迭代器如何工作？ # 三大关键方法 # prenext
在数据不足以完成计算时被调用。 用于初始化阶段的数据处理，比如累计数据。 nextstart
当累积到足够多的数据点，达到“最小周期”时被调用，仅触发一次。 默认会调用 next 方法。 next
在每次迭代时调用，用于正式处理当前索引上的数据。 为什么需要这些方法？ # 为了生成有效的计算结果，某些指标需要一个“缓冲期”。如 25 周期的简单移动平均线 (SMA) 需要累积 25 个数据点才能生成第一个值。在这之前，我们需要用 prenext 来处理空白期。
一旦累积到足够的数据点，进入“正式运行”阶段后，next 方法会被不断调用，每次处理新到达的数据。
示例：如何实现一个简单的 SMA # 以下是一个 SimpleMovingAverage（简单移动平均线）的实现示例：
class SimpleMovingAverage(Indicator): lines = (&amp;#39;sma&amp;#39;,) params = dict(period=25) def prenext(self): print(f&amp;#39;prenext:: 当前周期: {len(self)}&amp;#39;) def nextstart(self): print(f&amp;#39;nextstart:: 当前周期: {len(self)}&amp;#39;) self.</description></item><item><title>Plotting</title><link>https://www.poloxue.com/backtrader/docs/16-plotting/01-plotting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/16-plotting/01-plotting/</guid><description>绘图 # 尽管回测主要是基于数学计算的自动化过程，但人们常常希望能够实际可视化所发生的一切。不论是使用已经经过回测的现有算法，还是查看数据所产生的内置或自定义指标，绘图都能帮助人们更好地理解所发生的事情，剔除、修改或创建新的想法。
由于所有操作背后都是人类，绘制数据馈送、指标、操作、现金流动和投资组合价值的演变图表有助于人们更好地理解过程，从而做出更明智的决策。因此，backtrader 使用 matplotlib 提供的功能，内置了绘图设施。
如何绘图 # 任何回测运行都可以通过调用一个方法进行绘图：
cerebro.plot() 当然，这通常是最后一个命令。例如，以下简单代码使用了 backtrader 源代码中的一个示例数据：
from __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt class St(bt.Strategy): def __init__(self): self.sma = bt.indicators.SimpleMovingAverage(self.data) data = bt.feeds.BacktraderCSVData(dataname=&amp;#39;../../datas/2005-2006-day-001.txt&amp;#39;) cerebro = bt.Cerebro() cerebro.adddata(data) cerebro.addstrategy(St) cerebro.run() cerebro.plot() 这将生成以下图表：
图表包含了 3 个观察器，由于缺乏任何交易，它们在这种情况下几乎没有意义：
CashValue 观察器：跟踪回测运行期间的现金和总投资组合价值（包括现金）。 Trade 观察器：在交易结束时显示实际的利润和亏损。交易定义为开仓并将仓位归零（直接或从多头转为空头或从空头转为多头）。 BuySell 观察器：在价格图上绘制买入和卖出操作的位置。 这 3 个观察器由 cerebro 自动添加，可以通过 stdstats 参数控制（默认：True）。如果希望禁用它们，可以如下操作：
cerebro = bt.Cerebro(stdstats=False) 或在运行时：
cerebro = bt.Cerebro() ... cerebro.run(stdstats=False) 绘图元素 # 尽管前面提到了观察器，它们并不是唯一被绘制的元素。以下 3 种元素会被绘制：</description></item><item><title>sizers</title><link>https://www.poloxue.com/backtrader/docs/14-sizers/01-sizers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/14-sizers/01-sizers/</guid><description>Sizers # 策略提供交易方法，即：buy、sell 和 close。让我们看看 buy 的签名：
def buy(self, data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, **kwargs): 注意，如果调用者没有指定 size，则 size 的默认值为 None。这就是 Sizers 发挥重要作用的地方：
size=None 请求策略向其 Sizer 询问实际的头寸大小 这显然意味着策略有一个 Sizer：是的，确实如此！如果用户没有添加 Sizer，后台机制会为策略添加一个默认的 Sizer。添加到策略中的默认 Sizer 是 SizerFix。定义的初始行：
class SizerFix(SizerBase): params = ((&amp;#39;stake&amp;#39;, 1),) 很容易猜到这个 Sizer 只是使用 1 个单位（无论是股票、合约等）买卖。
使用 Sizers # 从 Cerebro # Sizers 可以通过 Cerebro 以两种不同的方法添加：
addsizer(sizercls, *args, **kwargs)：添加一个 Sizer，将应用于添加到 cerebro 的任何策略。这就是所谓的默认 Sizer。例如： cerebro = bt.Cerebro() cerebro.addsizer(bt.sizers.SizerFix, stake=20) # 默认策略的 Sizer addsizer_byidx(idx, sizercls, *args, **kwargs)：只将 Sizer 添加到 idx 引用的策略中。 这个 idx 可以作为 addstrategy 的返回值获得。例如：</description></item><item><title>Strategy</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/01-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/01-strategy/</guid><description>Strategy # 在 backtrader 中，Cerebro 实例是整个系统的核心，而 Strategy 是用户的核心。
Strategy 的生命周期方法 # 注意, 策略可以在创建时通过抛出 StrategySkipError 异常来中断，该异常来自 backtrader.errors 模块。这将避免在回测期间处理该策略。请参阅“异常”部分。
构建：__init__ # 这是在实例化期间调用的：指标将在此处创建以及其他需要的属性。
示例代码：
def __init__(self): self.sma = btind.SimpleMovingAverage(period=15) 启动：start # Cerebro 实例通知策略是时候开始运行了。存在一个默认的空方法。
初期：prenext # 在创建期间声明的指标将对策略的成熟期施加限制：这称为最小周期。上面的 __init__ 创建了一个周期为 15 的简单移动平均线 (SMA)。
只要系统看到的 bar 少于 15 个，就会调用 prenext（默认实现为空操作）。
成熟：next # 一旦系统看到 15 个 bar 并且 SMA 有足够的缓冲区开始生成值，策略就足够成熟可以真正执行。
存在一个 nextstart 方法，会在从 prenext 切换到 next 时调用一次。nextstart 的默认实现是简单地调用 next。
繁衍：无 # 策略实际上不会繁衍，但从某种意义上来说，它们会，因为系统会在优化时实例化它们多次（使用不同的参数）。
结束：stop # 系统通知策略是时候重置并整理一切了。存在一个默认的空方法。
通常情况下和常规使用模式下，这看起来像这样：</description></item><item><title>佣金</title><link>https://www.poloxue.com/backtrader/docs/11-commission-schemes/01-commission-schemes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/11-commission-schemes/01-commission-schemes/</guid><description>佣金 # 中立性 # 在开始之前，让我们记住 backtrader 尝试保持数据代表内容的中立性。不同的佣金方案可以应用于相同的数据集。让我们看看如何做到这一点。
经纪商快捷方式 # 这使得最终用户远离 CommissionInfo 对象，因为可以通过一次函数调用创建/设置佣金方案。在常规的 cerebro 创建/设置过程中，只需在经纪商成员属性上添加一个调用 setcommission 的调用即可。
以下调用设置了使用 Interactive Brokers 操作 Eurostoxx50 期货的常规佣金方案：
cerebro.broker.setcommission(commission=2.0, margin=2000.0, mult=10.0) 由于大多数用户通常只测试单一工具，这已经足够。
如果你为你的数据馈送命名，因为在图表上同时考虑了多个工具，这个调用可以稍微扩展如下：
cerebro.broker.setcommission(commission=2.0, margin=2000.0, mult=10.0, name=&amp;#39;Eurostoxxx50&amp;#39;) 在这种情况下，此即时佣金方案将仅应用于名称匹配 Eurostoxx50 的工具。
setcommission 参数的含义 # commission（默认值：0.0）
每次操作的货币单位，绝对值或百分比。在上述示例中，每份合约的买入和卖出费用分别为 2.0 欧元。 重要的是何时使用绝对值或百分比值。
如果 margin 为 False（例如，它是 False、0 或 None），则将视为佣金表示为价格乘以操作数量的百分比。
如果 margin 是其他值，则视为操作发生在类似期货的工具上，佣金是每张合约的固定价格。
margin（默认值：None）
操作期货类工具时需要的保证金。如上所述：
如果没有设置 margin，则佣金将被视为百分比，并应用于买卖操作的价格 * 数量。
如果设置了 margin，则佣金将被视为固定值，并乘以买卖操作的数量。
mult（默认值：1.0）
对于期货类工具，这决定了应用于损益计算的乘数。这使得期货同时具有吸引力和风险。
name（默认值：None）
将佣金方案应用于名称匹配的工具。可以在创建数据馈送时设置此值。如果未设置，则方案将适用于系统中的任何数据。
两个示例：股票 vs 期货 # 期货的示例：</description></item><item><title>使用指标</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/01-using-indicators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/01-using-indicators/</guid><description>使用指标 # 指标可以在平台中的两个地方使用：
策略内部 其他指标内部 指标在操作中的使用 # 在策略中，指标总是在 __init__ 中实例化。在 next 中使用/检查指标值（或派生值）。有一个重要的公理需要考虑：在 __init__ 中声明的任何指标（或派生值）将在调用 next 之前预先计算。
让我们了解操作模式的差异。
__init__ vs next # 在 __init__ 中涉及到线条对象的任何操作都会生成另一个线条对象。在 next 中涉及到线条对象的任何操作都会生成常规的 Python 类型，如浮点数和布尔值。
如 __init__ 中的一个操作：
hilo_diff = self.data.high - self.data.low 变量 hilo_diff 持有一个线条对象的引用，该对象在调用 next 之前预先计算，可以使用标准数组表示法 [] 访问。
它显然包含了数据源中每个条的高低差值。
这在混合简单线条（如 self.data 数据源中的线条）和复杂线条（如指标）时也有效：
sma = bt.SimpleMovingAverage(self.data.close) close_sma_diff = self.data.close - sma 现在 close_sma_diff 再次包含一个线条对象。
使用逻辑运算符：
close_over_sma = self.data.close &amp;gt; sma 现在生成的线条对象将包含一个布尔数组。
在 next 中，一个操作（逻辑运算符）：
close_over_sma = self.</description></item><item><title>数据源 DataFeed</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/01-datafeed/</guid><description>数据源 - 配置与使用 # 本节介绍 backtrader 中数据源的配置与使用，同时也包含了一些数据访问的技巧。
数据配置 # 在 Backtrader 中，数据源 DataFeed 通过 Celebro 配置。
配置代码：
cerebro = bt.Cerebro() data = btfeeds.MyFeed(...) cerebro.adddata(data) cerebro.addstrategy(MyStrategy, period=30) 通过 cerebro.adddata 将 DataFeed 添加到系统中。我们无需关心系统是如何接收 DataFeed 的。
使用方法 # 策略中，我们通过 self.datas 数组即可访问数据。我们看一个简单示例，如我们实现策略。
示例如下：
class MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): sma = btind.SimpleMovingAverage(self.datas[0], period=self.params.period) 通过 self.datas[0] 即可访问数据。
示例中有两个注意点：
策略的 __init__ 方法无需接收 *args 或 **kwargs； self.datas 是一个包含 DataFeed 的数组，至少包含一个数据源，否则会出现异常； 一旦数据源被添加到系统中，我们在策略实现就可以按它们添加的顺序访问到每个数据源。
cerebro.adddata(data0) cerebro.adddata(data1) 在策略类访问：
self.datas[0] # data0 self.</description></item><item><title>环境设置</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/01-setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/01-setup/</guid><description>环境设置 # 在开始构建复杂的交易策略前，我们要先配置策略运行环境。Backtrader 的环境离不开一个核心类 Cerebro（大脑），后续会详细介绍它。
初始化配置 # 我们先看完整的环境初始化设置的代码：
import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.Cerebro() print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 在这个示例中，我们首先导入了 backtrader 模块并命名为 bt。
import backtrader as bt 并基于 bt.Cerebro 实例化了 Cerebro 引擎。
cerebro = bt.Cerebro() 我们通过 cerebro.broker.getvalue() 获取并打印了初始的持仓组合价值，即我们的初始资金。
print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 接着运行 cerebro.run() 以处理数据模拟交易，并再次打印最终的持仓组合价值
cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 输出如下：
Starting Portfolio Value: 10000.</description></item><item><title>管理</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/01-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/01-management/</guid><description>管理 # 在发布 1.5.0 版本之前，backtrader 对时间管理采用的是直接方式，即直接使用数据源计算出的任何日期时间。用户输入的参数，如 fromdate（或 sessionstart），也可以传递给任何数据源。
这种方法在对冻结数据源进行回测时效果很好。可以假设输入的日期时间在进入系统之前已经经过处理。
但在 1.5.0 版本之后，backtrader 开始支持实时数据源，这就需要考虑日期时间管理。如果以下情况总是成立，那么就不需要进行这种管理：
纽约的交易者交易 ES-Mini。这两个的时区都是 US/Eastern（或其别名）。 柏林的交易者交易 DAX 期货。在这种情况下，两个的时区都是 CET（或 Europe/Berlin）。 上面的直接输入-输出日期时间方法可以工作，因为柏林的交易者可以始终这样做：
class Strategy(bt.Strategy): def next(self): # DAX 期货在 CET 时间早上 08:00 开盘 if self.data.datetime.time() &amp;lt; datetime.time(8, 30): # 市场运行 30 分钟之前不操作 return # 当同一个柏林交易者决定交易 ES-Mini 时，直接方法的问题就会显现出来。因为 DST（夏令时）的变化发生在一年中的不同时间，这会导致时间差异在一年中的某些周内不同步。
以下代码并不总是有效：
class Strategy(bt.Strategy): def next(self): # SPX 在 US/Eastern 全年早上 09:30 开盘 # 大部分时间是 15:30 CET # 但有时是 16:30 CET 或 14:30 CET，取决于美国和欧洲的 DST 切换时间 # 因此以下代码是不可靠的 if self.</description></item><item><title>统计</title><link>https://www.poloxue.com/backtrader/docs/13-observers/01-statistics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/13-observers/01-statistics/</guid><description>统计 # 在 backtrader 中运行的策略主要处理数据源和指标。数据源添加到 Cerebro 实例中，并最终成为策略的输入（解析并作为实例的属性提供），而指标由策略本身声明和管理。
到目前为止，所有 backtrader 示例图表都绘制了三件看似理所当然的东西，因为它们在任何地方都没有声明：
现金和价值（经纪人中的资金情况） 交易（即操作） 买/卖订单 它们是观察器，存在于子模块 backtrader.observers 中。因为 Cerebro 支持一个参数来自动将它们（或不将它们）添加到策略中：stdstats（默认：True）。
如果遵循默认设置，Cerebro 将执行以下等效用户代码：
import backtrader as bt cerebro = bt.Cerebro() # 默认参数：stdstats=True cerebro.addobserver(bt.observers.Broker) cerebro.addobserver(bt.observers.Trades) cerebro.addobserver(bt.observers.BuySell) 让我们看看通常带有这三个默认观察器的图表（即使没有发出订单，因此没有交易发生，现金和投资组合价值没有变化）：
from __future__ import (absolute_import, division, print_function, unicode_literals) import backtrader as bt import backtrader.feeds as btfeeds if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.Cerebro(stdstats=False) cerebro.addstrategy(bt.Strategy) data = bt.feeds.BacktraderCSVData(dataname=&amp;#39;../../datas/2006-day-001.txt&amp;#39;) cerebro.adddata(data) cerebro.run() cerebro.plot() 现在让我们在创建 Cerebro 实例时将 stdstats 的值更改为 False（也可以在调用 run 时完成）：</description></item><item><title>订单</title><link>https://www.poloxue.com/backtrader/docs/09-orders/01-general/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/01-general/</guid><description>订单 # Cerebro 是 backtrader 中的关键控制系统，而 Strategy（一个子类）是终端用户的关键控制点。后者需要一个连接系统其他部分的方法，这就是订单发挥关键作用的地方。
订单将策略中的逻辑决策转化为适合 Broker 执行操作的消息。这是通过以下方式完成的：
创建 # 通过 Strategy 的方法：buy、sell 和 close（Strategy），这些方法返回一个订单实例作为参考。
取消 # 通过 Strategy 的方法：cancel（Strategy），该方法需要一个订单实例来操作。
订单也作为一种通信方式反馈给用户，通知 Broker 中的执行情况。
通知 # 通过 Strategy 的方法：notify_order（Strategy），该方法报告一个订单实例。
订单创建 # 调用 buy、sell 和 close 时，以下参数适用于创建：
参数名 默认值 描述 data None 为哪个数据创建订单。如果为 None，则使用系统中的第一个数据，self.datas[0] 或 self.data0（又名 self.data）。 size None 使用的单位数量。如果为 None，则使用通过 getsizer 获取的 sizer 实例来确定大小。 price None 使用的价格（实时 Broker 可能会对格式有实际限制，如果不符合最小刻度要求）。对于 Market 和 Close 订单，None 是有效的（市场决定价格）。对于 Limit、Stop 和 StopLimit 订单，该值决定触发点（在 Limit 的情况下，触发点显然是订单匹配的价格）。 plimit None 仅适用于 StopLimit 订单。这是在 Stop 触发后设置隐含 Limit 订单的价格。 exectype None 可能的值：- Order.</description></item><item><title>超大内存</title><link>https://www.poloxue.com/backtrader/docs/19-articles/01-out-of-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/01-out-of-memory/</guid><description>关于回测性能和超大内存执行 # 最近在 Reddit 上有两个相关的帖子，启发了本文的写作：
一个声称 backtrader 无法处理 160 万根 K线的帖子：reddit/r/algotrading - A performant backtesting system? 另一个要求一个能回测 8000 支股票的工具：reddit/r/algotrading - Backtesting libs that supports 1000+ stocks? 其中有一位作者询问如何使用一个可以回测“超大内存”的框架，“因为显然不能将所有这些数据加载到内存中。”
我们将会在本文中讨论这些概念，结合 backtrader 来解决。
2M K线 # 为了验证这一点，首先需要生成这么多的 K线。考虑到第一个发帖者提到 77 支股票和 160 万根 K线，这意味着每支股票大约有 20,779 根 K线，因此我们将进行以下操作来使数据更加简洁：
为 100 支股票生成 K线数据 每支股票生成 20,000 根 K线 即：生成 100 个文件，总共 200 万根 K线。 生成数据的脚本如下：
import numpy as np import pandas as pd COLUMNS = [&amp;#39;open&amp;#39;, &amp;#39;high&amp;#39;, &amp;#39;low&amp;#39;, &amp;#39;close&amp;#39;, &amp;#39;volume&amp;#39;, &amp;#39;openinterest&amp;#39;] CANDLES = 20000 STOCKS = 100 dateindex = pd.</description></item><item><title>过滤器 Filters</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/09-datafeed-filters/01-datafeed-filters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/09-datafeed-filters/01-datafeed-filters/</guid><description>过滤器 Filters # 该功能是较晚加入到 Backtrader 中的，且为了适应已有的内部结构进行了一些调整。因此，它在灵活性和功能完备性上可能不如预期，但在许多情况下仍然能达到目的。
尽管实现时尝试支持即插即用的过滤器链，但由于原有内部结构的限制，始终无法保证每次都能实现。因此，有些过滤器可以链式使用，而有些则不能。
目的 # 将数据源提供的值转换为不同的数据流。
该实现最初是为了简化两个明显的过滤器的实现，这两个过滤器可以通过cerebro API直接使用，分别是 重采样 和 重放。
重采样（cerebro.resampledata）：这个过滤器会改变传入数据流的时间框架和压缩比例，如：(秒，1) -&amp;gt; (天，1)。这意味着原始数据流是以1秒为周期的数据条。重采样过滤器会拦截数据并进行缓冲，直到能够提供1天的条形数据。这发生在看到第二天的1秒条形数据时。
重放（cerebro.replaydata），在上面相同的时间框架下，过滤器会利用1秒的分辨率条形数据重建1天的条形数据。也就是说，1天的条形数据会被反复传递，直到显示出所有1秒的条形数据，并且数据内容会更新。这种方法模拟了实际交易日的发展。
注意，在日期没有变化的情况下，数据的长度（len(data)）以及策略的长度保持不变。
工作原理 # 给定一个已有的数据源，你可以使用addfilter方法来添加过滤器：
data = MyDataFeed(dataname=myname) data.addfilter(filter, *args, **kwargs) cerebro.adddata(data) 即使它与重采样或重放过滤器兼容，你也可以做如下操作：
data = MyDataFeed(dataname=myname) data.addfilter(filter, *args, **kwargs) cerebro.replaydata(data) 过滤器接口 # 过滤器必须符合以下接口要求。首先，要是一个可调用的对象，接受如下签名：
callable(data, *args, **kwargs) 或一个可以实例化并被调用的类，在实例化时其__init__方法必须支持以下签名：
def __init__(self, data, *args, **kwargs) __call__方法的签名为：
def __call__(self, data, *args, **kwargs) 每当新的数据流值到来时，实例都会被调用。*args和**kwargs与__init__方法传递的参数相同。
返回值 描述 True 表示数据流的内部数据获取循环需要重新尝试从数据源中获取数据，因为数据流的长度被修改了。 False 即使数据可能已经被编辑（例如：修改了close价格），数据流的长度保持不变。 如果是基于类的过滤器，还可以实现两个额外的方法：
last，其签名为：
def last(self, data, *args, **kwargs) 当数据流结束时，这个方法会被调用，允许过滤器推送它可能缓冲的数据。例如在重采样的情况下，一个条形数据会被缓冲，直到看到下一个时间段的数据。如果数据流结束，就没有新的数据可以推动缓冲的数据，last方法提供了推送缓冲数据的机会。</description></item><item><title>Pyfolio</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/02-pyfolio/</guid><description>PyFolio # 注意，截至（至少）2017-07-25，pyfolio 的 API 已更改，create_full_tear_sheet 不再有 gross_lev 作为命名参数。因此，集成示例无法正常工作。
引用 pyfolio 主页面 http://quantopian.github.io/pyfolio/ 的内容： pyfolio 是一个由 Quantopian Inc. 开发的用于金融投资组合的表现和风险分析的 Python 库。它与开源回测库 Zipline 配合良好，现在它也可以很好地与 backtrader 配合。所需的内容包括：
显然需要 pyfolio 以及它的依赖项（如 pandas、seaborn 等） 注意，在与 0.5.1 版本集成期间，需要更新依赖项的最新版本，例如将之前安装的 seaborn 从 0.7.0-dev 更新到 0.7.1，显然是由于缺少方法 swarmplot。
用法 # 将 PyFolio 分析器添加到 cerebro 中：
cerebro.addanalyzer(bt.analyzers.PyFolio) 运行并检索第一个策略：
strats = cerebro.run() strat0 = strats[0] 使用你给分析器命名的名称或默认名称（pyfolio）来检索分析器。例如：
pyfolio = strats.analyzers.getbyname(&amp;#39;pyfolio&amp;#39;) 使用分析器方法 get_pf_items 检索 pyfolio 后续需要的四个组件：
returns, positions, transactions, gross_lev = pyfolio.get_pf_items() 注意</description></item><item><title>Qanda</title><link>https://www.poloxue.com/backtrader/docs/15-livetrading/02-qanda-v1-0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/15-livetrading/02-qanda-v1-0/</guid><description>Oanda # Oanda的集成支持以下功能：
实时数据馈送 实时交易 要求 # oandapy：可以通过以下命令安装：pip install git+https://github.com/oanda/oandapy.git pytz（可选，不推荐）：由于外汇市场的全球性和24x7的特点，选择使用UTC时间。如果愿意，仍然可以使用所需的输出时区。 示例代码 # 源代码中包含完整示例：
samples/oandatest/oandatest.py
Oanda - 存储 # 存储是实时数据馈送和交易支持的核心，提供了Oanda API和数据馈送及经纪代理之间的适配层。
可以通过以下方法获取经纪商实例：
OandaStore.getbroker(*args, **kwargs) 可以通过以下方法获取数据馈送实例：
OandaStore.getdata(*args, **kwargs) 在这种情况下，许多**kwargs是数据馈送的常见参数，如dataname、fromdate、todate、sessionstart、sessionend、timeframe、compression。
数据可能提供其他参数。请参阅下面的参考。
必要参数 # 为了成功连接到Oanda，以下参数是必要的：
token（默认：无）：API访问令牌 account（默认：无）：账户ID 这些由Oanda提供。
无论是连接到模拟服务器还是真实服务器，请使用：
practice（默认：False）：使用测试环境 账户需要定期检查以获取现金和价值。周期性可以通过以下方式控制：
account_tmout（默认：10.0）：刷新账户价值/现金刷新周期 Oanda数据馈送 # 实例化数据时：
按照Oanda指南传递符号。例如，EUR/USD根据Oanda的指南需要指定为EUR_USD。实例化如下：
data = oandastore.getdata(dataname=&amp;#39;EUR_USD&amp;#39;, ...) 时间管理 # 除非传递了tz参数（一个pytz兼容对象）给数据馈送，否则所有时间输出都以UTC格式表示，如上所述。
回填 # backtrader不会向Oanda发出特殊请求。对于小时间框架，Oanda在模拟服务器上返回的回填数据长度为500个柱。
OandaBroker - 实时交易 # 使用经纪商 # 要使用OandaBroker，需要替换cerebro创建的标准经纪商模拟实例。
使用存储模型（推荐）：
import backtrader as bt cerebro = bt.Cerebro() oandastore = bt.</description></item><item><title>信号策略</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/02-strategy-with-signals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/02-strategy-with-signals/</guid><description>信号策略 # 使用 backtrader 进行操作不一定非得编写一个策略类。虽然这是首选方式，但由于对象层次结构的原因，使用信号也是可行的。
快速总结： # 不需要编写策略类、实例化指标、编写买卖逻辑等。 添加信号（无论如何也是指标），其余部分在后台完成。 快速示例： # import backtrader as bt data = bt.feeds.OneOfTheFeeds(dataname=&amp;#39;mydataname&amp;#39;) cerebro.adddata(data) cerebro.add_signal(bt.SIGNAL_LONGSHORT, MySignal) cerebro.run() 这就完成了。当然，信号本身还没有定义。
让我们定义一个非常简单的信号：
如果收盘价高于简单移动平均线 (SMA)，则发出多头信号。 如果收盘价低于 SMA，则发出空头信号。 定义如下：
class MySignal(bt.Indicator): lines = (&amp;#39;signal&amp;#39;,) params = ((&amp;#39;period&amp;#39;, 30),) def __init__(self): self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period) 现在真的完成了。
当运行 run 时，Cerebro 会处理实例化一个特殊的策略实例，它知道如何处理这些信号。
常见问题 # 买卖操作的数量是如何确定的？
Cerebro 实例自动为策略添加一个固定大小 (FixedSize) 的定量器。最终用户可以通过 cerebro.addsizer 更改定量器以改变策略。
订单是如何执行的？
执行类型为市价单，订单的有效期为“直到取消” (Good Until Canceled)。
信号细节 # 从技术和理论角度来看，可以描述为：
一个可调用对象，当被调用时返回另一个对象（只调用一次）。 在大多数情况下，这是一个类的实例化，但不一定非得是。 支持 __getitem__ 接口。唯一请求的键/索引将是 0。 从实际角度来看，信号是：</description></item><item><title>创建/执行</title><link>https://www.poloxue.com/backtrader/docs/09-orders/02-creation-execution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/02-creation-execution/</guid><description>订单管理和执行 # 对于订单管理，Backtrader 提供了3种基本操作：
buy sell cancel 注意：：一个更新操作显然是合乎逻辑的，但常识告诉我们，这种方法主要用于使用判断性交易方法的手动操作员。
对于订单执行逻辑，提供以下执行类型：
市价订单（Market） 收盘价订单（Close） 限价订单（Limit） 止损订单（Stop） 止损限价订单（StopLimit） 订单管理 # 一些示例：
# 购买主数据，使用sizer的默认股份，市价订单 order = self.buy() # 市价订单 - 有效期将被 &amp;#34;忽略&amp;#34; order = self.buy(valid=datetime.datetime.now() + datetime.timedelta(days=3)) # 市价订单 - 价格将被忽略 order = self.buy(price=self.data.close[0] * 1.02) # 市价订单 - 手动股份 order = self.buy(size=25) # 限价订单 - 想要设置价格并可以设置有效期 order = self.buy(exectype=Order.Limit, price=self.data.close[0] * 1.02, valid=datetime.datetime.now() + datetime.timedelta(days=3)) # 止损限价订单 - 想要设置价格，价格限制 order = self.buy(exectype=Order.StopLimit, price=self.data.close[0] * 1.</description></item><item><title>参数说明</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/02-reference/</guid><description>参数说明 # 如下是 Cerebro 类的详细说明。
实例化参数 # 参数 默认值 说明 preload True 是否预加载传递给策略的不同数据源。 runonce True 以矢量化模式计算指标，从而提高整个系统的性能。
注： 策略和观察者将始终基于事件运行。 live False 如果没有数据报告为实时（通过数据的islive方法，但用户仍希望以实时模式运行，可将此参数设为true。 maxcpus None 同时使用多少核心进行优化，默认 None，即启用所有可用的 CPU 核。 stdstats True） 如果为True，将添加默认观察者：经纪人（现金和价值）、交易和买卖。 oldbuysell False 如 stdstats 为 True 且自动添加观察者，此开关控制买卖观察者的主要行为。 oldtrades False 如果stdstats为True 且自动添加观察者，此开关控制交易观察者的主要行为。 exactbars False - False：默认值，将存储在 Line 中的值都保存到内存。-True或1：所有Line对象的内存使用减少至计算最小周期。如果简单移动平均线的周期为30，则底层数据将始终有一个30条的运行缓冲区，以允许计算简单移动平均线。此设置将停用preload和runonce。使用此设置还将停用绘图。 -1：策略级别的数据源和指标/操作将保留所有数据在内存中。如 RSI 通过指标UpDay计算，不会将它的所有数据保留内存。 这允许保持绘图和预加载活动。runonce将被停用。-2：作为策略属性的数据源和指标将保留所有点在内存中。例如：RSI内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。- 这允许保持绘图和预加载活动。runonce将被停用。 objcache False 实验选项，用于实现 Line 对象的缓存并减少它们的数量。示例来自UltimateOscillator：bp = self.data.close - TrueLow(self.data) # -&amp;gt; 创建另一个 TrueLow(self.data)tr = TrueRange(self.</description></item><item><title>参考</title><link>https://www.poloxue.com/backtrader/docs/14-sizers/02-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/14-sizers/02-reference/</guid><description> 参考 # FixedSize # class backtrader.sizers.FixedSize() 此 Sizer 仅为任何操作返回固定大小。通过指定 tranches 参数，可以控制系统希望用于逐步进入交易的批次数量。
参数：
stake（默认：1） tranches（默认：1） FixedReverser # class backtrader.sizers.FixedReverser() 此 Sizer 返回反转已开头寸所需的固定大小或开仓所需的固定大小。
开仓：返回参数 stake 反转头寸：返回 2 * stake 参数：
stake（默认：1） PercentSizer # class backtrader.sizers.PercentSizer() 此 Sizer 返回可用现金的百分比。
参数：
percents（默认：20） AllInSizer # class backtrader.sizers.AllInSizer() 此 Sizer 返回经纪人所有可用现金。
参数：
percents（默认：100） PercentSizerInt # class backtrader.sizers.PercentSizerInt() 此 Sizer 以整数形式返回可用现金的百分比，并将大小截断为整数。
参数：
percents（默认：20） AllInSizerInt # class backtrader.sizers.AllInSizerInt() 此 Sizer 返回经纪人所有可用现金，并将大小截断为整数。
参数：
percents（默认：100）</description></item><item><title>参考文档</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/09-datafeed-filters/02-datafeed-filters-referrence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/09-datafeed-filters/02-datafeed-filters-referrence/</guid><description>Filters 参考文档 # SessionFilter # class backtrader.filters.SessionFilter(data)
此类可作为过滤器应用于数据源，将过滤掉落在常规交易时间之外的日内数据（即盘前/盘后数据）。
这是一个“非简单”过滤器，必须管理数据栈（在初始化和调用期间传递）。 它不需要“last”方法，因为没有需要传递的内容。 SessionFilterSimple # class backtrader.filters.SessionFilterSimple(data)
此类可作为过滤器应用于数据源，将过滤掉落在常规交易时间之外的日内数据（即盘前/盘后数据）。
这是一个“简单”过滤器，不需要管理数据栈（在初始化和调用期间传递）。 它不需要“last”方法，因为没有需要传递的内容。 Bar 管理将由 SimpleFilterWrapper 类处理，该类在 DataBase.addfilter_simple 调用期间添加。 SessionFiller # class backtrader.filters.SessionFiller(data)
为声明的会话开始/结束时间内的数据源填充条。
参数：
fill_price (默认: None): 如果传递了 None，将使用前一个条的收盘价。为了得到一个不显示在图表中的条，可以使用 float(&amp;lsquo;NaN&amp;rsquo;)。 fill_vol (默认: float(&amp;lsquo;NaN&amp;rsquo;)): 用于填充缺失交易量的值。 fill_oi (默认: float(&amp;lsquo;NaN&amp;rsquo;)): 用于填充缺失未平仓合约的值。 skip_first_fill (默认: True): 在看到第一个有效条时，不从会话开始填充到该条。 CalendarDays # class backtrader.filters.CalendarDays(data)
填充缺失日历日到交易日。
参数：
fill_price (默认: None): 0: 用给定值填充。 None: 使用上一个已知收盘价。 -1: 使用上一个条的中点（高低平均值）。 fill_vol (默认: float(&amp;lsquo;NaN&amp;rsquo;)): 用于填充缺失交易量的值。 fill_oi (默认: float(&amp;lsquo;NaN&amp;rsquo;)): 用于填充缺失未平仓合约的值。 BarReplayer_Open # class backtrader.</description></item><item><title>启动运行</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/02-operate-the-platform/02-startup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/02-operate-the-platform/02-startup/</guid><description>启动和运行 # Backtrader 的启动和运行过程主要依赖于三个核心组件：
数据源：提供市场数据，用于回测或实时交易。 策略：定义交易逻辑（基于类继承实现）。 Cerebro：核心管理器，负责整合数据源、策略，并启动回测或实时交易。 数据源 # 数据源是回测和策略运行的基础，它为策略提供价格数据（如开盘价、高价、低价、收盘价）及其他市场信息。
支持的数据源 # 本地数据文件：
支持多种 CSV 格式（如 Yahoo Finance 数据）。 支持从 Pandas DataFrame 加载数据。 在线数据提取：
提供内置的 Yahoo Finance 在线数据提取功能。 实时数据源：
支持 Interactive Brokers (IB)、Visual Chart 和 Oanda 等实时数据源。 平台支持通过 时间框架（如日线、5分钟线）和 压缩级别（如1天、5分钟）自定义数据，以适配不同交易策略。
数据源设置示例 # 加载 Yahoo Finance 格式的 CSV 数据 # 以下是一个基本的 CSV 数据加载示例：
import backtrader as bt import datetime datapath = &amp;#39;path/to/your/yahoo/data.csv&amp;#39; data = bt.feeds.YahooFinanceCSVData( dataname=datapath, reversed=True # 如果数据是从最新日期到最早日期排列，需要设置为 True ) 如果数据跨越时间范围较长，可限制按时间限制加载的数据：</description></item><item><title>基准测试</title><link>https://www.poloxue.com/backtrader/docs/13-observers/02-benchmarking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/13-observers/02-benchmarking/</guid><description>基准测试 # Ticket #89 是关于添加基准测试以对比一个资产的表现。这个功能非常实用，因为有些策略即使盈利也可能低于单纯追踪资产的收益。
backtrader 包含两种不同类型的对象可以帮助进行追踪：
观察器 分析器 在分析器领域，已经有一个 TimeReturn 对象，用于跟踪整个投资组合价值的回报演变（包括现金）。
这显然也可以是一个观察器，所以在添加一些基准测试时，也对如何将观察器和分析器组合在一起进行了工作，这两者旨在跟踪相同的内容。
注意
观察器和分析器之间的主要区别在于观察器的线条特性，观察器记录每个值，这使得它们适合绘图和实时查询。当然，这会消耗内存。
另一方面，分析器通过 get_analysis 返回一组结果，并且实现可能直到运行结束时才会提供任何结果。
分析器 - 基准测试 # 标准的 TimeReturn 分析器已扩展为支持跟踪数据源。涉及的两个主要参数：
timeframe（默认：无） 如果为 None，将报告整个回测期间的总回报。 data（默认：无） 要跟踪的参考资产，而不是投资组合价值。 注意
此数据必须已通过 adddata、resampledata 或 replaydata 添加到 cerebro 实例中。
更多详细信息和参数请参阅：分析器参考。
因此，可以像这样按年度跟踪投资组合的回报：
import backtrader as bt cerebro = bt.Cerebro() cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years) # 添加数据、策略等... results = cerebro.run() strat0 = results[0] # 如果没有指定名称，则名称为类名的小写形式 tret_analyzer = strat0.analyzers.getbyname(&amp;#39;timereturn&amp;#39;) print(tret_analyzer.get_analysis()) 如果我们想跟踪一个数据的回报：
import backtrader as bt cerebro = bt.</description></item><item><title>定时器</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/02-timer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/02-timer/</guid><description>定时器 # 在版本 1.9.44.116 中，backtrader 添加了定时器功能。这使得在特定时间点调用 notify_timer（在 Cerebro 和 Strategy 中可用）成为可能，用户可以进行精细控制。
选项 # 基于绝对时间输入或相对于会话开始/结束时间的定时器。 时间规范的时区指定，可以直接通过 pytz 兼容对象或通过数据源会话结束时间进行指定。 相对于指定时间的起始偏移。 重复间隔。 工作日过滤器（带有结转选项）。 月份天数过滤器（带有结转选项）。 自定义回调过滤器。 使用模式 # 在 Cerebro 和 Strategy 子类中，定时器回调将在以下方法中接收：
def notify_timer(self, timer, when, *args, **kwargs): &amp;#39;&amp;#39;&amp;#39;接收定时器通知，其中 `timer` 是通过 `add_timer` 返回的定时器，`when` 是调用时间。 `args` 和 `kwargs` 是传递给 `add_timer` 的额外参数。 实际的 `when` 时间可能稍后，但系统可能无法在之前调用定时器。 此值是定时器值，而不是系统时间。 &amp;#39;&amp;#39;&amp;#39; 添加定时器 - 通过 Strategy # 使用以下方法完成：
def add_timer(self, when, offset=datetime.timedelta(), repeat=datetime.timedelta(), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, *args, **kwargs): &amp;#39;&amp;#39;&amp;#39; 它返回创建的 Timer 实例。下面是参数的解释。</description></item><item><title>扩展</title><link>https://www.poloxue.com/backtrader/docs/11-commission-schemes/02-commission-schemes-extending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/11-commission-schemes/02-commission-schemes-extending/</guid><description>扩展佣金 # 佣金及相关功能由一个单一的类 CommissionInfo 管理，通常通过调用 broker.setcommission 实例化。
这个概念限于带有保证金和每合同固定佣金的期货和基于价格/数量百分比佣金的股票。这不是最灵活的方案，但它已经发挥了它的作用。
GitHub 上的一个增强请求（#29）导致了一些重构，以便：
保持 CommissionInfo 和 broker.setcommission 与原始行为兼容 对代码进行一些清理 使佣金方案灵活，以支持增强请求和进一步的可能性 在进入示例之前的实际工作：
class CommInfoBase(with_metaclass(MetaParams)): COMM_PERC, COMM_FIXED = range(2) params = ( (&amp;#39;commission&amp;#39;, 0.0), (&amp;#39;mult&amp;#39;, 1.0), (&amp;#39;margin&amp;#39;, None), (&amp;#39;commtype&amp;#39;, None), (&amp;#39;stocklike&amp;#39;, False), (&amp;#39;percabs&amp;#39;, False), ) 引入了一个 CommissionInfo 的基类，该类添加了新的参数：
commtype（默认值：None）
这是兼容性的关键。如果值为 None，CommissionInfo 对象和 broker.setcommission 的行为将与以前相同。具体如下：
如果设置了 margin，则佣金方案是期货，每合同有固定佣金 如果未设置 margin，则佣金方案是股票，采用百分比方法 如果值是 COMM_PERC 或 COMM_FIXED（或派生类中的任何其他值），则显然决定了佣金是固定的还是基于百分比的 stocklike（默认值：False）
如上所述，旧 CommissionInfo 对象中的实际行为由 margin 参数决定。
如果 commtype 设置为其他值，则此值指示资产是类似期货的资产（将使用保证金并进行基于条形图的现金调整）还是类似股票的资产。
percabs（默认值：False）
如果为 False，则百分比必须以相对术语传递（xx%）</description></item><item><title>扩展数据源</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/02-datafeed-extending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/02-datafeed-extending/</guid><description>扩展数据源 # 用户是否可以轻松扩展现有机制，以添加额外的信息，将其与现有的价格信息（如开盘价、高价等）一起传递？
据我了解，答案是：可以。
一个数据源，正在解析为 CSV 格式 使用 GenericCSVData 加载信息 这种通用 CSV 支持是为了响应 Issue #6 开发的 一个额外的字段，显然包含 P/E 信息，需要与解析的 CSV 数据一起传递 让我们基于 CSV 数据源开发和 GenericCSVData 示例帖子构建。
步骤： # 假设 P/E 信息已设置在被解析的 CSV 数据中 使用 GenericCSVData 作为基类 使用 pe 扩展现有的行（开盘价/最高价/最低价/收盘价/成交量/持仓兴趣） 添加一个参数，让调用者确定 P/E 信息的列位置 结果如下：
from backtrader.feeds import GenericCSVData class GenericCSV_PE(GenericCSVData): # 添加 &amp;#39;pe&amp;#39; 行到从基类继承的行中 lines = (&amp;#39;pe&amp;#39;,) # GenericCSVData 中的 openinterest 索引为 7 ... 添加 1 # 将参数添加到从基类继承的参数中 params = ((&amp;#39;pe&amp;#39;, 8),) 这样工作就完成了&amp;hellip;</description></item><item><title>指标开发</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/02-indicators-development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/02-indicators-development/</guid><description>指标开发 # 如果需要开发任何内容（除了一个或多个获胜策略），这个内容就是自定义指标。在平台内开发此类内容很容易。
开发要点：
从 Indicator 类（直接或从现有子类）派生一个类； 定义它将包含的 Line； 一个指标至少要有一条线。如果从现有的类派生，线条可能已经定义好了 可选地定义可以改变行为的参数 可选地提供/自定义一些用于合理绘制指标的元素 在 __init__ 中提供一个完全定义的操作，并绑定（分配）到指标的线条，或者提供 next 方法和（可选的）once 方法 如果一个指标可以在初始化期间通过逻辑/算术操作完全定义，且结果分配给线条：完成。如果情况不是这样，至少要提供一个 next 方法，其中指标必须在索引 0 处分配一个值给线条。可以通过提供 once 方法来优化运行一次模式（批处理操作）的计算。
重要说明：幂等性 # 指标为每个接收到的条生成一个输出。不能假设同一个条会被发送多少次。操作必须是幂等的。
其背后的理由：
同一个条（索引-wise）可以多次发送，并且值会变化（即变化的值是收盘价） 这使得可以“重放”一个日内会话，但使用由 5 分钟条组成的日内数据。 这也允许平台从实时数据源获取值。
一个简单（但功能齐全）的指标 # 可以这样：
class DummyInd(bt.Indicator): lines = (&amp;#39;dummyline&amp;#39;,) params = ((&amp;#39;value&amp;#39;, 5),) def __init__(self): self.lines.dummyline = bt.Max(0.0, self.params.value) 完成！
该指标将始终输出相同的值：要么是 0.0，要么是 self.params.value（如果它恰好大于 0.0）。
使用 next 方法的相同指标：
class DummyInd(bt.Indicator): lines = (&amp;#39;dummyline&amp;#39;,) params = ((&amp;#39;value&amp;#39;, 5),) def next(self): self.</description></item><item><title>滑点</title><link>https://www.poloxue.com/backtrader/docs/10-broker/02-slippage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/02-slippage/</guid><description>滑点 # 回测无法保证真实市场条件。无论市场模拟有多好，在真实市场条件下滑点可能发生。这意味着，请求的价格可能无法匹配。
集成的回测经纪商支持滑点，以下参数可以传递给经纪商：
参数名 默认值 描述 slip_perc 0.0 应用于买卖订单的价格上下滑动的绝对百分比（且为正值），注意：0.01 是 1%，0.001 是 0.1%； slip_fixed 0.0 应用于买卖订单的价格上下滑动的单位百分比（且为正值），注意：如果 slip_perc 非零，则优先于此。 slip_open False 是否为专门使用下一个柱的开盘价执行的订单滑动价格。例如，市场订单将在下一个可用tick执行，即柱的开盘价。这也适用于其他一些执行，因为逻辑尝试检测开盘价是否会匹配请求的价格/执行类型在移动到新柱时。 slip_match True - 如果为 True，经纪商将通过在高/低价位封顶滑点来提供匹配，以防它们超出。- 如果为 False，经纪商将不会使用当前价格匹配订单，并将在下一次迭代中尝试执行 slip_limit True - 限价订单，给定确切的匹配价格请求，即使 slip_match 为 False，也会被匹配。- 此选项控制该行为。- 如果为 True，那么限价订单将通过在限价/高低价位封顶价格进行匹配。- 如果为 False 且滑点超出上限，则不会有匹配 slip_out False 即使价格超出高-低范围，也提供滑点。 工作原理 # 为了决定何时应用滑点，考虑了订单执行类型：
Close - 不应用滑点
这种订单匹配收盘价，而这个价格是当天的最后一个。滑点无法发生，因为订单只能在会话的最后一个tick发生，而这是唯一的价格，没有容忍度。 Market - 应用滑点
请检查 slip_open 例外情况。因为市场订单将匹配下一个柱的开盘价。 Limit - 按以下逻辑应用滑点
如果匹配价格是开盘价，则根据参数 slip_open 应用滑点。如果应用，价格不会比请求的限价更差。 如果匹配价格不是限价，则应用滑点在高/低点封顶。在这种情况下，slip_limit 应用以决定在超过封顶时是否会发生匹配。 如果匹配价格是限价，则不应用滑点。 Stop - 一旦订单触发，应用与市场订单相同的逻辑</description></item><item><title>策略参数</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/02-params/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/02-params/</guid><description>策略参数 # 策略基本上都需要参数，而在 backtrader 中，这些参数可作为类属性进行声明。我们可以通过元组或字典的形式声明这些策略变量。
元组：
class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) 字典：
class MyStrategy(bt.Strategy): params = dict(period=20) 无论是元组还是字典，参数声明后，都可以通过 self.params 或 self.p 访问参数的值。
class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=self.p.period) 在这个例子中，self.p.period 就是获取 period 参数的值。
参数继承 # 如果你在一个类中定义了参数，子类会自动继承这些参数。你可以在子类中重写这些参数的默认值。
class BaseStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) class MyStrategy(BaseStrategy): params = ((&amp;#39;period&amp;#39;, 30),) # 重写父类的 period 参数 如果你使用多重继承，子类会继承所有父类的参数。如果多个父类定义了相同的参数，子类会使用继承列表中最后一个类的默认值。</description></item><item><title>绘制日期范围</title><link>https://www.poloxue.com/backtrader/docs/16-plotting/02-ploting-date-ranges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/16-plotting/02-ploting-date-ranges/</guid><description>日期范围 # 在 1.9.31.x 版本中，backtrader 增加了部分绘图的功能。
可以使用策略实例中保存的完整时间戳数组的索引来指定绘图范围
也可以使用实际的 datetime.date 或 datetime.datetime 实例来限制绘图范围。
仍然通过标准的 cerebro.plot 进行。例如：
cerebro.plot(start=datetime.date(2005, 7, 1), end=datetime.date(2006, 1, 31)) 这对人类来说是最直接的方法。具有扩展能力的人类实际上可以尝试使用时间戳的索引，如下所示：
cerebro.plot(start=75, end=185) 下面是一个非常标准的示例，其中包含一个简单移动平均线（在数据上绘图）、一个随机指标（独立绘图）以及随机指标线的交叉。在命令行参数中传递给 cerebro.plot 的参数。
使用日期方法的执行：
./partial-plot.py --plot &amp;#39;start=datetime.date(2005, 7, 1),end=datetime.date(2006, 1, 31)&amp;#39; Python 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有意义的内容。输出图表如下所示：
让我们将其与完整的绘图进行比较，以查看数据是否确实从两端跳过：
./partial-plot.py --plot Python 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有意义的内容。输出图表如下所示：
示例用法 # $ ./partial-plot.py --help usage: partial-plot.py [-h] [--data0 DATA0] [--fromdate FROMDATE] [--todate TODATE] [--cerebro kwargs] [--broker kwargs] [--sizer kwargs] [--strat kwargs] [--plot [kwargs]] Sample for partial plotting optional arguments: -h, --help show this help message and exit --data0 DATA0 Data to read in (default: .</description></item><item><title>账户资金</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/02-cash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/02-cash/</guid><description>设置初始账户资金 # 上节中，账户资金使是默认值 10,000 货币单位。当然，这个默认值是可以更改的，通过 cerebro.broker 的 setcash 方法即可。
cerebro.broker.setcash(100000.0) 完整示例 # import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.Cerebro() cerebro.broker.setcash(100000.0) print(&amp;#39;Starting Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) cerebro.run() print(&amp;#39;Final Portfolio Value: %.2f&amp;#39; % cerebro.broker.getvalue()) 输出：
Starting Portfolio Value: 100000.00 Final Portfolio Value: 100000.00 让我们继续进入下一节，配置数据源（DataFeed）。</description></item><item><title>跨平台回测的陷进</title><link>https://www.poloxue.com/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/02-cross-backtesting-pitfalls/</guid><description>跨平台回测的陷阱 # 在 Backtrader 社区中，经常有用户希望将 TradingView 等流行的回测平台上的回测结果进行复制。TradingView 使用的脚本语言是 Pinescript，而用户往往并不了解该语言的具体实现，也未接触过回测引擎的内部机制。因此，即使用户有意复制回测结果，也必须明白跨平台编程有其局限性。
指标：并不总是忠实于原始定义 # 当在 Backtrader 中实现新指标时，开发者会特别强调尊重指标的原始定义。例如，RSI 指标就是一个典型的例子。
Welles Wilder 设计 RSI 时使用了修改过的移动平均（即平滑移动平均，参见 Wikipedia - Modified Moving Average）。然而，许多平台提供的 RSI 指标，实际上使用的是经典的指数移动平均（EMA），而非书中的定义。
尽管两者的差别并不算巨大，但这并不是 Wilder 原始定义的 RSI。它可能仍然有用，甚至可能更好，但它并不等同于 Wilder 所定义的 RSI。而且，大多数文档（如果有的话）并未提到这一点。
在 Backtrader 中，RSI 的默认配置使用 MMA，以保持忠实于原始定义。不过，开发者可以通过子类化或者在运行时实例化时，选择使用 EMA 或者简单移动平均（SMA）来替代。
例子：唐奇安通道 # Wikipedia 中的定义是这样的：Wikipedia - Donchian Channel。但是，它只是一些文字，未提到如何使用通道突破作为交易信号。
另外，以下两个定义明确说明，计算通道时数据不包括当前的柱线，因为如果包括了，突破就无法被反映出来：
StockCharts - School - Price Channels IncredibleCharts - Donchian Channels 这些来源明确指出，计算通道时不包含当前的价格柱线，这样突破才会被正确显示。以下是来自 StockCharts 的示例图表：
StockCharts - Donchian Channels - Breakouts
然后，我们看看 TradingView。首先是链接： TradingView - Wiki - Donchian Channels</description></item><item><title>Pyfolio 集成</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/03-pyfolio-integration/</guid><description>Pyfolio 集成 # 在 Ticket #108 中提出了一个投资组合工具，即 pyfolio 的集成。
一开始看教程觉得很难，因为 zipline 和 pyfolio 之间的紧密集成，但 pyfolio 提供的一些其他用途的示例测试数据实际上非常有用，可以解码幕后运行的内容，从而实现集成。
在 backtrader 中大多数部分已经就位：
分析器基础设施 子分析器 TimeReturn 分析器 只需要一个主 PyFolio 分析器和三个简单的子分析器。再加上依赖于 pyfolio 所需的依赖项之一，即 pandas 的方法。
最具挑战的部分是…“正确获取所有依赖项”。
更新 pandas 更新 numpy 更新 scikit-lean 更新 seaborn 在类似 Unix 的环境中，有一个 C 编译器，一切都是时间问题。在 Windows 上，即使安装了特定的 Microsoft 编译器（在这种情况下是 Python 2.7 的链），事情也失败了。但一个知名网站拥有最新的 Windows 软件包集合，提供了帮助。如果你需要它，可以访问：
http://www.lfd.uci.edu/~gohlke/pythonlibs/
如果没有测试集成，它就不会完成，这就是为什么通常的示例总是存在的原因。
没有 PyFolio # 示例使用 random.randint 来决定何时买卖，因此这只是检查事情是否正常运行：
$ ./pyfoliotest.py --printout --no-pyfolio --plot 输出：
Len,Datetime,Open,High,Low,Close,Volume,OpenInterest 0001,2005-01-03T23:59:59,38.36,38.90,37.65,38.18,25482800.00,0.00 BUY 1000 @%23.</description></item><item><title>Visual Chart</title><link>https://www.poloxue.com/backtrader/docs/15-livetrading/03-visual-chart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/15-livetrading/03-visual-chart/</guid><description>Visual Chart # Visual Chart 的集成支持以下功能：
实时数据馈送 实时交易 Visual Chart 是一个完整的交易解决方案：
集成图表、数据馈送和经纪功能于单一平台 有关更多信息，请访问： www.visualchart.com
要求 # VisualChart 6（运行在 Windows 上） comtypes fork： https://github.com/mementum/comtypes 可以通过以下命令安装：
pip install https://github.com/mementum/comtypes/archive/master.zip Visual Chart 的 API 基于 COM。目前 comtypes 主分支不支持解包 VT_ARRAYS of VT_RECORD。这是 Visual Chart 所使用的。Pull Request #104 已提交，但尚未集成。一旦集成，可以使用主分支。
pytz（可选但强烈推荐）：确保每个数据都在市场时间返回。这对于大多数市场来说都是正确的，但有些市场确实是例外（全球指数就是一个很好的例子）。 示例代码 # 源代码中包含完整示例：samples/vctest/vctest.py。
VCStore - 存储 # 存储是实时数据馈送/交易支持的核心，提供了 COM API 和数据馈送及经纪代理之间的适配层。
可以通过以下方法获取经纪商实例：
VCStore.getbroker(*args, **kwargs) 可以通过以下方法获取数据馈送实例：
VCStore.getdata(*args, **kwargs) 在这种情况下，许多 **kwargs 是数据馈送的常见参数，如 dataname、fromdate、todate、sessionstart、sessionend、timeframe、compression。
VCStore 将尝试：
使用 Windows 注册表自动定位 VisualChart 在系统中的位置。 如果找到，将扫描安装目录中的 COM DLLs 以创建 COM typelibs 并实例化适当的对象。 如果未找到，将尝试使用已知和硬编码的 CLSIDs 进行相同操作。 注意：即使通过扫描文件系统找到 DLLs，Visual Chart 本身也必须在运行。backtrader 不会启动 Visual Chart。</description></item><item><title>交易日历</title><link>https://www.poloxue.com/backtrader/docs/17-datetime/03-trading-calendars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/17-datetime/03-trading-calendars/</guid><description>交易日历 # 版本 1.9.42.116 增加了对交易日历的支持。这在以下场景中的重采样时非常有用：
从每日到每周的重采样现在可以将每周的K线与本周的最后一根K线一起交付。 这是因为交易日历可以识别下一个交易日，并且可以提前识别出本周的最后一个交易日。 当交易会话的结束时间不是常规时间（可以通过数据源来指定）时，从子日内到每日的重采样。 交易日历接口 # 有一个基类 TradingCalendarBase 用作任何交易日历的基类。它定义了两个必须被重写的方法：
class TradingCalendarBase(with_metaclass(MetaParams, object)): def _nextday(self, day): &amp;#39;&amp;#39;&amp;#39; 返回在 `day`（datetime/date 实例）之后的下一个交易日（datetime/date 实例）以及 isocalendar 组件。 返回值是一个包含两个组件的元组：(nextday, (y, w, d))，其中 (y, w, d)。 &amp;#39;&amp;#39;&amp;#39; raise NotImplementedError def schedule(self, day): &amp;#39;&amp;#39;&amp;#39; 返回给定日期（datetime/date 实例）的开盘和收盘时间（`datetime.time`）。 &amp;#39;&amp;#39;&amp;#39; raise NotImplementedError 实现 # PandasMarketCalendar # 这个实现基于一个不错的包，这是从 Quantopian 的初始功能衍生出来的。包位于 pandas_market_calendars，可以很容易地安装：
pip install pandas_market_calendars 实现的接口如下：
class PandasMarketCalendar(TradingCalendarBase): &amp;#39;&amp;#39;&amp;#39; `pandas_market_calendars` 的交易日历包装器。必须安装 `pandas_market_calendar` 包。 参数： - `calendar` (默认 `None`) 参数 `calendar` 接受以下内容： - 字符串：支持的日历名称，例如 `NYSE`。包装器会尝试获取一个日历实例。 - 日历实例：由 `get_calendar(&amp;#39;NYSE&amp;#39;)` 返回。 - `cachesize` (默认 `365`) 缓存查找提前天数。 参见： - https://github.</description></item><item><title>加密货币中的分位仓位</title><link>https://www.poloxue.com/backtrader/docs/19-articles/03-fractional-sizes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/03-fractional-sizes/</guid><description>在 backtrader 中交易加密货币的分数仓位
首先，让我们用两句话总结一下 backtrader 的工作方式：
它像一个构建工具包，包含一个基本构建模块（Cerebro），可以将许多不同的模块插入其中。
基本分发版包含许多模块，如指标、分析器、观察者、仓位大小计算器、过滤器、数据源、经纪商、佣金/资产信息方案等&amp;hellip;
可以轻松地从头开始构建新的模块，或者基于现有模块进行构建。
基本模块（Cerebro）已经实现了一些自动“插拔”，使得用户可以更轻松地使用框架，而不需要关注所有细节。
因此，该框架已预配置以提供默认行为，例如：
使用单一的主数据源 1天的时间框架/压缩组合 10,000 单位的货币 股票交易 这些设置可能并不适合每个人，但重要的是：它可以根据每个交易者/程序员的需求进行定制。
交易股票：整数
如上所述，默认配置是用于股票交易，当交易股票时，买入/卖出的是完整的股票份额（即：1、2、50、1000 等，而不是像 1.5 或 1001.7589 这样的数量）。
这意味着，当用户在默认配置下执行以下代码时：
def next(self): # 将投资组合的 50% 用于购买主资产 self.order_target_percent(target=0.5) 发生的情况是：
系统会计算出需要多少股票份额，以便该资产在投资组合中的价值尽可能接近 50%。
但是，由于默认配置是与股票交易配合使用，结果股票的数量将是一个整数。
注意
请注意，默认配置是使用单一的主数据源，因此在调用 order_target_percent 时，实际的数据并未指定。当使用多个数据源时，必须指定获取/卖出哪个数据（除非是主数据源）。
交易加密货币：分数
显然，在交易加密货币时，即使是小数点后有 20 位数字，也可以购买“半个比特币”。
好消息是，你可以更改与资产相关的信息。这是通过 CommissionInfo 家族的可插拔模块实现的。
一些文档： Docs - Commission Schemes
注意
不得不承认，名字不太合适，因为这些方案不仅仅包含佣金信息，还包含其他内容。
在分数方案中，关注的是该方案的 getsize(price, cash) 方法，它有如下文档字符串：
返回在给定价格下执行现金操作所需的仓位大小 这些方案与经纪商密切相关，并且可以通过经纪商 API 将这些方案添加到系统中。
经纪商文档在这里： Docs - Broker
相关方法是：addcommissioninfo(comminfo, name=None)。当 name 为 None 时，方案会应用到所有资产；如果指定了名称，则方案仅应用于具有特定名称的资产。</description></item><item><title>参考</title><link>https://www.poloxue.com/backtrader/docs/13-observers/03-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/13-observers/03-reference/</guid><description>参考 # Benchmark # class backtrader.observers.Benchmark() 该观察器存储策略的回报和作为参考资产的回报，这个参考资产是传递给系统的一个数据。
参数：
timeframe（默认：无）：如果为 None，则报告整个回测期间的总回报。 compression（默认：无）：仅用于子日时间框架，例如通过指定 “TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。 data（默认：无）：跟踪的参考资产以便进行比较。 注意：此数据必须已通过 adddata、resampledata 或 replaydata 添加到 cerebro 实例中。
_doprenext（默认：False）：基准测试将在策略开始运行时进行（即策略的最小周期已达到时）。将其设置为 True 将从数据源的起点记录基准值。 firstopen（默认：False）：保持为 False 确保价值和基准之间的首次比较点从 0% 开始，因为基准不会使用其开盘价。参见 TimeReturn 分析器参考以获得参数的完整解释。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。设置为 True 或 False 以获得特定行为。 记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。
Broker # class backtrader.observers.Broker(*args, **kwargs) 该观察器跟踪经纪人中的当前现金金额和投资组合价值（包括现金）。
参数：无
Broker - Cash # class backtrader.observers.Cash(*args, **kwargs) 该观察器跟踪经纪人中的当前现金金额。
参数：无
Broker - Value # class backtrader.observers.Value(*args, **kwargs) 该观察器跟踪经纪人中的当前投资组合价值，包括现金。</description></item><item><title>同轴绘图</title><link>https://www.poloxue.com/backtrader/docs/16-plotting/03-plotting-same-axis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/16-plotting/03-plotting-same-axis/</guid><description>在同轴绘图 # 在之前的文章“future-spot”中，我们在同一空间上绘制了原始数据和略微（随机）修改后的数据，但它们并没有在同一轴上绘制。
恢复该文章的第一张图片：
我们可以看到：
图表的左右两侧有不同的刻度。 当观察摆动的红线（随机化数据）时最明显，它在原始数据周围上下摆动大约 50 个点。 在图表上，视觉印象是这种随机化数据大部分时间都在原始数据上方。这只是由于不同刻度导致的视觉印象。 虽然 1.9.32.116 版本已经初步支持完全在同一轴上绘图，但图例标签会重复（仅标签，不是数据），这会让人感到困惑。
1.9.33.116 版本修复了这个问题，允许完全在同一轴上绘图。使用模式类似于选择使用哪个数据进行绘图。在之前的文章中：
import backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFavouriteDataFeed(dataname=&amp;#39;futurename&amp;#39;) cerebro.adddata(data0) data1 = bt.feeds.MyFavouriteDataFeed(dataname=&amp;#39;spotname&amp;#39;) data1.compensate(data0) # 告诉系统 data1 的操作影响 data0 data1.plotinfo.plotmaster = data0 data1.plotinfo.sameaxis = True cerebro.adddata(data1) ... cerebro.run() data1 获取一些 plotinfo 值来：
与 plotmaster（即 data0）在同一空间绘图。 获取使用 sameaxis 的指示。 原因是平台无法提前知道每个数据的刻度是否兼容。因此，它们会在独立的刻度上绘图。
在之前的示例中，增加了一个选项在 sameaxis 上绘图。示例执行：
$ ./future-spot.py --sameaxis 结果图表：
需要注意的是：
右侧只有一个刻度。 现在，随机化数据似乎明显在原始数据周围摆动，这是预期的视觉行为。 示例用法 # $ ./future-spot.py --help usage: future-spot.</description></item><item><title>周期混合</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/03-timeframe-mixing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/03-timeframe-mixing/</guid><description>周期混合 # 如果提供值的数据源有不同的时间框架，在 Cerebro 引擎中有不同的长度，指标将会出错。
示例计算中，data0 有天的时间框架，data1 有月的时间框架：
pivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close &amp;lt; pivotpoint.s1 在这里，当收盘价低于 s1 线（第一个支撑）时，寻求卖出信号。
注意
PivotPoint 定义上在较大的时间框架中工作。
过去，这会导致以下错误：
return self.array[self.idx + ago] IndexError: array index out of range 原因很简单：self.data.close 从第一个时刻提供值，但 PivotPoint（以及 s1 线）只有在整个月过去后才会提供值，这大约相当于 22 个 self.data0.close 的值。在这 22 个收盘价期间，s1 还没有值，尝试从底层数组获取它会失败。
线条对象支持 (ago) 操作符（Python 中的 __call__ 特殊方法）以提供其延迟版本：
close1 = self.data.close(-1) 在这个例子中，对象 close1（通过 [0] 访问时）始终包含由 close 提供的前一个值（-1）。此语法已被重用以适应时间框架。让我们重写上述的 pivotpoint 代码片段：
pivotpoint = btind.PivotPoint(self.data1) sellsignal = self.data0.close &amp;lt; pivotpoint.</description></item><item><title>开发 CSV 数据源</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/03-datafeed-development-csv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/03-datafeed-development-csv/</guid><description>CSV 数据源开发 # Backtrader 已经提供了一些通用 CSV 数据源和特定的 CSV 数据源。
GenericCSVData VisualChartCSVData YahooFinanceData（用于在线下载） YahooFinanceCSVData（用于已下载的数据） BacktraderCSVData（内部使用&amp;hellip;用于测试目的，但也可以使用） 即使如此，最终用户可能仍希望开发对特定 CSV 数据源的支持。
通常的格言是：“说起来容易做起来难”。实际上，结构旨在使其变得简单。
步骤 # 从 backtrader.CSVDataBase 继承 根据需要定义任何参数 在 start 方法中进行任何初始化 在 stop 方法中进行任何清理 定义一个 _loadline 方法，其中实际工作发生。此方法接收一个参数：linetokens。 顾名思义，这包含根据分隔符参数（从基类继承）拆分当前行后的标记。
如果在完成其工作后有新数据……填充相应的行并返回 True。
如果没有可用的数据，因此解析已结束：返回 False。
如果后台代码发现没有更多行需要解析，则可能不需要返回 False。
已考虑的事项：
打开文件（或接收类似文件的对象） 跳过标头行（如果指示存在） 读取行 标记行 预加载支持（将整个数据源一次性加载到内存中） 通常一个示例胜过千言万语。让我们使用 BacktraderCSVData 中定义的内部 CSV 解析代码的简化版本。这个版本不需要初始化或清理（例如，这可能是打开一个套接字并稍后关闭它）。
注意：
backtrader 数据源包含通常的行业标准源，这些源是要填充的。即：
datetime open high low close volume openinterest 如果您的策略/算法或简单数据浏览只需要，例如收盘价，您可以不触碰其他字段（每次迭代会自动用 float('NaN') 值填充它们，然后用户代码有机会进行任何操作）。
在此示例中，仅支持每日格式：
import itertools import backtrader as bt class MyCSVData(bt.</description></item><item><title>开盘作弊</title><link>https://www.poloxue.com/backtrader/docs/10-broker/03-cheat-on-open/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/03-cheat-on-open/</guid><description>Cheat On Open（开盘作弊） # 版本 1.9.44.116 添加了 Cheat-On-Open 支持。这似乎是对那些在计算完一个柱的收盘价后全仓操作的人们的需求，他们期望与开盘价匹配。
当开盘价跳空（向上或向下，取决于买入或卖出）且现金不足以进行全仓操作时，这种情况会失败。这迫使经纪商拒绝操作。
虽然人们可以尝试通过正 [1] 索引法查看未来，但这需要预加载数据，而这并不总是可行的。
模式 # cerebro = bt.Cerebro(cheat_on_open=True) 这会在系统中激活一个额外的循环，该循环调用策略中的 next_open、nextstart_open 和 prenext_open 方法。
为了清楚地分离常规方法（这些方法基于所检查的价格不再可用且未来未知）和作弊模式下的操作，决定增加一组额外的方法家族。
这也避免了对常规 next 方法的两次调用。
以下情况在 xxx_open 方法内部保持不变：
指标尚未重新计算，保持上一个循环中在等效的 xxx 常规方法中最后看到的值。 经纪商尚未评估新循环中的待处理订单，并且可以引入新订单，如果可能，将进行评估。 注意：
Cerebro 还有一个名为 broker_coo（默认值：True）参数，它告诉 cerebro 如果激活了 cheat-on-open，它也会尝试在经纪商中激活它（如果可能的话）。 模拟经纪商有一个名为 coo 的参数和一个名为 set_coo 的方法来设置它。 尝试 Cheat-on-open # 下面的示例有一个策略，具有两种不同的行为：
如果 cheat-on-open 为 True，它将仅从 next_open 操作。 如果 cheat-on-open 为 False，它将仅从 next 操作。 在这两种情况下，匹配价格必须相同：
如果不作弊，订单在前一天的收盘后发出，并将与下一个到来的价格（开盘价）匹配。 如果作弊，订单在同一天发出并执行。因为订单是在经纪商评估订单之前发出的，所以它也将与下一个到来的价格（开盘价）匹配。 第二种情况下，可以精确计算全仓策略的份额，因为可以直接访问当前的开盘价。
在这两种情况下，当前的开盘价和收盘价将从 next 中打印。</description></item><item><title>目标订单</title><link>https://www.poloxue.com/backtrader/docs/09-orders/03-target-orders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/03-target-orders/</guid><description>目标订单 # 在 1.8.10.96 版本之前，策略方法 buy 和 sell 可通过 sizer 实现智能持仓，sizer 负责确定持仓的大小。然而，Sizer 不能决定操作是买入还是卖出。这就需要一个新的概念，在决策中加入一个小的智能层。这就是策略中的order_target_xxx方法家族。
受 zipline 的启发，这些方法提供了简单指定最终目标的机会，无论目标是：
size -&amp;gt; 特定资产的股份或合约数量 value -&amp;gt; 资产在投资组合中的货币单位价值 percent -&amp;gt; 当前投资组合中资产的百分比值 注意：这些方法的在 Strategy 类的参考文档中可以找到。简言之，这些方法使用与 buy 和 sell 相同的参数签名，只是将 size 参数替换为 target 参数。
这些方法的核心在于指定最终目标，然后方法决定操作是买入还是卖出。所有三种方法的逻辑相同。以下是order_target_size的工作方式：
如果目标大于当前仓位，则发出买入指令，买入的数量为target - position_size。例如：
仓位：0，目标：7 -&amp;gt; buy(size=7 - 0) -&amp;gt; buy(size=7) 仓位：3，目标：7 -&amp;gt; buy(size=7 - 3) -&amp;gt; buy(size=4) 仓位：-3，目标：7 -&amp;gt; buy(size=7 - -3) -&amp;gt; buy(size=10) 仓位：-3，目标：-2 -&amp;gt; buy(size=-2 - -3) -&amp;gt; buy(size=1) 如果目标小于当前仓位，则发出卖出指令，卖出的数量为position_size - target。例如：</description></item><item><title>策略参考</title><link>https://www.poloxue.com/backtrader/docs/07-strategy/03-strategy-references/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/07-strategy/03-strategy-references/</guid><description>策略参考 # 内置策略参考 # MA_CrossOver # 别名：SMA_CrossOver，这是一个仅做多的策略，基于移动平均线交叉操作。
交易规则 # 买入逻辑： 如果无持仓，fast 移动平均线向上穿过 slow 移动平均线。
卖出逻辑： 有持仓时，fast 移动平均线向下穿过 slow 移动平均线。
订单类型： 市价单
参数：
fast (10)，_movav (&amp;lt;class ‘backtrader.indicators.sma.SMA’&amp;gt;) slow (30)，_movav (&amp;lt;class ‘backtrader.indicators.sma.SMA’&amp;gt;) SignalStrategy # 此策略的子类旨在使用信号自动操作。信号通常是指标，预期输出值为：
&amp;gt; 0 表示多头指示 &amp;lt; 0 表示空头指示 信号分为两组，共有 5 种类型。
主要组：
LONGSHORT：接受来自该信号的多头和空头指示。 LONG： 接受多头指示进行做多。 接受空头指示平仓多头。但： 如果系统中有 LONGEXIT 信号，将用它来平仓多头。 如果有 SHORT 信号且没有 LONGEXIT 信号，它将被用来平仓多头再开空头。 SHORT： 接受空头指示进行做空。 接受多头指示平仓空头。但： 如果系统中有 SHORTEXIT 信号，将用它来平仓空头。 如果有 LONG 信号且没有 SHORTEXIT 信号，它将被用来平仓空头再开多头。 退出组：
这两个信号旨在覆盖其他信号，并为平仓提供标准。
LONGEXIT：接受空头指示平仓多头。 SHORTEXIT：接受多头指示平仓空头。 订单发出：</description></item><item><title>线 Line 类</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/03-line/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/03-line/</guid><description>线 Line 类 # 在 Backtrader 中，许多对象都会生成 Line 对象，而每个 Line 代表的是一个时间序列数据，可以是价格、指标或其他数据。策略逻辑基本都离不开操作 Line 对象。
Line 的访问 # 数据源中的 Line # 数据源中包含了多个 Line，如 close、open、high、low ，通过 self.data.lines 访问它们。
class MyStrategy(bt.Strategy): def __init__(self): self.close_line = self.data.lines.close # 访问收盘价线 指标中的 Line # 指标同样会生成 Line，如 SimpleMovingAverage 的 sma，通过 self.movav.lines.sma 访问。
class MyStrategy(bt.Strategy): def __init__(self): self.movav = btind.SimpleMovingAverage(self.data, period=20) def next(self): if self.movav.lines.sma[0] &amp;gt; self.data.lines.close[0]: print(&amp;#39;移动平均大于收盘价&amp;#39;) 访问线的快捷方式 # 前面的语法和我们平时使用的不一样，因为我们平时都是通过简写访问，如 self.data.close 实际上是 self.data.lines.close 的快捷方式。
Backtrader 提供了多种简化访问 Line 的方式：</description></item><item><title>自定义佣金</title><link>https://www.poloxue.com/backtrader/docs/11-commission-schemes/03-customization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/11-commission-schemes/03-customization/</guid><description>自定义佣金 # 重新设计 CommInfo 对象以实现当前版本的最重要部分包括：
保留原始 CommissionInfo 类和行为 为轻松创建用户定义的佣金打开大门 将格式 xx% 作为新佣金方案的默认值，而不是 0.xx（这只是个口味问题），同时保持行为可配置 定义佣金方案 # 这涉及 1 到 2 个步骤：
子类化 CommInfoBase # 仅更改默认参数可能就足够了。backtrader 已经在模块 backtrader.commissions 中使用一些定义进行了此操作。期货的常规行业标准是每合同和每轮固定金额。定义可以这样做：
class CommInfo_Futures_Fixed(CommInfoBase): params = ( (&amp;#39;stocklike&amp;#39;, False), (&amp;#39;commtype&amp;#39;, CommInfoBase.COMM_FIXED), ) 对于股票和按百分比计算的佣金：
class CommInfo_Stocks_Perc(CommInfoBase): params = ( (&amp;#39;stocklike&amp;#39;, True), (&amp;#39;commtype&amp;#39;, CommInfoBase.COMM_PERC), ) 如上所述，此处解释百分比的默认值（作为参数 commission 传递）为：xx%。如果需要旧的/其他行为 0.xx，可以轻松实现：
class CommInfo_Stocks_PercAbs(CommInfoBase): params = ( (&amp;#39;stocklike&amp;#39;, True), (&amp;#39;commtype&amp;#39;, CommInfoBase.COMM_PERC), (&amp;#39;percabs&amp;#39;, True), ) 重写 _getcommission 方法（如有必要） # 定义如下：</description></item><item><title>节省内存</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/03-saving-memory/</guid><description>内存优化 # Backtrader 的开发是在拥有大量RAM的机器上进行的，加上绘图的可视化反馈非常有用，几乎是必需品，这使得设计决策变得容易：将所有内容保存在内存中。但这一决定有一些缺点：
使用array.array进行数据存储时，当某些边界被超出时，需要分配和移动数据。 内存较少的机器可能会受到影响。 连接到一个可能在线数周/数月、提供数千秒/分钟分辨率tick的实时数据源。 后者比前者更重要，因为backtrader做出了另一个设计决策：
保持纯Python以便在需要时能够在嵌入式系统中运行。 未来的一个场景可能是backtrader连接到第二台提供实时数据的机器，而backtrader本身运行在Raspberry Pi甚至更有限的设备上，如ADSL路由器（带有Freetz映像的AVM Frit!Box 7490）。
因此，需要backtrader支持动态内存方案。现在可以使用以下语义实例化或运行Cerebro：
exactbars 默认值为 False，每个存储在线中的值都保存在内存中。可能的值：
True或1：所有“线”对象将内存使用减少到自动计算的最小周期。
如果 SMA 的周期为30，则底层将始终有一个30条的运行缓冲区，以允许计算 SMA。 此设置将停用预加载和runonce。 使用此设置还将停用绘图。 -1：在策略级别的数据源和指标/操作将保留所有数据在内存中。
如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 -2：作为策略属性的数据源和指标将保留所有点在内存中。
如 RSI 内部使用指标UpDay进行计算。此子指标将不保留所有数据在内存中。 如果在__init__中定义了a = self.data.close - self.data.high，那么a将不保留所有数据在内存中。 这允许保持绘图和预加载活动。 runonce将被停用。 正如往常，示例胜过千言万语。一个示例脚本展示了差异。它针对1996年至2015年的雅虎每日数据运行，共计4965天。
注意：这是一个小样本。交易14小时的EuroStoxx50期货在一个月内将生成约18000个1分钟条。
首先执行脚本，查看在不请求内存节省时使用了多少内存位置：
$ ./memory-savings.py --save 0 Total memory cells used: 506430 对于级别1（完全节省）：
$ ./memory-savings.py --save 1 Total memory cells used: 2041 从 50 万降到 2041。确实如此。
系统中的每个“线”对象使用collections.deque作为缓冲区（而不是array.array），并且长度限制为所需操作的绝对最小值。
假设，使用周期为30的简单移动平均线的策略。在这种情况下，将进行以下调整：</description></item><item><title>配置数据</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/03-datafeed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/03-datafeed/</guid><description>配置数据 DataFeed # 我们目标是通过策略实现资产增值，这就离不开价格数据，甚至是其他有用的数据。本小节，我们将学习如何系统配置数据源，即添加数据源 DataFeed。
配置 DataFeed 要用到的是 backtrader.feeds 中提供的数据工具。要用到的数据文件是 orcl-1995-2014（点击下载即可下载）。
假设，数据文件被下载到当前目录，通过 bt.feeds.YahooFinanceCSVDataFeed 即可创建 datafeed。
data = bt.feeds.YahooFinanceCSVData( dataname=&amp;#34;./orcl-1995-2014.txt&amp;#34;, fromdate=datetime.datetime(2000, 1, 1), todate=datetime.datetime(2000, 12, 31), reverse=False ) Yahoo 在线下载的 CSV 数据按日期降序排列，YahooFinanceCSVData 也是按这个标准解析。但我们提供的数据是升序排列，故设置参数 reverse=True。
接下来，我们通过 cerebro.adddata 将数据添加系统即可。
cerebro.adddata(data) 将这部分实现补充到我们的系统中。
完整示例 # import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt if __name__ == &amp;#39;__main__&amp;#39;: cerebro = bt.</description></item><item><title>OCO 订单</title><link>https://www.poloxue.com/backtrader/docs/09-orders/04-oco-orders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/04-oco-orders/</guid><description>OCO订单 # 使用模式尽量保持简单。因此，如果策略中的逻辑决定是时候发布订单，可以像这样使用 OCO：
def next(self): ... o1 = self.buy(...) ... o2 = self.buy(..., oco=o1) ... o3 = self.buy(..., oco=o1) # 甚至可以是oco=o2，o2已经在o1组中 很简单，第一个订单 o1 将成为组长。通过指定 oco 命名参数，o2 和 o3 成为 OCO 组的一部分。请注意，代码注释指出 o3 也可以通过指定 o2 成为组的一部分（o2已经是组的一部分）。
一旦成功组成组后，如果组中的任何订单被执行、取消或过期，其他订单将被取消。
下面的示例展示了OCO概念。一个标准执行并绘图：
$ ./oco.py --broker cash=50000 --plot 注意
现金增加到50000，因为资产价值达到4000，3个订单的1个项目至少需要12000货币单位（经纪商默认值为10000）。
以下图表实际上没有提供太多信息（这是一个标准的SMA交叉策略）。
示例执行，当快速SMA上穿慢速SMA时，发布3个订单。
order1是一个限价订单，在limdays天后到期，限价为收盘价减少一个百分比。 order2是一个期限更长、限价更低的限价订单。 order3是一个限价更低的限价订单。 因此，order2 和 order3 不会执行，因为：
order1将首先执行，这将触发其他订单的取消。 或者order1将过期，这将触发其他订单的取消。 系统保存了3个订单的ref标识符，并且只有在notify_order中看到三个ref标识符分别为Completed、Cancelled、Margin或Expired时，才会发布新买单。
退出是在持有一段时间后后简单完成的。
为了跟踪实际执行，生成文本输出。部分内容如下：
2005-01-28: Oref 1 / Buy at 2941.11055 2005-01-28: Oref 2 / Buy at 2896.</description></item><item><title>Reference</title><link>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/12-analyzers/04-reference/</guid><description>参考 # AnnualReturn # class backtrader.analyzers.AnnualReturn() 该分析器通过查看年的起点和终点来计算年度回报率。
参数：
无 成员属性：
rets：计算出的年度回报率列表 ret：年度回报率字典（键：年份） get_analysis： 返回包含年度回报率的字典（键：年份）
Calmar # class backtrader.analyzers.Calmar() 该分析器计算 Calmar 比率，时间框架可以与基础数据使用的不同。
参数：
timeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.Minutes&amp;rdquo; 和 60 作为压缩在每小时时间框架上工作。 fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含时间段键和对应滚动 Calmar 比率的 OrderedDict。
DrawDown # class backtrader.analyzers.DrawDown() 该分析器计算交易系统的回撤统计数据，如百分比和美元的回撤值、最大回撤值、回撤长度和最大回撤长度。
参数：
fund（默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode - True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的 set_fundmode。 get_analysis： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可用的键/属性包括：
drawdown：回撤值（百分比） moneydown：回撤值（货币单位） len：回撤长度 max.drawdown：最大回撤值（百分比） max.moneydown：最大回撤值（货币单位） max.len：最大回撤长度 TimeDrawDown # class backtrader.analyzers.TimeDrawDown() 该分析器计算在选定时间框架上的交易系统回撤，可以与基础数据使用的时间框架不同。
参数：
timeframe（默认：无）：如果为 None，将使用系统中第一个数据的时间框架。 compression（默认：无）：仅用于子日时间框架，例如通过指定 &amp;ldquo;TimeFrame.</description></item><item><title>TA-Lib</title><link>https://www.poloxue.com/backtrader/docs/08-indicators/04-talib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/08-indicators/04-talib/</guid><description>TA-Lib # 即使backtrader已经提供了大量内置指标，并且开发一个指标主要是定义输入、输出并以自然方式编写公式，但有些人仍然希望使用TA-LIB。因为，指标X在TA-LIB库中存在，但在backtrader中不存在（作者很乐意接受请求），还有，TA-LIB的行为是众所周知的，人们信赖传统的事物。
为了满足每个人的需求，提供了TA-LIB集成。
需求 # TA-LIB的Python封装 任何需要的依赖项（例如numpy） 安装详情在GitHub仓库中 使用TA-LIB # 与使用backtrader内置指标一样简单。以下是一个简单移动平均线的示例。首先是backtrader的示例：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.sma = bt.indicators.SMA(self.data, period=self.p.period) ... 接下来是TA-LIB的示例：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.sma = bt.talib.SMA(self.data, timeperiod=self.p.period) ... 注意，TA-LIB指标的参数由库本身定义，而不是backtrader。在这种情况下，TA-LIB中的SMA使用名为timeperiod的参数来定义操作窗口的大小。
对于需要多个输入的指标，例如随机指标：
import backtrader as bt class MyStrategy(bt.Strategy): params = ((&amp;#39;period&amp;#39;, 20),) def __init__(self): self.stoc = bt.talib.STOCH(self.data.high, self.data.low, self.data.close, fastk_period=14, slowk_period=3, slowd_period=3) .</description></item><item><title>优化改进</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/04-optimization-improvements/</guid><description>优化改进 # Backtrader 通过引入两个新的 Cerebro 参数，优化了在多进程环境下管理数据源和结果的方式。
参数说明：
参数名 默认值 描述 optdatas True 如果为True并进行优化（系统可以预加载并使用runonce），则数据预加载将仅在主进程中进行一次，以节省时间和资源。 optreturn True 如果为True，优化结果将不是完整的策略对象（包括所有数据、指标、观察者等），而是带有以下属性的对象（与策略中相同）：- params（或p）：策略执行时的参数- analyzers：策略执行的分析器 通常，我们只需要查看策略使用的参数的最终表现（如收益率）。如想查看运行过程中的详细数据（如每个时间点的指标值），请关闭此选项。
数据源管理 # 在优化场景中，Cerebro 参数可能的组合是：
preload=True（默认），数据源将在运行任何回测代码前完成预加载： runonce=True（默认），指标将在紧密的for循环中批量计算，而不是逐步计算。 如果两个条件都为True且optdatas=True，则数据源将在生成新子进程之前在主进程中预加载（这些子进程负责执行回测）
结果管理 # 在优化场景中，当评估每个策略运行的不同参数时，最重要的两个因素是：
strategy.params（或strategy.p）
回测使用的实际参数集
strategy.analyzers
提供策略实际表现评估的对象。例如：SharpeRatio_A（年化夏普比率）
当optreturn=True时，不会返回完整的策略实例，而是创建占位符对象，这些对象携带上述两个属性以进行评估。
这避免了传回大量生成的数据，例如回测期间指标生成的值。
如果希望返回完整的策略对象，只需在Cerebro实例化或进行cerebro.run时设置optreturn=False。
一些测试运行 # backtrader源代码中的优化示例已扩展，添加了对optdatas和optreturn的控制（实际上是禁用它们）。
单核心运行 # 作为参考，当将CPU数量限制为1且不使用多进程模块时会发生什么：
$ ./optimization.py --maxcpus 1 ================================================== ************************************************** -------------------------------------------------- OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 10), (u&amp;#39;macdperiod1&amp;#39;, 12), (u&amp;#39;macdperiod2&amp;#39;, 26), (u&amp;#39;macdperiod3&amp;#39;, 9)]) ************************************************** -------------------------------------------------- OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 10), (u&amp;#39;macdperiod1&amp;#39;, 13), (u&amp;#39;macdperiod2&amp;#39;, 26), (u&amp;#39;macdperiod3&amp;#39;, 9)]) ... ... OrderedDict([(u&amp;#39;smaperiod&amp;#39;, 29), (u&amp;#39;macdperiod1&amp;#39;, 19), (u&amp;#39;macdperiod2&amp;#39;, 29), (u&amp;#39;macdperiod3&amp;#39;, 14)]) ================================================== Time used: 184.</description></item><item><title>利息</title><link>https://www.poloxue.com/backtrader/docs/11-commission-schemes/04-credit-interests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/11-commission-schemes/04-credit-interests/</guid><description>利息 # 在某些情况下，由于资产操作包含利率，实际经纪商的现金金额可能会减少。例如：
股票的卖空 ETF 的多头和空头操作 该费用直接从经纪账户的现金余额中扣除。但它仍然可以看作是佣金方案的一部分。因此，它已在 backtrader 中进行了建模。
CommInfoBase 类（以及主要的 CommissionInfo 接口对象）已扩展了：
两个新参数，用于设置利率并确定是否仅应用于空头还是同时应用于多头和空头 参数 # interest（默认值：0.0）
如果非零，这是持有卖空头寸时收取的年度利息。这主要用于股票卖空。
应用的默认公式：days * price * size * (interest / 365)
必须以绝对值指定：0.05 -&amp;gt; 5%
注意：可以通过重写方法 get_credit_interest 来更改行为
interest_long（默认值：False）
一些产品如 ETF，在多头和空头头寸上都收取利息。如果为 True 并且 interest 非零，则多头和空头方向都将收取利息。
公式 # 默认实现将使用以下公式：
days * abs(size) * price * (interest / 365) 其中：
days：自头寸开立或上次利息计算以来经过的天数 重写公式 # 要更改公式，需要子类化 CommissionInfo。需要重写的方法是：
def _get_credit_interest(self, size, price, days, dt0, dt1): &amp;#39;&amp;#39;&amp;#39; 此方法返回经纪商收取的利息成本。 对于 ``size &amp;gt; 0`` 的情况，仅在类参数 ``interest_long`` 为 ``True`` 时调用此方法。 计算利率的公式为： 公式：``days * price * abs(size) * (interest / 365)`` 参数： - ``data``：收取利息的数据源 - ``size``：当前头寸大小。&amp;gt; 0 表示多头头寸，&amp;lt; 0 表示空头头寸（此参数不会为 ``0``） - ``price``：当前头寸价格 - ``days``：自上次利息计算以来经过的天数（这是（dt0 - dt1）.</description></item><item><title>填充器</title><link>https://www.poloxue.com/backtrader/docs/10-broker/04-volume-filling-filler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/04-volume-filling-filler/</guid><description>填充器 # Backtrader 的经纪模拟在订单执行时有一个默认策略：忽略交易量。这是基于两个前提：
交易在流动性足够高的市场中，可以一次性完全吸收买/卖订单 实际的交易量匹配需要真实的市场环境 一个简单的例子是“立即成交或取消”（Fill or Kill）订单。即使细化到每一笔交易，并且有足够的交易量来完成订单，Backtrader的经纪模拟也无法知道市场中有多少其他参与者来判断这样的订单是否会被匹配以遵循“立即成交”部分，或者订单是否应该被取消。
但是经纪模拟可以接受交易量填充器（Volume Fillers），它们决定在给定时间点应该使用多少交易量来匹配订单。
填充器签名 # 在Backtrader生态系统中，填充器可以是任何符合以下签名的可调用对象：
callable(order, price, ago) 其中：
order 是即将执行的订单，该对象提供对目标数据对象的访问，创建的大小/价格、执行的价格/大小/剩余大小和其他详细信息 price 是订单执行的价格 ago 是数据在订单中的索引，用于查找交易量和价格元素 在几乎所有情况下，这将是0（当前时间点），但在某些特殊情况下（例如Close订单），这可能是-1。
例如，访问bar交易量可以这样做：
barvolume = order.data.volume[ago] 可调用对象可以是一个函数，或例如支持__call__方法的类的实例，例如：
class MyFiller(object): def __call__(self, order, price, ago): pass 将填充器添加到经纪模拟
最直接的方法是使用set_filler：
import backtrader as bt cerebro = Cerebro() cerebro.broker.set_filler(bt.broker.fillers.FixedSize()) 第二种选择是完全替换经纪模拟，这可能仅适用于重写了部分功能的BrokerBack子类：
import backtrader as bt cerebro = Cerebro() filler = bt.broker.fillers.FixedSize() newbroker = bt.broker.BrokerBack(filler=filler) cerebro.broker = newbroker 示例 # Backtrader的源代码中包含一个名为volumefilling的示例，它允许测试一些集成的填充器（最初是全部）。
参考 # class backtrader.</description></item><item><title>开发 Binary 数据源</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/04-datafeed-development-general/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/04-datafeed-development-general/</guid><description>开发 Binary 据源 # 注意：示例中使用的 Binary 文件 goog.fd 属于 VisualChart，不能与 backtrader 一起分发。
对于那些有兴趣直接使用 Binary 文件的人，可以免费下载 VisualChart。
CSV 数据源开发展示了如何添加新的基于 CSV 的数据源。现有的基类 CSVDataBase 提供了框架，减轻了子类的大部分工作，在大多数情况下，它们可以简单地执行：
def _loadline(self, linetokens): # 在这里解析 linetokens 并将它们放入 self.lines.close, self.lines.high 等中 return True # 如果数据已解析，否则返回 False 基类负责参数、初始化、打开文件、读取行、将行拆分为标记以及其他事项，例如跳过不符合日期范围（fromdate，todate）的行，这些行可能由最终用户定义。
开发非 CSV 数据源遵循相同的模式，而无需深入到已拆分的行标记。
需要做的事情： # 从 backtrader.feed.DataBase 派生 添加任何需要的参数 如果需要初始化，重写 __init__(self) 和/或 start(self) 如果需要清理代码，重写 stop(self) 工作发生在必须始终重写的方法 _load(self) 内 让我们看看 backtrader.feed.DataBase 已经提供的参数：
from backtrader.utils.py3 import with_metaclass ... ... class DataBase(with_metaclass(MetaDataBase, dataseries.OHLCDateTime)): params = ((&amp;#39;dataname&amp;#39;, None), (&amp;#39;fromdate&amp;#39;, datetime.</description></item><item><title>打败随机入场</title><link>https://www.poloxue.com/backtrader/docs/19-articles/04-beating-the-random-entry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/04-beating-the-random-entry/</guid><description>打败随机入场
最近，reddit/r/algotrading 上有一些讨论，关于是否能够成功复制已发布的算法交易策略。首先，我复现了130多篇关于“预测股市”的研究论文，从头开始编写了代码，并记录了结果。以下是我学到的一些东西：
因为之前的帖子已被删除，下面是快速总结：
策略无效
如果作者声称某个策略因阿尔法衰退而失效，那么这些测试都是在过去的数据上运行的，但它们仍然无效。 结论：这些策略要么是过拟合，要么是 p-hacking，或者只是微小的阿尔法，但这些阿尔法由于交易佣金的存在，已经被摧毁。 Artem Kaznatcheev 在《算法交易中的复现危机寓言》中写了对复现问题的描述，接着写了关于过拟合的文章。
前两篇文章主要是理论性的（即使第一篇提到实现了130个策略），而《过拟合》则提供了实际的代码。
在这么多讨论中，如何尝试复现一些已发布的策略而不是论文，采用像《过拟合》那样的实际方法呢？例如，出版在一本知名书籍中的策略。
目标：“打败随机入场”。这是这本书第三部分第八章中的一节：
《Amazon - 交易你的财务自由之路》
Van Tharp Institute - 《交易你的财务自由之路》
该书提供了一个结构化的算法交易方法，特别强调了：仓位大小和仓位管理（即：何时退出交易）。这些要远比大多数人认为最重要的入场设置更为关键。
在第八章中，Van K. Tharp 与 Tom Basso 交谈时提到：“从你说的来看，听起来只要你有好的退出方式，并且聪明地调整仓位大小，似乎你可以通过随机入场来持续赚钱。” Tom Basso 回应说，他可能确实可以做到。
规则：
基于硬币投掷的入场 始终在市场中——多头或空头 一旦退出信号给出，立即重新进入 市场波动性由10天的平均真实波幅指数（EMA ATR）决定 跟踪止损，距离收盘价3倍波动性 止损只能朝着交易方向移动 固定仓位（1个合约）或1%风险模型（见书第12章） 结果：
测试10个市场 固定仓位：80%的时间获利 1%风险模型：100%的时间获利 可靠性：38%（获胜交易的百分比） 缺失部分：
测试的市场 测试的时间段 如果“始终在市场中”意味着“今天”关闭交易并在“明天”重新进入，或者意味着同时发出关闭/重新开仓的订单，这一点实际上最容易克服。
对于最后两项，书中提到谈话发生在1991年，并且使用的是期货。为了公平起见，将使用1991年前的期货数据。也假设使用1天的价格条形图，考虑到提到的10天指数平滑移动平均（EMA）。
最明显的问题似乎是如何正确实现算法，但在这种情况下，书籍很好地描述了简单算法及其结果。接下来，我们总结一下第12章中的“百分比风险模型”（书中称为“模型3”）。
最大亏损：限制为账户总值的x%（即：百分比风险）
每合约风险：根据给定的算法，风险为初始止损距离（波动性的3倍）乘以期货的乘数
合约数量：最大亏损 / 每合约风险
复现细节 # 数据
将使用1985至1990年的CL（原油）期货数据（即：6年完整数据）。该合约的规格如下：
每点的最小变动：0.01（即：每点100个tick） 每个tick的费用：10美元 因此，乘数为1000美元/点（100 ticks/点 x 10美元/tick = 1000美元） 佣金</description></item><item><title>第一个策略</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/04-first-strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/04-first-strategy/</guid><description>第一个策略 # 本节我们将学习如何开发策略。
第一个策略不涉及交易，我们将通过它打印每一天（bar）的 &amp;ldquo;收盘价（Close）&amp;rdquo; 。
策略类（Strategy）继承自 bt.Strategy。
class TestStrategy(bt.Strategy): def __init__(self): pass def next(self): pass 它最重要的两个方法是 __init__（策略初始化）和 next（每个 OHLC，即bar，执行一次该方法）。
class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(&amp;#39;Close, %.2f&amp;#39; % self.dataclose[0]) 如上代码中的 self.datas[0].close 访问的就是 cerebro.broker.adddata 方法添加的第一个数据源 DataFeed。
数据列表（self.datas）是一个标准的Python列表，如添加多个数据源，数据按插入顺序存储。列表中的第一个数据项self.datas[0]是默认交易数据，用于同步所有策略元素（它作为系统时钟）。
self.datas 的列表元素 data 底层类是 DataSeries，它有别名访问众所周知的 OHLC（开盘、高、低、收盘）每日值。
open = data.open low = data.low high = data.high close = data.</description></item><item><title>索引和切片</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/04-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/04-index/</guid><description>索引和切片 # 索引：0 和 -1 # 在 Backtrader 中，Line 代表着一组按时间顺序排列的点。这些点在策略执行期间动态生成，可以通过索引来访问。
使用索引访问 Line # 访问当前值： 使用 0 索引访问当前的线值，如 self.data.close[0] 获取当前收盘价。
class MyStrategy(bt.Strategy): def next(self): print(self.data.close[0]) # 当前的收盘价 访问前值： 使用负数索引访问之前的值，如 self.data.close[-1] 获取上一条数据的收盘价。
class MyStrategy(bt.Strategy): def next(self): if self.data.close[0] &amp;gt; self.data.close[-1]: print(&amp;#34;今天的收盘价高于昨日的收盘价&amp;#34;) 索引的意义：
0 索引指向当前时刻的值，-1 指向上一个时刻的值，以此类推。 负数索引指向历史数据点，这对于时间序列分析和策略中的数据回溯非常有用。 简单示例：
class MyStrategy(bt.Strategy): def next(self): # 比较今天的收盘价和昨天的收盘价 if self.data.close[0] &amp;gt; self.data.close[-1]: print(&amp;#34;今天的收盘价更高&amp;#34;) else: print(&amp;#34;今天的收盘价更低&amp;#34;) 在这个示例中，self.data.close[0] 是今天的收盘价，self.data.close[-1] 是昨天的收盘价。
切片 # Backtrader 不支持对 Line 对象的切片操作，这是为了保持设计的一致性。切片适用于普通的 Python 数组，但在 Backtrader 中，Line 对象是动态增长的，因此切片的使用存在一定的限制。</description></item><item><title>Bracket Orders</title><link>https://www.poloxue.com/backtrader/docs/09-orders/05-bracket-orders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/05-bracket-orders/</guid><description>Bracket Orders # 1.9.37.116版本增加了Bracket订单，为回测经纪商提供了广泛的订单支持（Market、Limit、Close、Stop、StopLimit、StopTrail、StopTrailLimit、OCO）。
注意，这是为回测和 Interactive Brokers 实现的。
Bracket订单不是单个订单，而是由3个订单组成。
以做多为例：
一个主要的买单，通常设置为 Limit 或 StopLimit 订单。 一个低价卖单，通常设置为 Stop 订单以限制损失。 一个高价卖单，通常设置为 Limit 订单以获取利润。 做空也有对应的卖单和 2 个买单。
低价/高价卖单实际上形成了一个围绕主要订单的 Bracket。
为了使其合理，以下规则适用：
3个订单一起提交，以避免其中任何一个独立触发。 低价/高价卖单被标记为主要订单的子订单。 子订单在主要订单执行之前不活跃。 取消主要订单会取消低价和高价卖单。 执行主要订单会激活低价和高价卖单。 一旦活跃，低价/高价卖单的执行或取消会自动取消另一个订单。 使用模式 # 有两种方式创建 Bracket 订单组：
单次发布3个订单。 手动发布3个订单。 单次发布Bracket # backtrader在Strategy中提供了两个新方法来控制Bracket订单：buy_bracket和sell_bracket。
注意
签名和信息见下文或Strategy参考部分。
通过单个语句完成3个订单的设置。示例如下：
brackets = self.buy_bracket(limitprice=14.00, price=13.50, stopprice=13.00) 注意，stopprice和limitprice围绕price设定。这应该足够了。
实际的目标数据将是 data0，大小将由默认的sizer自动确定。当然，可以指定其他参数来精细控制执行。
返回值是一个包含3个订单的列表：[主要订单，stop订单，limit订单]。
因为在发布 sell_bracket 订单时，低价和高价将翻转，所以参数命名遵循约定：stop 用于止损（在做多操作中是低价，在做空操作中是高价），limit 用于获取利润（在做多操作中是高价，在做空操作中是低价）。
手动发布Bracket # 这涉及生成3个订单，并处理transmit和parent参数。规则如下：
必须首先创建主要订单并设置transmit=False。 低价/高价订单必须有parent=main_side_order。 第一个创建的低价/高价订单必须设置transmit=False。 最后一个创建的订单（无论是低价还是高价）设置transmit=True。 以下示例实现了与上述单次命令相同的效果：
mainside = self.</description></item><item><title>Position</title><link>https://www.poloxue.com/backtrader/docs/10-broker/05-position/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/05-position/</guid><description>Position # 通常在策略中要检查资产 Position，或成为仓位、头寸，通过 position 属性或 getposition(data=None, broker=None) 方法。这将返回策略在cerebro提供的默认经纪商中的datas[0]的头寸。
头寸只是一个表示：
持有的资产数量（size） 平均价格（price） 它用作状态指示，例如可以用于决定是否需要发出订单（例如：仅在没有持仓时进入多头头寸）。
参考 # class backtrader.position.Position(size=0, price=0.0) 保存并更新头寸的数量和价格。该对象与任何资产没有关系。它只保存数量和价格。
成员属性：
size（int）：当前头寸的数量 price（float）：当前头寸的价格 可以使用 len(position) 来测试头寸实例以查看数量是否不为零。</description></item><item><title>保守型公式的再平衡</title><link>https://www.poloxue.com/backtrader/docs/19-articles/05-rebalancing-conserative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/05-rebalancing-conserative/</guid><description>保守型公式的再平衡 # 本文提出了保守型公式的方法：Python中的保守型公式：简化的量化投资
这只是众多可能的再平衡方法中的一种，但它相对易于理解。方法概要如下：
从Y个股票（比如1000个中的100个）中选出x只股票 选股标准为： 低波动性 高净派息收益率（Net Payout Yield，NPY） 高动量 每月再平衡一次 了解了这些概念后，接下来我们将展示如何在Backtrader中实现这一策略。
数据 # 即使有一个获胜的策略，如果没有可用的数据，那么一切都不会成真。因此，需要考虑数据的格式和如何加载它。
假设有一组CSV文件（“逗号分隔值”），每个文件包含以下特征：
每月的OHLCV数据 额外的列包含净派息收益率（NPY），以形成一个ohlcvn数据集。 CSV数据格式如下：
date, open, high, low, close, volume, npy 2001-12-31, 1.0, 1.0, 1.0, 1.0, 0.5, 3.0 2002-01-31, 2.0, 2.5, 1.1, 1.2, 3.0, 5.0 ... 即每行表示一个月的数据。接下来，可以通过Backtrader的CSV数据加载引擎创建一个简单的扩展类。
class NetPayOutData(bt.feeds.GenericCSVData): lines = (&amp;#39;npy&amp;#39;,) # 增加一行，用于存储净派息收益率 params = dict( npy=6, # npy字段位于第6列（基于0的索引） dtformat=&amp;#39;%Y-%m-%d&amp;#39;, # 设置日期格式为yyyy-mm-dd timeframe=bt.TimeFrame.Months, # 设置时间框架为按月 openinterest=-1, # -1表示没有openinterest字段 ) 这样就完成了对数据源的扩展。注意，通过lines=('npy',)，已经将净派息收益率（NPY）数据添加到了OHLCV数据流中。其他常见的字段（如open、high等）已经是GenericCSVData的一部分。通过在params中指定位置，我们能够告诉Backtrader净派息收益率所在的列。
策略 # 接下来，我们将逻辑封装到Backtrader的标准策略中。为了使其尽可能通用和可自定义，我们将采用与数据源相同的params方法。</description></item><item><title>多时间框架</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/05-datafeed-multiple-timeframes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/05-datafeed-multiple-timeframes/</guid><description>多时间框架策略 # 在实际的交易中，我们常需要结合多个时间框架来制定投资决策，如在周级别评估趋势，而在日级别执行入场，或是基于 5 分钟与 60 分钟数据的对比执行交易。在 Backtrader 中要实现这个目标，需要将不同时间框架的数据组合在一起。
本节将介绍如何在 Backtrader 实现多周期交易策略。
基本规则 # Backtrader 原生支持多时间框架的数据组合，只需遵循几个简单的规则。
第一步，最小时间框架的数据必须首先加载。较小时间框架（条数最多的数据）应当首先加载到Cerebro实例中。
第二步，数据必须按日期时间对齐。为了让平台能够正确解析数据并执行策略，必须保证各时间框架的数据时间对齐。
第三步，使用 resampledata 实现较大时间框架的重采样。cerebro.resample 函数能轻松地将较大的时间框架数据添加到策略中。
在这个基础上，就可以在较短和较长时间框架上使用不同的技术指标。要注意，应用于大时间框架的指标产生的信号较少，还有，Backtrader 会考虑大时间框架的最小周期，以确保数据的准确性。
示例：如何使用多个时间框架 # 如何在 Backtrader 实现多时间周期呢？大概演示这个步骤吧。
加载数据 # 首先，加载较小时间框架的数据。
data = btfeeds.BacktraderCSVData(dataname=datapath) 将数据添加到Cerebro # 将较小时间框架数据都添加到 Cerebro 实例中。
cerebro.adddata(data) 重采样数据 # 使用 cerebro.resampledata 将数据重采样到较大的时间框架。
cerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression) 运行策略 # 执行策略并生成结果。
cerebro.run() 示例 # 首先，演示每日和每周时间框架。假设我们希望在一个策略中同时使用每日和每周的时间框架。通过命令行指定时间框架为每周，并进行数据重采样：
$ ./multitimeframe-example.py --timeframe weekly --compression 1 此时，程序会加载每日数据，并将其重采样为每周数据。最终输出将包括每周和每日数据的合成图表。
继续用每日时间框架压缩。如果我们希望将每日数据压缩为每两天一条数据，可以使用以下命令：
$ ./multitimeframe-example.py --timeframe daily --compression 2 此时，Backtrader会将每日数据压缩为每两天一条数据，并生成合成图表。</description></item><item><title>开始交易</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/05-strategy-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/05-strategy-logic/</guid><description>开始交易 # 本节，我们将演示一个简单的策略，让策略执行交易操作，如果出现连续两个交易日下跌即 - 买入！买入！买入！
我们将基于上节的策略类 TestStrategy 继续开发，策略逻辑部分要在 next 方法中实现。
class TestStrategy(bt.Strategy): def log(self, txt, dt=None): dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.datas[0].close def next(self): self.log(&amp;#39;Close, %.2f&amp;#39; % self.dataclose[0]) 首先是买入条件，如何判断两日连续下跌呢？
简单而言，就是 close[0] &amp;lt; close[-1] 和 close[-1] &amp;lt; close[-2]，即当前收盘价小于昨日收盘价，昨日收盘价小于大前日收盘价。
self.dataclose[0] &amp;lt; self.dataclose[-1] and self.dataclose[-1] &amp;lt; self.dataclose[-2] 而买入操作使用 self.buy 皆可。
self.buy() 默认情况下，如果存在多个数据源，self.buy 买入的是第一个数据资产。
完整示例 # import datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.</description></item><item><title>异常 Exceptions</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/05-exceptions/</guid><description>异常 # 设计目标之一是尽早退出并让用户完全透明地了解错误发生的情况。目的是强制自己编写在异常情况下会中断的代码，并强制重新审视受影响的部分。
但现在是时候了，某些异常可能会慢慢添加到平台中。
继承层次结构 # 所有异常的基类是 BacktraderError（直接继承自 Exception）。
位置 # 在 errors 模块内，可以通过以下方式访问：
import backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.errors.StrategySkipError 或者直接从 backtrader 访问：
import backtrader as bt class Strategy(bt.Strategy): def __init__(self): if something_goes_wrong(): raise bt.StrategySkipError 异常 # StrategySkipError，请求平台跳过该策略的回测。应在实例的初始化（__init__）阶段引发。</description></item><item><title>运算符</title><link>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/05-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/04-concepts/01-platform-concepts/05-operator/</guid><description>运算符 # 在 Backtrader 中，运算符不仅用于常规的数学运算，还能构建复杂的策略逻辑。Backtrader 的自定义运算符让策略的数学和逻辑运算更自然和简洁。
如何使用运算符 # backtrader 支持基于运算符创建新的对象，如在 __init__ 中通过运算符计算多个指标，得到一个新的操作对象。
class MyStrategy(bt.Strategy): def __init__(self): sma = btind.SimpleMovingAverage(self.data, period=20) # 使用运算符创建新的逻辑对象 close_over_sma = self.data.close &amp;gt; sma sma_dist_to_high = self.data.high - sma sma_dist_small = sma_dist_to_high &amp;lt; 3.5 # 创建卖出信号 self.sell_sig = bt.And(close_over_sma, sma_dist_small) 我们在 Line 对象上使用了常规的运算符，如加减乘除、大小比较等。这简化了策略代码，增强了策略逻辑的可读性和可维护性。
注：backtrader 的指标计算是自有的体系，不是基于 numpy 和 pandas，所以要单独实现这些运算符。
一些未覆盖的运算符/函数 # 某些 Python 中的运算符没有被覆盖，backtrader 提供了专门的函数来模拟逻辑运算，如 bt.And 和 bt.Or 来实现逻辑 &amp;ldquo;与&amp;rdquo; 和 &amp;ldquo;或&amp;rdquo;。
下面把这些单独实现的运算符列出来看看吧。
逻辑运算符 # Python 中的 and 和 or 运算符无法在 Backtrader 中覆盖，backtradr 提供了 bt.</description></item><item><title>MFI 通用版</title><link>https://www.poloxue.com/backtrader/docs/19-articles/06-mfi-generic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/19-articles/06-mfi-generic/</guid><description>MFI 通用版 # 在之前的《Canonical 与 Non-Canonical》一文中，介绍了 MFI（即 Money Flow Indicator，资金流动指标）的实现。
虽然这个实现是按照传统的方式开发的，但它依然有改进的空间，并且可以做得更通用。
让我们关注一下实现的前几行代码，即计算典型价格的部分。
Canonical MFI - 典型价格和原始资金流 # class MFI_Canonical(bt.Indicator): lines = (&amp;#39;mfi&amp;#39;,) params = dict(period=14) def __init__(self): tprice = (self.data.close + self.data.low + self.data.high) / 3.0 mfraw = tprice * self.data.volume ... 典型的实例化方式如下所示：
MFI 典型实例化 # class MyMFIStrategy(bt.Strategy): def __init__(self): mfi = bt.MFI_Canonical(self.data) 这里的问题应该很明显： “需要为指标提供包含收盘价、最低价、最高价和成交量的输入（即在 backtrader 生态系统中的lines）”。
当然，也可能有人希望使用来自不同数据源的组件来创建资金流动指标（例如来自数据源或其他指标的线）。例如，想要给收盘价赋予更多权重，而不需要开发一个特定的指标。考虑到行业标准的 OHLCV 数据字段顺序，支持多个输入并给收盘价加权的实例化可以是这样的：
MFI 多输入实例化 # class MyMFIStrategy2(bt.Strategy): def __init__(self): wclose = self.</description></item><item><title>Trade</title><link>https://www.poloxue.com/backtrader/docs/10-broker/06-trade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/10-broker/06-trade/</guid><description> Trade # 交易的定义：当一个工具的头寸从 0 变为一个大小X（多头/空头头寸分别为正/负）时，交易被认为是开启的。或是当一个头寸从X变为0时，交易被认为是关闭的。
以下两种操作：
从正变负 从负变正 实际上被视为：一个交易被关闭了（头寸从X变为0），一个新的交易被开启了（头寸从0变为Y）
交易仅用于信息展示，用户无法调用其方法。
参考 # class backtrader.trade.Trade(data=None, tradeid=0, historyon=False, size=0, price=0.0, value=0.0, commission=0.0) 追踪交易的生命周期：数量、价格、佣金（和价值？）。一个交易从0开始，可以增加和减少，如果回到0可以被认为是关闭的。交易可以是多头（正数）或空头（负数）。交易不支持反转（逻辑中不支持）
成员属性 描述 ref 唯一的交易标识符 status Created, Open, Closed之一 tradeid 在创建订单时传递给订单的分组交易ID，订单的默认值为0 size 当前交易的数量 price 当前交易的价格 value 当前交易的价值 commission 当前累计的佣金 pnl 当前交易的盈亏（毛利） pnlcomm 当前交易的净盈亏（扣除佣金后的净利润） isclosed 记录最后一次更新是否关闭了交易（将交易数量设为零） isopen 记录任何更新是否开启了交易 justopened 如果交易刚刚开启 baropen 交易开启的bar dtopen 交易开启的浮点编码日期时间，使用 open_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barclose 交易关闭的bar dtclose 交易关闭的浮点编码日期时间，使用 close_datetime 方法获取 Python datetime.datetime 或使用平台提供的 num2date 方法 barlen 交易开启的bar数量 historyon 是否记录历史 history 包含每次“更新”事件更新后的状态和使用的参数的列表，历史记录的第一个条目是开启事件，最后一个条目是关闭事件</description></item><item><title>卖出操作</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/06-sell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/06-sell/</guid><description>卖出操作 # 了解如何进入市场（多头，self.buy）后，还要一个“退出概念”，以及了解策略是否在市场中。
本节将演示入场后如何退出市场。
退出逻辑很简单，入场持有 5 根 bar 后（在第 6 根 bar 上）退出，无论是盈利还是亏损。另外，为了简化逻辑，仅在未入场时允许买入订单，即如果有持仓或者进行中的订单都不可买入。
逻辑逻辑 # 要完成这个逻辑，要能确认订单成交时间、成交所在位置、当前是否有进行中的订单以及是否有持仓。
订单状态 # 订单确认状态通过 Strategy 的订单状态变化 notify_order 方法监听。
def notify_order(self, order): print(order.status) 订单状态有 Accepted（已接受）、Submitted（已提交）、Completed（已成交）、Margin（保证金不足）、Rejected（已拒绝）。
订单类中除了状态，还包括订单的其他信息，如执行价格 - order.executed.price，已执行价值 - order.executed.value，订单手续费 - order.executed.comm。
更多订单的信息，可查看 订单- Orders。
成交位置 # 策略对象提供了对默认数据源位置的访问，通过 len(self) 即可获得。
len(self) next 方法没有提供 &amp;ldquo;bar索引&amp;rdquo;，因此很难理解何时经过了 5 根bar，但调用对象的 len 方法，它会告诉你线的长度。
我们只需记下订单完成时的长度，并查看当前长度是否距离其5根bar。
def notify_order(self, order): if order.status in [order.Completed]: self.bar_executed = len(self) def next(self): # 其他代码 if len(self) &amp;gt;= (self.</description></item><item><title>日志 Logging - Writter</title><link>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/05-cerebro/06-logging-writer/</guid><description> Writer # Writer类负责将以下内容写入流：
数据源、策略、指标和观察者的CSV流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。
属性摘要：
数据源 策略（线条和参数） 指标/观察者（线条和参数） 分析器（参数和分析结果） 系统中定义了一个名为WriterFile的Writer，可以通过以下方式添加：
设置Cerebro的writer参数为True，将实例化一个标准的WriterFile 调用Cerebro.addwriter(writerclass, **kwargs)，在回测执行期间，使用给定的kwargs实例化writerclass 由于标准的WriterFile默认不输出CSV，以下调用可以处理这一点：
cerebro.addwriter(bt.WriterFile, csv=True) 参考 # class backtrader.WriterFile() # 系统范围内的Writer类。
可以通过以下参数进行参数化：
参数名 默认 说明 out sys.stdout 写入的输出流，如果传递的是字符串，将使用参数内容作为文件名。 close_out False 如果 out 是一个流，是否需要由Writer显式关闭。 csv False 在执行过程中，是否将数据源、策略、观察者和指标的CSV流写入输出流。可以通过每个对象的csv属性控制哪些对象实际进入CSV流（数据源和观察者默认为True，指标默认为False）。 csv_filternan True CSV流中清除nan值（用空字段替换）。 csv_counter True 是否应保持并输出实际输出行的计数器。 indent 2 每个级别的缩进空格数。 separators &amp;lsquo;=&amp;rsquo;, &amp;lsquo;-&amp;rsquo;, &amp;lsquo;+&amp;rsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;.&amp;rsquo;, &amp;lsquo;~&amp;rsquo;, &amp;lsquo;&amp;quot;&amp;rsquo;, &amp;lsquo;^&amp;rsquo;, &amp;lsquo;#&amp;rsquo; 用于分隔部分/子部分的行分隔符字符。 seplen 79 包括缩进在内的行分隔符的总长度。 rounding None 将浮点数舍入到的小数位数。如果为None，则不执行舍入。</description></item><item><title>期货和现货补偿</title><link>https://www.poloxue.com/backtrader/docs/09-orders/06-future-spot-compensation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/06-future-spot-compensation/</guid><description>期货和现货补偿 # 版本 1.9.32.116 增加了对社区提出的一个有趣用例的支持：
用期货启动交易，包括实物交割； 使用指标进行分析； 如有必要，通过操作现货价格来平仓，从而有效地取消实物交割，无论是收货还是交货（希望能获利） 期货在操作现货价格的当天到期 这意味着：
平台接收来自两个不同资产的数据点 平台必须以某种方式理解这些资产是相关的，并且现货价格的操作将关闭在期货上开启的头寸 实际上，期货并未平仓，只是实物交割被补偿了 利用这种补偿概念，backtrader 增加了一种方式，让用户告知平台一个数据流上的操作将对另一个数据流产生补偿效果。使用模式如下：
import backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFavouriteDataFeed(dataname=&amp;#39;futurename&amp;#39;) cerebro.adddata(data0) data1 = bt.feeds.MyFavouriteDataFeed(dataname=&amp;#39;spotname&amp;#39;) data1.compensate(data0) # 告诉系统 data1 的操作会影响 data0 cerebro.adddata(data1) ... cerebro.run() 综合示例 # 一个示例胜过千言万语，所以让我们把所有的部分结合起来。
使用 backtrader 源代码中的一个标准示例数据源。这将是期货数据 通过重新使用相同的数据源并添加一个随机移动价格的过滤器来模拟一个类似但不同的价格，从而创建价差。如下简单地实现： # 更改收盘价的过滤器 def close_changer(data, *args, **kwargs): data.close[0] += 50.0 * random.randint(-1, 1) return False # 数据流长度未变 在同一轴上绘图会混淆默认包含的 BuyObserver 标记，因此将禁用标准观察者并手动重新添加以使用不同的数据标记。
头寸将随机进入并在 10 天后退出。
这并不匹配期货到期期限，但这只是为了实现功能，而不是检查交易日历。
注意：</description></item><item><title>重采样</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/06-datafeed-resampling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/06-datafeed-resampling/</guid><description>重采样 # 当数据只有单一时间框架可用，而分析要在不同时间框架上进行，就需要进行数据重采样。&amp;ldquo;重采样&amp;rdquo; 实际应称为 &amp;ldquo;上采样&amp;rdquo;，因为它是从源时间框架到更大的时间框架（如：从天到周）。
Backtrader 内置了通过过滤器对象进行重采样的支持。有几种方法可以实现这一点，但有一个简单的接口可以实现，它代替通过 cerebro.adddata(data) 将数据放入系统中，使用 resampledata。
cerebro.resampledata(data, **kwargs) 有两个主要选项可以控制：
更改时间框架 压缩条数 要实现这些功能，请在调用resampledata时使用以下参数：
timeframe（默认值：bt.TimeFrame.Days）：目标时间框架，必须等于或大于源时间框架。 compression（默认值：1）：将选定的值“n”压缩为1个条。 让我们来看一个从每日到每周的示例，通过手工编写的脚本：
$ ./resampling-example.py --timeframe weekly --compression 1 我们可以将其与原始每日数据进行比较：
$ ./resampling-example.py --timeframe daily --compression 1 实现这些功能的步骤有：
先用 cerebro.adddata 加载原始数据； 使用带参数的resampledata 传递数据给cerebro：timeframe 和 compression； 示例代码：
# 加载数据 datapath = args.dataname or &amp;#39;../../datas/2006-day-001.txt&amp;#39; data = btfeeds.BacktraderCSVData(dataname=datapath) # 方便的字典用于时间框架参数转换 tframes = dict( daily=bt.TimeFrame.Days, weekly=bt.TimeFrame.Weeks, monthly=bt.TimeFrame.Months) # 添加重采样数据而不是原始数据 cerebro.resampledata(data, timeframe=tframes[args.timeframe], compression=args.compression) 假设，将时间框架从每日更改为每周，然后将 3 条压缩为 1 条。</description></item><item><title>交易监控</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/07-commission/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/07-commission/</guid><description>交易监控 # 我们已经知道如何使用 backtrader 买卖交易了。本节将介绍 backtrader 如何监控它每笔交易，如成本、利润和佣金。由于佣金的存在，利润还分为毛利润和净利润
设置佣金 # 让我们先设置一个合理佣金率 - 0.1% （买入和卖出都要收取的），一行代码即可。
# 0.1% ... 除以 100 以去掉百分号 cerebro.broker.setcommission(commission=0.001) 订单的成本和佣金 # 订单的成本和佣金可从订单回调 notify_order 中获取，它的 Order 参数 order.executed.comm 即为订单的已执行佣金，order.executed.value 即投入的成本。
class TestStrategy(bt.Strategy): def notify_order(self, order): if order.status in [order.Completed]: if order.isbuy(): self.log( &amp;#39;买入执行，价格：%.2f，成本：%.2f，佣金 %.2f&amp;#39; % (order.executed.price, order.executed.value, order.executed.comm)) else: self.log(&amp;#39;卖出执行，价格：%.2f，成本：%.2f，佣金 %.2f&amp;#39; % (order.executed.price, order.executed.value, order.executed.comm)) 交易记录计算利润 # 对于利润的计算，使用交易记录会更简单，所谓成交记录，即成交撮合一笔记录一次。与订单类似，我们可通过 notify_trade 获取成交记录。它的回调参数是 Trade 类对象，利润相关属性有 trade.pnl（毛利润）和 trade.pnlcomm（净利润）。
class TestStrategy(bt.Strategy): def notify_trade(self, trade): if not trade.</description></item><item><title>数据回放</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/07-datafeed-replay/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/07-datafeed-replay/</guid><description>数据回放 # 随着时间的推移，单纯对已经完成关闭的 Bar 进行策略测试已不再足够，数据回放应运而生。假设，策略在时间框架X上操作（例如：每日），数据在更小的时间框架Y（例如：1分钟）可用。
数据回放的作用正如其名，使用1分钟数据回放每日条。虽然，这并不能完全再现市场发展，但比单独观察每日完成关闭的 Bar 要好得多。如果策略在每日 Bar 形成期间实时操作，那么近似 Bar 形成过程模拟策略在实际条件下的表现。
要实现数据回放，只按常规使用 backtrader 即可。
加载数据源； 使用 replaydata 将数据传递给cerebro； 添加策略； 注意： 数据回放不支持预加载，因为每个 Bar 实际上是实时构建的，任何 Cerebro 实例中都会自动禁用预加载。
可传递给replaydata的参数：
参数 默认值 描述 timeframe bt.TimeFrame.Days 目标时间框架，必须等于或大于源时间框架 compression 1 将选定值“n”压缩为1条 扩展参数（若无特别需要请勿修改）：
参数 默认值 描述 bar2edge True 使用时间边界作为闭合条的目标。例如，使用“ticks -&amp;gt; 5 seconds”时，生成的5秒条将对齐到xx:00、xx:05、xx:10…… adjbartime False 使用边界的时间调整传递的重采样条的时间，而不是最后看到的时间戳。 rightedge True 使用时间边界的右边缘设置时间。 举例说明，标准的 2006 年每日数据在每周基础上进行回放。
最终会有 52 个 Bar，即每周一个； Cerebro 将调用 prenext 和 next 共计255次，这是原始数量每日 Bar； 诀窍在于：
在每周 Bar 形成时，策略的长度（len(self)）保持不变。 每过一周，长度增加1。 以下是示例，但首先是测试脚本的主要部分，其中加载数据并将其传递给cerebro进行回放，然后运行。</description></item><item><title>跟踪止损（限价）</title><link>https://www.poloxue.com/backtrader/docs/09-orders/07-stop-trails/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/09-orders/07-stop-trails/</guid><description>跟踪止损（限价） # 版本 1.9.35.116 增加了跟踪止损和跟踪止损限价订单执行类型到回测工具中。
注意，这只在回测中实现，尚未在实时经纪商中实现
注意，更新至版本 1.9.36.116。Interactive Brokers 支持跟踪止损、跟踪止损限价和 OCO。
OCO 始终将组中的第一个订单指定为参数 oco
跟踪止损限价：经纪商模拟和 IB 经纪商具有相同的行为。指定：price 作为初始止损触发价格（也指定 trailamount），然后 plimit 作为初始限价。两者之间的差值将决定 limitoffset（限价与止损触发价格之间的距离）
使用模式完全集成到策略实例的标准买、卖和平仓市场操作方法中。需要注意：
指明所需的执行类型，如 exectype=bt.Order.StopTrail
以及跟踪价格是否需要用固定距离或百分比距离计算
固定距离：trailamount=10
百分比距离：trailpercent=0.02（即：2%）
如果通过发出买单进入市场多头，那么带有 StopTrail 和 trailamount 的卖单会这样做：
如果未指定价格，则使用最新的收盘价
从价格中减去 trailamount 以找到止损（或触发）价格
经纪商的下一次迭代检查是否触及触发价格
如果是：订单将以市场执行类型的方式执行
如果否，使用最新的收盘价重新计算止损价格，并减去 trailamount 距离
如果新价格上涨，则更新
如果新价格下跌（或不变），则忽略
也就是说：跟踪止损价格随着价格上涨而跟随，但如果价格开始下跌则保持不变，以潜在地确保利润。
如果进入市场时发出的是卖单，那么发出带 StopTrail 的买单会执行相反的操作，即：价格会向下跟随。
一些使用模式
# 对于向下的跟踪止损 # 将使用最后价格作为参考 self.buy(size=1, exectype=bt.Order.StopTrail, trailamount=0.25) # 或 self.buy(size=1, exectype=bt.Order.StopTrail, price=10.50, trailamount=0.25) # 对于向上的跟踪止损 # 将使用最后价格作为参考 self.sell(size=1, exectype=bt.Order.StopTrail, trailamount=0.25) # 或 self.</description></item><item><title>参数定义</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/08-parameters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/08-parameters/</guid><description>参数定义 # 前面的案例中，参数都是硬编码在策略中。本节将介绍如何在 backtrader 自定义参数。
定义参数 # 策略参数的定义非常简单，如在策略中定义两个参数：myparam 和 exitbars。
class TestStrategy: params = ((&amp;#39;myparam&amp;#39;, 27), (&amp;#39;exitbars&amp;#39;, 5),) 参数 myparam 的默认值是 27，exitbars 的默认值是 5。
配置参数 # 我们可以在添加策略时修改参数默认值。
# Add a strategy cerebro.addstrategy(TestStrategy, myparam=20, exitbars=7) 使用参数 # 策略代码中直接通过 self.params.param_name 即可调用参数。
如下代码，通过参数 exitbars 修改退出逻辑：
if len(self) &amp;gt;= (self.bar_executed + self.params.exitbars): 完整示例 # import backtrader as bt class TestStrategy(bt.Strategy): params = ( (&amp;#39;exitbars&amp;#39;, 5), ) def log(self, txt, dt=None): dt = dt or self.</description></item><item><title>数据滚动</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/08-datafeed-rollover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/08-datafeed-rollover/</guid><description>滚动 # 并非所有提供商都提供连续期货合约数据。有时提供的数据是仍在交易的到期合约的有效数据。这种情况下，进行回测会变得很不方便，因为数据分散在多个不同的合约上，并且这些合约还会在时间上重叠。
如果能够正确地将这些过去的合约数据连接成一个连续的数据流，可以缓解这种痛苦。问题在于：
没有一种最佳方法将不同到期日期的数据连接成一个连续的期货数据 有些文献，如 SierraChart的文章 滚动数据源 # 从backtrader 1.8.10.99开始，增加了将不同到期日期的期货数据连接成连续期货的功能：
import backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFeed(dataname=&amp;#39;Expiry0&amp;#39;) data1 = bt.feeds.MyFeed(dataname=&amp;#39;Expiry1&amp;#39;) ... dataN = bt.feeds.MyFeed(dataname=&amp;#39;ExpiryN&amp;#39;) drollover = cerebro.rolloverdata(data0, data1, ..., dataN, name=&amp;#39;MyRoll&amp;#39;, **kwargs) cerebro.run() 注意：
**kwargs将在下文解释 也可以直接访问RollOver数据源（如果需要子类化，这是很有帮助的）： import backtrader as bt cerebro = bt.Cerebro() data0 = bt.feeds.MyFeed(dataname=&amp;#39;Expiry0&amp;#39;) data1 = bt.feeds.MyFeed(dataname=&amp;#39;Expiry1&amp;#39;) ... dataN = bt.feeds.MyFeed(dataname=&amp;#39;ExpiryN&amp;#39;) drollover = bt.feeds.RollOver(data0, data1, ..., dataN, dataname=&amp;#39;MyRoll&amp;#39;, **kwargs) cerebro.adddata(drollover) cerebro.run() 注意：
使用RollOver时，使用dataname参数分配名称，这是所有数据源用于传递名称/代码的标准参数。在这种情况下，它被重用以给整个滚动的期货集分配一个通用名称。 对于cerebro.</description></item><item><title>技术指标</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/09-indicators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/09-indicators/</guid><description>技术指标（Indicators） # 本节将介绍如何使用技术指标，将技术指标作为入场和出场信号。我们将用简单移动平均线（Simple Moving Average），或称 SMA，作为演示指标。SMA 是一个非常简单的技术指标，计算一定周期的价格均值。
交易规则 # 基于 SMA 交易规则，定义如下所示：
入场条件： 当收盘价大于最新的 SMA，则入场买入。 出场条件： 当持有头寸，当收盘价小于 SMA，则出场卖出。 前面章节的策略代码大部分可复用，现在重点关注如何计算技术指标。
指标计算 # backtrader 下的 indicators 模块内置了大量技术指标的计算方法，如 SMA 简单移动均线的计算。
self.sma = bt.indicators.MovingAverageSimple(self.datas[0], period=self.params.maperiod) 如上代码中参数 self.params.maperiod 就是 SMA 的均线周期。
注：如果安装了 talib，backtrader 也集成了 talib 的支持，详情文档 指标-TALib。
条件判断 # 现在基于 self.sma 判断进出场条件。
为了简化代码，这里只考虑 SMA 的判断逻辑，在完整实例中会包含所有情况。
入场判断：
self.dataclose[0] &amp;gt; self.sma[0] 出场判断：
self.dataclose[0] &amp;lt; self.sma[0] 策略代码 # 起始现金 1000 货币单位。
import datetime # For datetime objects import os.</description></item><item><title>Yahoo 数据源说明</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/10-datafeed-yahoo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/10-datafeed-yahoo/</guid><description>Yahoo 数据源说明 # 在 2017 年 5 月，Yahoo 停用了现有的 CSV 格式的历史数据下载 API。
很快，新 API（这里称为 v7）被标准化并已实现。
这也带来了实际 CSV 下载格式的变化。
使用 v7 API/格式 # 从版本 1.9.49.116 开始，这是默认行为。可以简单地选择：
YahooFinanceData 用于在线下载 YahooFinanceCSVData 用于离线下载的文件 使用旧的 API/格式 # 要使用旧的 API/格式，可以：
在线 Yahoo 数据源实例化如下：
data = bt.feeds.YahooFinanceData( ... version=&amp;#39;&amp;#39;, ... ) 离线 Yahoo 数据源实例化如下：
data = bt.feeds.YahooFinanceCSVData( ... version=&amp;#39;&amp;#39;, ... ) 可能在线服务会恢复（服务在没有任何公告的情况下被停用……它也可能会恢复）
或者
仅用于在变更前下载的离线文件，也可以这样做：
data = bt.feeds.YahooLegacyCSV( ... ... ) 新的 YahooLegacyCSV 简化了使用 version='' 的操作。</description></item><item><title>可视化</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/10-plotting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/10-plotting/</guid><description>可视化 # 通过 print 输出每个 bar 的信息不利于我们阅读，我们还是更倾向于图表的视觉效果。backtrader 内置了图表绘制的能力，一行代码即可绘图。
cerebro.plot() 请确保在调用cerebro.run()之后执行，还有，backtrader 的绘图能力依赖 matplotlib。
演示 # 为了展示出基本的价格和收益外，我们将执行以下操作以展示绘图的功能和配置。
添加一个 EMA（指数移动平均线），默认情况下，它会与数据一起绘制。 添加一个 WMA（移动平均线加权），配置在子图绘制（即使没有意义）。 添加一个 StochasticSlow（慢速随机指标），不更改默认设置。 添加一个 MACD，不更改默认设置。 添加一个ATR，更改默认设置以避免绘图。 添加一个 RSI，不更改默认设置。 在 RSI 上添加一个 SMA 指标，不更改默认设置，且与RSI一起绘制。 在策略的 __init__ 方法中添加的所有内容：
# Indicators for the plotting show bt.indicators.ExponentialMovingAverage(self.datas[0], period=25) bt.indicators.WeightedMovingAverage(self.datas[0], period=25).subplot = True bt.indicators.StochasticSlow(self.datas[0]) bt.indicators.MACDHisto(self.datas[0]) rsi = bt.indicators.RSI(self.datas[0]) bt.indicators.SmoothedMovingAverage(rsi, period=10) bt.indicators.ATR(self.datas[0]).plot = False 即使将指标没有赋值到策略成员变量（如self.sma = MovingAverageSimple…），它们也会被注册到策略中，成为图表的一部分。
示例中，只有RSI被添加到临时变量rsi中，其目的是要在其上创建一个 SmoothedMovingAverage。
from __future__ import (absolute_import, division, print_function, unicode_literals) import datetime # For datetime objects import os.</description></item><item><title>Pandas 数据源示例</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/11-datafeed-pandas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/11-datafeed-pandas/</guid><description>Pandas 数据源示例 # 注意，需要安装 pandas 及其依赖项。支持 Pandas Dataframe 对很多人来说很重要，他们依赖于 Pandas 提供的不同数据源（包括 CSV）的解析代码及其他功能。
数据源的重要声明 # 注意
这些只是声明。不要盲目复制此代码。请参见下面的实际用法示例：
class PandasData(feed.DataBase): &amp;#39;&amp;#39;&amp;#39; ``dataname`` 参数继承自 ``feed.DataBase`` 是 pandas DataFrame &amp;#39;&amp;#39;&amp;#39; params = ( # datetime 的可能值（必须始终存在） # None : datetime 是 Pandas Dataframe 中的 &amp;#34;index&amp;#34; # -1 : 自动检测位置或大小写相同的名称 # &amp;gt;= 0 : pandas dataframe 中列的数值索引 # string : pandas dataframe 中的列名（作为索引） (&amp;#39;datetime&amp;#39;, None), # 下面是可能的值： # None : 列不存在 # -1 : 自动检测位置或大小写相同的名称 # &amp;gt;= 0 : pandas dataframe 中列的数值索引 # string : pandas dataframe 中的列名（作为索引） (&amp;#39;open&amp;#39;, -1), (&amp;#39;high&amp;#39;, -1), (&amp;#39;low&amp;#39;, -1), (&amp;#39;close&amp;#39;, -1), (&amp;#39;volume&amp;#39;, -1), (&amp;#39;openinterest&amp;#39;, -1), ) 上述 PandasData 类的片段展示了关键点：</description></item><item><title>策略优化</title><link>https://www.poloxue.com/backtrader/docs/03-quickstart/11-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/03-quickstart/11-optimization/</guid><description>策略优化 # 许多交易书籍中提到，每个市场和每个交易的股票（或商品等）都有不同的节奏，没有一种适合所有的策略。
在绘图示例前，当策略开始使用一个指标，周期默认值为 15 个 bar。这是一个策略参数，可以用于优化，改变参数值以找出哪个更适合你的市场。
注意：关于优化及其优缺点的文献很多。但建议基本是：不要过度优化。如果交易思路不健全，优化可能会产生一个仅对回测数据集有效的正面结果。
示例修改为优化简单移动平均线的周期。为了清晰起见，已删除与买卖订单相关的任何输出。
示例如下：
import datetime #For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) import backtrader as bt class TestStrategy(bt.Strategy): params = ( (&amp;#39;maperiod&amp;#39;, 15), (&amp;#39;printlog&amp;#39;, False), ) def log(self, txt, dt=None, doprint=False): if self.params.printlog or doprint: dt = dt or self.datas[0].datetime.date(0) print(&amp;#39;%s, %s&amp;#39; % (dt.isoformat(), txt)) def __init__(self): self.dataclose = self.</description></item><item><title>数据源参考</title><link>https://www.poloxue.com/backtrader/docs/06-datafeed/12-datafeed-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/docs/06-datafeed/12-datafeed-reference/</guid><description>数据源参考 # AbstractDataBase # 数据行（Lines）:
close low high open volume openinterest datetime 参数（Params）:
dataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.0) calendar (None) BacktraderCSVData # 解析用于测试的自定义 CSV 数据。
特定参数：
dataname: 要解析的文件名或类文件对象 数据行：
close low high open volume openinterest datetime 参数：
dataname (None) name () compression (1) timeframe (5) fromdate (None) todate (None) sessionstart (None) sessionend (None) filters ([]) tz (None) tzinput (None) qcheck (0.</description></item><item><title/><link>https://www.poloxue.com/backtrader/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/backtrader/readme/</guid><description>Fyne 中文文档 # Backtrader 是一款 Python 实现量化回测框架，本文档是基于 Backtrader4的官方文档中文翻译版。英文原版，请异步 backtrader.com。</description></item></channel></rss>