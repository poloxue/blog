<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>POLOXUE's 博客频道</title><link>https://www.poloxue.com/</link><description>Recent content on POLOXUE's 博客频道</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>2023 Polo Xue All rights reserved</copyright><lastBuildDate>Thu, 28 Oct 2021 13:35:05 +0800</lastBuildDate><atom:link href="https://www.poloxue.com/index.xml" rel="self" type="application/rss+xml"/><item><title>2021 10 23 Build Your Own Webframework in Golang Part 2</title><link>https://www.poloxue.com/posts/coder/2021-10-28-build-your-own-webframework-in-golang-part-2/</link><pubDate>Thu, 28 Oct 2021 13:35:05 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2021-10-28-build-your-own-webframework-in-golang-part-2/</guid><description>本文是构建 Go Web 框架的第二篇，目标是介绍中间件的最佳实践，访问原文。
译文如下：
在编写 Go Web 应用时，代码重复是大多数开发者将会遇到的第一个问题。
为什么呢？
原因在于，在处理 request 时，诸如记录请求、将应用程序错误转换为 HTTP 500 错误、验证用户等一些操作，这是每个处理程序都要执行的动作。
本文是 &amp;ldquo;构建属于自己的 Web 框架&amp;rdquo; 系列文章中的第二篇：
第 1 部分：简介 第 2 部分：Go 中间件：最佳实践和示例 第 3 部分：中间件数据共享 第 4 部分：第三方路由 第 5 部分：使用 MongoDB 实现 JSON-API 附加福利：上传文件到 s3 基础入门 首先，使用 net/http 包创建一个简单版本的 HTTP Server 应用。
代码如下：
import ( &amp;#34;net/http&amp;#34; &amp;#34;fmt&amp;#34; ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Welcome!&amp;#34;) } func main() { http.HandleFunc(&amp;#34;/&amp;#34;, handler) http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) } 阅读以上代码，我们看出 http.</description></item><item><title>从头构建 Go Web 框架（一）：介绍</title><link>https://www.poloxue.com/posts/coder/2021-10-23-build-your-own-webframework-in-golang/</link><pubDate>Sat, 23 Oct 2021 20:33:14 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2021-10-23-build-your-own-webframework-in-golang/</guid><description>本文写于 2014 年，对于 golang 十几年的发展历程而言，这已经是古董级别的一篇文章了，但通用的思想概念依然没有变。
我希望通过这个系列文章，让大家都现有的 Go Web 框架能有更深的认识。
访问：原文地址，译文如下：
Martini 发布之后，迅速成为了最受大家欢迎的 Go 语言 Web 框架，且现在依旧是如此。但必须指出的是，它不符合常规习惯，非常慢，概念也有不足。它教了我们一堆错误的做法。但因为它上手容易，许多开发人员仍在使用。
似乎是存在即合理！
我决定写一系列文章，基于现有库从头编写组件来构建自己的 Web 框架。在开始前，我搜罗和阅读了市面上绝大部分关于如何编写 Go Web 应用的资料。我希望，通过系列文章能教授 Go Web 开发人员一些最佳实践，同时能提醒老 Go 开发人员什么才是 Web 开发的最佳实践。
注：每个项目都是具有独特性的，最佳实践并非适用于所有场景。
概要 本系列不仅能让你了解 Go 中 Web 开发的最佳实践，还会让你了解其他常见问题的解决方案及如何正确运用。
第 1 部分：简介 第 2 部分：Go 中间件：最佳实践和示例 第 3 部分：中间件数据共享 第 4 部分：第三方路由 第 5 部分：使用 MongoDB 实现 JSON-API 附加福利：上传文件到 s3 框架该具备什么能力 市面主要有两种类型的 Web 框架。
一种是内置所有功能，类似 Rails 的框架，能帮你快速构建与引导项目。Go 中类似框架有：Beego 和 Revel。
另一种，类似于 Sinatra 的框架，提供路由和一些内置功能，但不会提供 ORM 等功能。 多数 Go 框架都采用了这种风格，如 Martini、Goji、gocraft/web 等。</description></item><item><title>Go 如何实现 HTTP 文件上传</title><link>https://www.poloxue.com/posts/coder/2019-12-10-golang-http-upload-file/</link><pubDate>Tue, 10 Dec 2019 15:25:18 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-12-10-golang-http-upload-file/</guid><description>早前写过一篇文章，Go HTTP 请求 QuickStart。当时，主要参考 Python 的 requests 大纲介绍 Go 的 net/http 如何发起 HTTP 请求。
最近，尝试录成它的视频，访问地址。发现当时写得挺详细的，发现当时虽然写得比较详细，但也只是介绍用法，可能不知其所以然。比如文件上传那部分，如果不了解 http 文件上传协议 RFC 1867，就很难搞懂为什么代码这么写。
今天，就以这个话题为基础，介绍下 Go 如何实现文件上传。
相关代码请访问 httpdemo/post。本文视频地址：Go 上传文件
简介 简单来说，HTTP 上传文件可以分三个步骤，分别是组织请求体，设置 Content-Type 和发送 Post 请求。POST 请求就不用介绍了，主要关注请求体和请求体内容类型。
请求体，即 request body，常用于 POST 请求上。请求体并非 POST 特有，GET 也支持，只不过约定俗成的规定，服务端一般会忽略 GET 的请求体。
Content-Type 是什么？
因为，请求体的格式并不固定，可能性很多，为了明确请求体内容类型，HTTP 定义了一个请求头 Content-Type。
常见的 Content-Type 选项有 application/x-www-form-urlencoded（默认的表单提交）、application/json（json）、text/xml（xml 格式）、text/plain（纯文本）、application/octet-stream（二进制流）等。
提交表单 文件上传可以理解为是提交表单的特例，先通过表单提交这个简单的例子介绍下整个流程。
如下是表单提交的 HTTP 请求文本。
POST http://httpbin.org/post HTTP/1.1 Content-Type: application/x-www-form-urlencoded username=poloxue&amp;amp;password=123456 Content-Type 是 application/x-www-form-urlencoded，数据通过 urlencoded 方式组织。
先用 html 的 form 表单实现。如下：</description></item><item><title>Go 命令行解析 flag 包之快速上手</title><link>https://www.poloxue.com/posts/coder/2019-11-23-commandline-tool-flag-in-golang/</link><pubDate>Sat, 23 Nov 2019 16:21:33 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-11-23-commandline-tool-flag-in-golang/</guid><description>本篇文章是 Go 标准库 flag 包的快速上手篇。
概述 开发一个命令行工具，视复杂程度，一般要选择一个合适的命令行解析库，简单的需求用 Go 标准库 flag 就够了，flag 的使用非常简单。
当然，除了标准库 flag 外，也有不少的第三方库。比如，为了替代 flag 而生的 pflag，它支持 POSIX 风格的命令行解析。关于 POSIX 风格，本文末尾有个简单的介绍。
更多与命令行处理相关的库，可以打开 awesome-go#command-line 命令行一节查看，star 最多的是 spf13/cobra 和 urfave/cli ，与 flag / pflag 相比，它们更加复杂，是一个完全的全功能的框架。
有兴趣都可以了解下。
目标案例 回归主题，继续介绍 flag 吧。通过案例介绍包的使用会比较直观。
举一个例子说明吧。假设，现在要开发一个 Go 语言环境的版本管理工具，gvg（go version management by go）。
命令行的帮助信息如下：
NAME: gvg - go version management by go USAGE: gvg [global options] command [command options] [arguments...] VERSION: 0.0.1 COMMANDS: list list go versions install install a go version info show go version info use select a version uninstall uninstall a go version get get the latest code uninstall uninstall a go version help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --help, -h show help --version, -v print the version 这个命令不仅包含了全局的选项，还有 8 个子命令，部分子命令支持参数和选项。暂时，子命令的选项参数先不列出来了，实现时再看。</description></item><item><title>详细介绍 Go 中如何实现 bitset</title><link>https://www.poloxue.com/posts/coder/2019-11-07-bitset-in-golang/</link><pubDate>Thu, 07 Nov 2019 19:37:26 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-11-07-bitset-in-golang/</guid><description>最近尝试在 B 站录些小视频，我的 B 站主页。录视频当是为了彻底搞懂某个知识点的最后一步吧，同时也希望能习得一些额外的能力。在讲 Go 如何实现 bitset 的时候，发现这块内容有点难讲。思考后，我决定通过文字辅以视频的方式说明，于是就写了这篇文章。
相关代码已经放在了 github，地址如下：go-set-example
如果发现有什么不妥的地方，欢迎大佬们指正，感谢。
bitset 结构 之前我已经写过一篇题为 Go 中如何使用 Set 的文章，其中介绍了 bitset 一种最简单的应用场景，状态标志位，顺便还提了下 bitset 的实现思路。
状态标志和一般的集合有什么区别呢？
我的总结是主要一点，那就是状态标志中元素个数通常是固定的。而一般的集合中，元素个数通常是动态变化的。这会导致什么问题？
一般，我们使用一个整数就足以表示状态标志中的所有状态，最大的 int64 类型，足足有 64 个二进制位，最多可以包含 64 个元素，完全足够使用。但如果是集合，元素数量和值通常都不固定。
比如一个 bitset 集合最初可能只包含 1、2、4 几个元素，只要一个 int64 就能表示。如下：
但如果再增加了一个元素，比如 64（一个 int64 的表示范围是 0-63），这已经超出了一个 int64 能表示的范围。该怎么办？
一个 int64 无法表示，那就用多个呗。此时的结构如下：
一个 int64 切片正好符合上面的结构。那我们就可以定义一个新的类型 BitSet，如下：
type BitSet struct { data []int64 size int } data 成员用于存放集合元素，切片的特点就是能动态扩容。
还有，因为 bitset 中元素个数无法通过 len 函数获取，而具体的方法相对复杂一点，可增加一个 size 字段记录集合元素的个数。然后就可以增加一个 Size 方法。</description></item><item><title>Go Module 依赖关系的可视化</title><link>https://www.poloxue.com/posts/coder/2019-10-23-golang-module-visualization/</link><pubDate>Wed, 23 Oct 2019 08:21:35 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-10-23-golang-module-visualization/</guid><description>最近，我开发了一个非常简单的小工具，总的代码量 200 行不到。今天，简单介绍下它。这是个什么工具呢？它是一个用于可视化展示 Go Module 依赖关系的工具。
为何开发 为什么会想到开发这个工具？主要有两点原因：
一是最近经常看到大家在社区讨论 Go Module。于是，我也花了一些时间研究了下。期间，遇到了一个需求，如何清晰地识别模块中依赖项之间的关系。一番了解后，发现了 go mod graph。
效果如下：
$ go mod graph github.com/poloxue/testmod golang.org/x/text@v0.3.2 github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0 github.com/poloxue/testmod rsc.io/sampler@v1.3.1 golang.org/x/text@v0.3.2 golang.org/x/tools@v0.0.0-20180917221912-90fa682c2a6e rsc.io/quote/v3@v3.1.0 rsc.io/sampler@v1.3.0 rsc.io/sampler@v1.3.1 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c rsc.io/sampler@v1.3.0 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c 每一行的格式是 模块 依赖模块，基本能满足要求，但总觉得还是不那么直观。
二是我之前手里有一个项目，包管理一直用的是 dep。于是，我也了解了下它，把官方文档仔细读了一遍。其中的某个章节介绍了依赖项可视化展示的方法。
文档中给出的包关系图：
看到这张图的时候，眼睛瞬间就亮了，图形化就是优秀，不同依赖之间的关系一目了然。这不就是我想要的效果吗？666，点个赞。
但 &amp;hellip;，随之而来的问题是，go mod 没这个能力啊。怎么办？
如何实现 先看看是不是已经有人做了这件事了。网上搜了下，没找到。那是不是能自己实现？应该可以借鉴下 dep 的思路吧？
如下是 dep 依赖实现可视化的方式：
# linux $ sudo apt-get install graphviz $ dep status -dot | dot -T png | display # macOS $ brew install graphviz $ dep status -dot | dot -T png | open -f -a /Applications/Preview.</description></item><item><title>Go 的 Http 请求系统指南</title><link>https://www.poloxue.com/posts/coder/2019-09-10-the-guide-for-go-http-client/</link><pubDate>Tue, 10 Sep 2019 16:37:17 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-09-10-the-guide-for-go-http-client/</guid><description>前几天在 &amp;ldquo;知乎想法&amp;rdquo; 谈到了一个话题，如何模仿学习，举了通过 net/http client 模仿 Pyhton 的requests的例子。但并未实践，难道想法真的只能是想法吗？当然不是，于是我决定先暂停一周 GO 笔记，来实践下自己的想法。
有些新的知识，我们可以通过模仿学习
本文将通过 GO 实现 requests 的 quick start 文档中的所有例子，系统学习http client的使用。虽然标题是 quick start，但其实内容挺多的。
快速体验 首先，我们来发起一个 GET 请求，代码非常简单。如下：
func get() { r, err := http.Get(&amp;#34;https://api.github.com/events&amp;#34;) if err != nil { panic(err) } defer func() { _ = r.Body.Close() }() body, _ := ioutil.ReadAll(r.Body) fmt.Printf(&amp;#34;%s&amp;#34;, body) } 通过 http.Get 方法，获取到了一个 Response 和一个 error ，即 r 和 err。通过 r 我们能获取响应的信息，err 可以实现错误检查。
r.Body 被读取后需要关闭，可以defer来做这件事。内容的读取可通过 ioutil.ReadAll实现。</description></item><item><title>如何防止你的 Goroutine 泄露(二)</title><link>https://www.poloxue.com/posts/coder/2019-06-17-prevent-goroutine-from-leaking-part-2/</link><pubDate>Mon, 17 Jun 2019 13:41:42 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-06-17-prevent-goroutine-from-leaking-part-2/</guid><description>上篇文章说到，防止 goroutine 泄露可从两个角度出发，分别是代码层面的预防与运行层面的监控检测。今天，我们来谈第二点。
简述 前文已经介绍了一种简单检测 goroutine 是否泄露的方法，即通过 runtime.NumGoroutine 获取当前运行中的 goroutine 数量粗略估计。但 NumGoroutine 是否真的能确定我们代码存在泄露，除此之外，还有没有其他更优的方式吗。
注：为了更好的演示效果，下面将会用常驻的 http 作为示例。
NumGoroutine runtime.NumGoroutine 可以获取当前进程中正在运行的 goroutine 数量，观察这个数字可以初步判断出是否存在 goroutine 泄露异常。
一个示例，如下：
package main import ( &amp;#34;net/http&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strconv&amp;#34; ) func write(w http.ResponseWriter, data []byte) { _, _ = w.Write(data) } func count(w http.ResponseWriter, r *http.Request) { write([]byte(strconv.Itoa(runtime.NumGoroutine()))) } func main() { http.HandleFunc(&amp;#34;/_count&amp;#34;, count) http.ListenAndServe(&amp;#34;:6080&amp;#34;, nil) } 功能很简单，设置 _count 路由请求处理函数 count，它负责输出服务当前 goroutine 数量。启动服务后访问 localhost:6080/_count 即可。
但只是一个数值，我们就能确认是否泄露了吗？
首先，如果这个数值很大，是不是就能说明出现了泄露。我的答案是否。理由很简单，高并发情况下的 goroutine 数量肯定很高的，但并非出现了泄露，可能只是当前的服务的承载能力还不够。我们可以在数量基础上引入时间，即如果 goroutine 随着时间增加，数量在不断上升，而基本没有下降，基本可以确定存在泄露。我们可以定时采集不同时刻的数据来分析。</description></item><item><title>如何防止你的 Goroutine 泄露</title><link>https://www.poloxue.com/posts/coder/2019-06-10-prevent-goroutine-from-leaking/</link><pubDate>Mon, 10 Jun 2019 13:40:37 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-06-10-prevent-goroutine-from-leaking/</guid><description>今天简单谈谈，Go 如何防止 goroutine 泄露。
概述 Go 的并发模型与其他语言不同，虽说它简化了并发程序的开发难度，但如果不了解使用方法，常常会遇到 goroutine 泄露的问题。虽然 goroutine 是轻量级的线程，占用资源很少，但如果一直得不到释放并且还在不断创建新协程，毫无疑问是有问题的，并且是要在程序运行几天，甚至更长的时间才能发现的问题。
对于上面描述的问题，我觉得可以从两方面入手解决，如下：
一是预防，要做到预防，我们就需要了解什么样的代码会产生泄露，以及了解正确的写法是如何的；
二是监控，虽说预防减少了泄露产生的概率，但没有人敢说自己不犯错，因而，通常我们还需要一些监控手段进一步保证程序的健壮性；
接下来，我将会分两篇文章分别从这两个角度进行介绍，今天先谈第一点。
如何监控泄露 本文主要集中在第一点上，但为了更好的演示效果，可以先介绍一个最简单的监控方式。通过 runtime.NumGoroutine() 获取当前运行中的 goroutine 数量，通过它确认是否发生泄漏。它的使用非常简单，就不为它专门写个例子了。
一个简单的例子 语言级别的并发支持是 Go 的一大优势，但这个优势也很容易被滥用。通常我们在开始 Go 并发学习时，常常听别人说，Go 的并发非常简单，在调用函数前加上 go 关键词便可启动 goroutine，即一个并发单元，但很多人可能只听到了这句话，然后就出现了类似下面的代码：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;time&amp;#34; ) func sayHello() { for { fmt.Println(&amp;#34;Hello gorotine&amp;#34;) time.Sleep(time.Second) } } func main() { defer func() { fmt.Println(&amp;#34;the number of goroutines: &amp;#34;, runtime.NumGoroutine()) }() go sayHello() fmt.Println(&amp;#34;Hello main&amp;#34;) } 对 Go 比较熟悉的话，很容易发现这段代码的问题，sayHello 是个死循环，没有如何退出机制，因此也就没有任何办法释放创建的 goroutine。我们通过在 main 函数最前面的 defer 实现在函数退出时打印当前运行中的 goroutine 数量，毫无意外，它的输出如下：</description></item><item><title>Golang 中如何使用 Set</title><link>https://www.poloxue.com/posts/coder/2019-06-03-set-in-golang/</link><pubDate>Mon, 03 Jun 2019 13:57:26 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-06-03-set-in-golang/</guid><description>今天来聊一下 Go 如何使用 set，本文将会涉及 set 和 bitset 两种数据结构。
注：花了点时间，将这个专题录制成了视频，上B 站查看 视频。
Go 的数据结构 Go 内置的数据结构并不多。工作中，我们最常用的两种数据结构分别是 slice 和 map，即切片和映射。 其实，Go 中也有数组，切片的底层就是数组，只不过因为切片的存在，我们平时很少使用它。
除了 Go 内置的数据结构，还有一些数据结构是由 Go 的官方 container 包提供，如 heap 堆、list 双向链表和ring 回环链表。但今天我们不讲它们，这些数据结构，对于熟手来说，看看文档就会使用了。
我们今天将来聊的是 set 和 bitset。据我所知，其他一些语言，比如 Java，是有这两种数据结构。但 Go 当前还没有以任何形式提供。
实现思路 先来看一篇文章，访问地址 2 basic set implementations 阅读。文中介绍了两种 go 实现 set 的思路， 分别是 map 和 bitset。
有兴趣可以读读这篇文章，我们接下来具体介绍下。
map 我们知道，map 的 key 肯定是唯一的，而这恰好与 set 的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现 set，在检查是否存在某个元素时可直接使用 _, ok := m[key] 的语法，效率高。</description></item><item><title>Go 虚拟环境管理工具 gvm</title><link>https://www.poloxue.com/posts/coder/2019-05-27-golang-virtualenv-tool-gvm/</link><pubDate>Mon, 27 May 2019 12:57:35 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-05-27-golang-virtualenv-tool-gvm/</guid><description>本文谈下我对 Go 版本管理的一些思考，并给大家介绍一个小工具，gvm。这个话题说起来也很简单，但如果想用的爽，还是要稍微梳理下。
背景介绍 Go 的版本管理，并非包的依赖管理。平时的工作中，很多时候并不会遇到这样的需求，所以可能并不是很明白它的价值。
简单说下我写这篇文章的背景吧。
最近几周，Go 最重要的一则消息应该莫过 9月份 Go 1.13 的正式发布。它的相关升级可查看 Go 1.13 正式发布，看看都有哪些值得关注的特性 或官方 Go 1.13 Relase Notes。
对于一名 gopher 而言，可能早已按捺不住自己那颗躁动的心，想尽快体验下新版的升级项。但问题是，切换至新版 Go 通常会遇到一些问题，比如不同版本的环境配置，安装的辅助工具和程序包在不同版本下可能会存在兼容或被覆盖等问题。
我自然就希望有一套方案可以帮助我完成 Go 版本的切换，实现不同版本间环境的完全隔离。
思考方案 谈到环境隔离，有很多方案可供选择，如多主机、虚拟机、容器等技术。这些听起来都挺不错，都能实现需求。但如果只是为了 Go 版本管理，完全可以自己实现。
多版本切换，主要是不同版本环境变量的隔离。Go 1.10 之前，我们关心的变量有 GOROOT、GOPATH 和 PATH。Go 1.10 之后，GOROOT 已经默认为 go 的当前安装路径，只要考虑 GOPATH 和 PATH 即可。
最近，刚答过一个关于 Go 环境变量的问题，查看回答。其中对每个变量的作用进行了比较细致的描述。
如何实现 现在，我要实现我自己电脑上的两个版本的 Go 自由切换，该如何做呢？
假设它们分别位于 ~/.goversions/sdk/ 目录下的 go1.11/ 和 go1.13/。我现在要启用 go 1.11，运行如下命令即可：
$ export PATH=~/.goversions/sdk/go1.11/bin/:$PATH 此时，GOROOT 已经自动识别，为 ~/.goversions/sdk/go1.11/。Go 相关的工具链，源码，标准库都在这个目录下。</description></item><item><title>详细聊聊如何安装 Go</title><link>https://www.poloxue.com/posts/coder/2019-04-15-install-golang/</link><pubDate>Mon, 15 Apr 2019 20:05:26 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2019-04-15-install-golang/</guid><description>本篇文章进入 Go 的开发环境搭建系列。
我们知道，编写任何语言的代码都离不开两样工具，语言开发包和代码编辑工具。
今天先来聊聊如何安装 Go。
我们或许都会觉得这种事非常简单，不值得写篇文章介绍。最初我也是这么想的。但深入了解下来，渐渐感觉这也是一件很有意思的事情。
如何安装 和其他语言的安装类似，Go 的安装我们也可以采用三种方式进行，从简单到复杂依次是通过系统方式安装、官方二进制包安装和源码编译安装。
系统方式 不同操作系统通常都会为 Go 提供相应的软件安装方式。这种方式很大程度上简化了安装过程，能为我们省去一些繁杂的步骤。下面分别介绍下不同系统下的安装方式：
windows
在windows下，软件安装通常可通过下载类似 setup.exe/msi 软件包来操作。按照导航的提示，不断执行 &amp;ldquo;下一步&amp;rdquo; &amp;ldquo;下一步&amp;rdquo; 即可完成。访问 下地地址 将看到如下内容：
选择其中的 &amp;ldquo;Microsoft Windows&amp;rdquo; 下载 windows 安装包。现在的系统基本都是64位的了，一般情况下不用考虑 32/64 位系统的问题。
下载好了安装包，点击启动执行，接下来的步骤就是按导航提示一步步操作即可。有一点要注意的是，GO的默认安装在 C:\GO，如果要修改默认安装路径，在见到如下界面时重新选择。
ubuntu/debian
在debian或ubuntu上，我们可使用 apt-get 命令安装go。比如，在Ubuntu 16.04.5 LTS系统，使用如下命令安装：
sudo apt-get update // 视情况决定是否更新 sudo apt-get install golang-go 如果是新建的系统，建议先update下软件源。否则可能会因为某些源异常而无法顺利安装。
centos/redhat
在centos或redhat上，我们可以使用yum命令安装go。比如，在CentOS 7.5上，使用如下命令安装：
$ yum epel-release $ yum install golang 先下载了epel-releaes源，可防止出现yum安装golang不支持或版本太旧的问题。
macos
在macos上，我们可使用pkg文件或homebrew安装go。
pkg的安装方式与windows的setup.exe/msi的类似，下载软件然后按导航 &amp;ldquo;下一步&amp;rdquo; &amp;ldquo;下一步&amp;rdquo; 即可完成。
来说说如何使用homebrew安装。和yum和apt-get不同，homebrew并非mac系统自带，我们需要先安装。进入homebrew官网，页面顶部便说明了安装的方式，命令如下：
/usr/bin/ruby -e &amp;#34;$(curl -fsSL https://raw.</description></item><item><title>一文精通 crontab 从入门到出坑</title><link>https://www.poloxue.com/posts/coder/2016-12-31-crontab-from-scratch/</link><pubDate>Sat, 31 Dec 2016 18:01:00 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2016-12-31-crontab-from-scratch/</guid><description>此篇技术博文主要介绍的是 crontab， Linux 下的计划任务管理工具。涉及内容包括 crontab 使用配置、常见坑的分析和编者总结的错误调试方法。
我的理解，后台任务通常分为两种：常驻和定时。之前的文章《pm2进程管理工具使用总结》主要针对的是常驻任务。今天来谈谈 crontab，主要针对的是定时任务。
实验环境： centos7
介绍crontab crontab的服务进程名为crond，英文意为周期任务。顾名思义，crontab在Linux主要用于周期定时任务管理。通常安装操作系统后，默认已启动crond服务。crontab可理解为cron_table，表示cron的任务列表。类似crontab的工具还有at和anacrontab，但具体使用场景不同，可参见附录《让你学会Linux计划任务》一文了解更多。
关于crontab的用途很多，如
定时系统检测； 定时数据采集； 定时日志备份； 定时更新数据缓存； 定时生成报表； &amp;hellip; 等等任务 当然，更多使用场景是要以视具体情况而定了。毕竟是工具通常都是常用规则总结而成的产物。
确认crond服务已经安装与开启之后，下面开始具体说明
简单示例 先来个简单示例体验一下。
目标：每分钟向/tmp/time.txt文件下写入当前时间 新建crontab任务 $ crontab -e // 打开crontab任务编辑 * * * * * date &amp;gt;&amp;gt; /tmp/time.txt 静静等待几分钟 $ cat /tmp/time.txt Do 29. Dez 22:45:01 CST 2016 Do 29. Dez 22:46:01 CST 2016 Do 29. Dez 22:47:01 CST 2016 从上面结果看出，每分钟执行了date并写入到/tmp/time.txt。 简单示例演示成功。下面从细节深入说明crontab使用。
使用选项 上面的实验中使用了crontab命令的-e选项。我们来看看crontab命令中有哪些选项?
-e 选项 表示打开当前用户的crontab任务列表配置文件。当然也可以直接打开，路径通常是在/var/spool/cron/下，文件以用户名命名，如/var/spool/cron/root。不过，采用-e方式打开，福利是可以帮助我们自动检查任务配置符合规则。
-u 选项 指定某用户的任务列表，很好理解。比如我当前是root用户，想操作poloxue用户的任务列表。如下：</description></item><item><title>循序渐进 MySQL 事务隔离级别</title><link>https://www.poloxue.com/posts/coder/2016-12-10-isolation-in-mysql/</link><pubDate>Sat, 10 Dec 2016 18:14:45 +0800</pubDate><guid>https://www.poloxue.com/posts/coder/2016-12-10-isolation-in-mysql/</guid><description>本篇文章的重点在于总结MYSQL事务。
什么是事务 事务简言之就是一组 SQL 执行要么全部成功，要么全部失败。MYSQL 的事务在存储引擎层实现。
事务都有 ACID 特性：
原子性（Atomicity）：一个事务必须被视为一个不可分割的单元； 一致性（Consistency）：数据库总是从一种状态切换到另一种状态； 隔离性（Isolation）：通常来说，事务在提交前对于其他事务不可见； 持久性（Durablity）：一旦事务提交，所做修改永久保存数据库； 事务最常用的例子就是银行转账。假设 polo 需给 lynn 转账1000元，如下步骤：
确认 polo 账户余额高于1000元； 从 polo 的账户余额减去1000元； 将 lynn 的账户余额增加1000元； SQL语句如下:
mysql&amp;gt; BEGIN; mysql&amp;gt; SELECT balance FROM bank_account WHERE uid=10001; mysql&amp;gt; UPDATE bank_account SET balance=balance-1000 WHERE uid=10001; mysql&amp;gt; UPDATE bank_account SET balance=balance+1000 WHERE uid=10002; mysql&amp;gt; COMMIT; mysql 启动事务可使用 BEGIN 或 START TRANSACTION；上述三个步骤执行在一个事务中就能够保证数据的完整性，要么全部成功，要么全部失败。
MYSQL 提供两种事务型引擎：Innodb 和 NDBCluster。默认采用自动提交模式，执行一条语句自动 COMMIT。通过 AUTOCOMMIT 变量可启用或者禁用自动提交模式：
mysql&amp;gt; SHOW VARIABLES LIKE &amp;#34;AUTOCOMMIT&amp;#34;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0.</description></item><item><title/><link>https://www.poloxue.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.poloxue.com/about/</guid><description>关于我 POLOXUE - 十三年编程经验的程序员一枚。</description></item></channel></rss>