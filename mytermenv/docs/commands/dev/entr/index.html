<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="entr - 实现语言无关热重启 # hi
在开发类似于 web 或其他常驻服务时，我们在修改代码后，要手动重启才能更新服务。如果你不是这种情况，或许框架默认支持热重启或是你集成了其他工具。
本文将介绍一款工具，它能轻松实现简单的热重启，它具有语言和框架无关性，是一个通用小工具，它就是 entry。
特别说明，这个工具主要是用在开发调试阶段，不支持复杂的热重启能力。
什么 entry # 简单来说，它是一个可监听文件状态变化并执行特定动作的命令。让我们直接通过演示观察它的行为。
$ ls text.txt | entr echo &#34;file changed&#34; 我们通过 ls text.txt 告诉 entry 监听的文件。当编辑并保存文件后，它通过指定命令 echo 打印提示 file changed。
我们只要对它稍做修改，就可以实现在监听到文件变化后，自动执行 停止服务 -> 重新编译 -> 启动服务 等一系列动作。
安装 # # mac 安装命令 brew install entr 实现热重启 # 首先，开发一个简单 Go server 服务，文件是 main.go，代码如下：
package main import ( &#34;fmt&#34; &#34;net/http&#34; ) func main() { http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, req *http."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="entr - 实现语言无关热重启"><meta property="og:description" content="entr - 实现语言无关热重启 # hi
在开发类似于 web 或其他常驻服务时，我们在修改代码后，要手动重启才能更新服务。如果你不是这种情况，或许框架默认支持热重启或是你集成了其他工具。
本文将介绍一款工具，它能轻松实现简单的热重启，它具有语言和框架无关性，是一个通用小工具，它就是 entry。
特别说明，这个工具主要是用在开发调试阶段，不支持复杂的热重启能力。
什么 entry # 简单来说，它是一个可监听文件状态变化并执行特定动作的命令。让我们直接通过演示观察它的行为。
$ ls text.txt | entr echo &#34;file changed&#34; 我们通过 ls text.txt 告诉 entry 监听的文件。当编辑并保存文件后，它通过指定命令 echo 打印提示 file changed。
我们只要对它稍做修改，就可以实现在监听到文件变化后，自动执行 停止服务 -> 重新编译 -> 启动服务 等一系列动作。
安装 # # mac 安装命令 brew install entr 实现热重启 # 首先，开发一个简单 Go server 服务，文件是 main.go，代码如下：
package main import ( &#34;fmt&#34; &#34;net/http&#34; ) func main() { http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, req *http."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/mytermenv/docs/commands/dev/entr/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-04-08T18:00:37+08:00"><title>entr - 实现语言无关热重启 | 我的终端环境</title><link rel=manifest href=/mytermenv/manifest.json><link rel=icon href=/mytermenv/favicon.png><link rel=canonical href=https://www.poloxue.com/mytermenv/docs/commands/dev/entr/><link rel=stylesheet href=/mytermenv/book.min.4f0117e74e5337280f18eb9641eae520cb4b25adcf5dd64fafad4664145a5957.css integrity="sha256-TwEX505TNygPGOuWQerlIMtLJa3PXdZPr61GZBRaWVc=" crossorigin=anonymous><script defer src=/mytermenv/flexsearch.min.js></script>
<script defer src=/mytermenv/en.search.min.1ff2efa015fc77410d6bc6555be1bd945c5f7c1f6e6b235fe6fcdf7b6608252b.js integrity="sha256-H/LvoBX8d0ENa8ZVW+G9lFxffB9uayNf5vzfe2YIJSs=" crossorigin=anonymous></script>
<script defer src=/mytermenv/sw.min.f888ca3f1a884bc850259e210b912f7631cc5beedc2fa1e324653bab31b8871a.js integrity="sha256-+IjKPxqIS8hQJZ4hC5EvdjHMW+7cL6HjJGU7qzG4hxo=" crossorigin=anonymous></script>
<script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/mytermenv/><img src=/mytermenv/logo.png alt=Logo><span>我的终端环境</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-fba4a8db7261d54d261a0776b385c4b7 class=toggle>
<label for=section-fba4a8db7261d54d261a0776b385c4b7 class="flex justify-between"><a href=/mytermenv/docs/terminal/>iTerm2</a></label><ul><li><a href=/mytermenv/docs/terminal/hello/>简要介绍</a></li><li><a href=/mytermenv/docs/terminal/install/>安装与主题</a></li><li><a href=/mytermenv/docs/terminal/usage/>开始使用</a></li><li><a href=/mytermenv/docs/terminal/pyapi/>Python API</a></li></ul></li><li><input type=checkbox id=section-0f880db9bf74f7d21521e992a6c21656 class=toggle>
<label for=section-0f880db9bf74f7d21521e992a6c21656 class="flex justify-between"><a href=/mytermenv/docs/zsh/>zsh</a></label><ul><li><a href=/mytermenv/docs/zsh/why/>为什么选择 zsh ？</a></li><li><a href=/mytermenv/docs/zsh/install/>快速安装</a></li></ul></li><li><input type=checkbox id=section-3cbc02454a3859bda006f4f5dbaa0992 class=toggle>
<label for=section-3cbc02454a3859bda006f4f5dbaa0992 class="flex justify-between"><a href=/mytermenv/docs/ohmyzsh/>ohmyzsh</a></label><ul><li><a href=/mytermenv/docs/ohmyzsh/install/>安装与主题</a></li><li><a href=/mytermenv/docs/ohmyzsh/basicplugins/>基础插件</a></li><li><a href=/mytermenv/docs/ohmyzsh/basicplugins2/>基础插件 2</a></li><li><a href=/mytermenv/docs/ohmyzsh/advancedplugins/>高级插件</a></li><li><a href=/mytermenv/docs/ohmyzsh/powerlevel10k/>自定义提示主题</a></li></ul></li><li><input type=checkbox id=section-3fb225060dbc6eb1fda04fb19c520b9e class=toggle checked>
<label for=section-3fb225060dbc6eb1fda04fb19c520b9e class="flex justify-between"><a href=/mytermenv/docs/commands/>高效命令</a></label><ul><li><input type=checkbox id=section-4d360b6d2174e1a19ba4329d57bf2936 class=toggle>
<label for=section-4d360b6d2174e1a19ba4329d57bf2936 class="flex justify-between"><a href=/mytermenv/docs/commands/filesystem/>文件目录</a></label><ul><li><a href=/mytermenv/docs/commands/filesystem/exa/>exa</a></li><li><a href=/mytermenv/docs/commands/filesystem/zoxide/>zoxide</a></li><li><a href=/mytermenv/docs/commands/filesystem/bat/>bat</a></li></ul></li><li><input type=checkbox id=section-a76fd5671ff74c276b5d82cfbdd68e75 class=toggle>
<label for=section-a76fd5671ff74c276b5d82cfbdd68e75 class="flex justify-between"><a href=/mytermenv/docs/commands/search/>搜索查找</a></label><ul><li><a href=/mytermenv/docs/commands/search/fd/>fd - 更易用的文件查找命令</a></li><li><a href=/mytermenv/docs/commands/search/ripgrep/>ripgrep - 更高效的文件搜索</a></li><li><a href=/mytermenv/docs/commands/search/fzf/>fzf - 交互式命令行查找器</a></li></ul></li><li><input type=checkbox id=section-46404c2e805134bf109f2309e56d329f class=toggle checked>
<label for=section-46404c2e805134bf109f2309e56d329f class="flex justify-between"><a href=/mytermenv/docs/commands/dev/>开发调试</a></label><ul><li><a href=/mytermenv/docs/commands/dev/entr/ class=active>entr - 实现语言无关热重启</a></li><li><a href=/mytermenv/docs/commands/dev/httpie/>httpie - 人性化 HTTP Client</a></li></ul></li></ul></li><li><input type=checkbox id=section-ff2ed6a53270462fb3b310011e3cce1a class=toggle>
<label for=section-ff2ed6a53270462fb3b310011e3cce1a class="flex justify-between"><a href=/mytermenv/docs/startup/>启动消息</a></label><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/mytermenv/svg/menu.svg class=book-icon alt=Menu></label>
<strong>entr - 实现语言无关热重启</strong>
<label for=toc-control><img src=/mytermenv/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#什么-entry>什么 entry</a></li><li><a href=#安装>安装</a></li><li><a href=#实现热重启>实现热重启</a></li><li><a href=#创建新文件>创建新文件</a></li><li><a href=#限制和考虑>限制和考虑</a></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=entr---实现语言无关热重启>entr - 实现语言无关热重启
<a class=anchor href=#entr---%e5%ae%9e%e7%8e%b0%e8%af%ad%e8%a8%80%e6%97%a0%e5%85%b3%e7%83%ad%e9%87%8d%e5%90%af>#</a></h1><p>hi</p><p>在开发类似于 web 或其他常驻服务时，我们在修改代码后，要手动重启才能更新服务。如果你不是这种情况，或许框架默认支持热重启或是你集成了其他工具。</p><p>本文将介绍一款工具，它能轻松实现简单的热重启，它具有语言和框架无关性，是一个通用小工具，它就是
<a href=https://github.com/eradman/entr>entry</a>。</p><p>特别说明，这个工具主要是用在开发调试阶段，不支持复杂的热重启能力。</p><h2 id=什么-entry>什么 entry
<a class=anchor href=#%e4%bb%80%e4%b9%88-entry>#</a></h2><p>简单来说，它是一个可监听文件状态变化并执行特定动作的命令。让我们直接通过演示观察它的行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ls text.txt | entr echo <span style=color:#e6db74>&#34;file changed&#34;</span>
</span></span></code></pre></div><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2023-11/2023-11-02-high-productivity-shell-commands-part3-01.gif alt></p><p>我们通过 <code>ls text.txt</code> 告诉 entry 监听的文件。当编辑并保存文件后，它通过指定命令 echo 打印提示 <code>file changed</code>。</p><p>我们只要对它稍做修改，就可以实现在监听到文件变化后，自动执行 <code>停止服务 -> 重新编译 -> 启动服务</code> 等一系列动作。</p><h2 id=安装>安装
<a class=anchor href=#%e5%ae%89%e8%a3%85>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># mac 安装命令</span>
</span></span><span style=display:flex><span>brew install entr
</span></span></code></pre></div><h2 id=实现热重启>实现热重启
<a class=anchor href=#%e5%ae%9e%e7%8e%b0%e7%83%ad%e9%87%8d%e5%90%af>#</a></h2><p>首先，开发一个简单 Go server 服务，文件是 <code>main.go</code>，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello World!&#34;</span>))
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Server is listening on :3000&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3000&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为这个服务加上热重启能力，命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fd -e go | entr -r go run *.go 重启服务
</span></span></code></pre></div><p>我们通过 <code>fd</code> 遍历所有 go 源码文件，当发现文件更新后会重新执行 <code>go run *.go</code>。注意，上述命令中，我们使用了 entr 的 <code>-r</code> 实现 reload，它会发送停止信号给常驻服务，让其重新运行。</p><p>如果你希望每次重新启动后，执行清屏日志，也可使用 -c 选项。</p><h2 id=创建新文件>创建新文件
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e6%96%b0%e6%96%87%e4%bb%b6>#</a></h2><p>但这还有一个缺点，当创建新文件，entry 默认无法检测。针对这个场景，entry 提供了一个选项 <code>-d</code>，它在检测新文件后，停止 entr 命令。由于是停止重新执行，我们要通过 while 循环才能重启服务。</p><p>命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>while</span> true <span style=color:#66d9ef>do</span> fd *.go | entr -d -r go run *.go; <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>看起来已经足够使用，但它有个问题，无法退出服务。因为即使是强制 kill 掉 <code>go run</code> 进程，依然会循环重启。我们要再引入一个命令 - trap，捕捉到退出信号停止循环，退出程序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>trap <span style=color:#e6db74>&#34;echo &#39;command you want to execute&#39;&#34;</span> SIGINT; <span style=color:#66d9ef>while</span> true <span style=color:#66d9ef>do</span> sleep 10; <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>这里的效果是捕捉 SIGINT 信号，并打印 <code>echo "command you want to execute"</code>。</p><p>效果如下所示：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2023-11/2023-11-02-high-productivity-shell-commands-part3-04.gif alt></p><p>如此的话，简单改造下前面的命令。</p><p>现在，在源码根目录下创建一个名为 <code>run.sh</code> 的文件，源码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>trap <span style=color:#e6db74>&#34;exit;&#34;</span> SIGINT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  fd -e go | entr -rcd go run *.go;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>现在，我们通过 <code>run.sh</code> 启动服务即可，我们为服务添加了一个实时构建编译和简单的热重启能力。</p><h2 id=限制和考虑>限制和考虑
<a class=anchor href=#%e9%99%90%e5%88%b6%e5%92%8c%e8%80%83%e8%99%91>#</a></h2><p>虽然 <code>entr</code> 能够实现一种简单的热重启机制，但它并不具备复杂的状态管理或零停机更新的能力。</p><p>对于需要更高级热更新或热重载功能的应用，可能需要使用更专门化的工具或框架来实现，这些工具或框架能够处理如状态迁移、版本兼容性等更复杂的场景。</p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>总体而言，不同语言或框架可能都有自己的管理工具，但通过 entr 命令，我们能以最简单的方式实现热重启这个需求。</p><p>希望本文对你有所帮助，感谢阅读。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/poloxue/myterminal/commit/a8650b7ed683c3d5397eb40c34ebab02ed886a9f title='Last modified by poloxue.xue | Apr 8, 2024' target=_blank rel=noopener><img src=/mytermenv/svg/calendar.svg class=book-icon alt=Calendar>
<span>Apr 8, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/poloxue/myterminal/blob/master/content/docs/commands/dev/entr.md target=_blank rel=noopener><img src=/mytermenv/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#什么-entry>什么 entry</a></li><li><a href=#安装>安装</a></li><li><a href=#实现热重启>实现热重启</a></li><li><a href=#创建新文件>创建新文件</a></li><li><a href=#限制和考虑>限制和考虑</a></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>