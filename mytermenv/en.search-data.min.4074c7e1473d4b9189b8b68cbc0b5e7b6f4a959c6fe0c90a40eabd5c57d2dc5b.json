[{"id":0,"href":"/mytermenv/docs/commands/dev/entr/","title":"entr - 实现语言无关热重启","section":"开发调试","content":" entr - 实现语言无关热重启 # hi\n在开发类似于 web 或其他常驻服务时，我们在修改代码后，要手动重启才能更新服务。如果你不是这种情况，或许框架默认支持热重启或是你集成了其他工具。\n本文将介绍一款工具，它能轻松实现简单的热重启，它具有语言和框架无关性，是一个通用小工具，它就是 entry。\n特别说明，这个工具主要是用在开发调试阶段，不支持复杂的热重启能力。\n什么 entry # 简单来说，它是一个可监听文件状态变化并执行特定动作的命令。让我们直接通过演示观察它的行为。\n$ ls text.txt | entr echo \u0026#34;file changed\u0026#34; 我们通过 ls text.txt 告诉 entry 监听的文件。当编辑并保存文件后，它通过指定命令 echo 打印提示 file changed。\n我们只要对它稍做修改，就可以实现在监听到文件变化后，自动执行 停止服务 -\u0026gt; 重新编译 -\u0026gt; 启动服务 等一系列动作。\n安装 # # mac 安装命令 brew install entr 实现热重启 # 首先，开发一个简单 Go server 服务，文件是 main.go，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, req *http.Request) { _, _ = w.Write([]byte(\u0026#34;Hello World!\u0026#34;)) }) fmt.Println(\u0026#34;Server is listening on :3000\u0026#34;) http.ListenAndServe(\u0026#34;:3000\u0026#34;, nil) } 为这个服务加上热重启能力，命令如下：\nfd -e go | entr -r go run *.go 重启服务 我们通过 fd 遍历所有 go 源码文件，当发现文件更新后会重新执行 go run *.go。注意，上述命令中，我们使用了 entr 的 -r 实现 reload，它会发送停止信号给常驻服务，让其重新运行。\n如果你希望每次重新启动后，执行清屏日志，也可使用 -c 选项。\n创建新文件 # 但这还有一个缺点，当创建新文件，entry 默认无法检测。针对这个场景，entry 提供了一个选项 -d，它在检测新文件后，停止 entr 命令。由于是停止重新执行，我们要通过 while 循环才能重启服务。\n命令如下：\nwhile true do fd *.go | entr -d -r go run *.go; done 看起来已经足够使用，但它有个问题，无法退出服务。因为即使是强制 kill 掉 go run 进程，依然会循环重启。我们要再引入一个命令 - trap，捕捉到退出信号停止循环，退出程序。\ntrap \u0026#34;echo \u0026#39;command you want to execute\u0026#39;\u0026#34; SIGINT; while true do sleep 10; done 这里的效果是捕捉 SIGINT 信号，并打印 echo \u0026quot;command you want to execute\u0026quot;。\n效果如下所示：\n如此的话，简单改造下前面的命令。\n现在，在源码根目录下创建一个名为 run.sh 的文件，源码如下所示：\n#!/bin/bash trap \u0026#34;exit;\u0026#34; SIGINT; while true; do fd -e go | entr -rcd go run *.go; done 现在，我们通过 run.sh 启动服务即可，我们为服务添加了一个实时构建编译和简单的热重启能力。\n限制和考虑 # 虽然 entr 能够实现一种简单的热重启机制，但它并不具备复杂的状态管理或零停机更新的能力。\n对于需要更高级热更新或热重载功能的应用，可能需要使用更专门化的工具或框架来实现，这些工具或框架能够处理如状态迁移、版本兼容性等更复杂的场景。\n最后 # 总体而言，不同语言或框架可能都有自己的管理工具，但通过 entr 命令，我们能以最简单的方式实现热重启这个需求。\n希望本文对你有所帮助，感谢阅读。\n"},{"id":1,"href":"/mytermenv/docs/commands/filesystem/exa/","title":"exa","section":"文件目录","content":" exa # 首先是 exa，一款可用于替换系统默认 ls 的命令，在平时工作中 ls 几乎使用最多的命令，而 exa 在支持 ls 的基本能力基础上，提供了更丰富的特性。\n快速安装 # brew install exa # 其他系统请查看 GithHub README.md 默认配色 # 首先，exa 默认提供了配色效果，无需 ls 要追加 --color 参数，省去了 alias 别名的设置。\n显示图标 # 其次，exa 支持显示文件图片，通过指明 --icons 实现，显示文件类型图标；\n详情与 GIT # 更复杂的命令，支持 ls -l 显示文件列表详情，添加头部说明 header，如果是 git 仓库，可显示文件的 Git 信息。\n目录树 Tree # 如果想显示文件数，也不需要单独安装 tree 命令，如下 exa --tree --icons，显示文件树；\n别名 # 如果你钟爱 exa 的这些能力，可通过别名将默认 ls 和 tree 命令替换为 exa。\n如下是一些常见的别名设置：\n# 默认显示 icons： alias ls=\u0026#34;exa --icons\u0026#34; # 显示文件目录详情 alias ll=\u0026#34;exa --icons --long --header\u0026#34; # 显示全部文件目录，包括隐藏文件 alias la=\u0026#34;exa --icons --long --header --all\u0026#34; # 显示详情的同时，附带 git 状态信息 alias lg=\u0026#34;exa --icons --long --header --all --git\u0026#34; # 替换 tree 命令 alias tree=\u0026#34;exa --tree --icons\u0026#34; 如此一来，就将 exa 设置为系统默认 ls。\n其他相似命令 # 除了 exa，还有两个可用于可替代 ls 的命令，分别名为 colorls 和 lsd，colorls 的性能太差，如果是目录中的文件数量多，能感觉到明显的卡顿。lsd 的号称是下一代的 ls，使用起来没有 colorls 那么卡，但性能上也不如 exa。\n如果你对它们感兴趣，可以研究下。\n注意 # 特别提醒，别名生效后，如果要用原始命令，要通过类似于 \\command 的形式实现，如 \\ls 将无效别名设置，直接使用系统内置 ls 命令。另外，如果你的 shell 脚本里使用了它，可能影响这些脚本的执行。这是设置别名替换系统命令要考虑的问题。\n"},{"id":2,"href":"/mytermenv/docs/terminal/","title":"iTerm2","section":"介绍","content":" iTerm2 # 终端是程序员日常必不可少的工具之一，特别是如果你的系统是 MacOS 或 Linux 的话，终端的地位更是遥遥领先。\n本文是搭建我的终端环境系列中的第一篇，首先将介绍第一个必不可可少的工具终端 - iTerm2，Mac 上的终端神器。\n故而，我们的开篇第一节先介绍 iTerm2 的使用方法。我将主要介绍如何安装与配置 iTerm2，安装成功后，会带着一起体验的一些能力。\n"},{"id":3,"href":"/mytermenv/docs/ohmyzsh/install/","title":"安装与主题","section":"ohmyzsh","content":" 安装与主题 # 本节介绍 ohmyzsh 的安装与主题。\n安装 # oh-my-zsh 的安装很简单。安装命令，如下所示：\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 安装后，就已经有一些默认效果，如命令行提示符的主题变化。\n这是默认的 oh-my-zsh 主题 \u0026ldquo;robbyrussell\u0026rdquo;。\n主题 # oh-my-zsh 提供了许多内置主题，可查看 themes 获取一系列的主题。\n我们可直接通过 ~/.zshrc 配置更新主题配置，将内容修改如下：\nZSH_THEME=\u0026#34;agnoster\u0026#34;` # 默认为 robbyrussell 执行 source ~/.zshrc 生效配置，就能看到主题效果。\n另外，oh-my-zsh 还提供了 random 主题，它会在 oh-my-zsh 内置主题中随机选择一个主题展示。只需编辑 ~/.zshrc，将 ZSH_THEME 更新为 random 即可。\n配置如下所示：\nZSH_THEME=\u0026#34;random\u0026#34; 演示效果，如下所示：\n说实话，我觉得没人会这么用吧。这明显很鸡肋的功能啊。\n"},{"id":4,"href":"/mytermenv/docs/commands/filesystem/","title":"文件目录","section":"高效命令","content":" 文件目录 # 我将先介绍平时工作中最常用的与目录文件相关的命令，分别是替换 ls 的 exa，替换 cd 的 zoxide 和替换 cat 的 bat。它们的优势会在文章中逐步展开说明。\n特别提醒：exa 已停止维护，可用 exa 的 fork 版本 eza 替代。\n"},{"id":5,"href":"/mytermenv/docs/terminal/hello/","title":"简要介绍","section":"iTerm2","content":" 简要介绍 # iTerm2 是一款终端软件，它是 macOS 下默认终端 Terminal 的替代品。每次拿到新电脑，或者因某种原因重装系统，我首先要做的就是下载 iTerm2 来替换默认的终端 terminal。\niTerm2 vs 默认 Terminal # 为什么要用 iTerm2 替换默认终端？相较于 Terminal，iTerm2 的几点优势：\n首先，它美观大方，相对于默认终端，它支持真彩。且它的功能上更加丰富，如灵活地分屏、主题配置；搜索功能，支持的搜索规则丰富；快捷键，快捷键的定制性更强；支持静态图片和 GIF 的展示；编程控制，支持如 python 编程控制，可实现自动背景，布局管理等。\n"},{"id":6,"href":"/mytermenv/docs/commands/search/fd/","title":"fd","section":"搜索查找","content":" fd # fd 是一款文件查找命令，可替换系统默认 find，它的体验更友好，且查询效率极高。我们在使用传统的 find 时，要经常查手册看帮助文档，但使用 fd，它的默认行为就能满足我们大部分的需求。\n如何使用呢？\n安装 # brew install fd 递归 # 文件系统下搜索文件名，最常见的场景是递归搜索文件名包含 pattern 的文件，不知道有你是否能立刻想起来 find 如何写呢？\n示例：遍历查找。\n$ fd pattern 正则 # 如果要正则查询，pattern 默认即支持正则表达式。\n查找文件名包含日期的文件：\n或者查找所有的 go 代码文件。\n这个表达式更加正确的表述是 fd .*\\.go$，查出所有以 .go 结尾的文件。\n通配符 # fd 同样是支持统配符的，通过 -g 选项指定通配符。\n文件类型 # 前面的查找 go 文件，其实也是查找类型是 Go 源码。但正则和通配符，都比较繁琐，可直接通过 fd -e go pattern 的模式直接寻找指定扩展的文件。\n示例：查找 python 源码文件。\n如果无需 patern，则表明查找所有的 .py 的文件。\n隐藏文件和 .gitinogre # fd 搜索效率高的一个原因是它默认不查找隐藏文件和 gitignore 文件。\n如想启用隐藏文件的查找，可指定 -H 选项，示例如下：\n从上图可知，其中包含了隐藏目录 .git 下的文件。\n除了默认忽略 hidden 文件，fd 还会忽略 .gitignore 中的文件，选项 -I 即可查找包含在 .gitinogre/.fdignore/.ignore 的文件。\n$ fd -I pattern 其他示例 # fd 的更多选项，我就不一一介绍了，可以查看如下表格。\n案例 命令 说明 忽略大小写 fd -i readme.md 包含 readme.md 和 README.md 大小写的 smartcase 模式 fd -s readme.md 包含 readme.md 和 README.md \u0026mdash; fd -s README.md 只包含 README.md 查找结果显示详细信息 fd -l .go 查询结果显示文件详情 大小过滤 fd -S +1000k 查询大小 \u0026gt; 1000k 的文件 仅查找目录 fd \u0026ndash;type/-t directory golang 查询所有目录文件 查询并执行命令 fd \u0026ndash;type/-t file -x wc -l 查询文件并计算行数 \u0026mdash; fd \u0026ndash;type/-t file -X vim 查询所有文件并用 vim 打开 性能 # 除了忽略隐藏和 gitignore 中的文件外，fd 在性能上也是碾压 find。通过 hyperfine 命令测试 fd 与 find。\nhyperfine --warmup 3 \u0026#34;find . -iname *.go\u0026#34; \u0026#34;fd -i -g \u0026#39;*.go\u0026#39; -uu\u0026#34; 性能对比结果：\n压测结果显示，fd 相较于 find 快了 3.88 倍。\n"},{"id":7,"href":"/mytermenv/docs/commands/dev/httpie/","title":"httpie - 人性化 HTTP Client","section":"开发调试","content":" 人性化 HTTP Client 命令 - httpie # 快速调试 HTTP Web 接口，你首先想到的方案是什么？或许是是图形化能力超强的 Postman，亦或是命令行工具 curl，甚至可能通过浏览器即可。\nhttpie 是一款更人性化的 HTTP 命令行客户端，简单来说，比 curl 更加易于使用。\n安装 # brew install httpie 快手上手 # 最简单的使用案例，快速发起 GET 和 POST 请求。\nGET 请求：\nhttp GET http://httpbin.org/get name==poloxue age==18 POST 请求：\nhttp POST http://httpbin.org/post name=poloxue age=18 http 命令的完整语法，如下所示：\nhttp [flags] [METHOD] URL [ITEM [ITEM]] 体现易用性 # 从易用性角度，如果拷贝一个 url 可直接通过在 scheme 之后添加一个 \u0026lt;space\u0026gt; 便可直接使用：\n例如，GET 方法请求 http://httpbin.org/get，如下所示：\nhttp ://httpbin.org/get 演示效果：\n另外，METHOD 默认也可省略的，省略规则是：\n当有 data：POST，如 http ://httpbin.org/post name=poloxue age=18 当无 data：GET，如 http ://httpbin.org/get httpie 还支持一种 offline 模式，debug 神器，只打印 HTTP 请求文本，但不进行网络请求；\nhttp --offline ://httpbin.org/get 输出内容：\nGET /get HTTP/1.1 Accept: */* Accept-Encoding: gzip, deflate Connection: keep-alive Host: httpbin.org User-Agent: HTTPie/3.2.2 现在，通过 offline 快速了解 httpie 的 header 设置，query 参数、JSON 请求体 等；\n几个规则，如下所示：\nheader：使用 key:value 设置 header； query string，使用 key==value，表示 query params，快速拼接 query string； body json data，使用 key=value 即可，更复杂结构，可通过命令管道或文件导入； 一个命令演示下如何设置：\nhttp --offline POST http://httpbin.org/post \\ X-API-Token:123456\\ User-Agent:foo\\ name==poloxue\\ age==18\\ password=123456\\ email=poloxue123@gmail.com 启用 offline 调试模式，输出结果：\nPOST /post?name=poloxue\u0026amp;age=18 HTTP/1.1 Accept: application/json, */*;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Content-Length: 55 Content-Type: application/json Host: httpbin.org User-Agent: foo X-API-Token: 123456 { \u0026#34;email\u0026#34;: \u0026#34;poloxue123@gmail.com\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34; } 输出美化 # httpie 还有一个能力，它默认会对返回数据进行格式化与语法高亮处理。如此一来，其他的 json 格式化命令就用不到了，如早前介绍的 pp_json 这个命令。毕竟，httpie 的格式美化能力更强大。\n想修改它的配色风格？\n通过 --style 选项即可修改。\nhttp --style autumn GET ://httpbin.org/get 如果想查看所有可用该配色，直接输入 http --style 即可查看：\n输出内容如下：\nusage: http -s/--style {abap, algol, algol_nu, arduino, auto, autumn, borland, bw, colorful, default, dracula, emacs, friendly, friendly_grayscale, fruity, github-dark, gruvbox-dark, gruvbox-light, igor, inkpot, lightbulb, lilypond, lovelace, manni, material, monokai, murphy, native, nord, nord-darker, one-dark, paraiso-dark, paraiso-light, pastie, perldoc, pie, pie-dark, pie-light, rainbow_dash, rrt, sas, solarized, solarized-dark, solarized-light, staroffice, stata, stata-dark, stata-light, tango, trac, vim, vs, xcode, zenburn} [METHOD] URL [REQUEST_ITEM ...] error: argument --style/-s: expected one argument for more information: run \u0026#39;http --help\u0026#39; or visit https://httpie.io/docs/cli httpie 的格式方式也是可配置的，选项 --pretty，可配置值有 all|colors|format|none，看名字大概能猜出它们的区别：\nall，默认值，即高亮又格式化； format，不高亮但格式化； colors，高亮但不格式化； http --style=autumn ://httpbin.org/get 演示效果：\n文件下载 # 通过 --donwload 即可：\nhttp --download https://github.com/httpie/cli/archive/master.tar.gz 文件下载，除去最基本的需求，肯定还是要支持断点续传的。\n要支持断点续传的话，首先，要通过 --output/-o 选项指定输出的文件名称。\nhttp --donwload -o httpie.tar.gz https://github.com/httpie/cli/archive/master.tar.gz 断点续传，要启用 --continue/-c 选项。\n为了掩饰效果，选择一个大文件进行下载，下载飞书的海外版 Mac 安装包。\n命令如下：\nhttp -dco lark.dmg https://sf16-va.larksuitecdn.com/obj/lark-artifact-storage/49f5b75a/Lark-darwin_x64-6.11.16-signed.dmg 演示效果，如下所示：\nhttpie 就介绍这么多，其他还有 cookie、session，authentication 等等请自行查阅文档 httpie 文档。\n"},{"id":8,"href":"/mytermenv/docs/commands/search/ripgrep/","title":"ripgrep","section":"搜索查找","content":" ripgrep # ripgrep 是一款文本搜索命令，功能与 grep 类似。和 fd 之于 find 一样，ripgrep 在体验和性能上同样完胜 grep。\n安装 # brew install ripgrep 递归 # ripgrep 的默认行为也是递归搜索，命令为 rg pattern，且默认高亮显示，与 grep --color main . -nR 对比，明显更加简洁易用，体验更好。\n示例效果：\n指定目录 # ripgrep 最后的参数即可指定搜索的目录。\nrg main ~/Code/golang-examples/ 指定文件 # 搜索指定文件与指定目录类似，命令的最后一个参数指定即可。\nrg main ~/Code/golang-examples/main.go 通配符 # 我们使用 -g 通过通配符指定搜索路径。\n如下是禁用目录递归：\nrg main -g \u0026#39;!/*/*\u0026#39; 还可实现如排除指定的文件：\nrg main -g \u0026#39;!main.go\u0026#39; 或者排除指定的目录\nrg -g \u0026#39;!directory\u0026#39; 正则 # ripgrep 支持通过 -e 选项启用正则表达式搜索，如搜索文件中的指定日期格式内容。\nrg -e \u0026#39;[0-9]{2}:[0-9]{2}\u0026#39; 默认过滤 # 和 fd 一样，ripgrep 的高效率搜索能力一方面也是因为默认忽略了一些文件，如它忽略隐藏文件以及 .gitgnore .ignore .rgignore 中的文件。禁用 ignore 可通过选项 \u0026ndash;no-ignore 即可。\n对于隐藏文件，通过 --hidden 即可搜索包含隐藏文件。\n如果希望彻底禁用隐藏能力，通过 -uuu 实现，如 rg -uuu pattern。\n大小写敏感 # ripgrep 默认即大小写敏感。\nrg pattern 通过 -i 选项可忽略大小写。\nrg -i pattern 或者通过 -S 启用 smartcase 模式，即\nrg -S pattern 搜索并替换 # ripgrep 中，我们通过 -r 可直接替换搜索结果，但不改变原内容。\nrg main ~/Code/golang-examples r main # 只替换输出，未修改文件 配置 # ripgrep 支撑配置文件修改 ripgrep 的默认行为。我们通过设置环境变量 RIPGREP_CONFIG_PATH 指定配置文件路径。\n配置文件的配置方式和上文介绍的 bat 类似，都是通过 --xxx 选项的形式设置。\n# Don\u0026#39;t let ripgrep vomit really long lines to my terminal, and show a preview. --max-columns=150 --max-columns-preview # Add my \u0026#39;web\u0026#39; type. --type-add web:*.{html,css,js}* # Search hidden files / directories (e.g. dotfiles) by default --hidden # Using glob patterns to include/exclude files or folders --glob=!.git/* # or --glob !.git/* # Set the colors. --colors=line:none --colors=line:style:bold # Because who cares about case!? --smart-case 如我们希望 ripgrep 默认启用 smartcase 能力，可将 --smart-case 直接配置到配置文件中。\n"},{"id":9,"href":"/mytermenv/docs/commands/filesystem/zoxide/","title":"zoxide","section":"文件目录","content":" zoxide # 在正式介绍 zoxide 前，尝试提前问自己一个问题，Linux 默认命令 cd 好不好用？我的答案是，相当难用，无论多么丝滑的操作，一旦遇到 cd，只能说一句 f**k。\n你是不是经常这样使用 cd 呢？\ncd ../ cd ../ cd ../ cd ../../../ cd x/ cd y/ cd z/ 如果不想被 cd 折磨的话，我强烈推荐这个工具： zoxide。\nzoxide 是一款受到 z 和 autojump 启发而来的命令，它会记录访问过的目录，通过搜索找到最匹配你目标的目标。从而实现以 最最最最 少按键就能实现目录跳转。\n一般情况下，我们关注的目录就那几个，90% 的情况用它的快速跳转能力即可，而一些特殊情况，cd 绝对路径即可，亦或者是使用它提供的另一种方式，交互式搜索。\n前面我写过一篇文章 介绍了 oh-my-zsh 提供的 z 插件，zoxide 与 z 相比更易于使用。这有一份对比报告： zoxide vs zsh-z。\n具体介绍它的安装使用吧。\n安装 # brew install zoxide # 其他系统请查看 GithHub README.md 配置 # 在 zsh 中使用 zoxide 要简单配置下，一行命令将 zoxide 初始化命令追加到 ~/.zshrc 中。\n如下所示：\necho \u0026#39;eval \u0026#34;$(zoxide init zsh --cmd z)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 生效后，即可通过 z 命令使用 zoxide 的能力。\n亦或者，如果觉得要从习惯于使用 cd 切换到 z 有难度，可直接将 z 命名为 cd，直接替换掉系统的 cd 命令，配置 --cmd cd 即可。\necho \u0026#39;eval \u0026#34;$(zoxide init zsh --cmd cd)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc 我将会使用 zoxide 直接替换 cd 命令进行演示，即第二种配置方式。\n使用 # 正式开始使用前，先假设我有如下目录结构：\n~/Hello |_ ./golang-examples |_ ./python-examples |_ ./rust-examples |_ ./trading-strategies 由于 zoxide 是在历史访问路径的基础上智能选择。为了便于演示，我把之前的访问历史记录已经清空了，并通过如下命令初始化访问历史：\ncd ~/Hello/golang-examples cd ~/Hello/python-examples cd ~/Hello/rust-examples cd ~/Hello/trading-strategies 假设现在在 ~ 用户目录下，如下是演示效果：\n主要演示了 zoxide 的三个能力，分别是全名匹配、部分匹配和如果存在重名目录下会选择智能最优的目录。\n首先是全名匹配，通过 zoxide 的 cd 命令，在 ~ 目录下快速跳转到 golang-examples 目录，直接输入 cd golang-examples。\n其次是部分匹配，由于记录中只有一个目录包含 python，执行 cd python 会直接进入到 python-examples；\n最后是重名按算法选择最优目录，我不清楚它的具体算法，但观察来看，它当前在 python-examples 目录下，执行 cd examples 会优先找到最近访问的包含 examples 的目录，且非当前位置，即 golang-examples。\n如果觉得它的智能算法不够灵活，还可以尽量补全路径，和使用普通 cd 一样。如果还想要它的效率，也可以进入它的交互搜索模式，zoxide 支持两种方式进入交互模式：\n一种是输入 cd + 目标名称 + 快捷键 \u0026lt;Space\u0026gt;+\u0026lt;Tab\u0026gt;，进入交互选择模式，效果如下：\n另一种是直接使用 cdi 命令也可进入交互搜索模式，如下所示：\n补充，zoxide 本身也是个命令，你可以用它增删改查，管理历史方案记录。\n$ zoxide query golang # 返回最匹配 golang 的目录 $ zoxide query golang --list # 返回所有匹配 golang 的目录 $ zoxide -h # 更多帮助信息 zoxide 0.9.2 Ajeet D\u0026#39;Souza \u0026lt;98ajeet@gmail.com\u0026gt; https://github.com/ajeetdsouza/zoxide 一个更智能的终端 `cd` 命令 使用方法： zoxide \u0026lt;命令\u0026gt; 命令： add 添加一个新目录或增加其排名 edit 编辑数据库 import 从另一个应用导入条目 init 生成 shell 配置 query 在数据库中搜索目录 remove 从数据库中移除目录 差不多，zoxide 大概就介绍的这么多吧。希望对于想用它替换掉 cd 的朋友有所帮助吧。\n"},{"id":10,"href":"/mytermenv/docs/zsh/","title":"zsh","section":"介绍","content":" zsh # 上节中，我们对 iTerm2 已经有了一个大概认识。但一个高效的终端环境，离不开一个优秀 shell 解释器。本章将主要介绍 zsh 的安装和简单介绍。\n如果你想深入学习 zsh，推荐 awesome-zsh-plugins。或看阅读一个 zsh 深度系列文章：\nA Guide to Zsh Expansion with Examples A Guide to the Zsh Completion with Examples A Guide to the Zsh Line Editor with Examples Configuring Zsh Without Dependencies "},{"id":11,"href":"/mytermenv/docs/zsh/why/","title":"为什么选择 zsh ？","section":"zsh","content":" 为什么选择 zsh ？ # 开始前，先问为什么，知其然，要知其所以然，是个好习惯。所以，为什么要用 zsh 呢？\n大家最熟悉的 shell 解释器，肯定是 bash。zsh（Z Sehll）相对于 bash（Bourne Again Shell）相对有哪些优势呢？\n改进的自动补全能力 # zsh 提供了更强大、更灵活的自动补全功能。它不但可以自动补全命令，设置选项、参数甚至文件名，都可自动补全。\n对于命令参数，zsh 甚至可以显示简短的帮助信息，这使得探索新命令变得更加容易。\n更好的脚本和插件支持 # zsh 有一个强大的社区，提供了大量的插件和主题，如 oh-my-zsh 这个流行的 zsh 框架，允许我们轻松添加、更新插件和主题。\n这些插件可以增强 shell 的功能，提供便捷的别名、函数以及其他有用的特性。\n高级的主题和提示符定制 # zsh 还允许用户对命令行提示符进行高度定制，包括颜色、内容和格式。用户可以非常容易地调整提示符来显示 git 分支、Python 虚拟环境等信息。\n我们会在后续介绍一款非常强大的 zsh 插件，名为 powerlevel10k，它支持完全的主题自定义特性，非常强大。\n更智能的命令行交互 # zsh 还支持 bash 不具备的一些智能特性，如拼写校正和近似完成。如果用户输入的命令有拼写错误，zsh 可以建议正确的命令。\n如我输入 lls，会提示我 \u0026ldquo;zsh: correct \u0026rsquo;lls\u0026rsquo; to \u0026rsquo;ls\u0026rsquo; [nyae]?\u0026rdquo;\n❯ lls zsh: correct \u0026#39;lls\u0026#39; to \u0026#39;ls\u0026#39; [nyae]? 输入 y 接受纠正建议。\n当然这个是要做个简单的配置，通过 setopt CORRECT_ALL 启用。\n其他 # 其他还有很多强大特性。如：\nzsh 的命令行历史是终端间共享的，通过自动补全，能一步增强了操作效率与体验。\nzsh 的文件匹配和通配符功能确实比 Bash 要强大得多，除了常规的通配符能力，还提供了一些扩展通配符、限定符等，如递归匹配 **/，ls **/*.go 会列出所有的 Go 文件。!{pattern}，匹配不符合模式的内容。其他更多自行探索。\nzsh 的可配置性更强，zsh 提供了比 bash 更多的选项和特性，我们都可通过配置文件调整。\n"},{"id":12,"href":"/mytermenv/docs/ohmyzsh/basicplugins/","title":"基础插件","section":"ohmyzsh","content":" 基础插件 # 重点来了，接下来我们一起来看看 zsh 的效率神器 - 插件能力吧。本问先给大家推荐 5 款常用的插件。ohmyzsh 提供的所有内置插件，都可以在仓库 ohmyzsh/ohmyzsh/plugins 中找到，每个插件都有相应的介绍文档。\n本教程将要介绍的 5 个 oh-my-zsh 内置插件，如下所示：\ngit，Git 插件，其实就是提供一些常用的 git 命令别名。 web-search，命令行打开搜索引擎，已支持大部分搜索引擎； jsontools，用于格式化 json 数据； z，基于历史访问目录的快速跳转； vi-mode，使用 vi 模式编辑命令行； 启用所有插件，打开 zshrc 配置，把这些内置插件都打开，如下所示：\nplugins=(git web-search jsontools z vi-mode) 插件 1 - git # Git 插件提供了 git 命令的大量别名，查看 git 插件文档。\n如下一些常用命令的别名：\ngit clone -\u0026gt; gcl git status -\u0026gt; gst git commit -\u0026gt; gc git add -\u0026gt; ga git add --all -\u0026gt; gaa git diff -\u0026gt; gd git push -\u0026gt; gp git pull -\u0026gt; gl 更多命令的映射关键关系，可自行查看它的 文档。\n这个插件不错，但有个缺点，这么多可用别名，我又记不住，岂不是成了摆设。如果想用好，我每次都用去查文档吗？不查文档行不行呢？\n当然也是可以的，oh-my-zsh 中启用的一些其他插件可能也会有别名。\n其实，有一个插件可帮忙我们解决这个问题，叫做 you-should-use，这是下期要介绍的一个插件。简单说下，它的作用是，当我们输入一个命令时，如果这个命令存在别名，它会提示我们要使用别名。\n插件 2 - web-search # web-search 提供了在终端直接搜索信息的能力。\n当然，其实也不是完全在终端完成，它会自动跳转浏览器，转到指定的搜索引擎执行搜索请求。\n效果大概就是下面这样：\n常见的搜索引擎基本都是支持的，诸如 google, bing, baidu, 甚至是 github 等。\n不过，我也得承认，其实这个插件一般我本人很少用，因为我已经安装了另外一个工具 alfred（替代 mac 默认的 spotlight），我都是通过它直接启动搜索。\n插件 3 - jsontools # 接下的这个插件，名为 jsontools ，即用于 json 的 tool。其实它只提供了一些操作 json 的基本命令，如下:\npp_json 实现 json 字符串格式化； is_json 判断是否是 json； 我们直接看下演示效果吧，如下所示：\n还是得说明，如果你没有更好的方案，安装了 oh-my-zsh，这是个不错的选择，因为你可能以前都没用过这类工具。\n不过其实这个插件呢？我也很少用。\n我习惯使用一款叫做 jq 的命令，如果你了解它，就知道它多强大。后面说到高效命令的时候，会介绍到它的。\n插件 4 - z # z 插件 可用于快速的目录跳转，我觉得大部分人在使用 Linux 都被 cd 跳转目录跳转烦恼过。\nz 就是这个烦恼的救星。\n想查看更多信息可找 z 原仓库 - zsh-z 查看。oh-my-zsh 下的 z 文档说明中提到，它是从这个 zsh-z 的插件中拷贝而来的。\n我们来介绍它的用法，简单来说，它是基于历史访问过的目录快速跳转。我们无需输入全路径，即可完成目录切换。\n下面是一些实际案例。\n首先，我直接输入 z，紧跟 tab 键，会看到如下的效果。它会直接将访问过的目录都列出来。\n这些由 tab 产生的自动补全目录都是历史访问过的目录。因为，在没有输入任何内容的情况下，我们输入 tab 的，它列出最近访问过的目录。\n如果我们输入形如 z substring，即提供子字符串，它们将所有匹配 substring 的目录都列举出来。\n效果如下：\n例如，我们输入 z blog，紧跟 tab 键，会直接列出访问过包含 blog 的目录。\n如果输入内容只有一个关联的目录名，它会如图上一样直接补全。\n演示效果：\n我们输入 z tmux，因为匹配 tmux 的目录只有一个，将会被直接选中。\n当然，其实这里匹配的目录名只有一个，直接输入 Enter 就可以进入目录，无需 tab 选择多次一举了。\n演示效果：\n我们输入 z tmux，直接 Enter 确认，即可进入到目录。\nz 非常强大是吧？\n其实，有一款更强大的命令，名为 zoxide，也提供了类似的能力，它的灵感是来源于 z。我一般用的是它，后面我会介绍。\n当然，这不妨碍你继续使用 oh-my-zsh 内置的工具 z，毕竟它很容易配置。\n插件 5 - vi-mode # vi-mode 插件 支持在命令行开启 vi 模式，利用 vi 键进行命令行编辑。这个插件，视个人情况，是否使用吧。如果你是一个 vi 忠实用户，可考虑开启。否则，还是简单最好，否则容易影响心情。\n这个插件就不多介绍了，更多查看 它的文档。另外，如果确实对 vim 感兴趣，也可以考虑另外一个 vi 插件，名为 zsh-vi-mode，它的能力更强大，也解决这个默认 vi 插件的一些不好用的 bug，不过它的配置有点复杂。\n"},{"id":13,"href":"/mytermenv/docs/terminal/install/","title":"安装与主题","section":"iTerm2","content":" 安装与主题 # 本节介绍 iTerm2 安装与主题。\n安装 # 首先是安装，可通过 iTerm2 官网 下载或者 MacOS 中 brew 安装，我将以 brew 安装为例。\n如果还未安装 brew，安装命令：\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 安装 iterm2，命令如下：\nbrew install --cask iterm2 等待执行完成，即安装完毕。\n主题 # iTerm2 支持自定义主题，即设置颜色面板 color preset。我将先以 material design colors 为例，介绍如何安装设置。\n它的安装命令，如下所示：\ncurl -Ls https://raw.githubusercontent.com/MartinSeeler/iterm2-material-design/master/material-design-colors.itermcolors \u0026gt; /tmp/material-design-colors.itermcolors \u0026amp;\u0026amp; open /tmp/material-design-colors.itermcolors 如果成功执行，将会在 iTerm2 的 Preferences （使用快捷键 CMD+, 可快捷打开）-\u0026gt; Color 下的 \u0026ldquo;Color Presets\u0026rdquo; 中新增一条颜色面板选项，即 \u0026ldquo;material-design-color\u0026rdquo;。选中确认即可将 iTerm2 默认的颜色面板修改为 \u0026ldquo;material-design-color\u0026rdquo;。\n上面的命令分为两步：首先通过 curl 下载配色文件，然后再通过 open 打开下载即可直接安装。\n稍微麻烦一点做法是，可通过设置面板 import 导入下载的后缀为 itermcolors 的文件。\n如下所示：\n想有更多的选择，再安装两个配色方案：\n安装 Snazzy：\ncurl -Ls https://raw.githubusercontent.com/sindresorhus/iterm2-snazzy/main/Snazzy.itermcolors \u0026gt; /tmp/Snazzy.itermcolors \u0026amp;\u0026amp; open /tmp/Snazzy.itermcolors 安装 Dracula:\ncurl -Ls https://raw.githubusercontent.com/dracula/iterm/master/Dracula.itermcolors \u0026gt; /tmp/Dracula.itermcolors \u0026amp;\u0026amp; open /tmp/Dracula.itermcolors 查看 Color Presets 面板，如下所示：\n选择一款你钟爱的配色，保存。\n如果还没有满意的，可以从 Iterm2-color-schemes 查找更多配色方案\n我从中选择了主题进行安装。如下是主题切换的效果：\n"},{"id":14,"href":"/mytermenv/docs/zsh/install/","title":"快速安装","section":"zsh","content":" 安装 # 对于不同系统，zsh 的安装命令，如下所示：\nDebian\napt install zsh Centos\nyum install -y zsh Arch Linux\npacman -S zsh Fedora\ndnf install zsh 对于 macOS 系统的用户，MacOS 的默认 shell 从 2019 开始以前替换为 zsh，该步骤可省略。可阅读： What is Zsh? Should You Use it? 其中有介绍为什么 2019 macOS 将默认的 shell 从 bash 切换到 zsh。\n我看下来，主要原因就是版权问题啦。\n如果你是个老古董，还是用 MacOS 2019 之前的系统，可通过如下命令安装：\nbrew install zsh 安装完成后，将 zsh 设置为默认 shell，命令如下所示：\nchsh -s /bin/zsh 通过如下命令检查下是否成功。\necho $SHELL zsh "},{"id":15,"href":"/mytermenv/docs/commands/search/","title":"搜索查找","section":"高效命令","content":" 搜索查找 # 本文将介绍三个高效搜索命令，分别是 fd、ripgrep 与 fzf。fd 和 ripgreap 对标的是传统 grep 和 find，它们在性能和体验上有大幅提升。\n如果你成为 10x 程序员，强烈推荐使用它们。\n快速一览：\nfd，目录与文件搜索命令，比默认 find 更易于使用，而且查找速度上更快； ripgrep，可用于高效的内容搜索，比默认的 grep 命令速度更快； fzf，命令行交互式模糊搜索工具，可与其他命令进行结合，提高使用体验； 如上的 fd 与 ripgrep 是由 rust 编写，性能上完虐传统的 find 与 grep。\n"},{"id":16,"href":"/mytermenv/docs/commands/filesystem/bat/","title":"bat","section":"文件目录","content":" bat # 说完了 ls 列举目录，cd 进入目录，我们继续介绍一个命令， bat 查看文件内容。\n这个 bat 和 Baidu/Alibaba/Tencent 没有联系，它是一款支持语法高亮、GIT 集成的用于替换类 Unix 系统下快速查看文件内容的命令，功能与 cat 相似的命令。\n我们直接介绍它的安装与使用吧。\n安装 # brew install bat # 其他系统请查看 GithHub README.md 使用 # 对于 bat 命令，我先介绍它的使用，然后再谈配置，因为配置并非它的必选项而是优化项。\nbat 相比于 cat 的第一个优势，就是它支持语法高亮效果与行号显示。如我们查看一个 Go 的源码文件，效果如下：\n而且，bat 还集成 Git。如下我们修改了 logger.go 文件，通过 bat 即可查看它的修改点；\n默认情况下，bat 采用分页输出，这对于读取大文件非常有帮助，不用担心失误导致产生一大片控制台输出。但如果你希望 bat 和 cat 一样，一次性无分页输出文本，可通过 --pager=never 或 --no-pager 选项实现。\nbat --pager=never logger.go bat --no-pager logger.go 如果你习惯使用 cat 的模式，希望默认不启用分页能力，可直接在配置文件配置默认行为，在其中增加 --pager=never。\n接下来说说如何通过 bat 的配置改变它的默认行为吧。\n配置 # bat 的配置文件路径是通过环境变量指定的。我们在 .zshrc 中设置 bat 配置文件位置环境变量。\nexport BAT_CONFIG_PATH=\u0026#34;${XDG_CONFIG_HOME:-~/.config/bat.conf\u0026#34; 生效后，执行如下命令将会生成配置文件：\nbat --generate-config-file 生成配置文件，位于 ~/.config/bat.conf。\n假设我不喜欢 bat 默认的主题，就可以通过配置修改了。如配置 bat 默认选项，将主题改为 --theme=TwoDark 启用：\n# Specify desired highlighting theme (e.g. \u0026#34;TwoDark\u0026#34;). Run `bat --list-themes` # for a list of all available themes --theme=TwoDark 如果你想查看更多主题，可通过 bat --list-themes 查看 bat 支持的主题列表。\n现在，不想启用 bat 的分页能力，在配置中添加：\n--pager=never 别名 # 觉得 bat 不错，想直接替换 cat 命令，在 zshrc 中配置别名即可，将默认 cat 命令，替换为 bat，如下所示：\nalias cat=\u0026#39;bat\u0026#39; "},{"id":17,"href":"/mytermenv/docs/ohmyzsh/","title":"ohmyzsh","section":"介绍","content":" ohmyzsh # oh-my-zsh 是用于管理 zsh 配置的轻量级框架，具有开箱即用的特点，而且它提供了大量内置插件。让我们用它快速配置 zsh 吧！\noh-my-zsh 这个名字起的很骚气的，大概就是下面这样表情。\n想表达的可能是，当别人看你用 oh-my-zsh 配置的终端，大概率发出 \u0026ldquo;wow! 你的终端太赞了！\u0026rdquo;\n推荐一个网站 # 在开始前，我想先推荐一个 github 仓库，awesome-zsh-plugins，通过浏览器打开 awesome-zsh-plugins，里面提供了相当丰富的 zsh 的框架、教程、插件与主题等等，是 zsh 的资源合集。\n包括如框架、插件和主题等。如 oh-my-zsh，还有其他的一些框架。其中，还有关于 zsh 的教程。除了 oh-my-zsh 内置主题，还有更多主题可选，如将在后面讲介绍的 powerlevel10k 这个 zsh 主题，在这个文档里也能找到。\n"},{"id":18,"href":"/mytermenv/docs/ohmyzsh/basicplugins2/","title":"基础插件 2","section":"ohmyzsh","content":"本文是基础篇插件的第二篇，继续介绍 4 个常用的 zsh 插件。我将涉及的插件，如下所示：\nname description copypath 拷贝路径到剪贴版； copyfile 拷贝文件内容到剪贴板； copybuffer 拷贝命令行内容到剪贴板； sudo 命令行开头快速添加 sudo； 让我们正式开始。\n推荐插件 # 先说 oh-my-zsh 的内置插件。\n打开 zsh 配置文件 ~/.zshrc，将要使用的 oh-my-zsh 的内置插件提前配置。\nplugins=(... copypath copyfile copybuffer sudo ...) 保存退出，执行 source ~/.zshrc 生效。\ncopypath # copypath 的用途如其名，就是用来 copy 路径的。\n支持两种用法。\ncopypath: 无参数，直接拷贝当前路径；\ncopypath \u0026lt;文件或目录\u0026gt;：拷贝指定文件或目录的绝对路径；\n相比于 pwd 之后再拷贝，这种方式真的是省心省力的方式。\ncopyfile # copyfile，用于拷贝文件内容，命令格式 copyfile \u0026lt;文件路径\u0026gt;。\n假设，现有一个文件 test.txt。\ncat test.txt Hello oh my zsh 一个测试命令，copyfile test.txt，即可将 test.txt 文件中的内容拷贝到剪贴板中。\n效果如下：\n无需鼠标选中复制粘贴。\ncopybuffer # copybuffer，是用于快速复制当前命令行的输入。\n如何使用呢？\n它不同于前面两个快捷键，要通过 CTRL+o 快捷键拷贝命令行内容。\n特别说明，我在测试的时候，发现 copybuffer 与 vi-mode 存在冲突，不过如果启用了 vi-mode， 命令行内容拷贝可直接使用 yy，无续开启 copybuffer；\nsudo # sudo 的主要作用是，当我们输入某个命令，如 vim /etc/zshrc，发现没有系统权限，利用 sudo 插件，可快速将 sudo 作为前缀添加到命令最前面。\n演示效果如下所示：\n"},{"id":19,"href":"/mytermenv/docs/commands/dev/","title":"开发调试","section":"高效命令","content":" 开发调试 # 本文将介绍的 3 命令，用于提高 Web 开发人员们的日常工作效率。\n对 Web 开发而言，除了基本的框架外，日常开发过程中，还常用的必然就是调试工具。本文将要介绍的三个命令分别是 entr、httpie、jq，主要是为了这个目的而生。\nentr，它的主要作用是在当监听文件变化后，执行相应的命令； httpie，相对于 curl，一款体验更加友好的 http client 命令； jq，一款强大的 JSON 数据的解析命令，甚至可简单的编程； 这三个命令在日常的 web 开发过程中扮演着不同的角色。\n"},{"id":20,"href":"/mytermenv/docs/terminal/usage/","title":"开始使用","section":"iTerm2","content":" 开始使用 # 打开 \u0026lsquo;iTerm2\u0026rsquo;，快速使用体验一下吧。\n分屏功能 # 如下图所示，\u0026ldquo;CommandL+d\u0026rdquo; 垂直分屏，\u0026ldquo;Command+D\u0026rdquo; 水平分屏。\n当然，这个快捷键是可以配置的，因为这两个快捷键趋势不够便捷。我们打开它的快捷键配置，进入 Preferences -\u0026gt; Keys -\u0026gt; key Binds 即可开始设置快捷键键。\n其中的红色框内容可用于设置如何水平和垂直分割屏幕：\nSHIFT+COMMAND+| -\u0026gt; 水平切片 split horizontally； SHIFT+COMMAND+- -\u0026gt; 水平切片 split horizontally； 其中的蓝色框区域可用于设置 vim 风格的上下左右分屏切换：\nCOMMAND+h：向左选中 COMMAND+j：向下选中 COMMAND+k：向上选中 COMMAND+l：向右选中 对于习惯使用 vim，但不是每个任务都有打开 tmux + vim 组合的时候，这个快捷键的设置就是效率神器啊。\n分屏最大化 # 如下图所示，\u0026ldquo;Shift+Command+Enter\u0026rdquo; 分屏最大化。\n再次 \u0026ldquo;Shift+Command+Enter\u0026rdquo; 恢复分屏。\n如果你习惯于在终端工作，那么分屏功能肯定是日常使用最多的能力了吧。如上的三分屏幕效果，左边座位代码编辑区域、右上方用于调试或运行代码，下面可用于其他一些测试或者运行命令区域。\n支持搜索 # 相对于 通过 \u0026ldquo;Command+f\u0026rdquo; 开启搜索框：\niTerm2 的搜索能力更强大，可以在搜索框下拉仔细检查下它能力。诸如默认的 smartcase 模式、大小写敏感和不敏感模式、正则。可能你觉得这些不是很正常吗？俗话说，没有对比就没有伤害，如果你和系统默认的终端对比下就知道它的优秀之处了。\n其他 # iTerm2 是真彩 256 colors，这才让我们可以在 iTerm2 将 neovim 打造成媲美 vscode 的 IDE。\n真彩测试，如下所示；\n获取脚本，访问 脚本地址。\nIDE 效果：\n还有，我们可以直接在 iTerm2 查看图片，静态图片和 GIF 都是支持的。\n我现在就希望有一天终端支持内置浏览器，实现我 360 度无死角不用离开终端的梦想。我知道有一些文本 browser，如 w3m、lynx、links 等等。还有 browsh 这样的利用 firefox 渲染，终端展示的图形化支持的浏览器。但体验都巨差，无法真正意义上替换浏览器。\n我的梦啊！\n"},{"id":21,"href":"/mytermenv/docs/terminal/pyapi/","title":"Python API","section":"iTerm2","content":" Python API # 这部分主要介绍 iTerm2 提供的 Python API，利用它，带你实现一些不一样的能力。我将演示两个案例，分别是背景图自动更换和分屏创建自动化。\n自动更换背景图 # 编程枯燥无味，想通过背景图为枯燥生活提供一些趣味。假设，我们要设计一个脚本，给终端一小时自动更好一个背景图。\n假设我的壁纸图片都在 ~/Public/images/beauties 目录下。\n实现下这个代码，如下所示：\nimport iterm2 import random import os import asyncio import sys # 替换背景图片的函数 async def change_background(session, image_path): # 获取当前会话的配置文件 profile = await session.async_get_profile() # 设置透明度，值在0（完全透明）到1（完全不透明）之间 await profile.async_set_transparency(0.2) # 设置为50%透明度 # 设置背景图像位置 await profile.async_set_background_image_location(image_path) async def main(connection): app = await iterm2.async_get_app(connection) window = app.current_terminal_window if window is None: return session = window.current_tab.current_session # 获取脚本参数提供的目录 directory = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#34;.\u0026#34; if not os.path.isdir(directory): raise ValueError(f\u0026#34;Provided path {directory} is not a directory\u0026#34;) while True: # 创建无限循环以定期更换背景 # 获取目录中的所有图片文件 image_files = [ os.path.join(directory, f) for f in os.listdir(directory) if f.lower().endswith((\u0026#34;.png\u0026#34;, \u0026#34;.jpg\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.tiff\u0026#34;, \u0026#34;.bmp\u0026#34;, \u0026#34;.gif\u0026#34;)) ] if image_files: # 随机选择一张图片 chosen_image = os.path.abspath(random.choice(image_files)) # 调用函数更改背景 await change_background(session, chosen_image) else: print(f\u0026#34;No images found in directory {directory}\u0026#34;) # 等待一个小时 await asyncio.sleep(3600) iterm2.run_until_complete(main) 代码中提供了注释说明，不熟悉 Python 直接考虑即可，命令的接收参数是存放图片的目录。\n定时能力，我们是通过 sleep(3600) 实现每小时随机更换背景图片。特别说明，不要用 crontab，因为存在环境上下文问题，crontab 无法知道 iTerm2 的存在。\n这个脚本可以放在 sh 的启动脚本中，如 bashrc、zshrc 等，这取决于你用什么 shell。我们只要将其设置为后台常驻的形式运行，\npython random-bg.py your-images-directory \u0026amp; 我假设将它设置为 1 秒换一次图片，效果如下所示：\n布局自动化 # 如果你用 tmux 的话，可能知道有些布局管理工具，如 tmuxifier 和 tmuxinator， 可自动创建布局。其实，只用 iTerm2，同样可实现这样的功能。\n因为 iTerm2 的 Python API 提供了创建分屏的接口。\n示例代码如下所示：\nimport iterm2 async def main(connection): app = await iterm2.async_get_app(connection) window = app.current_terminal_window if window is None: print(\u0026#34;No current window\u0026#34;) return session = window.current_tab.current_session # 垂直分屏 await session.async_split_pane(vertical=True) # 如果你想要水平分屏，将vertical参数设置为False # await session.async_split_pane(vertical=False) iterm2.run_until_complete(main) 重点就是那句 await session.async_split_pane(vertical=True)，执行这个角度会自动进行左右分屏，即垂直分屏。\n演示效果如下：\n假设，你想自定义一些布局的话，如前面提到这个效果，如下所示：\n我们来实现一个命令自动创建这个效果。\n需求详细描述，iTerm2 自动创建三个 pane 的布局，左边 pane 用于通过 vim 命令打开指定目录（IDE 写代码)，右边上下两个 pane 中，上面的 pane 执行 go run *.go 命令，下面的 pane 创建清空等待输入。\n编写这样一个脚本来实现这个流程，代码如下：\nimport iterm2 import sys async def main(connection): # 获取要打开的目录作为参数 directory = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#34;.\u0026#34; app = await iterm2.async_get_app(connection) window = app.current_terminal_window if window is not None: # 创建左边的pane left_session = window.current_tab.current_session await left_session.async_send_text(f\u0026#34;cd {directory}\\n\u0026#34;) await left_session.async_send_text(\u0026#34;vim\\n\u0026#34;) # 创建右边的pane # 右上的pane保持空白 top_right_session = await left_session.async_split_pane(vertical=True) await top_right_session.async_send_text(\u0026#34;\\clear\\n\u0026#34;) await top_right_session.async_send_text(\u0026#34;go run *.go\\n\u0026#34;) # 在右下的pane执行go run *.go bottom_right_session = await top_right_session.async_split_pane(vertical=False) await bottom_right_session.async_send_text(\u0026#34;\\clear\\n\u0026#34;) else: print(\u0026#34;No current window\u0026#34;) iterm2.run_until_complete(main) 就不啰嗦代码逻辑了，非常简单。\n命令效果，如下所示：\nPython API 的使用就演示这两个案例。想了解它的更多能力，可直接查看它的官方文档，访问 iTemr2 Python API Documentation。\n"},{"id":22,"href":"/mytermenv/docs/commands/","title":"高效命令","section":"介绍","content":" 高效 Shell 命令 # 类 Unix 系统发展多年，不少古董命令还在占据终端的绝大部分时间，但它们的使用体验上却是差强人意。最能说明问题的就是那个 cd 命令，无论是多么丝滑的操作，一旦遇到需要 change directory 就会变得磕磕绊绊。\n本章节，我计划介绍提升终端效率的一系列命令，它们更具现代风格，希望能让你眼前一亮。\n"},{"id":23,"href":"/mytermenv/docs/ohmyzsh/advancedplugins/","title":"高级插件","section":"ohmyzsh","content":" 高级插件 # 我们再来了解 4 个非 oh-my-zsh 内置插件，它们 zsh-syntax-highlighting、zsh-autosuggestions、zsh-substring-history-search 和 you-should-use。这两个插件由 zsh 社区开发。\n开始介绍前，先将这两个插件全部安装配置完成。\n下载 # 下载命令如下所示：\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search git clone https://github.com/MichaelAquilina/zsh-you-should-use.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/you-should-use 配置 # 打开 .zshrc 完成配置：\nplugins=(..., zsh-syntax-highlighting zsh-autosuggestions zsh-history-substring-search you-should-use)) 记得执行 source ~/.zshrc 生效配置。\n插件 1：zsh-syntax-highlighting # zsh-syntax-highlighting 是 zsh 的语法高亮插件，如果输入的命令不存在，或者输入 shell 语法不正确，将会自动以红色表示。它的优点就是，当我们在终端输入，实时输入实时反馈。\n首先，我们尝试下错误命令，提示效果，如下所示：\n再来看看，正确命令提示效果，如下所示：\n对，就是这么简单。通过这个插件提供的实时反馈，可以防止我们在命令执行后，才知道输入错了。\n插件 2：zsh-autosuggestions # zsh-autosuggestions 可以说是我最喜欢的插件了。\n它的作用是什么呢？\n它可用于提示补全建议，当输入字符，默认情况下，它基于我们的历史命令自动提供输入建议。还记得前面提到的，zsh 的历史命令是在不同的会话间共享。现在，再结合 zsh-autosuggestions 插件，简直不要太爽。哈哈。\n我们先看下效果，如下所示：\n默认情况下，输入右方向键 → 可将建议直接输入终端。\n但这个其实体验很差，对于一个双手不想离开键盘中心区域的人而言，通过右键接受提示建议，这简直不能忍啊。是否能改变这个默认快捷键呢？\n我的目标是希望通过输入 Ctrl + / 接受建议，配置实现，如下所示：\n# \u0026lt;Ctrl+/\u0026gt; 接受 auto-suggestion 的补全建议 bindkey \u0026#39;^_\u0026#39; autosuggest-accept 对！不要怀疑，CTRL+/ 的的字符表示就是 \u0026lsquo;^_\u0026rsquo;，我们可以通过执行 cat 命令查看，输入 CTRL+/，会到看如下输出。\n如果你不知道想要设置的快捷键的字符表示，可以通过这种方式找到。\n另外，如果希望 zsh-autosuggestion 不仅支持 history，也支持自动补全的建议提示，即原来那些要输入 tab 才能出现的内容，如子命令、命令选项、目录文件等提示，也能在提示建议的范围中。我们只需增加 completeion 这个配置项。\n如下所示：\nexport ZSH_AUTOSUGGEST_STRATEGY=(history completion) 现在，如果输入时，还没有历史命令可作为建议，会提供类似于目录、参数选项等建议。\n类似于如下的效果：\n插件 3：zsh-history-substring-search # 先介绍 zsh-history-substring-search。它的主要用途是什么？\n一般情况下，在使用 zsh 时，通过 ↑ 或 ↓ 方向键，能实现类似按前缀匹配补齐的效果。\n而如果输入的是中间的字符串，则没法自动补齐。这个插件真是为这个目的而生的。\n使用这个插件前，除了启用插件以外，还需要进一步配置下，将 zsh-history-substring-search 提供的能力绑定到快捷按键。\n例如，上下方向键 ↑ 和 ↓。\nbindkey \u0026#39;^[[A\u0026#39; history-substring-search-up bindkey \u0026#39;^[[B\u0026#39; history-substring-search-down 在生效配置后，测试失败的话，查看文档，其中有介绍：\nHowever, if the observed values don\u0026rsquo;t work, you can try using terminfo:\nbindkey \u0026ldquo;$terminfo[kcuu1]\u0026rdquo; history-substring-search-up bindkey \u0026ldquo;$terminfo[kcud1]\u0026rdquo; history-substring-search-down\n那我们就增加这两行配置吧。\nbindkey \u0026#34;$terminfo[kcuu1]\u0026#34; history-substring-search-up bindkey \u0026#34;$terminfo[kcud1]\u0026#34; history-substring-search-down 除了 ↑ ↓ 按键外，我一般还习惯使用 CTRL+P/N 上下查找历史记录，配置如下：\nbindkey \u0026#39;^p\u0026#39; history-substring-search-up bindkey \u0026#39;^n\u0026#39; history-substring-search-down 如果希望支持 vi 的 jk，配置如下：\nbindkey -M vicmd \u0026#39;k\u0026#39; history-substring-search-up bindkey -M vicmd \u0026#39;j\u0026#39; history-substring-search-up 保存生效配置，测试下最终的成功成果吧。效果如下所示：\n另外，高亮样色可配置化的，可通过类似如下语法实现：\nexport HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND=(bg=none,fg=magenta,bold) 设置 background 为 none，即无色，而 front 设置为 magenta,bold。效果如下：\n如上的 zsh 的颜色变量，可查看 zsh 仓库文档 发现更多颜色。\ncolor=( # Codes listed in this array are from ECMA-48, Section 8.3.117, p. 61. # Those that are commented out are not widely supported or aren\u0026#39;t closely # enough related to color manipulation, but are included for completeness. # Attribute codes: 00 none # 20 gothic 01 bold # 21 double-underline 02 faint 22 normal 03 italic 23 no-italic # no-gothic 04 underline 24 no-underline 05 blink 25 no-blink # 06 fast-blink # 26 proportional 07 reverse 27 no-reverse # 07 standout 27 no-standout 08 conceal 28 no-conceal # 09 strikethrough # 29 no-strikethrough # ... # Bright color codes (xterm extension) 90 bright-gray 100 bg-bright-gray 91 bright-red 101 bg-bright-red 92 bright-green 102 bg-bright-green 93 bright-yellow 103 bg-bright-yellow 94 bright-blue 104 bg-bright-blue 95 bright-magenta 105 bg-bright-magenta 96 bright-cyan 106 bg-bright-cyan 97 bright-white 107 bg-bright-white ) 插件 4：you-should-use # you-should-use 用途是，如果执行的命令存在别名，会自动提示推荐使用的别名；\n由于，默认的提示信息在命令输出之前，添加如下配置：\nexport YSU_MESSAGE_POSITION=\u0026#34;after\u0026#34; 它的作用是，实现将提示信息打印在命令输出的最后。\n最终效果演示，如下：\n总结 # 本文介绍了 4 个 zsh 高级插件，每个插件都有特定的场景用途，希望能给大家的日常工作提升效率。\n"},{"id":24,"href":"/mytermenv/docs/startup/","title":"启动消息","section":"介绍","content":" 启动消息 # "},{"id":25,"href":"/mytermenv/docs/ohmyzsh/powerlevel10k/","title":"自定义提示主题","section":"ohmyzsh","content":" 自定义提示主题 # 不知道你是否想过自定义 Shell 提示符主题能带来的不仅是终端美观度的提升，还能通过视觉优化增强了工作效率呢？\n在众多 shell 提示符主题中，Powerlevel10k 因为支持高度可定制和丰富的功能选，非常值得推荐。本文基于这个主题介绍 zsh 主题插件 powerlevel10k，包括它的安装和配置自定义。\n什么是 powerlevel10k? # Powerlevel10 是一款 zsh 的主题，强调性能、灵活性和开箱即用，但同时自定义能力极强。前面介绍 zsh 轻量级框架 oh-my-zsh 时，提到过一些 zsh 主题，而通过 p10k（powerlevel10k 的简称）的自定义配置化能力，同样能配置出覆盖出之前主题的类似效果，当然相对而言，也更加强大。\n效果展示：\n安装依赖字体 # 在安装 powerlevel10k 前，要先安装它依赖的字体： NerdFont。不同系统下的安装方法，查看 它的文档。\n简单说下 Nerd Fonts 字体。它是一系列开源字体的集合，被特别增强，它包含大量的图标和符号，如开发工具、编程语言和版本控制系统的图标。这些字体对于提高我们终端和编辑器的视觉体验和功能性有着极大帮助。\n有了它，我们的终端才能显示一些复杂字体甚至是图标。\nMacOS 的话，可直接通过 Homebrew 快速安装：\nbrew tap homebrew/cask-fonts brew install font-hack-nerd-font 安装完成，配置终端字体，进入 iTerm2 Settings -\u0026gt; Profiles -\u0026gt; Text -\u0026gt; Font -\u0026gt; MesloLGS NF 即可。\n现在，我们终端就支持 NerdFont 字体了。\n如何测试？\n接下来安装 Powerlevel10k 时，它会提示我们检查字体是否正确安装。\n安装 powerlevel10k # 先通过如下的命令下载插件源码放到指定的位置。\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 在 ~/.zshrc 配置启动 powerlevel10k 主题插件。\nZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 现在我们只要重新终端或执行 source ~/.zshrc 生效配置就会进入到配置向导流程中了。\n配置 powerlevel10k # 终端将进入到 powerlevel10k 的配置向导后，我们通过回答问题来完成自定义的安装流程。这个流程有点繁琐，我将一步一步介绍，要跟着操作可能更有感觉吧。\n前置问题 # 首先，为了确认 NerdFont 字体安装成功，正式开始配置前，要先提出几个问题，识别图片是否如描述说的那样。我们回答后才能进入到主题的自定义。\n这些问题有诸如：\nDoes this look like a diamond (rotated square)? 这是看起来钻石吗？ Does this look like a lock? 这看起来是锁吗？ Does this look like an upwards arrow? 这看起来是向上箭头吗？ 等等。\n如果已经成功安装配置了字体，这些问题看起来就像逗傻子一样，按实际情况回答问题即可。如果字体安装成功，都是选择 \u0026ldquo;Yes\u0026rdquo; 即可。\n开始配置 # 进入到正式阶段，按步骤配置自己的提示符风格，下面一共 12 步，都是非常简单的回答问题。考虑到第一次配置，有懵逼的可能性，我把全部的步骤都列出来了。\n选择提示符风格，分别是 Lean、Classic、Rainbow 和 Pure。我选风格 3，大众所爱的风格，彩虹 Rainbow，则输入 3。\n字符集设置，毫无疑问，配置 unicode，选择 1。\n提示符显示当前时间风格。我选择 1，只显示命令耗时，不显示当前时间。\n提示符分隔符，也就是 src/master 之间的符号风格。我钟爱箭头，选择 1 -\u0026gt; Angled.\n提示符头部风格，就是 master \u0026gt; 的风格选择。毫无疑问，我钟爱箭头，选择 1 - Sharp。\n提示符尾部风格，钟爱箭头，但不是双箭头，选择 1 - Flat。\n提示符高度，显示一行还是两行，体验过两行，还是一行更紧凑一些，选择 1 - one line。\n两个命令键的间距，我喜欢两行离的近一点，选择 1 - Compact。\n提示符 Icons，多点 Icon 更帅，否则看起来就和一般主题没区别了，so 选择 2 - Many Icons。\n提示符丰富度，增加一些文本描述，帮助理解提示符中字符含义。还是简洁为美，毕竟空间不能占用太多，而且含义简单，无需文本辅助。我选择 1 - Consice。\n这是什么配置ne？提示符瞬闪？好像命令执行后提示符就立刻消失，只保留在最新的提示符，先选择 n - No 看看效果吧。\n提示符高性能模式，是否启用。推荐启用，就启用吧 1-verbose，如果发现有兼容问题，在重新配置 off。\n到此基本全部的配置都已经完成，powerlevel10k 命令行提示符的最终效果，如下所示：\n重新配置 # 在配置完成后，如果希望重新配置，重启整个流程，直接执行 p10k configure ，它会重新打开配置向导。\n配置文件 # 通过 powerlevel10k 的配置导航能快速自定义提示符的主题风格，但如想更细粒度的配置，可直接在 $HOME/.p10k.zsh 配置，配置导航只是最粗粒度的配置方式。\n如配置提示符两侧内容，通过 ~/.p10k.sh 中的变量 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS 和 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 设置。\n配置文件的内容，如下所示：\ntypeset -g POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=( # 操作系统图标 os_icon # 当前目录 dir # 版本控制信息 vcs # 提示符 # prompt_char ) typeset -g POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( # 最后一条命令的退出码 status # 最后一条命令的执行时间 command_execution_time ... # 当前时间 # time ... ) 前面配置时，设置了不显示当前时间，可以通过打开 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 中的 time 重新显示时间。\n还有前面对提示符瞬闪的配置，transient 设置为 off。如果希望启用，同时有不重新经历一次配置向导，直接进入 ~/.p10k.zsh 配置变量 POWERLEVEL9K_TRANSIENT_PROMPT=always，即可。\n# Transient prompt works similarly to the builtin transient_rprompt option. It trims down prompt # when accepting a command line. Supported values: # # - off: Don\u0026#39;t change prompt when accepting a command line. # - always: Trim down prompt when accepting a command line. # - same-dir: Trim down prompt when accepting a command line unless this is the first command # typed after changing current working directory. typeset -g POWERLEVEL9K_TRANSIENT_PROMPT=always Powerlevel10k 还进一步集成了对各种工具的支持，包括但不限于 npm、k8s、Python 和 Go。在 ~/.p10k.zsh 中配置相应的提示元素，如 node_version、kubecontext、python_version 和 go_version。\n这些都是位于 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 配置项下。\ntypeset -g POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( # ... virtualenv anaconda pyenv goenv nodenv nvm nodeenv node_version go_version rust_version dotnet_version php_version laravel_version java_version package rbenv rvm fvm luaenv jenv plenv perlbrew phpenv scalaenv haskell_stack kubecontext terraform terraform_version aws aws_eb_env azure gcloud google_app_cred toolbox context nordvpn ranger nnn lf xplr vim_shell midnight_commander nix_shell chezmoi_shell vpn_ip load disk_usage ram swap todo timewarrior taskwarrior per_directory_history cpu_arch time newline ip public_ip proxy battery wifi example ) 这些配置让我们也可以在提示符中直观地看到当前环境的版本信息，以及 Kubernetes 上下文等关键信息，从而使我们的工作流程更加高效、直观。\n这里只是简单介绍了 powerlevel10k 的配置。想了解它的更多能力，可以在 ~/.p10k.sh 继续探索。\n总结 # 本文介绍了 powerlevel10k 的安装与配置。如果希望你命令行提示能给你提供更多信息，减少使用终端时的一些心智负担，如少执行几次版本，分支或所在上下文查询的命令，强烈推荐安装 powerlevel10k！\n"},{"id":26,"href":"/mytermenv/readme/","title":"Readme","section":"高效终端","content":" Fyne 中文文档 # Fyne 是一款 GO 实现 GUI 框架，本文档是基于 Fyne v2.4 的官方文档中文翻译版。英文原版，请异步 docs.fyne.io。\n"},{"id":27,"href":"/mytermenv/docs/commands/search/fzf/","title":"fzf","section":"搜索查找","content":" fzf # fzf 全名 fuzzy finder，一款通用的命令行模糊查找工具。它可与其他命令结合，提升其他命令的使用体验。\n安装 # brew install fzf 目录搜索 # fzf 的默认行为是在当前目录搜索。当然它的搜索和 fd 的搜索不同，它会进入交互式模式搜索文件或目录路径。\n它支持通过 CTRL+P/N 上下选择，确认搜索结果后，输入 Enter 确认后，它会将输出直接作为输出打印到标准输出。由于它输出为标准输出，我们就有了更多可能性，通过管道将它与其他命令结合。\n命令组合 # fzf 最大的魅力在于，我们可将其与其他命令组合，如\n将其他命令的输出作为 fzf 的输入，基于它进行搜索； 或将 fzf 的搜索内容作为其他命令的输入，更智能使用其他命令。 我们具体介绍下吧。\n首先，我们示例将 one、two、three、four 作为输入，通过 fzf 搜索选择。\necho \u0026#34;one\\ntwo\\nthree\\nfour\u0026#34; | fzf 更多可能就诞生了，我们可以讲 ls 的输出作为 fzf 的输入。\nls | fzf 将 fd 查找结果作为 fzf 的输入。\nfd --type file | fzf 接下来，我们尝试将搜索结果作为其他命令的输入。毕竟，如果 fzf 的搜索结果只是输出到终端，那就太可惜了，可将其作为其它命令的输入。\n如将 fzf 搜索结果作为 vim 的输入，助力 vim 快速打开文件。\nvim `fzf` 我们也可以将多个命令组合，fzf 从其他命令接收输入，同时将搜索结果输出给其他啊命令。这样就能实现更多可能。\n实际场景 # 是不是已经发现，fzf 实现更多可能性的能力，如 command1 | fzf | xargs command2，将 command1 的结果作为 fzf 的搜索来源，将 fzf 的确认结果作为 command2 的输入。\n如 cd 的替代命令 zoxide，它有个高效 cdi 命令，能快速进入某个目录，我们可用 fzf 实现：\ncd `zoxide query --list {querystring} | fzf` 默认的 zoxide query --list 只记录的是 zoxide 中的历史记录，如想实现进入任意的目录，可使用如下命令：\ncd `fd --type=directory | fzf` 如下是一个 cdg 命令，作用是交互式搜索全局任意目录并通过 cd 进入。可 zoxide 中的 cdi 对比。\nalias cdg=\u0026#39;cd_global() {cd $(fd --type directory $1 $2 | fzf)}; cd_global\u0026#39; 使用方式形如 cdg pattern directory，在哪一个目录下查询包含 pattern 的目录，确认后即可 cd 进入到这个目录。\n"},{"id":28,"href":"/mytermenv/docs/","title":"介绍","section":"高效终端","content":"本文档是 Go GUI 框架 Fyne 的中文翻译，英文原版请查看： docs.fyne.io/doc\n"}]