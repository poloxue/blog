<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Backtrader 教程一：为什么选择 Backtrader？ - 菠萝学量化</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Backtrader 教程一：为什么选择 Backtrader？"><meta itemprop=description content="今天想跟大家聊一个量化交易中非常实用的工具——Backtrader。
如果你对量化交易感兴趣，可能已经听说过策略回测。简单说，就是用历史数据去验证一个交易策略有没有效。在Python里，其实有不少回测框架可以用，比如backtesting.py、vectorbt，还有已经不更新的 zipline。
但今天，我要重点介绍的是——Backtrader。
🤔 为什么选Backtrader？ 因为构建一个稳健的交易系统，光有策略还不够，还需要有清晰的架构、可扩展的功能，以及模块化的设计。而Backtrader，就是一个以策略回测为核心，同时帮你搭建交易系统骨架的Python框架。
它不只是回测工具，更是一个轻量级的“交易系统骨架”。
🔍 Backtrader是什么？ Backtrader是一个用Python写的量化回测框架，专门为个人交易者和研究者设计。它支持策略开发、历史回测、可视化分析，甚至还能接入实盘交易。
更重要的是，它采用面向对象的设计，把策略、数据、订单、资金账户这些模块分得清清楚楚，你不用把所有代码都塞在一个脚本里，而是像搭积木一样，有条不紊地搭建系统。
🧱 核心架构：五大模块 Backtrader的架构非常清晰，主要由五个模块组成：
策略逻辑（Strategy）
你把买卖信号的判断写在这里，框架自动帮你执行订单，你不用操心具体怎么成交。
数据输入（DataFeed）
支持从CSV、Pandas、甚至实时API导入数据，不管是日线、分钟线，还是多个股票，都能一起回测。
交易与资金管理（Broker）
模拟真实市场的成交，支持市价单、限价单、滑点、佣金计算，自动更新你的账户余额和持仓。
绩效分析（Analyzer）
回测结束后，自动计算收益率、最大回撤、夏普比率等指标，帮你全面评估策略表现。
图形展示（Observer）
自动画出买卖点、资金曲线、技术指标，一眼看懂策略行为。
这五个模块各司其职，而你只需要专注在策略逻辑上。
🔄 一张图看懂回测流程 从数据加载 → 策略判断 → 订单生成 → 成交撮合 → 绩效分析 → 图形输出，整个过程都由一个叫Cerebro的引擎统一调度。你只需要写策略，其它交给Backtrader。
📊 和其它框架比，Backtrader强在哪？ ✅ 完全本地运行，不依赖网络，数据更安全
✅ 支持多策略并行运行，方便组合对比
✅ 支持多股票、多周期数据一起分析
✅ 自带可视化，不用另外画图
✅ 结构清晰，组件解耦，易扩展维护
💡 和手写回测的对比 很多人一开始学量化，会用Pandas写循环来回测，比如：
1 2 3 4 for i in range(1, len(data)): if data['close'][i] > data['close'][i-1] and position == 0: # 买入... elif ... 这样写虽然直接，但策略一复杂，代码就变得又乱又难维护。"><meta itemprop=datePublished content="2025-07-03T15:18:08+08:00"><meta itemprop=dateModified content="2025-07-03T15:18:08+08:00"><meta itemprop=wordCount content="103"><meta property="og:url" content="https://www.poloxue.com/posts/2025-07-03-backtrader-tutorial-p1/"><meta property="og:site_name" content="菠萝学量化"><meta property="og:title" content="Backtrader 教程一：为什么选择 Backtrader？"><meta property="og:description" content="今天想跟大家聊一个量化交易中非常实用的工具——Backtrader。
如果你对量化交易感兴趣，可能已经听说过策略回测。简单说，就是用历史数据去验证一个交易策略有没有效。在Python里，其实有不少回测框架可以用，比如backtesting.py、vectorbt，还有已经不更新的 zipline。
但今天，我要重点介绍的是——Backtrader。
🤔 为什么选Backtrader？ 因为构建一个稳健的交易系统，光有策略还不够，还需要有清晰的架构、可扩展的功能，以及模块化的设计。而Backtrader，就是一个以策略回测为核心，同时帮你搭建交易系统骨架的Python框架。
它不只是回测工具，更是一个轻量级的“交易系统骨架”。
🔍 Backtrader是什么？ Backtrader是一个用Python写的量化回测框架，专门为个人交易者和研究者设计。它支持策略开发、历史回测、可视化分析，甚至还能接入实盘交易。
更重要的是，它采用面向对象的设计，把策略、数据、订单、资金账户这些模块分得清清楚楚，你不用把所有代码都塞在一个脚本里，而是像搭积木一样，有条不紊地搭建系统。
🧱 核心架构：五大模块 Backtrader的架构非常清晰，主要由五个模块组成：
策略逻辑（Strategy）
你把买卖信号的判断写在这里，框架自动帮你执行订单，你不用操心具体怎么成交。
数据输入（DataFeed）
支持从CSV、Pandas、甚至实时API导入数据，不管是日线、分钟线，还是多个股票，都能一起回测。
交易与资金管理（Broker）
模拟真实市场的成交，支持市价单、限价单、滑点、佣金计算，自动更新你的账户余额和持仓。
绩效分析（Analyzer）
回测结束后，自动计算收益率、最大回撤、夏普比率等指标，帮你全面评估策略表现。
图形展示（Observer）
自动画出买卖点、资金曲线、技术指标，一眼看懂策略行为。
这五个模块各司其职，而你只需要专注在策略逻辑上。
🔄 一张图看懂回测流程 从数据加载 → 策略判断 → 订单生成 → 成交撮合 → 绩效分析 → 图形输出，整个过程都由一个叫Cerebro的引擎统一调度。你只需要写策略，其它交给Backtrader。
📊 和其它框架比，Backtrader强在哪？ ✅ 完全本地运行，不依赖网络，数据更安全
✅ 支持多策略并行运行，方便组合对比
✅ 支持多股票、多周期数据一起分析
✅ 自带可视化，不用另外画图
✅ 结构清晰，组件解耦，易扩展维护
💡 和手写回测的对比 很多人一开始学量化，会用Pandas写循环来回测，比如：
1 2 3 4 for i in range(1, len(data)): if data['close'][i] > data['close'][i-1] and position == 0: # 买入... elif ... 这样写虽然直接，但策略一复杂，代码就变得又乱又难维护。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-03T15:18:08+08:00"><meta property="article:modified_time" content="2025-07-03T15:18:08+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Backtrader 教程一：为什么选择 Backtrader？"><meta name=twitter:description content="今天想跟大家聊一个量化交易中非常实用的工具——Backtrader。
如果你对量化交易感兴趣，可能已经听说过策略回测。简单说，就是用历史数据去验证一个交易策略有没有效。在Python里，其实有不少回测框架可以用，比如backtesting.py、vectorbt，还有已经不更新的 zipline。
但今天，我要重点介绍的是——Backtrader。
🤔 为什么选Backtrader？ 因为构建一个稳健的交易系统，光有策略还不够，还需要有清晰的架构、可扩展的功能，以及模块化的设计。而Backtrader，就是一个以策略回测为核心，同时帮你搭建交易系统骨架的Python框架。
它不只是回测工具，更是一个轻量级的“交易系统骨架”。
🔍 Backtrader是什么？ Backtrader是一个用Python写的量化回测框架，专门为个人交易者和研究者设计。它支持策略开发、历史回测、可视化分析，甚至还能接入实盘交易。
更重要的是，它采用面向对象的设计，把策略、数据、订单、资金账户这些模块分得清清楚楚，你不用把所有代码都塞在一个脚本里，而是像搭积木一样，有条不紊地搭建系统。
🧱 核心架构：五大模块 Backtrader的架构非常清晰，主要由五个模块组成：
策略逻辑（Strategy）
你把买卖信号的判断写在这里，框架自动帮你执行订单，你不用操心具体怎么成交。
数据输入（DataFeed）
支持从CSV、Pandas、甚至实时API导入数据，不管是日线、分钟线，还是多个股票，都能一起回测。
交易与资金管理（Broker）
模拟真实市场的成交，支持市价单、限价单、滑点、佣金计算，自动更新你的账户余额和持仓。
绩效分析（Analyzer）
回测结束后，自动计算收益率、最大回撤、夏普比率等指标，帮你全面评估策略表现。
图形展示（Observer）
自动画出买卖点、资金曲线、技术指标，一眼看懂策略行为。
这五个模块各司其职，而你只需要专注在策略逻辑上。
🔄 一张图看懂回测流程 从数据加载 → 策略判断 → 订单生成 → 成交撮合 → 绩效分析 → 图形输出，整个过程都由一个叫Cerebro的引擎统一调度。你只需要写策略，其它交给Backtrader。
📊 和其它框架比，Backtrader强在哪？ ✅ 完全本地运行，不依赖网络，数据更安全
✅ 支持多策略并行运行，方便组合对比
✅ 支持多股票、多周期数据一起分析
✅ 自带可视化，不用另外画图
✅ 结构清晰，组件解耦，易扩展维护
💡 和手写回测的对比 很多人一开始学量化，会用Pandas写循环来回测，比如：
1 2 3 4 for i in range(1, len(data)): if data['close'][i] > data['close'][i-1] and position == 0: # 买入... elif ... 这样写虽然直接，但策略一复杂，代码就变得又乱又难维护。"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script><script src=https://www.poloxue.com/js/main.js></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["[","]"],["$$","$$"]],inlineMath:[["(",")"],["$","$"]]}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.png alt=菠萝学量化></a></div><h1 class=site-title><a href=https://www.poloxue.com/>菠萝学量化</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>文章列表</a></li><li><a href=/about/about>关于我</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>03</span>
<span class=rest>Jul 2025</span></div></div><div class=matter><h1 class=title>Backtrader 教程一：为什么选择 Backtrader？</h1></div></div><p>今天想跟大家聊一个量化交易中非常实用的工具——Backtrader。</p><p>如果你对量化交易感兴趣，可能已经听说过策略回测。简单说，就是用历史数据去验证一个交易策略有没有效。在Python里，其实有不少回测框架可以用，比如backtesting.py、vectorbt，还有已经不更新的 zipline。</p><p>但今天，我要重点介绍的是——Backtrader。</p><h2 id=-为什么选backtrader><strong>🤔 为什么选Backtrader？</strong></h2><p>因为构建一个稳健的交易系统，光有策略还不够，还需要有清晰的架构、可扩展的功能，以及模块化的设计。而Backtrader，就是一个以策略回测为核心，同时帮你搭建交易系统骨架的Python框架。</p><p>它不只是回测工具，更是一个轻量级的“交易系统骨架”。</p><h2 id=-backtrader是什么><strong>🔍 Backtrader是什么？</strong></h2><p>Backtrader是一个用Python写的量化回测框架，专门为个人交易者和研究者设计。它支持策略开发、历史回测、可视化分析，甚至还能接入实盘交易。</p><p>更重要的是，它采用面向对象的设计，把策略、数据、订单、资金账户这些模块分得清清楚楚，你不用把所有代码都塞在一个脚本里，而是像搭积木一样，有条不紊地搭建系统。</p><h2 id=-核心架构五大模块><strong>🧱 核心架构：五大模块</strong></h2><p>Backtrader的架构非常清晰，主要由五个模块组成：</p><p><strong>策略逻辑（Strategy）</strong></p><p>你把买卖信号的判断写在这里，框架自动帮你执行订单，你不用操心具体怎么成交。</p><p><strong>数据输入（DataFeed）</strong></p><p>支持从CSV、Pandas、甚至实时API导入数据，不管是日线、分钟线，还是多个股票，都能一起回测。</p><p><strong>交易与资金管理（Broker）</strong></p><p>模拟真实市场的成交，支持市价单、限价单、滑点、佣金计算，自动更新你的账户余额和持仓。</p><p><strong>绩效分析（Analyzer）</strong></p><p>回测结束后，自动计算收益率、最大回撤、夏普比率等指标，帮你全面评估策略表现。</p><p><strong>图形展示（Observer）</strong></p><p>自动画出买卖点、资金曲线、技术指标，一眼看懂策略行为。</p><p>这五个模块各司其职，而你只需要专注在策略逻辑上。</p><h2 id=-一张图看懂回测流程><strong>🔄 一张图看懂回测流程</strong></h2><p>从数据加载 → 策略判断 → 订单生成 → 成交撮合 → 绩效分析 → 图形输出，整个过程都由一个叫Cerebro的引擎统一调度。你只需要写策略，其它交给Backtrader。</p><h2 id=-和其它框架比backtrader强在哪><strong>📊 和其它框架比，Backtrader强在哪？</strong></h2><p>✅ 完全本地运行，不依赖网络，数据更安全<br>✅ 支持多策略并行运行，方便组合对比<br>✅ 支持多股票、多周期数据一起分析<br>✅ 自带可视化，不用另外画图<br>✅ 结构清晰，组件解耦，易扩展维护</p><h2 id=-和手写回测的对比><strong>💡 和手写回测的对比</strong></h2><p>很多人一开始学量化，会用Pandas写循环来回测，比如：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, len(data)):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> data[<span style=color:#e6db74>&#39;close&#39;</span>][i] <span style=color:#f92672>&gt;</span> data[<span style=color:#e6db74>&#39;close&#39;</span>][i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>and</span> position <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 买入...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> <span style=color:#f92672>...</span>
</span></span></code></pre></td></tr></table></div></div><p>这样写虽然直接，但策略一复杂，代码就变得又乱又难维护。</p><p>而用Backtrader，同样的策略可以这样写：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyStrategy</span>(bt<span style=color:#f92672>.</span>Strategy):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>close[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>close[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>buy()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> self<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>close[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> self<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>close[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>sell()
</span></span></code></pre></td></tr></table></div></div><p>清晰、干净，所有底层操作都被封装好了。</p><h2 id=-总结><strong>🎯 总结</strong></h2><p>我喜欢Backtrader，就是因为它让我更专注于策略本身，而不是重复造轮子。</p><p>它干净、模块化、易于扩展，不管你是刚入门，还是想搭建自己的交易系统，Backtrader都是一个非常理想的起点。</p><p>下一期，我会带大家安装Backtrader，并实现一个最简单的“买入持有”策略。如果你对量化交易感兴趣，别忘了关注我，我们下期见！</p><div>本文来源于 <a href=https://www.poloxue.com>POLOXUE's BLOG</a>，地址： <a href=https://www.poloxue.com/posts/2025-07-03-backtrader-tutorial-p1/>Backtrader 教程一：为什么选择 Backtrader？</a><hr class=footer-separator><div class=tags></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post>欢迎关注我的公众号：<img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@main/wechat.png>
欢迎加入我的知识星球：<img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@coupon/20251210-20251231-v1.png><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2025 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script></body></html>