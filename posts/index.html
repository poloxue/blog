<!doctype html><html lang=zh-cn><head><title>Posts // POLOXUE's 博客频道</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.115.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="POLO XUE"><meta name=description content><link rel=stylesheet href=/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="技术生活随笔记录"><meta property="og:title" content="Posts"><meta property="og:description" content="技术生活随笔记录"><meta property="og:type" content="website"><meta property="og:url" content="https://www.poloxue.com/posts/"></head><body><header class=app-header><a href=https://www.poloxue.com><img class=app-header-avatar src=/avatar.jpg alt="POLO XUE"></a>
<span class=app-header-title>POLOXUE's 博客频道</span><p>技术生活随笔记录</p></header><main class=app-container><article><h1>Posts</h1><ul class=posts-list><li class=posts-list-item><a class=posts-list-item-title href=https://www.poloxue.com/posts/2023-07-31-create-your-own-free-blog/>如何搭建一个免费的博客</a>
<span class=posts-list-item-description><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jul 31, 2023
<span class=posts-list-item-separator>-</span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
1 min read</span><div>我是从几年前开始写博客，当时把博客部署在一台云主机上，而且单独买了一个域名。
hugo + github page 免费搭建博客.</div><a href=https://www.poloxue.com/posts/2023-07-31-create-your-own-free-blog/>Read More ...</a></li><li class=posts-list-item><a class=posts-list-item-title href=https://www.poloxue.com/posts/2019-09-10-the-guide-for-go-http-client/>Go 的 Http 请求系统指南</a>
<span class=posts-list-item-description><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Sep 10, 2019
<span class=posts-list-item-separator>-</span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
7 min read</span><div>前几天在 &ldquo;知乎想法&rdquo; 谈到了一个话题，如何模仿学习，举了通过 net/http client 模仿 Pyhton 的requests的例子。但并未实践，难道想法真的只能是想法吗？当然不是，于是我决定先暂停一周 GO 笔记，来实践下自己的想法。
有些新的知识，我们可以通过模仿学习
本文将通过 GO 实现 requests 的 quick start 文档中的所有例子，系统学习http client的使用。虽然标题是 quick start，但其实内容挺多的。
快速体验 首先，我们来发起一个 GET 请求，代码非常简单。如下：
func get() { r, err := http.Get("https://api.github.com/events") if err != nil { panic(err) } defer func() { _ = r.Body.Close() }() body, _ := ioutil.ReadAll(r.Body) fmt.Printf("%s", body) } 通过 http.Get 方法，获取到了一个 Response 和一个 error ，即 r 和 err。通过 r 我们能获取响应的信息，err 可以实现错误检查。
r.Body 被读取后需要关闭，可以defer来做这件事。内容的读取可通过 ioutil.ReadAll实现。</div><a href=https://www.poloxue.com/posts/2019-09-10-the-guide-for-go-http-client/>Read More ...</a></li><li class=posts-list-item><a class=posts-list-item-title href=https://www.poloxue.com/posts/2019-05-27-golang-virtualenv-tool-gvm/>Go 虚拟环境管理工具 gvm</a>
<span class=posts-list-item-description><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 27, 2019
<span class=posts-list-item-separator>-</span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span><div>本文谈下我对 Go 版本管理的一些思考，并给大家介绍一个小工具，gvm。这个话题说起来也很简单，但如果想用的爽，还是要稍微梳理下。
背景介绍 Go 的版本管理，并非包的依赖管理。平时的工作中，很多时候并不会遇到这样的需求，所以可能并不是很明白它的价值。
简单说下我写这篇文章的背景吧。
最近几周，Go 最重要的一则消息应该莫过 9月份 Go 1.13 的正式发布。它的相关升级可查看 Go 1.13 正式发布，看看都有哪些值得关注的特性 或官方 Go 1.13 Relase Notes。
对于一名 gopher 而言，可能早已按捺不住自己那颗躁动的心，想尽快体验下新版的升级项。但问题是，切换至新版 Go 通常会遇到一些问题，比如不同版本的环境配置，安装的辅助工具和程序包在不同版本下可能会存在兼容或被覆盖等问题。
我自然就希望有一套方案可以帮助我完成 Go 版本的切换，实现不同版本间环境的完全隔离。
思考方案 谈到环境隔离，有很多方案可供选择，如多主机、虚拟机、容器等技术。这些听起来都挺不错，都能实现需求。但如果只是为了 Go 版本管理，完全可以自己实现。
多版本切换，主要是不同版本环境变量的隔离。Go 1.10 之前，我们关心的变量有 GOROOT、GOPATH 和 PATH。Go 1.10 之后，GOROOT 已经默认为 go 的当前安装路径，只要考虑 GOPATH 和 PATH 即可。
最近，刚答过一个关于 Go 环境变量的问题，查看回答。其中对每个变量的作用进行了比较细致的描述。
如何实现 现在，我要实现我自己电脑上的两个版本的 Go 自由切换，该如何做呢？
假设它们分别位于 ~/.goversions/sdk/ 目录下的 go1.11/ 和 go1.13/。我现在要启用 go 1.11，运行如下命令即可：
$ export PATH=~/.goversions/sdk/go1.11/bin/:$PATH 此时，GOROOT 已经自动识别，为 ~/.goversions/sdk/go1.11/。Go 相关的工具链，源码，标准库都在这个目录下。</div><a href=https://www.poloxue.com/posts/2019-05-27-golang-virtualenv-tool-gvm/>Read More ...</a></li><li class=posts-list-item><a class=posts-list-item-title href=https://www.poloxue.com/posts/2016-12-31-crontab-from-scratch/>一文精通 crontab 从入门到出坑</a>
<span class=posts-list-item-description><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 31, 2016
<span class=posts-list-item-separator>-</span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span><div>此篇技术博文主要介绍的是 crontab， Linux 下的计划任务管理工具。涉及内容包括 crontab 使用配置、常见坑的分析和编者总结的错误调试方法。
我的理解，后台任务通常分为两种：常驻和定时。之前的文章《pm2进程管理工具使用总结》主要针对的是常驻任务。今天来谈谈 crontab，主要针对的是定时任务。
实验环境： centos7
介绍crontab crontab的服务进程名为crond，英文意为周期任务。顾名思义，crontab在Linux主要用于周期定时任务管理。通常安装操作系统后，默认已启动crond服务。crontab可理解为cron_table，表示cron的任务列表。类似crontab的工具还有at和anacrontab，但具体使用场景不同，可参见附录《让你学会Linux计划任务》一文了解更多。
关于crontab的用途很多，如
定时系统检测； 定时数据采集； 定时日志备份； 定时更新数据缓存； 定时生成报表； &mldr; 等等任务 当然，更多使用场景是要以视具体情况而定了。毕竟是工具通常都是常用规则总结而成的产物。
确认crond服务已经安装与开启之后，下面开始具体说明
简单示例 先来个简单示例体验一下。
目标：每分钟向/tmp/time.txt文件下写入当前时间 新建crontab任务 $ crontab -e // 打开crontab任务编辑 * * * * * date >> /tmp/time.txt 静静等待几分钟 $ cat /tmp/time.txt Do 29. Dez 22:45:01 CST 2016 Do 29. Dez 22:46:01 CST 2016 Do 29. Dez 22:47:01 CST 2016 从上面结果看出，每分钟执行了date并写入到/tmp/time.txt。 简单示例演示成功。下面从细节深入说明crontab使用。
使用选项 上面的实验中使用了crontab命令的-e选项。我们来看看crontab命令中有哪些选项?
-e 选项 表示打开当前用户的crontab任务列表配置文件。当然也可以直接打开，路径通常是在/var/spool/cron/下，文件以用户名命名，如/var/spool/cron/root。不过，采用-e方式打开，福利是可以帮助我们自动检查任务配置符合规则。
-u 选项 指定某用户的任务列表，很好理解。比如我当前是root用户，想操作poloxue用户的任务列表。如下：</div><a href=https://www.poloxue.com/posts/2016-12-31-crontab-from-scratch/>Read More ...</a></li></ul></article></main></body></html>