<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go 中 Slice 的 In 实现探索 - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Go 中 Slice 的 In 实现探索"><meta itemprop=description content="之前在知乎看到一个问题：为什么 Golang 没有像 Python 中 in 一样的功能？于是，搜了下这个问题，发现还是有不少人有这样的疑问。
今天来谈谈这个话题。
in 是一个很常用的功能，有些语言中可能也称为 contains，虽然不同语言的表示不同，但基本都是有的。不过可惜的是，Go 却没有，它即没有提供类似 Python 操作符 in，也没有像其他语言那样提供这样的标准库函数，如 PHP 中 in_array。
Go 的哲学是追求少即是多。我想或许 Go 团队觉得这是一个实现起来不足为道的功能吧。
为何说微不足道？如果要自己实现，又该如何做呢？
我所想到的有三种实现方式，一是遍历，二是 sort 的二分查找，三是 map 的 key 索引。
本文相关源码已经上传在我的 github 上，poloxue/gotin。
遍历 遍历应该是我们最容易想到的最简单的实现方式。
示例如下：
1 2 3 4 5 6 7 8 9 func InIntSlice(haystack []int, needle int) bool { for _, e := range haystack { if e == needle { return true } } return false } 上面演示了如何在一个 []int 类型变量中查找指定 int 是否存在的例子，是不是非常简单，由此我们也可以感受到我为什么说它实现起来微不足道。"><meta itemprop=datePublished content="2019-09-15T14:10:29+08:00"><meta itemprop=dateModified content="2019-09-15T14:10:29+08:00"><meta itemprop=wordCount content="1058"><meta itemprop=keywords content="Golang,"><meta property="og:title" content="Go 中 Slice 的 In 实现探索"><meta property="og:description" content="之前在知乎看到一个问题：为什么 Golang 没有像 Python 中 in 一样的功能？于是，搜了下这个问题，发现还是有不少人有这样的疑问。
今天来谈谈这个话题。
in 是一个很常用的功能，有些语言中可能也称为 contains，虽然不同语言的表示不同，但基本都是有的。不过可惜的是，Go 却没有，它即没有提供类似 Python 操作符 in，也没有像其他语言那样提供这样的标准库函数，如 PHP 中 in_array。
Go 的哲学是追求少即是多。我想或许 Go 团队觉得这是一个实现起来不足为道的功能吧。
为何说微不足道？如果要自己实现，又该如何做呢？
我所想到的有三种实现方式，一是遍历，二是 sort 的二分查找，三是 map 的 key 索引。
本文相关源码已经上传在我的 github 上，poloxue/gotin。
遍历 遍历应该是我们最容易想到的最简单的实现方式。
示例如下：
1 2 3 4 5 6 7 8 9 func InIntSlice(haystack []int, needle int) bool { for _, e := range haystack { if e == needle { return true } } return false } 上面演示了如何在一个 []int 类型变量中查找指定 int 是否存在的例子，是不是非常简单，由此我们也可以感受到我为什么说它实现起来微不足道。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/2019-09-15-how-to-use-contain-function-in-golang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-09-15T14:10:29+08:00"><meta property="article:modified_time" content="2019-09-15T14:10:29+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 中 Slice 的 In 实现探索"><meta name=twitter:description content="之前在知乎看到一个问题：为什么 Golang 没有像 Python 中 in 一样的功能？于是，搜了下这个问题，发现还是有不少人有这样的疑问。
今天来谈谈这个话题。
in 是一个很常用的功能，有些语言中可能也称为 contains，虽然不同语言的表示不同，但基本都是有的。不过可惜的是，Go 却没有，它即没有提供类似 Python 操作符 in，也没有像其他语言那样提供这样的标准库函数，如 PHP 中 in_array。
Go 的哲学是追求少即是多。我想或许 Go 团队觉得这是一个实现起来不足为道的功能吧。
为何说微不足道？如果要自己实现，又该如何做呢？
我所想到的有三种实现方式，一是遍历，二是 sort 的二分查找，三是 map 的 key 索引。
本文相关源码已经上传在我的 github 上，poloxue/gotin。
遍历 遍历应该是我们最容易想到的最简单的实现方式。
示例如下：
1 2 3 4 5 6 7 8 9 func InIntSlice(haystack []int, needle int) bool { for _, e := range haystack { if e == needle { return true } } return false } 上面演示了如何在一个 []int 类型变量中查找指定 int 是否存在的例子，是不是非常简单，由此我们也可以感受到我为什么说它实现起来微不足道。"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script>
<script src=https://www.poloxue.com/js/main.js></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body><div class="container-wide wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.png alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>文章列表</a></li><li><a href=/tags>分类标签</a></li><li><a href=/about/>关于我</a></li></ul></nav></div><div class=article-nav id=article-nav-id><div class=post><div class=post-header><div class=meta><div class=date><span class=day>15</span>
<span class=rest>Sep 2019</span></div></div><div class=matter><h1 class=title>Go 中 Slice 的 In 实现探索</h1></div></div><aside class="show-on-mobile toc" id=static-toc><header><h3>Contents</h3></header><nav id=TableOfContents><ol><li><a href=#遍历>遍历</a></li><li><a href=#二分查找>二分查找</a></li><li><a href=#map-key>map key</a></li><li><a href=#性能>性能</a></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ol></nav></aside><p>之前在知乎看到一个问题：为什么 Golang 没有像 Python 中 in 一样的功能？于是，搜了下这个问题，发现还是有不少人有这样的疑问。</p><p>今天来谈谈这个话题。</p><p>in 是一个很常用的功能，有些语言中可能也称为 contains，虽然不同语言的表示不同，但基本都是有的。不过可惜的是，Go 却没有，它即没有提供类似 Python 操作符 in，也没有像其他语言那样提供这样的标准库函数，如 PHP 中 in_array。</p><p>Go 的哲学是追求少即是多。我想或许 Go 团队觉得这是一个实现起来不足为道的功能吧。</p><p>为何说微不足道？如果要自己实现，又该如何做呢？</p><p>我所想到的有三种实现方式，一是遍历，二是 sort 的二分查找，三是 map 的 key 索引。</p><p>本文相关源码已经上传在我的 github 上，<a href=https://github.com/poloxue/gotin>poloxue/gotin</a>。</p><h2 id=遍历>遍历</h2><p>遍历应该是我们最容易想到的最简单的实现方式。</p><p>示例如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InIntSlice</span>(<span style=color:#a6e22e>haystack</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>haystack</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>needle</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>上面演示了如何在一个 []int 类型变量中查找指定 int 是否存在的例子，是不是非常简单，由此我们也可以感受到我为什么说它实现起来微不足道。</p><p>这个例子有个缺陷，它只支持单一类型。如果要支持像解释语言一样的通用 in 功能，则需借助反射实现。</p><p>代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>haystack</span> <span style=color:#66d9ef>interface</span>{}, <span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>interface</span>{}) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sVal</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>kind</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sVal</span>.<span style=color:#a6e22e>Kind</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>kind</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Slice</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>kind</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Array</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>sVal</span>.<span style=color:#a6e22e>Len</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sVal</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Interface</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>needle</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>ErrUnSupportHaystack</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>为了更加通用，In 函数的输入参数 haystack 和 needle 都是 interface{} 类型。</p><p>简单说说输入参数都是 interface{} 的好处吧，主要有两点，如下：</p><p>其一，haystack 是 interface{} 类型，使 in 支持的类型不止于 slice，还包括 array。我们看到，函数内部通过反射对 haystack 进行了类型检查，支持 slice（切片）与 array（数组）。如果是其他类型则会提示错误，增加新的类型支持，如 map，其实也很简单。但不推荐这种方式，因为通过 _, ok := m[k] 的语法即可达到 in 的效果。</p><p>其二，haystack 是 interface{}，则 []interface{} 也满足要求，并且 needle 是 interface{}。如此一来，我们就可以实现类似解释型语言一样的效果了。</p><p>怎么理解？直接示例说明，如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>gotin</span>.<span style=color:#a6e22e>In</span>([]<span style=color:#66d9ef>interface</span>{}{<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;two&#34;</span>, <span style=color:#ae81ff>3</span>}, <span style=color:#e6db74>&#34;two&#34;</span>)
</span></span></code></pre></td></tr></table></div></div><p>haystack 是 []interface{}{1, &ldquo;two&rdquo;, 3}，而且 needle 是 interface{}，此时的值是 &ldquo;two&rdquo;。如此看起来，是不是实现了解释型语言中，元素可以是任意类型，不必完全相同效果。如此一来，我们就可以肆意妄为的使用了。</p><p>但有一点要说明，In 函数的实现中有这样一段代码：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sVal</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Interface</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>needle</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>Go 中并非任何类型都可以使用 == 比较的，如果元素中含有 slice 或 map，则可能会报错。</p><h2 id=二分查找>二分查找</h2><p>以遍历确认元素是否存在有个缺点，那就是，如果数组或切片中包含了大量数据，比如 1000000 条数据，即一百万，最坏的情况是，我们要遍历 1000000 次才能确认，时间复杂度 On。</p><p>有什么办法可以降低遍历次数？</p><p>自然而然地想到的方法是二分查找，它的时间复杂度 log2(n) 。但这个算法有前提，需要依赖有序序列。</p><p>于是，第一个要我们解决的问题是使序列有序，Go 的标准库已经提供了这个功能，在 sort 包下。</p><p>示例代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SortInts</span>([]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>}))
</span></span></code></pre></td></tr></table></div></div><p>对于 []int，我们使用的函数是 SortInts，如果是其他类型切片，sort 也提供了相关的函数，比如 []string 可通过 SortStrings 排序。</p><p>完成排序就可以进行二分查找，幸运的是，这个功能 Go 也提供了，[]int 类型对应函数是 SearchInts。</p><p>简单介绍下这个函数，先看定义：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SearchInts</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span></code></pre></td></tr></table></div></div><p>输入参数容易理解，从切片 a 中搜索 x。重点要说下返回值，这对于我们后面确认元素是否存在至关重要。返回值的含义，返回查找元素在切片中的位置，如果元素不存在，则返回，在保持切片有序情况下，插入该元素应该在什么位置。</p><p>比如，序列如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1 2 6 8 9 11
</span></span></code></pre></td></tr></table></div></div><p>假设，x 为 6，查找之后将发现它的位置在索引 2 处；x 如果是 7，发现不存在该元素，如果插入序列，将会放在 6 和 8 之间，索引位置是 3，因而返回值为 3。</p><p>代码测试下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SearchInts</span>([]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>11</span>}, <span style=color:#ae81ff>6</span>)) <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SearchInts</span>([]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>11</span>}, <span style=color:#ae81ff>7</span>)) <span style=color:#75715e>// 3
</span></span></span></code></pre></td></tr></table></div></div><p>如果判断元素是否在序列中，只要判断返回位置上的值是否和查找的值相同即可。</p><p>但还有另外一种情况，如果插入元素位于序列最后，例如元素值为 12，插入位置即为序列的长度 6。如果直接查找 6 位置上的元素就可能发生越界的情况。那怎么办呢？其实判断返回是否大于切片长度即可，大于则说明元素不在切片序列中。</p><p>完整的实现代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SortInIntSlice</span>(<span style=color:#a6e22e>haystack</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SearchInts</span>(<span style=color:#a6e22e>haystack</span>, <span style=color:#a6e22e>needle</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>index</span> &lt; len(<span style=color:#a6e22e>haystack</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>haystack</span>[<span style=color:#a6e22e>index</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>needle</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>但这还有个问题，对于无序的场景，如果每次查询都要经过一次排序并不划算。最后能实现一次排序，稍微修改下代码。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InIntSliceSortedFunc</span>(<span style=color:#a6e22e>haystack</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Ints</span>(<span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SearchInts</span>(<span style=color:#a6e22e>haystack</span>, <span style=color:#a6e22e>needle</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>index</span> &lt; len(<span style=color:#a6e22e>haystack</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>haystack</span>[<span style=color:#a6e22e>index</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>needle</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>上面的实现，我们通过调用 InIntSliceSortedFunc 对 haystack 切片排序，并返回一个可多次使用的函数。</p><p>使用案例如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gotin</span>.<span style=color:#a6e22e>InIntSliceSortedFunc</span>(<span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>maxNeedle</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>in</span>(<span style=color:#a6e22e>i</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d is in %v&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>二分查找的方式有什么不足呢？</p><p>我想到的重要一点，要实现二分查找，元素必须是可排序的，如 int，string，float 类型。而对于结构体、切片、数组、映射等类型，使用起来就不是那么方便，当然，如果要用，也是可以的，不过需要我们进行一些适当扩展，按指定标准排序，比如结构的某个成员。</p><p>到此，二分查找的 in 实现就介绍完毕了。</p><h2 id=map-key>map key</h2><p>本节介绍 map key 方式。它的算法复杂度是 O1，无论数据量多大，查询性能始终不变。它主要依赖的是 Go 中的 map 数据类型，通过 hash map 直接检查 key 是否存在，算法大家应该都比较熟悉，通过 key 可直接映射到索引位置。</p><p>我们常会用到这个方法。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>k</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Found&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>那么它和 in 如何结合呢？一个案例就说明白了这个问题。</p><p>假设，我们有一个 []int 类型变量，如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span></code></pre></td></tr></table></div></div><p>为了使用 map 的能力检查某个元素是否存在，可以将 s 转化 map[int]struct{}。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>interface</span>{}]<span style=color:#66d9ef>struct</span>{}{
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>1</span>: <span style=color:#66d9ef>struct</span>{}{},
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>2</span>: <span style=color:#66d9ef>struct</span>{}{},
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>3</span>: <span style=color:#66d9ef>struct</span>{}{},
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>4</span>: <span style=color:#66d9ef>struct</span>{}{},
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>如果检查某个元素是否存在，只需要通过如下写法即可确定：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>k</span>]; <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d is found\n&#34;</span>, <span style=color:#a6e22e>k</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>是不是非常简单？</p><p>补充一点，关于这里为什么使用 struct{}，可以阅读我之前写的一篇关于 <a href=https://mp.weixin.qq.com/s/a0BWRTikJNTPc6VXVn43OQ>Go 中如何使用 set</a> 的文章。</p><p>按照这个思路，实现函数如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MapKeyInIntSlice</span>(<span style=color:#a6e22e>haystack</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>struct</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span> , <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>haystack</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>set</span>[<span style=color:#a6e22e>e</span>] = <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>set</span>[<span style=color:#a6e22e>needle</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ok</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>实现起来不难，但和二分查找有着同样的问题，开始要做数据处理，将 slice 转化为 map。如果是每次数据相同，稍微修改下它的实现。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InIntSliceMapKeyFunc</span>(<span style=color:#a6e22e>haystack</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>struct</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span> , <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>haystack</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>set</span>[<span style=color:#a6e22e>e</span>] = <span style=color:#66d9ef>struct</span>{}{}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>needle</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>set</span>[<span style=color:#a6e22e>needle</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ok</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>对于相同的数据，它会返回一个可多次使用的 in 函数，一个使用案例如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gotin</span>.<span style=color:#a6e22e>InIntSliceMapKeyFunc</span>(<span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>maxNeedle</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>in</span>(<span style=color:#a6e22e>i</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d is in %v&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>haystack</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>对比前两种算法，这种方式的处理效率最高，非常适合于大数据的处理。接下来的性能测试，我们将会看到效果。</p><h2 id=性能>性能</h2><p>介绍完所有方式，我们来实际对比下每种算法的性能。测试源码位于 <a href=https://github.com/poloxue/gotin/blob/master/gotin_test.go>gotin_test.go</a> 文件中。</p><p>基准测试主要是从数据量大小考察不同算法的性能，本文中选择了三个量级的测试样本数据，分别是 10、1000、1000000。</p><p>为便于测试，首先定义了一个用于生成 haystack 和 needle 样本数据的函数。</p><p>代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randomHaystackAndNeedle</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) ([]<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>haystack</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span>&lt;<span style=color:#a6e22e>size</span> ; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>haystack</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>haystack</span>, <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>输入参数是 size，通过 rand.Int() 随机生成切片大小为 size 的 haystack 和 1 个 needle。在基准测试用例中，引入这个随机函数生成数据即可。</p><p>举个例子，如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkIn_10</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>haystack</span>, <span style=color:#a6e22e>needle</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>randomHaystackAndNeedle</span>(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ResetTimer</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>gotin</span>.<span style=color:#a6e22e>In</span>(<span style=color:#a6e22e>haystack</span>, <span style=color:#a6e22e>needle</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>首先，通过 randomHaystackAndNeedle 随机生成了一个含有 10 个元素的切片。因为生成样本数据的时间不应该计入到基准测试中，我们使用 b.ResetTimer() 重置了时间。</p><p>其次，压测函数是按照 <code>Test+函数名+样本数据量</code> 规则编写，如案例中 BenchmarkIn_10，表示测试 In 函数，样本数据量为 10。如果我们要用 1000 数据量测试 InIntSlice，压测函数名为 BenchmarkInIntSlice_1000。</p><p>测试开始吧！简单说下我的笔记本配置，Mac Pro 15 版，16G 内存，512 SSD，4 核 8 线程的 CPU。</p><p>测试所有函数在数据量在 10 的情况下的表现。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -run<span style=color:#f92672>=</span>none -bench<span style=color:#f92672>=</span>10$ -benchmem
</span></span></code></pre></td></tr></table></div></div><p>匹配所有以 10 结尾的压测函数。</p><p>测试结果：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: github.com/poloxue/gotin
</span></span><span style=display:flex><span>BenchmarkIn_10-8                         <span style=color:#ae81ff>3000000</span>               <span style=color:#ae81ff>501</span> ns/op             <span style=color:#ae81ff>112</span> B/op         <span style=color:#ae81ff>11</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSlice_10-8                <span style=color:#ae81ff>200000000</span>                7.47 ns/op            <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceSortedFunc_10-8      <span style=color:#ae81ff>100000000</span>               22.3 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkSortInIntSlice_10-8            <span style=color:#ae81ff>10000000</span>               <span style=color:#ae81ff>162</span> ns/op              <span style=color:#ae81ff>32</span> B/op          <span style=color:#ae81ff>1</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceMapKeyFunc_10-8      <span style=color:#ae81ff>100000000</span>               17.7 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkMapKeyInIntSlice_10-8           <span style=color:#ae81ff>3000000</span>               <span style=color:#ae81ff>513</span> ns/op             <span style=color:#ae81ff>163</span> B/op          <span style=color:#ae81ff>1</span> allocs/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      github.com/poloxue/gotin        13.162s
</span></span></code></pre></td></tr></table></div></div><p>表现最好的并非 SortedFunc 和 MapKeyFunc，而是最简单的针对单类型的遍历查询，平均耗时 7.47ns/op，当然，另外两种方式表现也不错，分别是 22.3ns/op 和 17.7ns/op。</p><p>表现最差的是 In、SortIn（每次重复排序） 和 MapKeyIn（每次重复创建 map）两种方式，平均耗时分别为 501ns/op 和 513ns/op。</p><p>测试所有函数在数据量在 1000 的情况下的表现。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -run<span style=color:#f92672>=</span>none -bench<span style=color:#f92672>=</span>1000$ -benchmem
</span></span></code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: github.com/poloxue/gotin
</span></span><span style=display:flex><span>BenchmarkIn_1000-8                         <span style=color:#ae81ff>30000</span>             <span style=color:#ae81ff>45074</span> ns/op            <span style=color:#ae81ff>8032</span> B/op       <span style=color:#ae81ff>1001</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSlice_1000-8               <span style=color:#ae81ff>5000000</span>               <span style=color:#ae81ff>313</span> ns/op               <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceSortedFunc_1000-8    <span style=color:#ae81ff>30000000</span>                44.0 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkSortInIntSlice_1000-8             <span style=color:#ae81ff>20000</span>             <span style=color:#ae81ff>65401</span> ns/op              <span style=color:#ae81ff>32</span> B/op          <span style=color:#ae81ff>1</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceMapKeyFunc_1000-8    <span style=color:#ae81ff>100000000</span>               17.6 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkMapKeyInIntSlice_1000-8           <span style=color:#ae81ff>20000</span>             <span style=color:#ae81ff>82761</span> ns/op           <span style=color:#ae81ff>47798</span> B/op         <span style=color:#ae81ff>65</span> allocs/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      github.com/poloxue/gotin        11.312s
</span></span></code></pre></td></tr></table></div></div><p>表现前三依然是 InIntSlice、InIntSliceSortedFunc 和 InIntSliceMapKeyFunc，但这次顺序发生了变化，MapKeyFunc 表现最好，17.6 ns/op，与数据量 10 的时候相比基本无变化。再次验证了前文的说法。</p><p>同样的，数据量 1000000 的时候。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -run<span style=color:#f92672>=</span>none -bench<span style=color:#f92672>=</span>1000000$ -benchmem
</span></span></code></pre></td></tr></table></div></div><p>测试结果如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>goos: darwin
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: github.com/poloxue/gotin
</span></span><span style=display:flex><span>BenchmarkIn_1000000-8                                 <span style=color:#ae81ff>30</span>          <span style=color:#ae81ff>46099678</span> ns/op         <span style=color:#ae81ff>8000098</span> B/op    <span style=color:#ae81ff>1000001</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSlice_1000000-8                       <span style=color:#ae81ff>3000</span>            <span style=color:#ae81ff>424623</span> ns/op               <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceSortedFunc_1000000-8         <span style=color:#ae81ff>20000000</span>                72.8 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkSortInIntSlice_1000000-8                     <span style=color:#ae81ff>10</span>         <span style=color:#ae81ff>138873420</span> ns/op              <span style=color:#ae81ff>32</span> B/op          <span style=color:#ae81ff>1</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkInIntSliceMapKeyFunc_1000000-8         <span style=color:#ae81ff>100000000</span>               16.5 ns/op             <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span><span style=display:flex><span>BenchmarkMapKeyInIntSlice_1000000-8                   <span style=color:#ae81ff>10</span>         <span style=color:#ae81ff>156215889</span> ns/op        <span style=color:#ae81ff>49824225</span> B/op      <span style=color:#ae81ff>38313</span> allocs/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      github.com/poloxue/gotin        15.178s
</span></span></code></pre></td></tr></table></div></div><p>MapKeyFunc 依然表现最好，每次操作用时 17.2 ns，Sort 次之，而 InIntSlice 呈现线性增加的趋势。一般情况下，如果不是对性能要特殊要求，数据量特别大的场景，针对单类型的遍历已经有非常好的性能了。</p><p>从测试结果可以看出，反射实现的通用 In 函数每次执行需要进行大量的内存分配，方便的同时，也是以牺牲性能为代价的。</p><h2 id=总结>总结</h2><p>本文通过一个问题引出主题，为什么 Go 中没有类似 Python 的 In 方法。我认为，一方面是实现非常简单，没有必要。除此以外，另一方面，在不同场景下，我们还需要根据实际情况分析用哪种方式实现，而不是一种固定的方式。</p><p>接着，我们介绍了 In 实现的三种方式，并分析了各自的优劣。通过性能分析测试，我们能得出大致的结论，什么方式适合什么场景，但总体还是分析的不够细致，有兴趣的朋友可以继续研究下。</p><p>博文地址：<a href=https://www.poloxue.com/posts/2019-09-15-how-to-use-contain-function-in-golang/>Go 中 Slice 的 In 实现探索</a></p><h2 id=参考>参考</h2><p><a href=https://stackoverflow.com/questions/15323767/does-go-have-if-x-in-construct-similar-to-python>Does Go have “if x in” construct similar to Python?</a></p><p><a href=https://www.zhihu.com/question/328393303/answer/711287362>为什么Golang没有像Python中in一样的功能？</a></p><div>本文来源于 <a href=https://www.poloxue.com>POLOXUE's BLOG</a>，地址： <a href=https://www.poloxue.com/posts/2019-09-15-how-to-use-contain-function-in-golang/>Go 中 Slice 的 In 实现探索</a></div></div><nav class="hide-on-mobile section-nav"><nav id=TableOfContents><ol><li><a href=#遍历>遍历</a></li><li><a href=#二分查找>二分查找</a></li><li><a href=#map-key>map key</a></li><li><a href=#性能>性能</a></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ol></nav></nav></div><div class=post><hr class=footer-separator><div class=tags><ul class=flat><li class=tag-li><a href=/tags/golang>Golang</a></li></ul></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post><img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@main/wechat.png><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2019 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script><script>var enableTruncate=!0,filterDepth=!1;const MAX_DEPTH=9;window.addEventListener("DOMContentLoaded",()=>{const e=new IntersectionObserver(e=>{e.reverse().forEach(e=>{const n=e.target.getAttribute("id");if(e.intersectionRatio>0){var t=document.querySelectorAll(`nav li a[href="#${n}"]`);t!=null&&t.forEach(e=>{if(e!=null){var t=getDepth(e.parentElement);filterDepth&&t<=MAX_DEPTH&&(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))}else filterDepth||(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))})}})});document.querySelectorAll("h1[id],h2[id],h3[id],h4[id]").forEach(t=>{e.observe(t)})});function isVisible(e){if(!(e instanceof Element))return!1;const n=getComputedStyle(e);if(n.display==="none")return!1;if(n.visibility!=="visible")return!1;if(n.opacity<.1)return!1;if(e.offsetWidth+e.offsetHeight+e.getBoundingClientRect().height+e.getBoundingClientRect().width===0)return!1;const t={x:e.getBoundingClientRect().left+e.offsetWidth/2,y:e.getBoundingClientRect().top+e.offsetHeight/2};if(t.x<0)return!1;if(t.x>(document.documentElement.clientWidth||window.innerWidth))return!1;if(t.y<0)return!1;if(t.y>(document.documentElement.clientHeight||window.innerHeight))return!1;let s=document.elementFromPoint(t.x,t.y);do if(s===e)return!0;while(s=s.parentNode)return!1}function clearActiveStatesInTableOfContents(){document.querySelectorAll("nav li").forEach(e=>{e.classList.remove("active")})}function getDepth(e){for(var t=0;e!==null&&e.tagName.toLowerCase()!=="ul";)t++,e=e.parentElement;return t}function navItems(){var e=document.querySelectorAll("nav nav li a");return Array.from(e).filter(e=>e.href!=null&&e.hash.startsWith("#"))}function lasItemInNavBarVisible(){var e=navItems().slice(-1)[0];return isVisible(e)}document.addEventListener("DOMContentLoaded",function(){if(!enableTruncate)return;var e=navItems();console.log(e),lasItemInNavBarVisible()||(filterDepth=!0,e.forEach(function(e){var t=getDepth(e.parentElement);t>MAX_DEPTH&&e.parentElement.classList.add("depth-nested")}))})</script></body></html>