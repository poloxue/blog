<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据 - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据"><meta itemprop=description content="Fasthttp 是一个高性能的 Golang HTTP 框架，它在设计上做了许多优化以提高性能。其中一个显著的设计选择是使用 slice 而非 map 来存储数据，尤其是在处理 HTTP headers 时。"><meta itemprop=datePublished content="2024-01-22T20:36:04+08:00"><meta itemprop=dateModified content="2024-01-22T20:36:04+08:00"><meta itemprop=wordCount content="227"><meta itemprop=keywords content><meta property="og:title" content="为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据"><meta property="og:description" content="Fasthttp 是一个高性能的 Golang HTTP 框架，它在设计上做了许多优化以提高性能。其中一个显著的设计选择是使用 slice 而非 map 来存储数据，尤其是在处理 HTTP headers 时。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/2024-01-18-why-fasthttp-opts-for-slice-over-map/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-22T20:36:04+08:00"><meta property="article:modified_time" content="2024-01-22T20:36:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据"><meta name=twitter:description content="Fasthttp 是一个高性能的 Golang HTTP 框架，它在设计上做了许多优化以提高性能。其中一个显著的设计选择是使用 slice 而非 map 来存储数据，尤其是在处理 HTTP headers 时。"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script>
<script src=https://www.poloxue.com/js/main.js></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script>MathJax={tex:{displayMath:[["[","]"],["$$","$$"]],inlineMath:[["(",")"],["$","$"]]}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.png alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>文章列表</a></li><li><a href=/tags>分类标签</a></li><li><a href=/about/about>关于我</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>22</span>
<span class=rest>Jan 2024</span></div></div><div class=matter><h1 class=title>为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据</h1></div></div><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-18-why-fasthttp-opts-for-slice-over-map-01.png alt></p><blockquote><p>嗨，大家好！本文是系列文章 Go 小技巧第六篇，系列文章查看：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=3291066778475053060">Go 语言小技巧</a>。</p></blockquote><p>Fasthttp 是一个高性能的 Golang HTTP 框架，它在设计上做了许多优化以提高性能。其中一个显著的设计选择是使用 slice 而非 map 来存储数据，尤其是在处理 HTTP headers 时。</p><p>为什么呢？</p><p>本文将从简单到复杂，逐步剖析为什么 Fasthttp 选择使用 slice 而非 map，并通过代码示例解释这一选择背后高性能的原因</p><h2 id=slice-vs-map基本概念>Slice vs Map：基本概念</h2><p>首先，这个设计选择背后有着深思熟虑的考量，主要围绕性能优化展开。在深入探讨之前，我们需要理解 slice 和 map 在 Go 语言中的基本概念和性能特点。</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-18-why-fasthttp-opts-for-slice-over-map-04.png alt></p><ul><li><strong>Slice</strong>：Slice 是对数组的封装，它提供了一个动态大小的、灵活的视图。Slices 的底层实际上是数组，这意味着它们的元素在内存中是连续存储的。</li><li><strong>Map</strong>：Map 是一种无序的键值对的集合，它通过哈希表实现。Map 提供了快速的查找、添加和删除操作，但这些操作的性能并不总是稳定。</li></ul><h2 id=内存分配和性能>内存分配和性能</h2><p>在高性能的应用场景中，内存分配和回收是性能的关键因素之一。Fasthttp 在这方面做了考量。</p><p><strong>Slice 的内存效率</strong></p><p>由于 slice 的元素在内存中是连续存储的，它们访问速度快，且能有效利用 CPU 缓存。此外，slice 可以通过重新切片来复用已有的数组，减少内存分配和垃圾回收的压力。</p><p><strong>Map 的内存开销</strong></p><p>相比之下，map 的内存开销较大。</p><p>在 map 中，键和值通常是散布在内存中的，这导致 CPU 缓存利用率不高。而且，map 的增长通常涉及重新哈希和重新分配内存，这些操作在性能敏感的应用中可能成为瓶颈。</p><h2 id=fasthttp-中的-slicemap>Fasthttp 中的 SliceMap</h2><p>Fasthttp 选择使用自定义的 <code>sliceMap</code> 结构来存储键值对，而非标准的 map。</p><p>下面是 <code>sliceMap</code> 的一个简化实现和它的 <code>Add</code> 方法：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>kv</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sliceMap</span> []<span style=color:#a6e22e>kv</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sm</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sliceMap</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> []<span style=color:#66d9ef>byte</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kvs</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sm</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cap(<span style=color:#a6e22e>kvs</span>) &gt; len(<span style=color:#a6e22e>kvs</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kvs</span> = <span style=color:#a6e22e>kvs</span>[:len(<span style=color:#a6e22e>kvs</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kvs</span> = append(<span style=color:#a6e22e>kvs</span>, <span style=color:#a6e22e>kv</span>{})
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kv</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kvs</span>[len(<span style=color:#a6e22e>kvs</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kv</span>.<span style=color:#a6e22e>key</span> = append(<span style=color:#a6e22e>kv</span>.<span style=color:#a6e22e>key</span>[:<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>k</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kv</span>.<span style=color:#a6e22e>value</span> = append(<span style=color:#a6e22e>kv</span>.<span style=color:#a6e22e>value</span>[:<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>v</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>sm</span> = <span style=color:#a6e22e>kvs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>在这个设计中，<code>sliceMap</code> 通过以下方式优化性能：</p><p><strong>减少内存分配</strong></p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-18-why-fasthttp-opts-for-slice-over-map-02.gif alt></p><p>通过在现有的 slice 上进行操作，<code>sliceMap</code> 尽可能地复用内存。当容量足够时，它通过重新切片 <code>kvs = kvs[:len(kvs)+1]</code> 来扩展 slice，避免了额外的内存分配。</p><p><strong>减少垃圾回收压力</strong></p><p>由于 slice 的元素是连续存储的，它可以更有效地被垃圾回收器处理，减少了垃圾回收的开销。而且，由于内存是复用的，垃圾回收的次数也大大减少。</p><h2 id=性能优化的深层原因>性能优化的深层原因</h2><p>Fasthttp 使用 <code>sliceMap</code> 而非 map 的决策不仅仅是基于内存和性能的考量，还有更深层的原因：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-18-why-fasthttp-opts-for-slice-over-map-03.png alt></p><h3 id=存储数据特性>存储数据特性</h3><p>在处理 HTTP 请求时，通常 headers、query 参数或 cookies 的数量并不多。这意味着即使使用线性搜索，查找效率也不会成为性能瓶颈。</p><p>相比之下，虽然 hash map 提供了理论上接近 O(1) 的查找效率，但实际使用中也有其开销和复杂性。</p><ul><li>首先，hash map 的哈希计算本身就需要时间。</li><li>其次，哈希碰撞时，hash map 要额外处理来解决碰撞，这可能涉及到链表遍历或重新哈希等操作。</li></ul><p>这些因素在元素数量较少时可能会抵消 hash map 在查找效率上的理论优势，而 slice 则才是更优质的选择。</p><h3 id=cpu-预加载特性>CPU 预加载特性</h3><p>由于 slice 的内存布局是连续的，它符合 CPU 缓存的工作原理，即一次性加载相邻数据。这种连续性使得 CPU 在访问一个 slice 元素后，能预加载相邻元素到缓存中，提高后续访问的速度。</p><p>因此，顺序访问 slice 时，缓存命中率高，减少了对主内存的访问次数，从而提高了性能。</p><h2 id=结论>结论</h2><p>Fasthttp 的设计选择反映了对性能细节的深入理解和精心优化。通过使用 slice 而非 map，Fasthttp 在内存分配、垃圾回收以及 CPU 缓存利用等方面实现了优化，为高性能的 HTTP 应用提供了坚实的基础。这种设计不仅仅是技术上的选择，更是对实际应用场景和性能需求的深入洞察。</p><p>博文地址：<a href=https://www.poloxue.com/posts/2024-01-18-why-fasthttp-opts-for-slice-over-map/>为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据</a></p><div>本文来源于 <a href=https://www.poloxue.com>POLOXUE's BLOG</a>，地址： <a href=https://www.poloxue.com/posts/2024-01-18-why-fasthttp-opts-for-slice-over-map/>为什么 Golang Fasthttp 选择使用 slice 而非 map 存储请求数据</a><hr class=footer-separator><div class=tags></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post>欢迎关注我的公众号：<img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@main/wechat.png><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2024 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script></body></html>