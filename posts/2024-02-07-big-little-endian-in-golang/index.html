<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go 语言中如何大小端字节序？int 转 byte 是如何进行的？ - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Go 语言中如何大小端字节序？int 转 byte 是如何进行的？"><meta itemprop=description content="在 Go 语言中，将 byte 转换为 int 时是否涉及字节序（endianness）？我可以直接使用 `int(byte_var)` 进行转换吗？"><meta itemprop=datePublished content="2024-02-07T08:00:00+08:00"><meta itemprop=dateModified content="2024-02-07T08:00:00+08:00"><meta itemprop=wordCount content="212"><meta itemprop=keywords content><meta property="og:title" content="Go 语言中如何大小端字节序？int 转 byte 是如何进行的？"><meta property="og:description" content="在 Go 语言中，将 byte 转换为 int 时是否涉及字节序（endianness）？我可以直接使用 `int(byte_var)` 进行转换吗？"><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/2024-02-07-big-little-endian-in-golang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-07T08:00:00+08:00"><meta property="article:modified_time" content="2024-02-07T08:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 语言中如何大小端字节序？int 转 byte 是如何进行的？"><meta name=twitter:description content="在 Go 语言中，将 byte 转换为 int 时是否涉及字节序（endianness）？我可以直接使用 `int(byte_var)` 进行转换吗？"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script>
<script src=https://www.poloxue.com/js/main.js></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script>MathJax={tex:{displayMath:[["[","]"],["$$","$$"]],inlineMath:[["(",")"],["$","$"]]}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.png alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>文章列表</a></li><li><a href=/tags>分类标签</a></li><li><a href=https://crypto.poloxue.com/>每日币圈</a></li><li><a href=/about/about>关于我</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>07</span>
<span class=rest>Feb 2024</span></div></div><div class=matter><h1 class=title>Go 语言中如何大小端字节序？int 转 byte 是如何进行的？</h1></div></div><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-01.png alt></p><blockquote><p>嗨，大家好！我是波罗学。</p><p>本文是系列文章 Go 技巧第十五篇，系列文章查看：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0MzE2NTY2MA==&amp;action=getalbum&amp;album_id=3291066778475053060#wechat_redirect">Go 语言技巧</a>。</p></blockquote><p>我们先看这样一个问题：“Go 语言中，将 byte 转换为 int 时是否涉及字节序（endianness）？我可以直接使用 <code>int(byte_var)</code> 进行转换吗？”</p><p>这个问题非常简单，直接回答不涉及字节序，可以直接转换。但为什么呢？如果要彻底搞明白这个问题，还是要了解下字节序这个概念。</p><p>接下来，让我带你深入地了解这个问题，以及如何在 Go 中如何处理字节序。</p><h2 id=字节序>字节序</h2><p>我们先解释一下什么是字节序？</p><p>字节序，或称为字节顺序，即数据在内存中存储的字节顺序。字节序主要有两种：大端和小端。</p><p>什么是大端模式？</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-03.png alt></p><p>大端模式指的是高位字节（0x12）存储在低地址位（0）。</p><p>什么是小端模式？</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-02.png alt></p><p>小端模式指的是低位字节（0x78）存储在低地址位（0）。</p><h2 id=将-byte-和-int-相互转换>将 byte 和 int 相互转换</h2><p>首先，int 如何转为 byte？</p><p>在 Go 中，byte 是 int8 的别名，占用一个字节。由于它只有一个字节，自然不存在字节序的说法。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>byteVar</span> <span style=color:#66d9ef>byte</span> = <span style=color:#ae81ff>0x78</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>intVar</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>byteVar</span>)
</span></span></code></pre></td></tr></table></div></div><p>我们将一个 byte 变量转换为 int 类型，byte 只占用一个字节，所以没有字节序的问题。当然，一定要说有字节序，也可以。毕竟，将 byte 转为 int 时，其实是将 byte 数值存在 int 低位，而不是高位。</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-05-v1.png alt></p><p>那么，将 int 转换为 byte 呢？当从 int 类型转换为 byte 时，字节序变得重要了。</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-04.png alt></p><p>从 int 转为 byte 时，将会截断 int 数据，将最低位的数值作为 byte 的值。</p><p>那么，如果我们想判断自己电脑上的字节序，只要将 int 转为 byte，即可判断。</p><p>示例代码，如下所示：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> int32(<span style=color:#ae81ff>0x12345678</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> byte(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;0x%x\n&#34;</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>0x78
</span></span></code></pre></td></tr></table></div></div><p>我的电脑上的输出结果为 0x78，它是低位的值，即低位存放于低地址。这表明我的机器是小端模式。</p><h2 id=网络传输与-go-的-encodingbinary-包>网络传输与 Go 的 encoding/binary 包</h2><p>在网络传输中，字节序至关重要。通常，网络协议要求使用大端字节序。当在不同字节序的系统之间通信时，正确处理字节序至关重要。</p><p>Go 的 <code>encoding/binary</code> 包提供了处理字节序的便利工具。它定义了一个 ByteOrder 接口，包括各种转换函数。</p><p>它的使用非常简单，代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bytes</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>0x78</span>, <span style=color:#ae81ff>0x56</span>, <span style=color:#ae81ff>0x34</span>, <span style=color:#ae81ff>0x12</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;LittleEndian: 0x%x\n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>LittleEndian</span>.<span style=color:#a6e22e>Uint32</span>(<span style=color:#a6e22e>bytes</span>),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;BigEndian: 0x%x\n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint32</span>(<span style=color:#a6e22e>bytes</span>),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>我们使用 <code>binary.LittleEndian</code> 和 <code>binary.BigEndian</code> 完成小端和大端字节向 <code>uint32</code> 的转换。</p><p>输出:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>LittleEndian: 0x12345678
</span></span><span style=display:flex><span>BigEndian: 0x78563412
</span></span></code></pre></td></tr></table></div></div><p>小端模式下，结果是 0x12345678，在大端模式下，是 0x78563412。这个例子演示了 Go 如何使用小端和大端模式将字节数组转换为 uint32 类型。</p><p>我们通过图示再看下这个转化的对应关系：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-02/2024-02-07-big-little-endian-in-golang-06.png alt></p><p>输出结果符合我们的预期。</p><h2 id=结论>结论</h2><p>本文主要介绍字节序这个概念，还有如何在 Go 中进行正确的字节序处理。有兴趣可阅读 encoding/binary 包的源代码，以获得更深入的理解。</p><p>最后，希望这篇文章能对你有所帮助，如果你有任何问题，请随时提问。</p><p>博文地址：<a href=https://www.poloxue.com/posts/2024-02-07-big-little-endian-in-golang/>Go 语言中如何大小端字节序？int 转 byte 是如何进行的？</a></p><div>本文来源于 <a href=https://www.poloxue.com>POLOXUE's BLOG</a>，地址： <a href=https://www.poloxue.com/posts/2024-02-07-big-little-endian-in-golang/>Go 语言中如何大小端字节序？int 转 byte 是如何进行的？</a><hr class=footer-separator><div class=tags></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post>欢迎关注我的公众号：<img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@main/wechat.png><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2024 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script></body></html>