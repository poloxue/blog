<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>如何评价 Golang 开源库 Cobra - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="如何评价 Golang 开源库 Cobra"><meta itemprop=description content="问题：如何评价 Cobra （Golang 库）？
项目地址：https://github.com/spf13/cobra
事实上，这个库是 k8s、hugo 等开源项目都在用的库。它可用于创建命令行应用。
命令行应用 一般写命令行应用，如果要求不是太多，直接用 flag 标准库就够了，毕竟像 Go 命令也是通过 flag 包实现的，完全能够驾驭。
前段时间还写了篇文章，结果发现，似乎没人对这个话题感兴趣。
文章地址：Go 命令行解析 flag 包之通过子命令实现看 go 命令源码
命令行应用可以和 web 应用做类比，就像 web 只有路由，就可以实现一个复杂的 web 应用，同样 flag 提供的基本功能，也足够写出非常复杂的应用了。
但不是任何人都想去了解 flag，或者裸写一个命令行应用。
为什么呢？
因为命令行的有些内容还要处理，比如，
默认没有子命令的一套实现规范， 不支持参数校验； 不支持帮助信息模板配置。 没有对一些标准提供默认支持，如 POSIX 标准，没有 -v，&ndash;version 和 -h、&ndash;help 的默认支持等。 一套完整的命令行框架应用就要这些能力，能提供一套最佳实践。Cobra 就是这样一套框架。
Cobra Cobra 支持的功能非常多，一些非常出名的开源项目，比如 k8s、hugo 等都在使用它。我之前读过它的文档。
github 的说明已经介绍了它的很多能力，比如支持子命令，posix 规范的 Flag，嵌套的子命令，支持全局、局部和级联的选项，支持 bash 自动补全，便捷的参数校验。
Easy subcommand-based CLIs: app server, app fetch, etc. Fully POSIX-compliant flags (including short & long versions) Nested subcommands Global, local and cascading flags Easy generation of applications & commands with cobra init appname & cobra add cmdname Intelligent suggestions (app srver."><meta itemprop=datePublished content="2019-12-03T05:30:11+08:00"><meta itemprop=dateModified content="2019-12-03T05:30:11+08:00"><meta itemprop=wordCount content="172"><meta itemprop=keywords content="Golang,"><meta property="og:title" content="如何评价 Golang 开源库 Cobra"><meta property="og:description" content="问题：如何评价 Cobra （Golang 库）？
项目地址：https://github.com/spf13/cobra
事实上，这个库是 k8s、hugo 等开源项目都在用的库。它可用于创建命令行应用。
命令行应用 一般写命令行应用，如果要求不是太多，直接用 flag 标准库就够了，毕竟像 Go 命令也是通过 flag 包实现的，完全能够驾驭。
前段时间还写了篇文章，结果发现，似乎没人对这个话题感兴趣。
文章地址：Go 命令行解析 flag 包之通过子命令实现看 go 命令源码
命令行应用可以和 web 应用做类比，就像 web 只有路由，就可以实现一个复杂的 web 应用，同样 flag 提供的基本功能，也足够写出非常复杂的应用了。
但不是任何人都想去了解 flag，或者裸写一个命令行应用。
为什么呢？
因为命令行的有些内容还要处理，比如，
默认没有子命令的一套实现规范， 不支持参数校验； 不支持帮助信息模板配置。 没有对一些标准提供默认支持，如 POSIX 标准，没有 -v，&ndash;version 和 -h、&ndash;help 的默认支持等。 一套完整的命令行框架应用就要这些能力，能提供一套最佳实践。Cobra 就是这样一套框架。
Cobra Cobra 支持的功能非常多，一些非常出名的开源项目，比如 k8s、hugo 等都在使用它。我之前读过它的文档。
github 的说明已经介绍了它的很多能力，比如支持子命令，posix 规范的 Flag，嵌套的子命令，支持全局、局部和级联的选项，支持 bash 自动补全，便捷的参数校验。
Easy subcommand-based CLIs: app server, app fetch, etc. Fully POSIX-compliant flags (including short & long versions) Nested subcommands Global, local and cascading flags Easy generation of applications & commands with cobra init appname & cobra add cmdname Intelligent suggestions (app srver."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/2019-12-03-what-is-cobra/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-03T05:30:11+08:00"><meta property="article:modified_time" content="2019-12-03T05:30:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何评价 Golang 开源库 Cobra"><meta name=twitter:description content="问题：如何评价 Cobra （Golang 库）？
项目地址：https://github.com/spf13/cobra
事实上，这个库是 k8s、hugo 等开源项目都在用的库。它可用于创建命令行应用。
命令行应用 一般写命令行应用，如果要求不是太多，直接用 flag 标准库就够了，毕竟像 Go 命令也是通过 flag 包实现的，完全能够驾驭。
前段时间还写了篇文章，结果发现，似乎没人对这个话题感兴趣。
文章地址：Go 命令行解析 flag 包之通过子命令实现看 go 命令源码
命令行应用可以和 web 应用做类比，就像 web 只有路由，就可以实现一个复杂的 web 应用，同样 flag 提供的基本功能，也足够写出非常复杂的应用了。
但不是任何人都想去了解 flag，或者裸写一个命令行应用。
为什么呢？
因为命令行的有些内容还要处理，比如，
默认没有子命令的一套实现规范， 不支持参数校验； 不支持帮助信息模板配置。 没有对一些标准提供默认支持，如 POSIX 标准，没有 -v，&ndash;version 和 -h、&ndash;help 的默认支持等。 一套完整的命令行框架应用就要这些能力，能提供一套最佳实践。Cobra 就是这样一套框架。
Cobra Cobra 支持的功能非常多，一些非常出名的开源项目，比如 k8s、hugo 等都在使用它。我之前读过它的文档。
github 的说明已经介绍了它的很多能力，比如支持子命令，posix 规范的 Flag，嵌套的子命令，支持全局、局部和级联的选项，支持 bash 自动补全，便捷的参数校验。
Easy subcommand-based CLIs: app server, app fetch, etc. Fully POSIX-compliant flags (including short & long versions) Nested subcommands Global, local and cascading flags Easy generation of applications & commands with cobra init appname & cobra add cmdname Intelligent suggestions (app srver."><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.webp alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>HOME</a></li><li><a href=/posts>POSTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/about/>ABOUT</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>03</span>
<span class=rest>Dec 2019</span></div></div><div class=matter><h1 class=title>如何评价 Golang 开源库 Cobra</h1></div></div><p>问题：<a href=https://www.zhihu.com/question/358956995/answer/919748685>如何评价 Cobra （Golang 库）？</a></p><p>项目地址：https://github.com/spf13/cobra</p><p>事实上，这个库是 k8s、hugo 等开源项目都在用的库。它可用于创建命令行应用。</p><h2 id=命令行应用>命令行应用</h2><p>一般写命令行应用，如果要求不是太多，直接用 flag 标准库就够了，毕竟像 Go 命令也是通过 flag 包实现的，完全能够驾驭。</p><p>前段时间还写了篇文章，结果发现，似乎没人对这个话题感兴趣。</p><p>文章地址：<a href=https://www.poloxue.com/posts/2019-11-23-commandline-tool-flag-in-golang/>Go 命令行解析 flag 包之通过子命令实现看 go 命令源码</a></p><p>命令行应用可以和 web 应用做类比，就像 web 只有路由，就可以实现一个复杂的 web 应用，同样 flag 提供的基本功能，也足够写出非常复杂的应用了。</p><p>但不是任何人都想去了解 flag，或者裸写一个命令行应用。</p><p>为什么呢？</p><p>因为命令行的有些内容还要处理，比如，</p><ul><li>默认没有子命令的一套实现规范，</li><li>不支持参数校验；</li><li>不支持帮助信息模板配置。</li><li>没有对一些标准提供默认支持，如 POSIX 标准，没有 -v，&ndash;version 和 -h、&ndash;help 的默认支持等。</li></ul><p>一套完整的命令行框架应用就要这些能力，能提供一套最佳实践。Cobra 就是这样一套框架。</p><h2 id=cobra>Cobra</h2><p>Cobra 支持的功能非常多，一些非常出名的开源项目，比如 k8s、hugo 等都在使用它。我之前读过它的文档。</p><p>github 的说明已经介绍了它的很多能力，比如支持子命令，posix 规范的 Flag，嵌套的子命令，支持全局、局部和级联的选项，支持 bash 自动补全，便捷的参数校验。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Easy subcommand-based CLIs: app server, app fetch, etc.
</span></span><span style=display:flex><span>Fully POSIX-compliant flags <span style=color:#f92672>(</span>including short &amp; long versions<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Nested subcommands
</span></span><span style=display:flex><span>Global, local and cascading flags
</span></span><span style=display:flex><span>Easy generation of applications &amp; commands with cobra init appname &amp; cobra add cmdname
</span></span><span style=display:flex><span>Intelligent suggestions <span style=color:#f92672>(</span>app srver... did you mean app server?<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Automatic help generation <span style=color:#66d9ef>for</span> commands and flags
</span></span><span style=display:flex><span>Automatic help flag recognition of -h, --help, etc.
</span></span><span style=display:flex><span>Automatically generated bash autocomplete <span style=color:#66d9ef>for</span> your application
</span></span><span style=display:flex><span>Automatically generated man pages <span style=color:#66d9ef>for</span> your application
</span></span><span style=display:flex><span>Command aliases so you can change things without breaking them
</span></span><span style=display:flex><span>The flexibility to define your own help, usage, etc.
</span></span><span style=display:flex><span>Optional tight integration with viper <span style=color:#66d9ef>for</span> 12-factor apps
</span></span></code></pre></div><p>它还提供了一套脚手架，能便捷地创建一个命令行应用，就像写 web 应用一样，快速创建一个 handler、Controller。</p><p>当然，如果只是写个简单小工具，连子命令都没有，Flag 选项又少的可怜。flag 就足够了，没有必要依赖它。</p><h2 id=使用演示>使用演示</h2><p>让我们使用 Cobra 创建一个简单的命令行应用。</p><hr class=footer-separator><div class=tags><ul class=flat><li class=tag-li><a href=/tags/golang>Golang</a></li></ul></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>2019 2023 Polo Xue All rights reserved</div></nav></div></body></html>