<!doctype html><html lang=zh-cn><head><title>从头构建 Go Web 框架（二）：中间件 // POLOXUE's 博客频道</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.116.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="POLO XUE"><meta name=description content><link rel=stylesheet href=/css/main.min.bc53baba214f8015c0d60c05be847bd7734aeb6e7c6b25f647bd242952d8d436.css><link rel=alternate type=application/rss+xml href=https://www.poloxue.com/index.xml title="POLOXUE's 博客频道" description="欢迎订阅 POLOXUE's 的博客频道"><meta name=twitter:card content="summary"><meta name=twitter:title content="从头构建 Go Web 框架（二）：中间件"><meta name=twitter:description content="本文是构建 Go Web 框架的第二篇，目标是介绍中间件的最佳实践，访问原文。
译文如下：
在编写 Go Web 应用时，代码重复是大多数开发者将会遇到的第一个问题。
为什么呢？
原因在于，在处理 request 时，诸如记录请求、将应用程序错误转换为 HTTP 500 错误、验证用户等一些操作，这是每个处理程序都要执行的动作。
本文是 &ldquo;构建属于自己的 Web 框架&rdquo; 系列文章中的第二篇：
第 1 部分：简介 第 2 部分：Go 中间件：最佳实践和示例 第 3 部分：中间件数据共享 第 4 部分：第三方路由 第 5 部分：使用 MongoDB 实现 JSON-API 附加福利：上传文件到 s3 基础入门 首先，使用 net/http 包创建一个简单版本的 HTTP Server 应用。
代码如下：
import ( &#34;net/http&#34; &#34;fmt&#34; ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &#34;Welcome!&#34;) } func main() { http.HandleFunc(&#34;/&#34;, handler) http.ListenAndServe(&#34;:8080&#34;, nil) } 阅读以上代码，我们看出 http."><meta property="og:title" content="从头构建 Go Web 框架（二）：中间件"><meta property="og:description" content="本文是构建 Go Web 框架的第二篇，目标是介绍中间件的最佳实践，访问原文。
译文如下：
在编写 Go Web 应用时，代码重复是大多数开发者将会遇到的第一个问题。
为什么呢？
原因在于，在处理 request 时，诸如记录请求、将应用程序错误转换为 HTTP 500 错误、验证用户等一些操作，这是每个处理程序都要执行的动作。
本文是 &ldquo;构建属于自己的 Web 框架&rdquo; 系列文章中的第二篇：
第 1 部分：简介 第 2 部分：Go 中间件：最佳实践和示例 第 3 部分：中间件数据共享 第 4 部分：第三方路由 第 5 部分：使用 MongoDB 实现 JSON-API 附加福利：上传文件到 s3 基础入门 首先，使用 net/http 包创建一个简单版本的 HTTP Server 应用。
代码如下：
import ( &#34;net/http&#34; &#34;fmt&#34; ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &#34;Welcome!&#34;) } func main() { http.HandleFunc(&#34;/&#34;, handler) http.ListenAndServe(&#34;:8080&#34;, nil) } 阅读以上代码，我们看出 http."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/coder/2021-10-28-build-your-own-webframework-in-golang-part-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-28T13:35:05+08:00"><meta property="article:modified_time" content="2021-10-28T13:35:05+08:00"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body><header class=app-header><a href=https://www.poloxue.com><img class=app-header-avatar src=/avatar.webp alt="POLO XUE"></a>
<span class=app-header-title>POLOXUE's 博客频道</span><nav class=app-header-menu><a class=app-header-menu-item href=/>首页</a><br><a class=app-header-menu-item href=/posts/coder>编程杂谈</a><br><a class=app-header-menu-item href=/posts/trader>交易人生</a><br><a class=app-header-menu-item href=/about/>关于我</a></nav><p>技术生活随笔记录</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>从头构建 Go Web 框架（二）：中间件</h1><div class=post-meta><div><span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Oct 28, 2021&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read &nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-eye"><title>eye</title><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg><span id=1695950b8ec6b73a5696b7dbc2434dde title>0 views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("1695950b8ec6b73a5696b7dbc2434dde").innerText=JSON.parse(this.responseText).count_unique+" views"}),r.open("GET","https://poloxue.goatcounter.com/counter/"+encodeURIComponent("/posts/coder/2021-10-28-build-your-own-webframework-in-golang-part-2/".replace(/(\/)?$/,""))+".json"),r.send()</script>&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://www.poloxue.com/tags/golang/>Golang</a></span></div></div></header><div class=post-content><p>本文是构建 Go Web 框架的第二篇，目标是介绍中间件的最佳实践，<a href=https://www.nicolasmerouze.com/middlewares-golang-best-practices-examples>访问原文</a>。</p><p>译文如下：</p><p>在编写 Go Web 应用时，代码重复是大多数开发者将会遇到的第一个问题。</p><p>为什么呢？</p><p>原因在于，在处理 request 时，诸如记录请求、将应用程序错误转换为 HTTP 500 错误、验证用户等一些操作，这是每个处理程序都要执行的动作。</p><p>本文是 &ldquo;构建属于自己的 Web 框架&rdquo; 系列文章中的第二篇：</p><ul><li><a href=https://www.nicolasmerouze.com/build-web-framework-golang>第 1 部分：简介</a></li><li><a href=https://www.nicolasmerouze.com/middlewares-golang-best-practices-examples>第 2 部分：Go 中间件：最佳实践和示例</a></li><li><a href=https://www.nicolasmerouze.com/share-values-between-middlewares-context-golang>第 3 部分：中间件数据共享</a></li><li><a href=https://www.nicolasmerouze.com/guide-routers-golang>第 4 部分：第三方路由</a></li><li><a href=https://www.nicolasmerouze.com/how-to-render-json-api-golang-mongodb>第 5 部分：使用 MongoDB 实现 JSON-API</a></li><li><a href=https://www.nicolasmerouze.com/file-upload-web-service-golang-s3-aws>附加福利：上传文件到 s3</a></li></ul><h1 id=基础入门>基础入门</h1><p>首先，使用 net/http 包创建一个简单版本的 HTTP Server 应用。</p><p>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Welcome!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>handler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>阅读以上代码，我们看出 <code>http.HandleFunc</code> 通过接受参数 <code>location pattern</code> 和 <code>handler</code>，实现特定路径与处理程序的匹配映射。<code>handler</code> 有 2 个参数，分别是 response writer 和 request，分别用于请求响应写入和请求信息读取。</p><p>除了通过 <code>http.HandleFunc</code> 指定处理函数的方式，实现 <code>http.Handler</code> 接口也可以帮助我们达成同样目的。</p><p>接口定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Handler</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>示例代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>handler</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>handler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Welcome!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>handler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一旦实现了 <code>http.Handler</code> 的 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 方法， 就能被 Go muxer (http.Handle(pattern, handler) function) 使用。</p><h2 id=添加日志>添加日志</h2><p>现在，我们希望通过增加一个简单的日志，记录处理每个请求所花费的时间。</p><p>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>indexHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Welcome!&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s] %q %v\n&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>String</span>(), <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>t1</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>indexHandler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出内容如下：</p><pre tabindex=0><code class=language-log data-lang=log>[GET] / 1.43ms
[GET] /about 1.98ms
</code></pre><p>继续，我们增加第二个 handler。毕竟，只有一个路由的应用程序并不多。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>aboutHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;You are on the about page.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s] %q %v\n&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>String</span>(), <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>t1</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>indexHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Welcome!&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s] %q %v\n&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>String</span>(), <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>t1</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/about&#34;</span>, <span style=color:#a6e22e>aboutHandler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>indexHandler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代码重复！ 该如何解决呢？</p><p>我们可以创建一个带有闭包的函数。但是，当我们有多个这样的函数时，它就会变得像 Javascript 中的回调一样糟糕，我们并不想如此。</p><h1 id=链接处理>链接处理</h1><p>我们希望有一种类似 Rack、Ring、Connect.js 等的中间件系统的解决方案，链接多个处理程序。标准库中已经有这种实现的示例：</p><ul><li><code>http.StripPrefix(prefix, handler)</code>；</li><li><code>http.TimeoutHandler(handler, duration, message)</code>。</li></ul><p>它们将 <code>handler</code> 作为参数传递，返回一个新的 <code>handler</code>。如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>loggingHandler</span>(<span style=color:#a6e22e>recoverHandler</span>(<span style=color:#a6e22e>indexHandler</span>))
</span></span></code></pre></div><p>中间件类似于 <code>func (http.Handler) http.Handler</code>，我们传递一个 <code>handler</code> 并返回一个 <code>handler</code>。我们就可以用 http.Handle(pattern, handler) 得到目标的处理程序。</p><p>实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>loggingHandler</span>(<span style=color:#a6e22e>recoverHandler</span>(<span style=color:#a6e22e>indexHandler</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但如此还是很麻烦，一遍又一遍地重复堆栈。 有没有什么更优雅的方式实现呢？</p><h1 id=通用包-alice>通用包 alice</h1><p><a href=https://github.com/justinas/alice>alice</a> 是一个非常短小精悍的包，它优雅地实现了 <code>handler</code> 的链接调用。通过它，我们可以创建一个通用的 <code>handler</code> 列表，便于我们重复使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>commonHandlers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alice</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>loggingHandler</span>, <span style=color:#a6e22e>recoverHandler</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/about&#34;</span>, <span style=color:#a6e22e>commonHandlers</span>.<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>aboutHandler</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>alice</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>commonHandlers</span>, <span style=color:#a6e22e>bodyParserHandler</span>).<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>indexHandler</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题解决！</p><p>我们已经有了一个使用标准接口的中间件系统，alice 有 50 行代码，一个非常小的依赖。如果想了解 alice 的实现细节，可自行阅读 <a href=https://github.com/justinas/alice>alice 源码</a>。</p><h1 id=多个参数的-handler>多个参数的 Handler</h1><p>alice 这样的中间件系统中，我们仍然不能使用类似 <code>http.StripPrefix(prefix, handler)</code> 具有多个参数的 <code>handler</code>。因为，它不是 <code>func (http.Handler) http.Handler</code> 类型函数。</p><p>怎么办？</p><p>我们可以通过定义新的 <code>handler</code> 实现兼容效果，保证满足 <code>func (http.Handler) http.Handler</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>myStripPrefix</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StripPrefix</span>(<span style=color:#e6db74>&#34;/old&#34;</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，新的 handler 我们在 alice 中间件系统可以开始使用了。</p><h1 id=再谈-logging-middleware>再谈 logging middleware</h1><p>通过 alice，我们有了更加优雅的方式实现代码重复的删除。我们无需重新定义的一个新的 http.Handler 接口，标准接口即可满足要求，这意味学习成本非常低，依赖更少。</p><p>实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loggingHandler</span>(<span style=color:#a6e22e>next</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;[%s] %q %v\n&#34;</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span>, <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>String</span>(), <span style=color:#a6e22e>t2</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>t1</span>))
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>fn</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后，我们使用 alice 将 loggingHandler 与其他 <code>handler</code> 链接起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>aboutHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;You are on the about page.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>indexHandler</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Welcome!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>commonHandlers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alice</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>loggingHandler</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/about&#34;</span>, <span style=color:#a6e22e>commonHandlers</span>.<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>aboutHandler</span>))
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>commonHandlers</span>.<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>indexHandler</span>))
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>大功告成！</p><h1 id=新中间件panic-recovery>新中间件：panic recovery</h1><p>另一个真正必要的功能：<code>panic recovery</code>。</p><p>当生产环境出现 <code>panic</code>，应用程序会被关闭。即使，我们有一个监控负责应用程序检测重启，也会不可避免的停机一小段时间。我们必须捕捉和记录 panic，并保持应用程序运行。</p><p>使用 Go 和中间件系统，这会变得非常容易。 只需要我们创建一个 <code>defer</code> 函数恢复 <code>panic</code>，响应 HTTP 500 错误并记录 panic 即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recoverHandler</span>(<span style=color:#a6e22e>next</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;panic: %+v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusText</span>(<span style=color:#ae81ff>500</span>), <span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>fn</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，将它追加到我们的中间件 stack 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>commonHandlers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alice</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>loggingHandler</span>, <span style=color:#a6e22e>recoverHandler</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/about&#34;</span>, <span style=color:#a6e22e>commonHandlers</span>.<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>aboutHandler</span>))
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>commonHandlers</span>.<span style=color:#a6e22e>ThenFunc</span>(<span style=color:#a6e22e>indexHandler</span>))
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=总结>总结</h1><p>我们已经了解，<code>func (http.Handler) http.Handler</code> 是一种非常简单的中间件定义方法，它提供了一切所需，<code>http.Handler</code> 是一个标准接口。</p><p>而通过链接方式实现中间件系统，已经是非常流行的方案，比如 Gorilla 和标准库本身。 我认为这是最惯用的方式。</p><p>我们已经编写了两个中间件：logging 和 panice recovery。</p><p>几乎每个框架中都在重写它们，尽管它们的功能几乎一样。大多数框架都有自己特定的 <code>handler</code> 定义，很难与其他中间件协同使用。接下来的一部分，我们将会了解到，在中间件之间共享值时，我们可能要更改一些内容。但它其实没有那么大的变化，我们没有理由重写已有的中间件。</p></div><div class=post-footer><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></article></main></body></html>