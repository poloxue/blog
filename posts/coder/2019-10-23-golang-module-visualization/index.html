<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go Module 依赖关系的可视化 - POLOXUE's 博客频道</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Go Module 依赖关系的可视化"><meta itemprop=description content="最近，我开发了一个非常简单的小工具，总的代码量 200 行不到。今天，简单介绍下它。这是个什么工具呢？它是一个用于可视化展示 Go Module 依赖关系的工具。
为何开发 为什么会想到开发这个工具？主要有两点原因：
一是最近经常看到大家在社区讨论 Go Module。于是，我也花了一些时间研究了下。期间，遇到了一个需求，如何清晰地识别模块中依赖项之间的关系。一番了解后，发现了 go mod graph。
效果如下：
$ go mod graph github.com/poloxue/testmod golang.org/x/text@v0.3.2 github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0 github.com/poloxue/testmod rsc.io/sampler@v1.3.1 golang.org/x/text@v0.3.2 golang.org/x/tools@v0.0.0-20180917221912-90fa682c2a6e rsc.io/quote/v3@v3.1.0 rsc.io/sampler@v1.3.0 rsc.io/sampler@v1.3.1 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c rsc.io/sampler@v1.3.0 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c 每一行的格式是 模块 依赖模块，基本能满足要求，但总觉得还是不那么直观。
二是我之前手里有一个项目，包管理一直用的是 dep。于是，我也了解了下它，把官方文档仔细读了一遍。其中的某个章节介绍了依赖项可视化展示的方法。
文档中给出的包关系图：
看到这张图的时候，眼睛瞬间就亮了，图形化就是优秀，不同依赖之间的关系一目了然。这不就是我想要的效果吗？666，点个赞。
但 &mldr;，随之而来的问题是，go mod 没这个能力啊。怎么办？
如何实现 先看看是不是已经有人做了这件事了。网上搜了下，没找到。那是不是能自己实现？应该可以借鉴下 dep 的思路吧？
如下是 dep 依赖实现可视化的方式：
# linux $ sudo apt-get install graphviz $ dep status -dot | dot -T png | display # macOS $ brew install graphviz $ dep status -dot | dot -T png | open -f -a /Applications/Preview."><meta itemprop=datePublished content="2019-10-23T08:21:35+08:00"><meta itemprop=dateModified content="2019-10-23T08:21:35+08:00"><meta itemprop=wordCount content="696"><meta itemprop=keywords content="Golang,"><meta property="og:title" content="Go Module 依赖关系的可视化"><meta property="og:description" content="最近，我开发了一个非常简单的小工具，总的代码量 200 行不到。今天，简单介绍下它。这是个什么工具呢？它是一个用于可视化展示 Go Module 依赖关系的工具。
为何开发 为什么会想到开发这个工具？主要有两点原因：
一是最近经常看到大家在社区讨论 Go Module。于是，我也花了一些时间研究了下。期间，遇到了一个需求，如何清晰地识别模块中依赖项之间的关系。一番了解后，发现了 go mod graph。
效果如下：
$ go mod graph github.com/poloxue/testmod golang.org/x/text@v0.3.2 github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0 github.com/poloxue/testmod rsc.io/sampler@v1.3.1 golang.org/x/text@v0.3.2 golang.org/x/tools@v0.0.0-20180917221912-90fa682c2a6e rsc.io/quote/v3@v3.1.0 rsc.io/sampler@v1.3.0 rsc.io/sampler@v1.3.1 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c rsc.io/sampler@v1.3.0 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c 每一行的格式是 模块 依赖模块，基本能满足要求，但总觉得还是不那么直观。
二是我之前手里有一个项目，包管理一直用的是 dep。于是，我也了解了下它，把官方文档仔细读了一遍。其中的某个章节介绍了依赖项可视化展示的方法。
文档中给出的包关系图：
看到这张图的时候，眼睛瞬间就亮了，图形化就是优秀，不同依赖之间的关系一目了然。这不就是我想要的效果吗？666，点个赞。
但 &mldr;，随之而来的问题是，go mod 没这个能力啊。怎么办？
如何实现 先看看是不是已经有人做了这件事了。网上搜了下，没找到。那是不是能自己实现？应该可以借鉴下 dep 的思路吧？
如下是 dep 依赖实现可视化的方式：
# linux $ sudo apt-get install graphviz $ dep status -dot | dot -T png | display # macOS $ brew install graphviz $ dep status -dot | dot -T png | open -f -a /Applications/Preview."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/coder/2019-10-23-golang-module-visualization/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-23T08:21:35+08:00"><meta property="article:modified_time" content="2019-10-23T08:21:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Module 依赖关系的可视化"><meta name=twitter:description content="最近，我开发了一个非常简单的小工具，总的代码量 200 行不到。今天，简单介绍下它。这是个什么工具呢？它是一个用于可视化展示 Go Module 依赖关系的工具。
为何开发 为什么会想到开发这个工具？主要有两点原因：
一是最近经常看到大家在社区讨论 Go Module。于是，我也花了一些时间研究了下。期间，遇到了一个需求，如何清晰地识别模块中依赖项之间的关系。一番了解后，发现了 go mod graph。
效果如下：
$ go mod graph github.com/poloxue/testmod golang.org/x/text@v0.3.2 github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0 github.com/poloxue/testmod rsc.io/sampler@v1.3.1 golang.org/x/text@v0.3.2 golang.org/x/tools@v0.0.0-20180917221912-90fa682c2a6e rsc.io/quote/v3@v3.1.0 rsc.io/sampler@v1.3.0 rsc.io/sampler@v1.3.1 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c rsc.io/sampler@v1.3.0 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c 每一行的格式是 模块 依赖模块，基本能满足要求，但总觉得还是不那么直观。
二是我之前手里有一个项目，包管理一直用的是 dep。于是，我也了解了下它，把官方文档仔细读了一遍。其中的某个章节介绍了依赖项可视化展示的方法。
文档中给出的包关系图：
看到这张图的时候，眼睛瞬间就亮了，图形化就是优秀，不同依赖之间的关系一目了然。这不就是我想要的效果吗？666，点个赞。
但 &mldr;，随之而来的问题是，go mod 没这个能力啊。怎么办？
如何实现 先看看是不是已经有人做了这件事了。网上搜了下，没找到。那是不是能自己实现？应该可以借鉴下 dep 的思路吧？
如下是 dep 依赖实现可视化的方式：
# linux $ sudo apt-get install graphviz $ dep status -dot | dot -T png | display # macOS $ brew install graphviz $ dep status -dot | dot -T png | open -f -a /Applications/Preview."><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/main.js></script></head><body><div class="container-wide wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.webp alt="POLOXUE's 博客频道"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's 博客频道</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>首页</a></li><li><a href=/posts/coder>编程杂谈</a></li><li><a href=/posts/trader>交易人生</a></li><li><a href=/posts/translator>技术译文</a></li><li><a href=/posts/english>英语学习</a></li><li><a href=/about/>关于我</a></li></ul></nav></div><div class=article-nav id=article-nav-id><div class=post><div class=post-header><div class=meta><div class=date><span class=day>23</span>
<span class=rest>Oct 2019</span></div></div><div class=matter><h1 class=title>Go Module 依赖关系的可视化</h1></div></div><aside class="show-on-mobile toc" id=static-toc><header><h3>Contents</h3></header><nav id=TableOfContents></nav></aside><p>最近，我开发了一个非常简单的小工具，总的代码量 200 行不到。今天，简单介绍下它。这是个什么工具呢？它是一个用于可视化展示 Go Module 依赖关系的工具。</p><h1 id=为何开发>为何开发</h1><p>为什么会想到开发这个工具？主要有两点原因：</p><p>一是最近经常看到大家在社区讨论 Go Module。于是，我也花了一些时间研究了下。期间，遇到了一个需求，如何清晰地识别模块中依赖项之间的关系。一番了解后，发现了 <code>go mod graph</code>。</p><p>效果如下：</p><pre tabindex=0><code>$ go mod graph
github.com/poloxue/testmod golang.org/x/text@v0.3.2
github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0
github.com/poloxue/testmod rsc.io/sampler@v1.3.1
golang.org/x/text@v0.3.2 golang.org/x/tools@v0.0.0-20180917221912-90fa682c2a6e
rsc.io/quote/v3@v3.1.0 rsc.io/sampler@v1.3.0
rsc.io/sampler@v1.3.1 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c
rsc.io/sampler@v1.3.0 golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c
</code></pre><p>每一行的格式是 <code>模块 依赖模块</code>，基本能满足要求，但总觉得还是不那么直观。</p><p>二是我之前手里有一个项目，包管理一直用的是 dep。于是，我也了解了下它，把官方文档仔细读了一遍。其中的<a href=https://golang.github.io/dep/docs/daily-dep.html>某个章节</a>介绍了依赖项可视化展示的方法。</p><p>文档中给出的包关系图：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@main/golang-module-visualization-02.png alt></p><p>看到这张图的时候，眼睛瞬间就亮了，图形化就是优秀，不同依赖之间的关系一目了然。这不就是我想要的效果吗？666，点个赞。</p><p>但 &mldr;，随之而来的问题是，go mod 没这个能力啊。怎么办？</p><h1 id=如何实现>如何实现</h1><p>先看看是不是已经有人做了这件事了。网上搜了下，没找到。那是不是能自己实现？应该可以借鉴下 dep 的思路吧？</p><p>如下是 dep 依赖实现可视化的方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># linux</span>
</span></span><span style=display:flex><span>$ sudo apt-get install graphviz
</span></span><span style=display:flex><span>$ dep status -dot | dot -T png | display
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># macOS</span>
</span></span><span style=display:flex><span>$ brew install graphviz
</span></span><span style=display:flex><span>$ dep status -dot | dot -T png | open -f -a /Applications/Preview.app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Windows</span>
</span></span><span style=display:flex><span>&gt; choco install graphviz.portable
</span></span><span style=display:flex><span>&gt; dep status -dot | dot -T png -o status.png; start status.png
</span></span></code></pre></div><p>这里展示了三大系统下的使用方式，它们都安装了一个软件包，graphviz。从名字上看，这应该是一个用来实现可视化的软件，即用来画图的。事实也是这样，可以看看它的<a href=http://www.graphviz.org/documentation/>官网</a>。</p><p>再看下它的使用，发现都是通过管道命令组合的方式，而且前面的部分基本相同，都是 <code>dep status -dot | dot -T png</code>。后面的部分在不同的系统就不同了，Linux 是 <code>display</code>，MacOS 是 <code>open -f -a /Applications/Preview.app</code>，Window 是 <code>start status.png</code>。</p><p>稍微分析下就会明白，前面是生成图片，后面是显示图片。因为不同系统的图片展示命令不同，所以后面的部分也就不同了。</p><p>现在关心的重点在前面，即 <code>dep status -dot | dot -T png</code> 干了啥，它究竟是如何实现绘图的？大致猜测，dot -T png 是由 dep status -dot 提供的数据生成图片。继续看下 <code>dep status -dot</code> 的执行效果吧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ dep status -dot
</span></span><span style=display:flex><span>digraph <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	node <span style=color:#f92672>[</span>shape<span style=color:#f92672>=</span>box<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>2609291568</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;github.com/poloxue/hellodep&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>953278068</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;rsc.io/quote\nv3.1.0&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>3852693168</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;rsc.io/sampler\nv1.0.0&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>2609291568</span> -&gt; 953278068;
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>953278068</span> -&gt; 3852693168;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>咋一看，输出的是一段看起来不知道是啥的代码，这应该是 graphviz 用于绘制图表的语言。那是不是还有学习下？当然不用啊，这里用的很简单，直接套用就行了。</p><p>试着分析一下吧，前面两行可以不用关心，这应该是 graphviz 特定的写法，表示要画的是什么图。我们主要关心如何将数据以正确形式提供出来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>2609291568</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;github.com/poloxue/hellodep&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#ae81ff>953278068</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;rsc.io/quote\nv3.1.0&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#ae81ff>3852693168</span> <span style=color:#f92672>[</span>label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;rsc.io/sampler\nv1.0.0&#34;</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#ae81ff>2609291568</span> -&gt; 953278068;
</span></span><span style=display:flex><span><span style=color:#ae81ff>953278068</span> -&gt; 3852693168;
</span></span></code></pre></div><p>一看就知道，这里有两种结构，分别是为依赖项关联 ID ，和通过 ID 和 <code>-></code> 表示依赖间的关系。</p><p>按上面的猜想，我们可以试着画出一个简单的图, 用于表示 a 模块依赖 b 模块。执行命令如下，将绘图代码通过 <code>each</code> 管道的方式发送给 <code>dot</code> 命令。</p><pre tabindex=0><code>$ echo &#39;digraph {
node [shape=box];
1 [label=&#34;a&#34;];
2 [label=&#34;b&#34;];
1 -&gt; 2;
}&#39; | dot -T png | open -f -a /Applications/Preview.app
</code></pre><p>效果如下：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@main/golang-module-visualization-03.png alt></p><p>绘制一个依赖关系图竟然这么简单。</p><p>看到这里，是不是发现问题已经变得非常简单了。我们只要将 <code>go mod graph</code> 的输出转化为类似的结构就能实现可视化了。</p><h1 id=开发流程介绍>开发流程介绍</h1><p>接下来，开发这个小程序吧，我将这个小程序命名为 <code>modv</code>，即 module visible 的意思。项目源码位于 <a href=https://github.com/poloxue/modv>poloxue/modv</a>。</p><h1 id=接收管道的输入>接收管道的输入</h1><p>先要检查数据输入管道是否正常。</p><p>我们的目标是使用类似 <code>dep</code> 中作图的方式，<code>go mod graph</code> 通过管道将数据传递给 <code>modv</code>。因此，要先检查 <code>os.Stdin</code>，即检查标准输入状态是否正常， 以及是否是管道传输。</p><p>下面是 main 函数的代码，位于 <a href=https://github.com/poloxue/modv/blob/master/main.go>main.go</a> 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>info</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdin</span>.<span style=color:#a6e22e>Stat</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;os.Stdin.Stat:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>PrintUsage</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 是否是管道传输
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>info</span>.<span style=color:#a6e22e>Mode</span>()<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModeNamedPipe</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;command err: command is intended to work with pipes.&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>PrintUsage</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>一旦确认输入设备一切正常，我们就可以进入到数据读取、解析与渲染的流程了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>mg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewModuleGraph</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdin</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mg</span>.<span style=color:#a6e22e>Parse</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mg</span>.<span style=color:#a6e22e>Render</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来，开始具体看看如何实现数据的处理流程。</p><h1 id=抽象实现结构>抽象实现结构</h1><p>先定义一个结构体，并大致定义整个流程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ModGraph</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Reader</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>  <span style=color:#75715e>// 读取数据流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewModGraph</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ModGraph</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ModGraph</span>{<span style=color:#a6e22e>Reader</span>: <span style=color:#a6e22e>r</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 执行数据的处理转化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ModGraph</span>) <span style=color:#a6e22e>Parse</span>() <span style=color:#66d9ef>error</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 结果渲染与输出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ModGraph</span>) <span style=color:#a6e22e>Render</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>) <span style=color:#66d9ef>error</span> {}
</span></span></code></pre></div><p>再看下 <code>go mod graph</code> 的输出吧，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>github.com/poloxue/testmod golang.org/x/text@v0.3.2
</span></span><span style=display:flex><span>github.com/poloxue/testmod rsc.io/quote/v3@v3.1.0
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>每一行的结构是 <code>模块 依赖项</code>。现在的目标是要它解析成下面这样的结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>digraph <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    node <span style=color:#f92672>[</span>shape<span style=color:#f92672>=</span>box<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> github.com/poloxue/testmod;
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span> golang.org/x/text@v0.3.2;
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span> rsc.io/quote/v3@v3.1.0;
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> -&gt; 2;
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> -&gt; 3;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>前面说过，这里包含了两种不同的结构，分别是模块与 ID 关联关系，以及模块 ID 表示模块间的依赖关联。为 <code>ModGraph</code> 结构体增加两个成员表示它们。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ModGraph</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>  <span style=color:#75715e>// 数据流读取实例，这里即 os.Stdin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 每一项名称与 ID 的映射
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Mods</span>         <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ID 和依赖 ID 关系映射，一个 ID 可能依赖多个项
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Dependencies</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>][]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要注意的是，增加了两个 map 成员后，记住要在 <code>NewModGraph</code> 中初始化下它们。</p><h1 id=mod-graph-输出解析>mod graph 输出解析</h1><p>如何进行解析？</p><p>介绍到这里，目标已经很明白了。就是要将输入数据解析到 <code>Mods</code> 和 <code>Dependencies</code> 两个成员中，实现代码都在 <code>Parse</code> 方法中。</p><p>为了方便进行数据读取，首先，我们利用 <code>bufio</code> 基于 <code>reader</code> 创建一个新的 <code>bufReader</code>，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ModGraph</span>) <span style=color:#a6e22e>Parse</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufReader</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Reader</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span></code></pre></div><p>为便于按行解析数据，我们通过 bufReader 的 <code>ReadBytes()</code> 方法循环一行一行地读取 os.Stdin 中的数据。然后，对每一行数据按空格切分，获取到依赖关系的两项。代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>relationBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufReader</span>.<span style=color:#a6e22e>ReadBytes</span>(<span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>relation</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>relationBytes</span>, []byte(<span style=color:#e6db74>&#34; &#34;</span>))
</span></span><span style=display:flex><span>    <span style=color:#75715e>// module and dependency
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mod</span>, <span style=color:#a6e22e>depMod</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(string(<span style=color:#a6e22e>relation</span>[<span style=color:#ae81ff>0</span>])), <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(string(<span style=color:#a6e22e>relation</span>[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来，就是将解析出来的依赖关系组织到 <code>Mods</code> 和 <code>Dependencies</code> 两个成员中。模块 ID 是生成规则采用的是最简单的实现方式，从 1 自增。实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>modId</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Mods</span>[<span style=color:#a6e22e>mod</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>modId</span> = <span style=color:#a6e22e>serialID</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Mods</span>[<span style=color:#a6e22e>mod</span>] = <span style=color:#a6e22e>modId</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>serialID</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>depModId</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Mods</span>[<span style=color:#a6e22e>depMod</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>depModId</span> = <span style=color:#a6e22e>serialID</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Mods</span>[<span style=color:#a6e22e>depMod</span>] = <span style=color:#a6e22e>depModId</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>serialID</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dependencies</span>[<span style=color:#a6e22e>modId</span>]; <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dependencies</span>[<span style=color:#a6e22e>modId</span>] = append(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dependencies</span>[<span style=color:#a6e22e>modId</span>], <span style=color:#a6e22e>depModId</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dependencies</span>[<span style=color:#a6e22e>modId</span>] = []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>depModId</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解析的工作到这里就结束了。</p><h1 id=渲染解析的结果>渲染解析的结果</h1><p>这个小工具还剩下最后一步工作要做，即将解析出来的数据渲染出来，以满足 <code>graphviz</code> 工具的作图要求。实现代码是 <code>Render</code>部分：</p><p>首先，定义一个模板，以生成满足要求的输出格式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>graphTemplate</span> = <span style=color:#e6db74>`digraph {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>node [shape=box];
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>$mod</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>$modId</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>.mods</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{</span> <span style=color:#a6e22e>$modId</span> <span style=color:#75715e>}}</span><span style=color:#e6db74> [label=&#34;</span><span style=color:#75715e>{{</span> <span style=color:#a6e22e>$mod</span> <span style=color:#75715e>}}</span><span style=color:#e6db74>&#34;];
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{</span> <span style=color:#66d9ef>end</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{-</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>$modId</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>$depModIds</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>.dependencies</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{-</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>$_</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>$depModId</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>$depModIds</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{</span> <span style=color:#a6e22e>$modId</span> <span style=color:#75715e>}}</span><span style=color:#e6db74> -&gt; </span><span style=color:#75715e>{{</span> <span style=color:#a6e22e>$depModId</span> <span style=color:#75715e>}}</span><span style=color:#e6db74>;
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{</span>  <span style=color:#66d9ef>end</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>{{-</span> <span style=color:#66d9ef>end</span> <span style=color:#75715e>-}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>
</span></span></code></pre></div><p>这一块没啥好介绍的，主要是要熟悉 Go 中的 <code>text/template</code> 模板的语法规范。为了展示友好，这里通过 <code>-</code> 实现换行的去除，整体而言不影响阅读。</p><p>接下来，看 <code>Render</code> 方法的实现，把前面解析出来的 <code>Mods</code> 和 <code>Dependencies</code> 放入模板进行渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ModuleGraph</span>) <span style=color:#a6e22e>Render</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>templ</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;graph&#34;</span>).<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>graphTemplate</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;templ.Parse: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>templ</span>.<span style=color:#a6e22e>Execute</span>(<span style=color:#a6e22e>w</span>, <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;mods&#34;</span>:         <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Mods</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;dependencies&#34;</span>: <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dependencies</span>,
</span></span><span style=display:flex><span>	}); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;templ.Execute: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，全部工作都完成了。最后，将这个流程整合到 main 函数。接下来就是使用了。</p><h1 id=使用体验>使用体验</h1><p>开始体验下吧。补充一句，这个工具，我现在只测试了 Mac 下的使用，如有问题，欢迎提出来。</p><p>首先，要先安装一下 <code>graphviz</code>，安装的方式在本文开头已经介绍了，选择你的系统安装方式。</p><p>接着是安装 <code>modv</code>，命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go get github.com/poloxue/modv
</span></span></code></pre></div><p>安装完成！简单测试下它的使用。</p><p>以 MacOS 为例。先下载测试库，github.com/poloxue/testmod。 进入 testmod 目录执行命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go mod graph | modv | dot -T png | open -f -a /Applications/Preview.app
</span></span></code></pre></div><p>如果执行成功，将看到如下的效果：</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@main/golang-module-visualization-04.png alt></p><p>完美地展示了各个模块之间的依赖关系。</p><h1 id=一些思考>一些思考</h1><p>本文是篇实践性的文章，从一个简单想法到成功呈现出一个可以使用的工具。虽然，开发起来并不难，从开发到完成，仅仅花了一两个小时。但我的感觉，这确实是个有实际价值的工具。</p><p>还有一些想法没有实现和验证，比如一旦项目较大，是否可以方便的展示某个指定节点的依赖树，而非整个项目。还有，在其他项目向 Go Module 迁移的时候，这个小工具是否能产生一些价值。</p></div><nav class="hide-on-mobile section-nav"><nav id=TableOfContents></nav></nav></div><div class=post><hr class=footer-separator><div class=tags><ul class=flat><li class=tag-li><a href=/tags/golang>Golang</a></li></ul></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div></div><div class="footer wrapper"><nav class=nav><div>2019 2023 Polo Xue All rights reserved</div></nav></div><script>var enableTruncate=!0,filterDepth=!1;const MAX_DEPTH=9;window.addEventListener("DOMContentLoaded",()=>{const e=new IntersectionObserver(e=>{e.reverse().forEach(e=>{const n=e.target.getAttribute("id");if(e.intersectionRatio>0){var t=document.querySelectorAll(`nav li a[href="#${n}"]`);t!=null&&t.forEach(e=>{if(e!=null){var t=getDepth(e.parentElement);filterDepth&&t<=MAX_DEPTH&&(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))}else filterDepth||(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))})}})});document.querySelectorAll("h1[id],h2[id],h3[id],h4[id]").forEach(t=>{e.observe(t)})});function isVisible(e){if(!(e instanceof Element))return!1;const n=getComputedStyle(e);if(n.display==="none")return!1;if(n.visibility!=="visible")return!1;if(n.opacity<.1)return!1;if(e.offsetWidth+e.offsetHeight+e.getBoundingClientRect().height+e.getBoundingClientRect().width===0)return!1;const t={x:e.getBoundingClientRect().left+e.offsetWidth/2,y:e.getBoundingClientRect().top+e.offsetHeight/2};if(t.x<0)return!1;if(t.x>(document.documentElement.clientWidth||window.innerWidth))return!1;if(t.y<0)return!1;if(t.y>(document.documentElement.clientHeight||window.innerHeight))return!1;let s=document.elementFromPoint(t.x,t.y);do if(s===e)return!0;while(s=s.parentNode)return!1}function clearActiveStatesInTableOfContents(){document.querySelectorAll("nav li").forEach(e=>{e.classList.remove("active")})}function getDepth(e){for(var t=0;e!==null&&e.tagName.toLowerCase()!=="ul";)t++,e=e.parentElement;return t}function navItems(){var e=document.querySelectorAll("nav nav li a");return Array.from(e).filter(e=>e.href!=null&&e.hash.startsWith("#"))}function lasItemInNavBarVisible(){var e=navItems().slice(-1)[0];return isVisible(e)}document.addEventListener("DOMContentLoaded",function(){if(!enableTruncate)return;var e=navItems();console.log(e),lasItemInNavBarVisible()||(filterDepth=!0,e.forEach(function(e){var t=getDepth(e.parentElement);t>MAX_DEPTH&&e.parentElement.classList.add("depth-nested")}))})</script></body></html>