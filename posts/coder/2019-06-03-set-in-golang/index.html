<!doctype html><html lang=zh-cn><head><title>Golang 中如何使用 Set // POLOXUE's 博客频道</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.117.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="POLO XUE"><meta name=description content><link rel=stylesheet href=/css/main.min.793141cb28d4ed7f0c313c54678b45746c45defce0221a9dfc49283ab3049c77.css><link rel=alternate type=application/rss+xml href=https://www.poloxue.com/index.xml title="POLOXUE's 博客频道" description="欢迎订阅 POLOXUE's 的博客频道"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang 中如何使用 Set"><meta name=twitter:description content="今天来聊一下 Go 如何使用 set，本文将会涉及 set 和 bitset 两种数据结构。
注：花了点时间，将这个专题录制成了视频，上B 站查看 视频。
Go 的数据结构 Go 内置的数据结构并不多。工作中，我们最常用的两种数据结构分别是 slice 和 map，即切片和映射。 其实，Go 中也有数组，切片的底层就是数组，只不过因为切片的存在，我们平时很少使用它。
除了 Go 内置的数据结构，还有一些数据结构是由 Go 的官方 container 包提供，如 heap 堆、list 双向链表和ring 回环链表。但今天我们不讲它们，这些数据结构，对于熟手来说，看看文档就会使用了。
我们今天将来聊的是 set 和 bitset。据我所知，其他一些语言，比如 Java，是有这两种数据结构。但 Go 当前还没有以任何形式提供。
实现思路 先来看一篇文章，访问地址 2 basic set implementations 阅读。文中介绍了两种 go 实现 set 的思路， 分别是 map 和 bitset。
有兴趣可以读读这篇文章，我们接下来具体介绍下。
map 我们知道，map 的 key 肯定是唯一的，而这恰好与 set 的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现 set，在检查是否存在某个元素时可直接使用 _, ok := m[key] 的语法，效率高。"><meta property="og:title" content="Golang 中如何使用 Set"><meta property="og:description" content="今天来聊一下 Go 如何使用 set，本文将会涉及 set 和 bitset 两种数据结构。
注：花了点时间，将这个专题录制成了视频，上B 站查看 视频。
Go 的数据结构 Go 内置的数据结构并不多。工作中，我们最常用的两种数据结构分别是 slice 和 map，即切片和映射。 其实，Go 中也有数组，切片的底层就是数组，只不过因为切片的存在，我们平时很少使用它。
除了 Go 内置的数据结构，还有一些数据结构是由 Go 的官方 container 包提供，如 heap 堆、list 双向链表和ring 回环链表。但今天我们不讲它们，这些数据结构，对于熟手来说，看看文档就会使用了。
我们今天将来聊的是 set 和 bitset。据我所知，其他一些语言，比如 Java，是有这两种数据结构。但 Go 当前还没有以任何形式提供。
实现思路 先来看一篇文章，访问地址 2 basic set implementations 阅读。文中介绍了两种 go 实现 set 的思路， 分别是 map 和 bitset。
有兴趣可以读读这篇文章，我们接下来具体介绍下。
map 我们知道，map 的 key 肯定是唯一的，而这恰好与 set 的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现 set，在检查是否存在某个元素时可直接使用 _, ok := m[key] 的语法，效率高。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/coder/2019-06-03-set-in-golang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-03T13:57:26+08:00"><meta property="article:modified_time" content="2019-06-03T13:57:26+08:00"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body><header class=app-header><a href=https://www.poloxue.com><img class=app-header-avatar src=/avatar.webp alt="POLO XUE"></a>
<span class=app-header-title>POLOXUE's 博客频道</span><nav class=app-header-menu><a class=app-header-menu-item href=/>首页</a><br><a class=app-header-menu-item href=/posts/coder>编程杂谈</a><br><a class=app-header-menu-item href=/posts/trader>交易人生</a><br><a class=app-header-menu-item href=/about/>关于我</a></nav><p>技术生活随笔记录</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Golang 中如何使用 Set</h1><div class=post-meta><div><span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 3, 2019&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read &nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-eye"><title>eye</title><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg><span id=5757848bb6f69792a7cd17b3dc295780 title>0 views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("5757848bb6f69792a7cd17b3dc295780").innerText=JSON.parse(this.responseText).count_unique+" views"}),r.open("GET","https://poloxue.goatcounter.com/counter/"+encodeURIComponent("/posts/coder/2019-06-03-set-in-golang/".replace(/(\/)?$/,""))+".json"),r.send()</script>&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://www.poloxue.com/tags/golang/>Golang</a></span></div></div></header><div class=post-content><p>今天来聊一下 Go 如何使用 set，本文将会涉及 set 和 bitset 两种数据结构。</p><p>注：花了点时间，将这个专题录制成了视频，上B 站查看 <a href=https://www.bilibili.com/video/av75078755>视频</a>。</p><h1 id=go-的数据结构>Go 的数据结构</h1><p>Go 内置的数据结构并不多。工作中，我们最常用的两种数据结构分别是 slice 和 map，即切片和映射。 其实，Go 中也有数组，切片的底层就是数组，只不过因为切片的存在，我们平时很少使用它。</p><p>除了 Go 内置的数据结构，还有一些数据结构是由 Go 的官方 container 包提供，如 heap 堆、list 双向链表和ring 回环链表。但今天我们不讲它们，这些数据结构，对于熟手来说，看看文档就会使用了。</p><p>我们今天将来聊的是 set 和 bitset。据我所知，其他一些语言，比如 Java，是有这两种数据结构。但 Go 当前还没有以任何形式提供。</p><h1 id=实现思路>实现思路</h1><p>先来看一篇文章，访问地址 <a href=https://yourbasic.org/golang/implement-set/>2 basic set implementations</a> 阅读。文中介绍了两种 go 实现 set 的思路， 分别是 map 和 bitset。</p><p>有兴趣可以读读这篇文章，我们接下来具体介绍下。</p><h1 id=map>map</h1><p>我们知道，map 的 key 肯定是唯一的，而这恰好与 set 的特性一致，天然保证 set 中成员的唯一性。而且通过 map 实现 set，在检查是否存在某个元素时可直接使用 <code>_, ok := m[key]</code> 的语法，效率高。</p><p>先来看一个简单的实现，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>bool</span>) <span style=color:#75715e>// New empty set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>set</span>[<span style=color:#e6db74>&#34;Foo&#34;</span>] = <span style=color:#66d9ef>true</span>            <span style=color:#75715e>// Add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>set</span> {         <span style=color:#75715e>// Loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>delete(<span style=color:#a6e22e>set</span>, <span style=color:#e6db74>&#34;Foo&#34;</span>)    <span style=color:#75715e>// Delete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>set</span>)      <span style=color:#75715e>// Size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>exists</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>set</span>[<span style=color:#e6db74>&#34;Foo&#34;</span>]  <span style=color:#75715e>// Membership
</span></span></span></code></pre></div><p>通过创建 map[string]bool 来存储 string 的集合，比较容易理解。但这里还有个问题，map 的 value 是布尔类型，这会导致 set 多占一定内存空间，而 set 不该有这个问题。</p><p>怎么解决这个问题？</p><p>设置 value 为空结构体，在 Go 中，空结构体不占任何内存。当然，如果不确定，也可以来证明下这个结论。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#66d9ef>struct</span>{}{}) <span style=color:#75715e>// 结果为 0
</span></span></span></code></pre></div><p>优化后的代码，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>void</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>member</span> <span style=color:#a6e22e>void</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>void</span>) <span style=color:#75715e>// New empty set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>set</span>[<span style=color:#e6db74>&#34;Foo&#34;</span>] = <span style=color:#a6e22e>member</span>          <span style=color:#75715e>// Add
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>set</span> {         <span style=color:#75715e>// Loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>k</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>delete(<span style=color:#a6e22e>set</span>, <span style=color:#e6db74>&#34;Foo&#34;</span>)      <span style=color:#75715e>// Delete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>set</span>)        <span style=color:#75715e>// Size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>exists</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>set</span>[<span style=color:#e6db74>&#34;Foo&#34;</span>] <span style=color:#75715e>// Membership
</span></span></span></code></pre></div><p>之前在网上看到有人按这个思路做了封装，还写了<a href=https://allenwu.itscoder.com/set-in-go>一篇文章</a>，可以去读一下。</p><p>其实，github 上已经有个成熟的包，名为 golang-set，它也是采用这个思路实现的。访问地址 <a href=https://github.com/deckarep/golang-set>golang-set</a>，描述中说 Docker 用的也是它。包中提供了两种 set 实现，线程安全的 set 和非线程安全的 set。</p><p>演示一个简单的案例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mapset</span> <span style=color:#e6db74>&#34;github.com/deckarep/golang-set&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 默认创建的线程安全的，如果无需线程安全
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 可以使用 NewThreadUnsafeSet 创建，使用方法都是一样的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mapset</span>.<span style=color:#a6e22e>NewSet</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s1 contains 3: &#34;</span>, <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s1 contains 5: &#34;</span>, <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// interface 参数，可以传递任意类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;poloxue&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s1 contains poloxue: &#34;</span>, <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#e6db74>&#34;poloxue&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s1 contains 3: &#34;</span>, <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mapset</span>.<span style=color:#a6e22e>NewSet</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 并集
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>Union</span>(<span style=color:#a6e22e>s2</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下：</p><pre tabindex=0><code>s1 contains 3:  true
s1 contains 5:  false
s1 contains poloxue:  true
s1 contains 3:  false
Set{4, polxue, 1, 2, 3, 5}
</code></pre><p>例子中演示了简单的使用方式，如果有不明白的，看下源码，这些数据结构的操作方法名都是很常见的，比如交集 Intersect、差集 Difference 等，一看就懂。</p><h1 id=bitset>bitset</h1><p>继续聊聊 bitset，bitset 中每个数子用一个 bit 即能表示，对于一个 int8 的数字，我们可以用它表示 8 个数字，能帮助我们大大节省数据的存储空间。</p><p>bitset 最常见的应用有 bitmap 和 flag，即位图和标志位。这里，我们先尝试用它表示一些操作的标志位。比如某个场景，我们需要三个 flag 分别表示权限1、权限2和权限3，而且几个权限可以共存。我们可以分别用三个常量 F1、F2、F3 表示位 Mask。</p><p>示例代码如下（引用自文章 <a href=https://yourbasic.org/golang/bitmask-flag-set-clear/>Bitmasks, bitsets and flags</a>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Bits</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>F0</span> <span style=color:#a6e22e>Bits</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>iota</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>F1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>F2</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>flag</span> <span style=color:#a6e22e>Bits</span>) <span style=color:#a6e22e>Bits</span>    { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span> | <span style=color:#a6e22e>flag</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Clear</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>flag</span> <span style=color:#a6e22e>Bits</span>) <span style=color:#a6e22e>Bits</span>  { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&amp;^</span> <span style=color:#a6e22e>flag</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Toggle</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>flag</span> <span style=color:#a6e22e>Bits</span>) <span style=color:#a6e22e>Bits</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span> ^ <span style=color:#a6e22e>flag</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Has</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>flag</span> <span style=color:#a6e22e>Bits</span>) <span style=color:#66d9ef>bool</span>    { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>flag</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>Bits</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>F0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>Toggle</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>F2</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>flag</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> []<span style=color:#a6e22e>Bits</span>{<span style=color:#a6e22e>F0</span>, <span style=color:#a6e22e>F1</span>, <span style=color:#a6e22e>F2</span>} {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>Has</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>flag</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>例子中，我们本来需要三个数才能表示这三个标志，但现在通过一个 uint8 就可以。bitset 的一些操作，如设置 Set、清除 Clear、切换 Toggle、检查 Has 通过位运算就可以实现，而且非常高效。</p><p>bitset 对集合操作有着天然的优势，直接通过位运算符便可实现。比如交集、并集、和差集，示例如下：</p><ul><li>交集：a & b</li><li>并集：a | b</li><li>差集：a & (~b)</li></ul><p>底层的语言、库、框架常会使用这种方式设置标志位。</p><p>以上的例子中只展示了少量数据的处理方式，uint8 占 8 bit 空间，只能表示 8 个数字。那大数据场景能否可以使用这套思路呢？</p><p>我们可以把 bitset 和 Go 中的切片结合起来，重新定义 Bits 类型，如下：</p><pre tabindex=0><code>type Bitset struct {
    data []int64
}
</code></pre><p>但如此也会产生一些问题，设置 bit，我们怎么知道它在哪里呢？仔细想想，这个位置信息包含两部分，即保存该 bit 的数在切片索引位置和该 bit 在数字中的哪位，分别将它们命名为 index 和 position。那怎么获取？</p><p>index 可以通过整除获取，比如我们想知道表示 65 的 bit 在切片的哪个 index，通过 65 / 64 即可获得，如果为了高效，也可以用位运算实现，即用移位替换除法，比如 65 &#187; 6，6 表示移位偏移，即 2^n = 64 的 n。</p><p>postion 是除法的余数，我们可以通过模运算获得，比如 65 % 64 = 1，同样为了效率，也有相应的位运算实现，比如 65 & 0b00111111，即 65 & 63。</p><p>一个简单例子，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>shift</span> = <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mask</span>  = <span style=color:#ae81ff>0x3f</span> <span style=color:#75715e>// 即0b00111111
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Bitset</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewBitSet</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Bitset</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取位置信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Bitset</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>data</span>: make([]<span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>index</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 根据 n 设置 bitset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>set</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>index</span>] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> uint(<span style=color:#a6e22e>n</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mask</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>set</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>set</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Bitset</span>) <span style=color:#a6e22e>Contains</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取位置信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>index</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>shift</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>set</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>index</span>]<span style=color:#f92672>&amp;</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span>uint(<span style=color:#a6e22e>n</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mask</span>)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>set</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewBitSet</span>(<span style=color:#ae81ff>65</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;set contains 65&#34;</span>, <span style=color:#a6e22e>set</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>65</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;set contains 64&#34;</span>, <span style=color:#a6e22e>set</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>64</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果</p><pre tabindex=0><code>set contains 65 true
set contains 64 false
</code></pre><p>以上的例子功能很简单，只是为了演示，只有创建 bitset 和 contains 两个功能，其他诸如添加、删除、不同 bitset 间的交、并、差还没有实现。有兴趣的朋友可以继续尝试。</p><p>其实，bitset 包也有人实现了，github地址 <a href=https://github.com/yourbasic/bit>bit</a>。可以读读它的源码，实现思路和上面介绍差不多。</p><p>下面是一个使用案例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/yourbasic/bit&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bit</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>65</span>, <span style=color:#ae81ff>128</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s contains 65&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>65</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s contains 15&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;s contains 15&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;next 20 is &#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#ae81ff>20</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;prev 20 is &#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Prev</span>(<span style=color:#ae81ff>20</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bit</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>22</span>, <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;next 20 is &#34;</span>, <span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#ae81ff>20</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s3</span>.<span style=color:#a6e22e>Visit</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>  <span style=color:#75715e>// 返回 true 表示终止遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行结果：</p><pre tabindex=0><code>s contains 65 true
s contains 15 false
s contains 15 true
next 20 is 65
prev 20 is 15
next 20 is 22
2
3
4
10
15
22
30
65
128
</code></pre><p>代码的意思很好理解，就是一些增删改查和集合的操作。要注意的是，bitset 和前面的 set 的区别，bitset 的成员只能是 int 整型，没有 set 灵活。平时的使用场景也比较少，主要用在对效率和存储空间要求较高的场景。</p><h1 id=总结>总结</h1><p>本文介绍了Go 中两种 set 的实现原理，并在此基础介绍了对应于它们的两个包简单使用。我觉得，通过这篇文章，Go 中 set 的使用，基本都可以搞定了。</p><p>除这两个包，再补充两个，<a href=https://github.com/zoumo/goset>zoumo/goset</a> 和 <a href=https://github.com/willf/bitset>github.com/willf/bitset</a>。</p></div><div class=post-footer><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></article></main></body></html>