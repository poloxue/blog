<!doctype html><html lang=zh-cn><head><title>循序渐进 MySQL 事务隔离级别 // POLOXUE's 博客频道</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.116.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="POLO XUE"><meta name=description content><link rel=stylesheet href=/css/main.min.bc53baba214f8015c0d60c05be847bd7734aeb6e7c6b25f647bd242952d8d436.css><link rel=alternate type=application/rss+xml href=https://www.poloxue.com/index.xml title="POLOXUE's 博客频道" description="欢迎订阅 POLOXUE's 的博客频道"><meta name=twitter:card content="summary"><meta name=twitter:title content="循序渐进 MySQL 事务隔离级别"><meta name=twitter:description content="本篇文章的重点在于总结MYSQL事务。
什么是事务 事务简言之就是一组 SQL 执行要么全部成功，要么全部失败。MYSQL 的事务在存储引擎层实现。
事务都有 ACID 特性：
原子性（Atomicity）：一个事务必须被视为一个不可分割的单元； 一致性（Consistency）：数据库总是从一种状态切换到另一种状态； 隔离性（Isolation）：通常来说，事务在提交前对于其他事务不可见； 持久性（Durablity）：一旦事务提交，所做修改永久保存数据库； 事务最常用的例子就是银行转账。假设 polo 需给 lynn 转账1000元，如下步骤：
确认 polo 账户余额高于1000元； 从 polo 的账户余额减去1000元； 将 lynn 的账户余额增加1000元； SQL语句如下:
mysql> BEGIN; mysql> SELECT balance FROM bank_account WHERE uid=10001; mysql> UPDATE bank_account SET balance=balance-1000 WHERE uid=10001; mysql> UPDATE bank_account SET balance=balance+1000 WHERE uid=10002; mysql> COMMIT; mysql 启动事务可使用 BEGIN 或 START TRANSACTION；上述三个步骤执行在一个事务中就能够保证数据的完整性，要么全部成功，要么全部失败。
MYSQL 提供两种事务型引擎：Innodb 和 NDBCluster。默认采用自动提交模式，执行一条语句自动 COMMIT。通过 AUTOCOMMIT 变量可启用或者禁用自动提交模式：
mysql> SHOW VARIABLES LIKE &#34;AUTOCOMMIT&#34;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0."><meta property="og:title" content="循序渐进 MySQL 事务隔离级别"><meta property="og:description" content="本篇文章的重点在于总结MYSQL事务。
什么是事务 事务简言之就是一组 SQL 执行要么全部成功，要么全部失败。MYSQL 的事务在存储引擎层实现。
事务都有 ACID 特性：
原子性（Atomicity）：一个事务必须被视为一个不可分割的单元； 一致性（Consistency）：数据库总是从一种状态切换到另一种状态； 隔离性（Isolation）：通常来说，事务在提交前对于其他事务不可见； 持久性（Durablity）：一旦事务提交，所做修改永久保存数据库； 事务最常用的例子就是银行转账。假设 polo 需给 lynn 转账1000元，如下步骤：
确认 polo 账户余额高于1000元； 从 polo 的账户余额减去1000元； 将 lynn 的账户余额增加1000元； SQL语句如下:
mysql> BEGIN; mysql> SELECT balance FROM bank_account WHERE uid=10001; mysql> UPDATE bank_account SET balance=balance-1000 WHERE uid=10001; mysql> UPDATE bank_account SET balance=balance+1000 WHERE uid=10002; mysql> COMMIT; mysql 启动事务可使用 BEGIN 或 START TRANSACTION；上述三个步骤执行在一个事务中就能够保证数据的完整性，要么全部成功，要么全部失败。
MYSQL 提供两种事务型引擎：Innodb 和 NDBCluster。默认采用自动提交模式，执行一条语句自动 COMMIT。通过 AUTOCOMMIT 变量可启用或者禁用自动提交模式：
mysql> SHOW VARIABLES LIKE &#34;AUTOCOMMIT&#34;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/coder/2016-12-10-isolation-in-mysql/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-12-10T18:14:45+08:00"><meta property="article:modified_time" content="2016-12-10T18:14:45+08:00"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body><header class=app-header><a href=https://www.poloxue.com><img class=app-header-avatar src=/avatar.webp alt="POLO XUE"></a>
<span class=app-header-title>POLOXUE's 博客频道</span><nav class=app-header-menu><a class=app-header-menu-item href=/>首页</a><br><a class=app-header-menu-item href=/posts/coder>编程杂谈</a><br><a class=app-header-menu-item href=/posts/trader>交易人生</a><br><a class=app-header-menu-item href=/about/>关于我</a></nav><p>技术生活随笔记录</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>循序渐进 MySQL 事务隔离级别</h1><div class=post-meta><div><span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 10, 2016&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read &nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-eye"><title>eye</title><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg><span id=5e9d65977cb82dc35b07b27e558f1d1b title>0 views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("5e9d65977cb82dc35b07b27e558f1d1b").innerText=JSON.parse(this.responseText).count_unique+" views"}),r.open("GET","https://poloxue.goatcounter.com/counter/"+encodeURIComponent("/posts/coder/2016-12-10-isolation-in-mysql/".replace(/(\/)?$/,""))+".json"),r.send()</script>&nbsp;</span>
<span><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://www.poloxue.com/tags/mysql/>mysql</a></span></div></div></header><div class=post-content><p>本篇文章的重点在于总结MYSQL事务。</p><h1 id=什么是事务>什么是事务</h1><p>事务简言之就是一组 SQL 执行要么全部成功，要么全部失败。MYSQL 的事务在存储引擎层实现。</p><p>事务都有 ACID 特性：</p><ul><li>原子性（Atomicity）：一个事务必须被视为一个不可分割的单元；</li><li>一致性（Consistency）：数据库总是从一种状态切换到另一种状态；</li><li>隔离性（Isolation）：通常来说，事务在提交前对于其他事务不可见；</li><li>持久性（Durablity）：一旦事务提交，所做修改永久保存数据库；</li></ul><p>事务最常用的例子就是银行转账。假设 polo 需给 lynn 转账1000元，如下步骤：</p><ul><li>确认 polo 账户余额高于1000元；</li><li>从 polo 的账户余额减去1000元；</li><li>将 lynn 的账户余额增加1000元；</li></ul><p>SQL语句如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> balance <span style=color:#66d9ef>FROM</span> bank_account <span style=color:#66d9ef>WHERE</span> uid<span style=color:#f92672>=</span><span style=color:#ae81ff>10001</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>UPDATE</span> bank_account <span style=color:#66d9ef>SET</span> balance<span style=color:#f92672>=</span>balance<span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span> <span style=color:#66d9ef>WHERE</span> uid<span style=color:#f92672>=</span><span style=color:#ae81ff>10001</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>UPDATE</span> bank_account <span style=color:#66d9ef>SET</span> balance<span style=color:#f92672>=</span>balance<span style=color:#f92672>+</span><span style=color:#ae81ff>1000</span> <span style=color:#66d9ef>WHERE</span> uid<span style=color:#f92672>=</span><span style=color:#ae81ff>10002</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>COMMIT</span>;
</span></span></code></pre></div><p>mysql 启动事务可使用 BEGIN 或 START TRANSACTION；上述三个步骤执行在一个事务中就能够保证数据的完整性，要么全部成功，要么全部失败。</p><p>MYSQL 提供两种事务型引擎：Innodb 和 NDBCluster。默认采用自动提交模式，执行一条语句自动 COMMIT。通过 AUTOCOMMIT 变量可启用或者禁用自动提交模式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SHOW</span> VARIABLES <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#34;AUTOCOMMIT&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> Variable_name <span style=color:#f92672>|</span> Value <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> autocommit    <span style=color:#f92672>|</span> <span style=color:#66d9ef>ON</span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>---------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> AUTOCOMMIT<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>AUTOCOMMIT=1 表示开启默认提交，0表示关闭默认提交需要手动提交。</p><h1 id=隔离级别>隔离级别</h1><p>事务隔离性的解释：通常情况下，事务在提交之前对于其他事务不可见。</p><p>数据库有四种隔离级别，当然 MYSQL 也是如此。分别是：</p><ul><li>未提交读，READ UNCOMMITTED</li><li>已提交读，READ COMMITTED</li><li>可重复读，REPEATABLE READ</li><li>串行化，SEAIALIZABLE</li></ul><p>关于隔离级别的两个理解</p><ul><li>书本解释，每种级别都规定了一个事务中所做修改，哪些在事务内和事务间是可见的。</li><li>我的理解，隔离级别就是决定一个事务的修改另一个事务什么情况下能看到。</li></ul><p>两者区别在于是否存在事务内可见性，但无论哪个级别在事务内的操作肯定是可见的，重点在事务间可见性。</p><p>下面开始说明 MYSQL 的四种隔离级别，先准备一张学生表：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>student<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span> <span style=color:#f92672>`</span>name<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>32</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>|</span>
</span></span></code></pre></div><p>只有id（主键自增）与name字段</p><h1 id=未提交读>未提交读</h1><p>事务中修改没有提交对其他事务也是可见的，俗称脏读。非常不建议使用。</p><p>示例演示,客户端A和B设置隔离级别为未提交读</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>SESSION</span> TX_ISOLATION<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;READ-UNCOMMITTED&#39;</span>;
</span></span></code></pre></div><p>客户端A与B开启事务并查询student</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>BEGIN</span><span style=color:#960050;background-color:#1e0010>；</span> mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span>Empty <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>当前，客户端 A 和 B 都是空数据。此时在客服端 B 插入一条新的数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> student(name) <span style=color:#66d9ef>VALUES</span>(<span style=color:#e6db74>&#34;polo&#34;</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> affected (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>此时事务还未提交，客服端 A 查看一下 student 表，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>可以看出，客户端 A 看到 B 未提交的修改。客户端 B 执行回滚操作，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>ROLLBACK</span>
</span></span></code></pre></div><p>成功之后，客户端 A 查看 student 表：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span>Empty <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>输出显示，客户端A查看数据为空。</p><p>以上可以看出未提交读隔离级别的危险性，对于一个没有提交事务所做修改对另一个事务是可见状态，容易造成脏读。非特殊情况不得使用此级别</p><h1 id=读提交读>读提交读</h1><p>多数数据库系统默认为此级别（MYSQL不是）。已提交读级别即为一个事务只能看到已提交事务所做的修改，也就解决了未提交读的问题，即脏读的问题。</p><p>示例演示，客户端A和B设置隔离级别为已提交读，执行如下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>SESSION</span> TX_ISOLATION<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;READ-COMMITTED&#39;</span>;
</span></span></code></pre></div><p>客户端 A与 B 开启事务并查询 student</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span>Empty <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>结果显示，客户端A和B都为空。接着，客户端 B 插入一条新的数据但不执行提交：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> student (name) <span style=color:#66d9ef>VALUES</span>(<span style=color:#e6db74>&#39;polo&#39;</span>);
</span></span></code></pre></div><p>接下来，客户端 A 查看一下 student 数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span>Empty <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>注意这里与上面不同了，在客户端B没有提交事务情况下无数据。下面客户端B提交事务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>COMMIT</span>;
</span></span></code></pre></div><p>客户端 A 再查看下 student 表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>这样我们就成功读取到了客户。</p><p>从上面的示例可以看出，提交读没有了脏读问题，但我们可以看到在客户端 A 的一个事务中执行两次同样的 SELECT 语句得到不同结果，因此已提交读又被称为不可重复读。同样筛选条件可能得到不同的结果。</p><h1 id=可重复读>可重复读</h1><p>如其名所言，解决已提交读不可重复读取的问题。</p><p>示例演示，客户端A和B设置隔离级别为可重复读。首先设置隔离级别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>SESSION</span> tx_isolation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;REPEATABLE-READ&#39;</span>
</span></span></code></pre></div><p>客户端A与B开启事务并查看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>rows</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>客服端 B 更新 polo 为 adam 并提交事务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>UPDATE</span> student <span style=color:#66d9ef>SET</span> name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;adam&#39;</span> <span style=color:#66d9ef>WHERE</span> id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>COMMIT</span>
</span></span></code></pre></div><p>客户端A查看student表，结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>rows</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>客户端 A 查看数据未变，没有不可重复读问题。</p><p>客户端 A 提交事务，并查看student表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>COMMIT</span>; mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>rows</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>从上面的示例可知，可重复读两次读取内容一样。该级别并没有解决幻读的问题。但是MYSQL在可重复读基础上增加了MVCC机制解决了此问题，此处无法演示幻读的效果。</p><p>那什么是幻读？首先，可重复读锁定范围为当前查询到的内容，如执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student <span style=color:#66d9ef>WHERE</span> id<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>锁定的即 id>=1 查到的行，为行级锁。如另一事务执行并默认提交以下语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> student (name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;stephen&#39;</span>);
</span></span></code></pre></div><p>新增的这行并没有被锁定，此时读取 student</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student <span style=color:#66d9ef>WHERE</span> id<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> stephen <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>2</span> <span style=color:#66d9ef>rows</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>出现了幻读。关于这个问题，除了使用 MYSQL 的 MVCC 机制，还可以用可串行化隔离级别解决此问题。</p><h1 id=串行化>串行化</h1><p>串行化是最高隔离级别，强制事务串行执行。执行串行了，那么也就解决了一切的问题，这个级别只有在对数据一致性要求非常严格且没用并发的情况下使用。</p><p>示例演示，客户端 A 和 B 设置隔离级别为可串行化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>SESSION</span> tx_isolation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;SERIALIZABLE&#39;</span>;
</span></span></code></pre></div><p>首先，客户端 A 执行一下查询：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student <span style=color:#66d9ef>WHERE</span> id<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> id <span style=color:#f92672>|</span> name    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> polo    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|</span>  <span style=color:#ae81ff>2</span> <span style=color:#f92672>|</span> stephen <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>----+---------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>2</span> <span style=color:#66d9ef>rows</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><p>接下来，客户端 B 执行数据新增：</p><p>mysql> INSERT INTO student (name) VALUES(&lsquo;yunteng&rsquo;);
好的！效果出现了，此时我们会发现INSERT语句被阻塞执行，原因就是A执行了查询表student同时满足<code>id&lt;4</code>，已被锁定。如果查询表student条件为<code>id&lt;3</code>，则新增语句可正常执行。</p><h1 id=汇总图>汇总图</h1><table><thead><tr><th>隔离级别</th><th>英文</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>未提交读</td><td>READ UNCOMMITTED</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>提交读</td><td>READ COMMITTED</td><td>否</td><td>是</td><td>是</td><td>否</td></tr><tr><td>可重复读</td><td>REPEATABLE READ</td><td>否</td><td>否</td><td>是</td><td>否</td></tr><tr><td>串行化</td><td>SERIALIZABLE</td><td>否</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p>关于事务的隔离级别到此结束。具体使用何种情况还要根据具体的业务场景来决定。</p></div><div class=post-footer><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></article></main></body></html>