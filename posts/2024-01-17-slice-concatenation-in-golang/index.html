<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Go 语言中高效切片拼接和 GO 1.22 提供的新方法 - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Go 语言中高效切片拼接和 GO 1.22 提供的新方法"><meta itemprop=description content="在 Go 语言中，切片拼接是一项常见的操作，但如果处理不当，可能会导致性能问题或意外的副作用。本文将详细介绍几种高效的切片拼接方法，包括它们的优缺点以及适用场景。"><meta itemprop=datePublished content="2024-01-17T18:29:38+08:00"><meta itemprop=dateModified content="2024-01-17T18:29:38+08:00"><meta itemprop=wordCount content="196"><meta property="og:url" content="https://www.poloxue.com/posts/2024-01-17-slice-concatenation-in-golang/"><meta property="og:site_name" content="POLOXUE's BLOG"><meta property="og:title" content="Go 语言中高效切片拼接和 GO 1.22 提供的新方法"><meta property="og:description" content="在 Go 语言中，切片拼接是一项常见的操作，但如果处理不当，可能会导致性能问题或意外的副作用。本文将详细介绍几种高效的切片拼接方法，包括它们的优缺点以及适用场景。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-17T18:29:38+08:00"><meta property="article:modified_time" content="2024-01-17T18:29:38+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 语言中高效切片拼接和 GO 1.22 提供的新方法"><meta name=twitter:description content="在 Go 语言中，切片拼接是一项常见的操作，但如果处理不当，可能会导致性能问题或意外的副作用。本文将详细介绍几种高效的切片拼接方法，包括它们的优缺点以及适用场景。"><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script><script src=https://www.poloxue.com/js/main.js></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["[","]"],["$$","$$"]],inlineMath:[["(",")"],["$","$"]]}}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7019080091542951" crossorigin=anonymous></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.png alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>文章列表</a></li><li><a href=/tags>分类标签</a></li><li><a href=/about/about>关于我</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>17</span>
<span class=rest>Jan 2024</span></div></div><div class=matter><h1 class=title>Go 语言中高效切片拼接和 GO 1.22 提供的新方法</h1></div></div><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-17-slices-concatenation-in-golang-01.png alt></p><blockquote><p>嗨，大家好！本文是系列文章 Go 小技巧第三篇，系列文章查看：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=3291066778475053060">Go 语言小技巧</a>。</p></blockquote><p>在 Go 语言中，切片拼接是一项常见的操作，但如果处理不当，可能会导致性能问题或意外的副作用。</p><p>本文将详细介绍几种高效的切片拼接方法，包括它们的优缺点以及适用场景。</p><h2 id=切片拼接的必要性>切片拼接的必要性</h2><p>在 Go 中，切片是一种动态数组，常用于存储和处理一系列相同类型的数据。</p><p>在实际应用中，我们经常需要将两个或多个切片合并为一个新的切片，例如在处理字符串、整数列表或自定义结构体数组时。</p><p>这种需求促使我们探索更高效的切片拼接方法。</p><h2 id=基本拼接方法及其局限性>基本拼接方法及其局限性</h2><h3 id=使用-append-函数>使用 append 函数</h3><p>最直接的方法是使用 <code>append</code> 函数，它可以将一个切片的元素追加到另一个切片的末尾。</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-17-slices-concatenation-in-golang-02.gif alt></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>slice1</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice2</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>slice1</span>, <span style=color:#a6e22e>slice2</span><span style=color:#f92672>...</span>)
</span></span></code></pre></td></tr></table></div></div><p>虽然这种方法简单快捷，但它有一个局限性：当 <code>slice1</code> 的容量不足以容纳所有元素时，Go 会分配一个新的底层数组。这可能导致性能问题，特别是在处理大型切片时。</p><h2 id=高效拼接的策略>高效拼接的策略</h2><p>为了克服基本方法的局限性，我们可以采取以下策略：</p><h3 id=控制容量和避免副作用>控制容量和避免副作用</h3><p>为了避免不必要的内存分配和潜在的副作用，我们可以先检查第一个切片的容量是否足够。如果不够，可以先创建一个新的切片，确保足够的容量。</p><p><img src=https://cdn.jsdelivr.net/gh/poloxue/images@2024-01/2024-01-17-slices-concatenation-in-golang-03.gif alt></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>a</span>), len(<span style=color:#a6e22e>a</span>)<span style=color:#f92672>+</span>len(<span style=color:#a6e22e>b</span>))
</span></span><span style=display:flex><span>copy(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> = append(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>...</span>)
</span></span></code></pre></td></tr></table></div></div><p>这种方法虽然代码稍长，但可以有效避免不必要的内存分配和对原始切片的影响。</p><h3 id=利用-go-122-的新特性>利用 Go 1.22 的新特性</h3><p>将要发布的 1.22 版本开始，将提供了一个新的 <code>Concat</code> 函数，它提供了一种更简洁的方式来拼接多个切片。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>slices</span>.<span style=color:#a6e22e>Concat</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</span></span></code></pre></td></tr></table></div></div><p>slices 包中 Concat 的实现源码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Concat</span>[<span style=color:#a6e22e>S</span> ~[]<span style=color:#a6e22e>E</span>, <span style=color:#a6e22e>E</span> <span style=color:#66d9ef>any</span>](<span style=color:#a6e22e>slices</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>S</span>) <span style=color:#a6e22e>S</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>slices</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>size</span> <span style=color:#f92672>+=</span> len(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			panic(<span style=color:#e6db74>&#34;len out of range&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>newslice</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Grow</span>[<span style=color:#a6e22e>S</span>](<span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>slices</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>newslice</span> = append(<span style=color:#a6e22e>newslice</span>, <span style=color:#a6e22e>s</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newslice</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>这种方法不仅代码更简洁，而且内部优化了内存分配和复制操作，适用于需要高性能处理的场景。</p><h2 id=切片动态扩容的深入理解>切片动态扩容的深入理解</h2><p>我们来深入理解下切片的动态扩容机制吧。这对于优化切片拼接至关重要。</p><h3 id=元素追加的逻辑过程>元素追加的逻辑过程</h3><p>首先，当我们不断向切片追加元素时，如果每次追加都超出了当前的容量，Go 语言的运行时环境会自动进行内存重新分配。</p><p>这个过程涉及到创建一个新的、更大的内存空间，并将现有元素从旧空间复制到新空间，然后追加新元素。虽然这个机制保证了切片的灵活性和动态增长能力，但在处理大量数据时，频繁的内存分配和数据复制可能会成为性能瓶颈。</p><h3 id=内存重新分配与数据迁移>内存重新分配与数据迁移</h3><p>当切片的容量不足以容纳新元素时，Go 会执行以下步骤：</p><ol><li><strong>分配新的内存空间</strong>：创建一个更大的内存空间来容纳扩展后的切片。新空间的容量通常是原来容量的两倍。</li><li><strong>拷贝现有元素</strong>：将原切片中的元素拷贝到新的内存空间中。</li><li><strong>追加新元素</strong>：在新的内存空间中追加新元素。</li></ol><h3 id=预估容量减少不必要扩容>预估容量减少不必要扩容</h3><p>故而，为了减少内存重新分配和数据迁移的性能开销，可采取以下策略：</p><ul><li><p><strong>预估容量</strong>：在创建切片时，如果能预估到需要存储的元素数量，应该指定一个足够大的容量。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>elements</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>expectedSize</span>)
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>批量追加</strong>：尽量一次追加多个元素，减少触发扩容的次数。</p></li><li><p><strong>避免不必要的扩容</strong>：在可能的情况下，先将数据收集到一个临时容器中，然后一次性追加到目标切片。</p></li><li><p><strong>使用缓冲区</strong>：对于频繁变化的切片，使用一个足够大的缓冲区可以有效避免频繁的内存重新分配。</p></li></ul><h2 id=结论>结论</h2><p>通过深入理解 Go 切片的内存管理机制和动态扩容行为，可以更加高效地进行切片拼接操作。合理的容量规划、批量操作和缓冲区使用，不仅提高了代码的效率，还保证了程序的稳定性和可维护性。</p><div>本文来源于 <a href=https://www.poloxue.com>POLOXUE's BLOG</a>，地址： <a href=https://www.poloxue.com/posts/2024-01-17-slice-concatenation-in-golang/>Go 语言中高效切片拼接和 GO 1.22 提供的新方法</a><hr class=footer-separator><div class=tags></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post>欢迎关注我的公众号：<img style=width:85% src=https://cdn.jsdelivr.net/gh/poloxue/images@main/wechat.png><div class=utterances></div><script src=https://utteranc.es/client.js repo=poloxue/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div><div class="footer wrapper"><nav class=nav><div>2024 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script></body></html>