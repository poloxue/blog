<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Go 实现词法分析与解析 Part Two - POLOXUE's BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Go 实现词法分析与解析 Part Two"><meta itemprop=description content="本文是关于词法器实现的具体介绍，如果在阅读时遇到困难，建议参考源码阅读，文中的代码片段为了介绍思路。如何解析会在下一篇介绍。
最近简单看了下 Go 源码，在 src/go 目录下有几个模块，token、scanner 和 parser 应该就是 Go 词法相关实现的核心代码，打开 token 目录会发现其中的源码和上一节介绍的内容有诸多相似之处。
由于最近并发任务比较多，不能以最快的速度更新。词法的相关内容，除了本系列，我把其他一些相关文章的链接都贴在下面，如果英文阅读功底不错，可自行阅读。
A look at Go lexer/scanner packages
Rob Pike&rsquo;s Functional Way
Handwritten Parser & Lexers In Go
译文如下：
本系列的第一篇文章（英文原版）。
我介绍了关于词法分析与解析的一些基本概念和 INI 文件内容的基本组成。之后，我们创建了部分相关结构体与常量，帮助实现接下来的 INI 文本解析器。
本篇文章将实际深入到词法分析的细节。
词法分析 (lexing)，指的是将输入文本转化为一系列 Token 的过程。Token 是比文本更小的单元，将它们组合在一起才可能产生有实际意义的内容，如程序、配置文件等。
本系列文章中的 INI 文件，Token 包括左括号、右括号、SectionName、Key，Value 以及等于号。用正确的顺序组合它们，你就会有一个 INI 文件。词法器的职责是读取 INI 文件内容、分析创建 Token，以及通过 channel 将 Token 发送给解析器。
词法分析器 为了实现文本到 Token 的转化，我们还需要追踪一些信息，比如文本内容，当前分析文本的位置，以及当前分析的 Token 的开始和结束位置。
完成分析后，我们还要将 Token 发送给解析器，可以通过 channel 传递。
我们还需要一个函数实现词法器状态的追踪。Rob Pike 的演讲中谈到利用函数追踪词法器当前和接下来期望的状态。简单而言，就是一个函数处理一个 Token，并返回下一个状态函数生成下一个期望 Token。下面，我就简单翻译为状态函数吧."><meta itemprop=datePublished content="2019-07-24T17:10:19+08:00"><meta itemprop=dateModified content="2019-07-24T17:10:19+08:00"><meta itemprop=wordCount content="890"><meta itemprop=keywords content="Golang,"><meta property="og:title" content="Go 实现词法分析与解析 Part Two"><meta property="og:description" content="本文是关于词法器实现的具体介绍，如果在阅读时遇到困难，建议参考源码阅读，文中的代码片段为了介绍思路。如何解析会在下一篇介绍。
最近简单看了下 Go 源码，在 src/go 目录下有几个模块，token、scanner 和 parser 应该就是 Go 词法相关实现的核心代码，打开 token 目录会发现其中的源码和上一节介绍的内容有诸多相似之处。
由于最近并发任务比较多，不能以最快的速度更新。词法的相关内容，除了本系列，我把其他一些相关文章的链接都贴在下面，如果英文阅读功底不错，可自行阅读。
A look at Go lexer/scanner packages
Rob Pike&rsquo;s Functional Way
Handwritten Parser & Lexers In Go
译文如下：
本系列的第一篇文章（英文原版）。
我介绍了关于词法分析与解析的一些基本概念和 INI 文件内容的基本组成。之后，我们创建了部分相关结构体与常量，帮助实现接下来的 INI 文本解析器。
本篇文章将实际深入到词法分析的细节。
词法分析 (lexing)，指的是将输入文本转化为一系列 Token 的过程。Token 是比文本更小的单元，将它们组合在一起才可能产生有实际意义的内容，如程序、配置文件等。
本系列文章中的 INI 文件，Token 包括左括号、右括号、SectionName、Key，Value 以及等于号。用正确的顺序组合它们，你就会有一个 INI 文件。词法器的职责是读取 INI 文件内容、分析创建 Token，以及通过 channel 将 Token 发送给解析器。
词法分析器 为了实现文本到 Token 的转化，我们还需要追踪一些信息，比如文本内容，当前分析文本的位置，以及当前分析的 Token 的开始和结束位置。
完成分析后，我们还要将 Token 发送给解析器，可以通过 channel 传递。
我们还需要一个函数实现词法器状态的追踪。Rob Pike 的演讲中谈到利用函数追踪词法器当前和接下来期望的状态。简单而言，就是一个函数处理一个 Token，并返回下一个状态函数生成下一个期望 Token。下面，我就简单翻译为状态函数吧."><meta property="og:type" content="article"><meta property="og:url" content="https://www.poloxue.com/posts/2019-07-24-golang-lexer-and-parser-part2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-24T17:10:19+08:00"><meta property="article:modified_time" content="2019-07-24T17:10:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 实现词法分析与解析 Part Two"><meta name=twitter:description content="本文是关于词法器实现的具体介绍，如果在阅读时遇到困难，建议参考源码阅读，文中的代码片段为了介绍思路。如何解析会在下一篇介绍。
最近简单看了下 Go 源码，在 src/go 目录下有几个模块，token、scanner 和 parser 应该就是 Go 词法相关实现的核心代码，打开 token 目录会发现其中的源码和上一节介绍的内容有诸多相似之处。
由于最近并发任务比较多，不能以最快的速度更新。词法的相关内容，除了本系列，我把其他一些相关文章的链接都贴在下面，如果英文阅读功底不错，可自行阅读。
A look at Go lexer/scanner packages
Rob Pike&rsquo;s Functional Way
Handwritten Parser & Lexers In Go
译文如下：
本系列的第一篇文章（英文原版）。
我介绍了关于词法分析与解析的一些基本概念和 INI 文件内容的基本组成。之后，我们创建了部分相关结构体与常量，帮助实现接下来的 INI 文本解析器。
本篇文章将实际深入到词法分析的细节。
词法分析 (lexing)，指的是将输入文本转化为一系列 Token 的过程。Token 是比文本更小的单元，将它们组合在一起才可能产生有实际意义的内容，如程序、配置文件等。
本系列文章中的 INI 文件，Token 包括左括号、右括号、SectionName、Key，Value 以及等于号。用正确的顺序组合它们，你就会有一个 INI 文件。词法器的职责是读取 INI 文件内容、分析创建 Token，以及通过 channel 将 Token 发送给解析器。
词法分析器 为了实现文本到 Token 的转化，我们还需要追踪一些信息，比如文本内容，当前分析文本的位置，以及当前分析的 Token 的开始和结束位置。
完成分析后，我们还要将 Token 发送给解析器，可以通过 channel 传递。
我们还需要一个函数实现词法器状态的追踪。Rob Pike 的演讲中谈到利用函数追踪词法器当前和接下来期望的状态。简单而言，就是一个函数处理一个 Token，并返回下一个状态函数生成下一个期望 Token。下面，我就简单翻译为状态函数吧."><script data-goatcounter=https://poloxue.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/main.css><link rel=stylesheet type=text/css media=screen href=https://www.poloxue.com/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://www.poloxue.com/css/dark.css><script src=https://www.poloxue.com/js/feather.min.js></script>
<script src=https://www.poloxue.com/js/main.js></script></head><body><div class="container-wide wrapper"><div class=header><div class=avatar><a href=https://www.poloxue.com/><img src=/avatar.webp alt="POLOXUE's BLOG"></a></div><h1 class=site-title><a href=https://www.poloxue.com/>POLOXUE's BLOG</a></h1><div class=site-description><nav class="nav social"><ul class=flat><li><a href=https://github.com/poloxue/ title=Github><i data-feather=github></i></a></li><li><a href=/posts/index.xml title=RSS><i data-feather=rss></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>HOME</a></li><li><a href=/posts>POSTS</a></li><li><a href=/tags>TAGS</a></li><li><a href=/about/>ABOUT</a></li></ul></nav></div><div class=article-nav id=article-nav-id><div class=post><div class=post-header><div class=meta><div class=date><span class=day>24</span>
<span class=rest>Jul 2019</span></div></div><div class=matter><h1 class=title>Go 实现词法分析与解析 Part Two</h1></div></div><aside class="show-on-mobile toc" id=static-toc><header><h3>Contents</h3></header><nav id=TableOfContents></nav></aside><p>本文是关于词法器实现的具体介绍，如果在阅读时遇到困难，建议参考源码阅读，文中的代码片段为了介绍思路。如何解析会在下一篇介绍。</p><p>最近简单看了下 Go 源码，在 src/go 目录下有几个模块，token、scanner 和 parser 应该就是 Go 词法相关实现的核心代码，打开 token 目录会发现其中的源码和上一节介绍的内容有诸多相似之处。</p><p>由于最近并发任务比较多，不能以最快的速度更新。词法的相关内容，除了本系列，我把其他一些相关文章的链接都贴在下面，如果英文阅读功底不错，可自行阅读。</p><p><a href=https://arslan.io/2015/10/12/a-look-at-go-lexerscanner-packages/>A look at Go lexer/scanner packages</a><br><a href="https://www.youtube.com/watch?v=HxaD_trXwRE">Rob Pike&rsquo;s Functional Way</a><br><a href=https://blog.gopheracademy.com/advent-2014/parsers-lexers/>Handwritten Parser & Lexers In Go</a></p><p>译文如下：</p><p>本系列的<a href=https://www.poloxue.com/posts/2019-07-17-golang-lexer-and-parser-part1/>第一篇文章</a>（<a href=https://adampresley.github.io/2015/04/12/writing-a-lexer-and-parser-in-go-part-1.html>英文原版</a>）。</p><p>我介绍了关于词法分析与解析的一些基本概念和 INI 文件内容的基本组成。之后，我们创建了部分相关结构体与常量，帮助实现接下来的 INI 文本解析器。</p><p>本篇文章将实际深入到词法分析的细节。</p><p>词法分析 (lexing)，指的是将输入文本转化为一系列 Token 的过程。Token 是比文本更小的单元，将它们组合在一起才可能产生有实际意义的内容，如程序、配置文件等。</p><p>本系列文章中的 INI 文件，Token 包括左括号、右括号、SectionName、Key，Value 以及等于号。用正确的顺序组合它们，你就会有一个 INI 文件。词法器的职责是读取 INI 文件内容、分析创建 Token，以及通过 channel 将 Token 发送给解析器。</p><h1 id=词法分析器>词法分析器</h1><p>为了实现文本到 Token 的转化，我们还需要追踪一些信息，比如文本内容，当前分析文本的位置，以及当前分析的 Token 的开始和结束位置。</p><p>完成分析后，我们还要将 Token 发送给解析器，可以通过 channel 传递。</p><p>我们还需要一个函数实现词法器状态的追踪。Rob Pike 的演讲中谈到利用函数追踪词法器当前和接下来期望的状态。简单而言，就是一个函数处理一个 Token，并返回下一个状态函数生成下一个期望 Token。下面，我就简单翻译为状态函数吧.</p><p>举个例子吧！</p><p>INI 中 Section 由三部分组成，分别是左括号、SectionName 以及右括号。第一个函数将会生成左括号类型的 Token，返回 SectionName 的状态函数，它会分析处理 SectionName 的相关逻辑，并返回处理右括号的状态函数。总的顺序是，左括号 -> section 名称 -> 右括号。</p><p>百闻不如意见，具体看下词法器的结构吧。如下：</p><p><strong>Lexer.go</strong></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Lexer</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Name</span>   <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Input</span>  <span style=color:#66d9ef>string</span>  <span style=color:#75715e>// 输入文本
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>Tokens</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>Token</span> <span style=color:#75715e>// 用于向词法分析器发送 Token 的 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>State</span>  <span style=color:#a6e22e>LexFn</span>   <span style=color:#75715e>// 上面提到的状态函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Start</span> <span style=color:#66d9ef>int</span>      <span style=color:#75715e>// token 的开始位置，结束位置可以通过 start + len(token) 获得
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>Pos</span>   <span style=color:#66d9ef>int</span>      <span style=color:#75715e>// 词法器处理文本位置，当确认 Token 结尾时，即相当于知道 Token 的 end position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>Width</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><strong>LexFn.go</strong></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>LexFn</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span>  <span style=color:#75715e>// 词法器状态函数的定义，返回下一个期望 Token 的分析函数。
</span></span></span></code></pre></td></tr></table></div></div><p>上篇文章，我们已经定义了 Token 结构。LexFn，是用于处理 Token 的词法器状态函数类型。</p><p>现在再为我们的额词法器增加一些能力。Lexer 是用于文本处理的，为了获取下一个 Token，我们为 Lexer 增加诸如读取 rune 字符串、跳过空格，和其他一些有用的方法。基本都是文本处理的一些简单方法。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Puts a token onto the token channel. The value of this token is
</span></span></span><span style=display:flex><span><span style=color:#75715e>read from the input based on the current lexer position.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>tokenType</span> <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TokenType</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Tokens</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>Token</span>{<span style=color:#a6e22e>Type</span>: <span style=color:#a6e22e>tokenType</span>, <span style=color:#a6e22e>Value</span>: <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Input</span>[<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Start</span>:<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Pos</span>]}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Pos</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Increment the position
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>Inc</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Pos</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Pos</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>utf8</span>.<span style=color:#a6e22e>RuneCountInString</span>(<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Input</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_EOF</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Return a slice of the input from the current lexer position
</span></span></span><span style=display:flex><span><span style=color:#75715e>to the end of the input string.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>InputToEnd</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Input</span>[<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Post</span>:]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Skips whitespace until we get something meaningful
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>this</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>SkipWhiteSpace</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Next</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>unicode</span>.<span style=color:#a6e22e>IsSpace</span>(<span style=color:#a6e22e>ch</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Dec</span>()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ch</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>EOF</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_EOF</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>重点需要了解的是，Token 的读取与发送。主要涉及几个步骤，如下：</p><p>首先，一直读取字符，直到形成一个确定的 Token，举例说明，SectionName 的状态函数，只有读到右括号才能确认 SectionName。
接着，将 Token 和 Token 类型通过 channel 发送给解析器。
最后，判断下一个期望的状态函数，并返回。</p><p>我们先定义一个启动函数。它同样是解析器（下篇文章）的启动入口。它初始化了一个 Lexer，赋予它第一个状态函数。</p><p>第一个期望的 Token 可能是什么？一个特殊符号还是一个关键词？</p><p>在我们的例子中，第一个状态函数将会用一个通用的名称 LexBegin 命名，因为在 INI 文件中，section 开始可以，但也可以没有 section，以 key/value 开投。<strong>LexBegin</strong> 会负责处理这个逻辑。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Start a new lexer with a given input string. This returns the
</span></span></span><span style=display:flex><span><span style=color:#75715e>instance of the lexer and a channel of tokens. Reading this stream
</span></span></span><span style=display:flex><span><span style=color:#75715e>is the way to parse a given input and perform processing.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BeginLexing</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Lexer</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Lexer</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Name</span>: <span style=color:#a6e22e>name</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Input</span>: <span style=color:#a6e22e>input</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>State</span>: <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>LexBegin</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Tokens</span>: make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>Token</span>, <span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>l</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h1 id=开始>开始</h1><p>第一个状态函数 <strong>LexBegin</strong>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function starts everything off. It determines if we are
</span></span></span><span style=display:flex><span><span style=color:#75715e>beginning with a key/value assignment or a section.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexBegin</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>SkipWhitespace</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>InputToEnd</span>(), <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>LEFT_BRACKET</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexLeftBracket</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexKey</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>正如所见，首先是跳过所有空格，INI 文件中，空格是没有意义。接着，我们需要确认第一个字符是否是左括号，是的话，则返回 <strong>LexLetBracket</strong>，否则即是 key 类型，返回 <strong>LexKey</strong> 状态函数。</p><h1 id=section>Section</h1><p>开始 section 的处理逻辑介绍。</p><p>INI 文件中的 SectionName 是由左右括号包裹起来的。我们可以将 Key/Value 组织在某个 Section 中。在 <strong>LexBegin</strong> 中，如果发现了左括号，则会返回 <strong>LexLeftBracket</strong> 函数。</p><p><strong>LexLeftBracket</strong> 的代码如下：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function emits a TOKEN_LEFT_BRACKET then returns
</span></span></span><span style=display:flex><span><span style=color:#75715e>the lexer for a section header.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexLeftBracket</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Pos</span> <span style=color:#f92672>+=</span> len(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>LEFT_BRACKET</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_LEFT_BRACKET</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexSection</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>代码很简单！根据括号长度（长度位 1），将词法器的位置后移，接着向 channel 发送 TOKEN_LEFT_BRACKET。</p><p>在这个场景下，Token 内容并没有什么意义。当 Emit 执行完成后，开始位置被赋值为词法器当前位置，这将会为下一个 Token 做好准备。最后，返回用于处理 SectioName 的状态函数，<strong>LexSection</strong>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function exits a TOKEN_SECTION with the name of an
</span></span></span><span style=display:flex><span><span style=color:#75715e>INI file section header.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexSection</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>IsEOF</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>LEXER_ERROR_MISSING_RIGHT_BRACKET</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>InputEnd</span>(), <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>RIGHT_BRACKET</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_SECTION</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexRightBracket</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Inc</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>逻辑稍微有点复杂，但基本逻辑一样。</p><p>函数中通过一个循环遍历字符，直到遇到 RIGHT_BRACKET，即右括号，才可以确认 SectionName 的结束位置。如果遇到 EOF，则说明是一个错误格式的 INI，我们应该进行错误提示，并通过 channel 发送给解析器。如果正常，将一直循环，直到发现右括号，然后 TOKEN_SECTION 和相应文本发送出去。</p><p><strong>LexSection</strong> 返回的状态函数是 <strong>LexerRightBracket</strong>，逻辑与 <strong>LexerLeftBracket</strong> 类似，不同的是，它返回的状态函数是 <strong>LexBegin</strong>， 原因是 Section 可能是空 Section，也可能有 Key/Value。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function emits a TOKEN_RIGHT_BRACKET then returns
</span></span></span><span style=display:flex><span><span style=color:#75715e>the lexer for a begin.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexRightBracket</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Pos</span> <span style=color:#f92672>+=</span> len(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>RIGHT_BRACKET</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_RIGHT_BRACKET</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexBegin</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h1 id=keyvalue>Key/Value</h1><p>继续 Key/Value 处理的介绍，它的表达形式非常简单：key=value。</p><p>首先是 Key 的处理，和 <strong>LexSection</strong> 类似，一直循环直到遇到等于号才能确定一个完整的 Key。然后执行 Emit 将 Key 发送，并返回状态函数 <strong>LexEqualSign</strong>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function emits a TOKEN_KEY with the name of an
</span></span></span><span style=display:flex><span><span style=color:#75715e>key that will assigned a value
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexKey</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>InputToEnd</span>(), <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>EQUAL_SIGN</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_KEY</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexEqualSign</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Inc</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>IsEOF</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>LEXER_ERROR_UNEXPECTED_EOF</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>等号的处理非常简单，和左右括号类似。直接发送 <strong>TOKEN_EQUAL_SIGN</strong> 类型 Token 给解析器，并返回 <strong>LexValue</strong>。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer functions emits a TOKEN_EQUAL_SIGN then returns
</span></span></span><span style=display:flex><span><span style=color:#75715e>the lexer for value.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexEqualSign</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Pos</span> <span style=color:#f92672>+=</span> len(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>EQUAL_SIGN</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>EQUAL_SIGN</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexValue</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>最后介绍的状态函数是 <strong>LexValue</strong>，用于 Key/Value 中的 Value 部分的处理。它会在遇到换行符时确认一个完整的Value。它返回的状态函数是 <strong>LexBegin</strong>，以此继续下一轮的分析。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>This lexer function emits a TOKEN_VALUE with the value to be assigned
</span></span></span><span style=display:flex><span><span style=color:#75715e>to a key.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LexValue</span>(<span style=color:#a6e22e>lexer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Lexer</span>) <span style=color:#a6e22e>LexFn</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>InputToEnd</span>(), <span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>NEWLINE</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Emit</span>(<span style=color:#a6e22e>lexertoken</span>.<span style=color:#a6e22e>TOKEN_VALUE</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>LexBegin</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Inc</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>IsEOF</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lexer</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>LEXER_ERROR_UNEXPECTED_EOF</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h1 id=接下来>接下来</h1><p>在 <a href=https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-3.html>Part 3</a>，本系列的最后一篇，我们将会介绍如何创建一个基本的解析器，将从 lexer 获得的 Token 处理为我们期望得到的结构化数据。</p><p>我的博文：<a href=https://www.poloxue.com/posts/2019-07-24-golang-lexer-and-parser-part2>Go 实现词法分析与解析 Part Two</a>，译：<a href=https://adampresley.github.io/2015/05/12/writing-a-lexer-and-parser-in-go-part-2.html>Writeing a Lexer and Parser in Go - Part 2</a></p></div><nav class="hide-on-mobile section-nav"><nav id=TableOfContents></nav></nav></div><div class=post><hr class=footer-separator><div class=tags><ul class=flat><li class=tag-li><a href=/tags/golang>Golang</a></li></ul></div><div class=back><a href=https://www.poloxue.com/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div></div><div class="footer wrapper"><nav class=nav><div>2019 Polo Xue All rights reserved</div></nav></div><script>feather.replace()</script><script>var enableTruncate=!0,filterDepth=!1;const MAX_DEPTH=9;window.addEventListener("DOMContentLoaded",()=>{const e=new IntersectionObserver(e=>{e.reverse().forEach(e=>{const n=e.target.getAttribute("id");if(e.intersectionRatio>0){var t=document.querySelectorAll(`nav li a[href="#${n}"]`);t!=null&&t.forEach(e=>{if(e!=null){var t=getDepth(e.parentElement);filterDepth&&t<=MAX_DEPTH&&(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))}else filterDepth||(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))})}})});document.querySelectorAll("h1[id],h2[id],h3[id],h4[id]").forEach(t=>{e.observe(t)})});function isVisible(e){if(!(e instanceof Element))return!1;const n=getComputedStyle(e);if(n.display==="none")return!1;if(n.visibility!=="visible")return!1;if(n.opacity<.1)return!1;if(e.offsetWidth+e.offsetHeight+e.getBoundingClientRect().height+e.getBoundingClientRect().width===0)return!1;const t={x:e.getBoundingClientRect().left+e.offsetWidth/2,y:e.getBoundingClientRect().top+e.offsetHeight/2};if(t.x<0)return!1;if(t.x>(document.documentElement.clientWidth||window.innerWidth))return!1;if(t.y<0)return!1;if(t.y>(document.documentElement.clientHeight||window.innerHeight))return!1;let s=document.elementFromPoint(t.x,t.y);do if(s===e)return!0;while(s=s.parentNode)return!1}function clearActiveStatesInTableOfContents(){document.querySelectorAll("nav li").forEach(e=>{e.classList.remove("active")})}function getDepth(e){for(var t=0;e!==null&&e.tagName.toLowerCase()!=="ul";)t++,e=e.parentElement;return t}function navItems(){var e=document.querySelectorAll("nav nav li a");return Array.from(e).filter(e=>e.href!=null&&e.hash.startsWith("#"))}function lasItemInNavBarVisible(){var e=navItems().slice(-1)[0];return isVisible(e)}document.addEventListener("DOMContentLoaded",function(){if(!enableTruncate)return;var e=navItems();console.log(e),lasItemInNavBarVisible()||(filterDepth=!0,e.forEach(function(e){var t=getDepth(e.parentElement);t>MAX_DEPTH&&e.parentElement.classList.add("depth-nested")}))})</script></body></html>